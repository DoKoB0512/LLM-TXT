Directory structure:
└── nestjs-nest/
    ├── Readme.md
    ├── CODE_OF_CONDUCT.md
    ├── CONTRIBUTING.md
    ├── eslint.config.mjs
    ├── gulpfile.js
    ├── lerna.json
    ├── LICENSE
    ├── package.json
    ├── readme_jp.md
    ├── readme_kr.md
    ├── readme_zh.md
    ├── renovate.json
    ├── SECURITY.md
    ├── tsconfig.json
    ├── tsconfig.spec.json
    ├── .commitlintrc.json
    ├── .npmignore
    ├── .prettierignore
    ├── .prettierrc
    ├── benchmarks/
    │   ├── all_output.txt
    │   ├── express.js
    │   ├── fastify.js
    │   ├── nest-fastify.js
    │   ├── nest.js
    │   └── nest/
    │       ├── app.controller.d.ts
    │       ├── app.controller.js
    │       ├── app.module.d.ts
    │       ├── app.module.js
    │       └── main.d.ts
    ├── hooks/
    │   └── mocha-init-hook.ts
    ├── integration/
    │   ├── docker-compose.yml
    │   ├── mosquitto.conf
    │   ├── auto-mock/
    │   │   ├── tsconfig.json
    │   │   ├── src/
    │   │   │   ├── bar.service.ts
    │   │   │   └── foo.service.ts
    │   │   └── test/
    │   │       └── bar.service.spec.ts
    │   ├── cors/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── express.spec.ts
    │   │   │   └── fastify.spec.ts
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       └── app.module.ts
    │   ├── discovery/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   └── discover-by-meta.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── webhooks.explorer.ts
    │   │       ├── decorators/
    │   │       │   ├── non-applied.decorator.ts
    │   │       │   └── webhook.decorators.ts
    │   │       └── my-webhook/
    │   │           ├── cleanup.webhook.ts
    │   │           ├── flush.webhook.ts
    │   │           └── my-webhook.module.ts
    │   ├── graphql-code-first/
    │   │   ├── schema.gql
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── code-first.spec.ts
    │   │   │   ├── guards-filters.spec.ts
    │   │   │   └── pipes.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── common/
    │   │       │   ├── filters/
    │   │       │   │   └── unauthorized.filter.ts
    │   │       │   ├── guards/
    │   │       │   │   └── auth.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── data.interceptor.ts
    │   │       │   └── scalars/
    │   │       │       └── date.scalar.ts
    │   │       └── recipes/
    │   │           ├── recipes.module.ts
    │   │           ├── recipes.resolver.ts
    │   │           ├── recipes.service.ts
    │   │           ├── dto/
    │   │           │   ├── new-recipe.input.ts
    │   │           │   └── recipes.args.ts
    │   │           └── models/
    │   │               └── recipe.ts
    │   ├── graphql-schema-first/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── graphql-async-class.spec.ts
    │   │   │   ├── graphql-async-existing.spec.ts
    │   │   │   ├── graphql-async.spec.ts
    │   │   │   ├── graphql-request-scoped.spec.ts
    │   │   │   └── graphql.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── async-options-class.module.ts
    │   │       ├── async-options-existing.module.ts
    │   │       ├── async-options.module.ts
    │   │       ├── config.module.ts
    │   │       ├── config.service.ts
    │   │       ├── main.ts
    │   │       ├── cats/
    │   │       │   ├── cats-request-scoped.service.ts
    │   │       │   ├── cats.guard.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.resolvers.ts
    │   │       │   ├── cats.service.ts
    │   │       │   ├── cats.types.graphql
    │   │       │   └── interfaces/
    │   │       │       └── cat.interface.ts
    │   │       └── common/
    │   │           └── scalars/
    │   │               └── date.scalar.ts
    │   ├── hello-world/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── exceptions.spec.ts
    │   │   │   ├── exclude-middleware-fastify.spec.ts
    │   │   │   ├── exclude-middleware.spec.ts
    │   │   │   ├── express-instance.spec.ts
    │   │   │   ├── express-multiple.spec.ts
    │   │   │   ├── fastify-adapter.spec.ts
    │   │   │   ├── fastify-multiple.spec.ts
    │   │   │   ├── guards.spec.ts
    │   │   │   ├── hello-world.spec.ts
    │   │   │   ├── interceptors.spec.ts
    │   │   │   ├── local-pipes.spec.ts
    │   │   │   ├── middleware-class.spec.ts
    │   │   │   ├── middleware-execute-order.spec.ts
    │   │   │   ├── middleware-fastify.spec.ts
    │   │   │   ├── middleware-run-match-route.ts
    │   │   │   ├── middleware-with-versioning.spec.ts
    │   │   │   ├── middleware.spec.ts
    │   │   │   ├── router-module-middleware.spec.ts
    │   │   │   └── router-module.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── errors/
    │   │       │   └── errors.controller.ts
    │   │       ├── hello/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       ├── host/
    │   │       │   ├── host.controller.ts
    │   │       │   ├── host.module.ts
    │   │       │   ├── host.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       └── host-array/
    │   │           ├── host-array.controller.ts
    │   │           ├── host-array.module.ts
    │   │           ├── host-array.service.ts
    │   │           ├── dto/
    │   │           │   └── test.dto.ts
    │   │           └── users/
    │   │               ├── user-by-id.pipe.ts
    │   │               └── users.service.ts
    │   ├── hooks/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── before-app-shutdown.spec.ts
    │   │   │   ├── enable-shutdown-hook.spec.ts
    │   │   │   ├── lifecycle-hook-order.spec.ts
    │   │   │   ├── on-app-boostrap.spec.ts
    │   │   │   ├── on-app-shutdown.spec.ts
    │   │   │   ├── on-module-destroy.spec.ts
    │   │   │   └── on-module-init.spec.ts
    │   │   └── src/
    │   │       └── enable-shutdown-hooks-main.ts
    │   ├── injector/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── circular-custom-providers.spec.ts
    │   │   │   ├── circular-modules.spec.ts
    │   │   │   ├── circular-property-injection.spec.ts
    │   │   │   ├── circular-structure-dynamic-modules.spec.ts
    │   │   │   ├── circular.spec.ts
    │   │   │   ├── core-injectables.spec.ts
    │   │   │   ├── default-values.spec.ts
    │   │   │   ├── injector.spec.ts
    │   │   │   ├── introspection.spec.ts
    │   │   │   ├── multiple-providers.spec.ts
    │   │   │   ├── optional-factory-provider-dep.spec.ts
    │   │   │   ├── property-injection.spec.ts
    │   │   │   └── scoped-instances.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── circular/
    │   │       │   ├── circular.module.ts
    │   │       │   ├── circular.service.ts
    │   │       │   └── input.service.ts
    │   │       ├── circular-modules/
    │   │       │   ├── circular.module.ts
    │   │       │   ├── circular.service.ts
    │   │       │   ├── input.module.ts
    │   │       │   └── input.service.ts
    │   │       ├── circular-properties/
    │   │       │   ├── circular-properties.module.ts
    │   │       │   ├── circular.service.ts
    │   │       │   ├── input-properties.module.ts
    │   │       │   └── input.service.ts
    │   │       ├── circular-structure-dynamic-module/
    │   │       │   ├── circular.module.ts
    │   │       │   └── input.service.ts
    │   │       ├── core-injectables/
    │   │       │   └── core-injectables.module.ts
    │   │       ├── defaults/
    │   │       │   ├── core.service.ts
    │   │       │   ├── defaults.module.ts
    │   │       │   └── defaults.service.ts
    │   │       ├── dynamic/
    │   │       │   └── dynamic.module.ts
    │   │       ├── exports/
    │   │       │   ├── exports.module.ts
    │   │       │   └── exports.service.ts
    │   │       ├── inject/
    │   │       │   ├── core.service.ts
    │   │       │   ├── inject-same-name.module.ts
    │   │       │   ├── inject.module.ts
    │   │       │   └── inject.service.ts
    │   │       ├── multiple-providers/
    │   │       │   ├── a.module.ts
    │   │       │   ├── b.module.ts
    │   │       │   ├── c.module.ts
    │   │       │   └── multiple-providers.module.ts
    │   │       ├── properties/
    │   │       │   ├── dependency.service.ts
    │   │       │   ├── properties.module.ts
    │   │       │   └── properties.service.ts
    │   │       ├── scoped/
    │   │       │   ├── scoped.controller.ts
    │   │       │   ├── scoped.module.ts
    │   │       │   ├── scoped.service.ts
    │   │       │   ├── transient.service.ts
    │   │       │   ├── transient2.service.ts
    │   │       │   └── transient3.service.ts
    │   │       └── self-injection/
    │   │           └── self-injection-provider.module.ts
    │   ├── inspector/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── graph-inspector.spec.ts
    │   │   │   └── fixtures/
    │   │   │       ├── post-init-graph.json
    │   │   │       └── pre-init-graph.json
    │   │   └── src/
    │   │       ├── app-v1.controller.ts
    │   │       ├── app-v2.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── cats/
    │   │       │   ├── cats.controller.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── create-cat.dto.ts
    │   │       │   └── interfaces/
    │   │       │       └── cat.interface.ts
    │   │       ├── chat/
    │   │       │   ├── chat.gateway.ts
    │   │       │   ├── chat.module.ts
    │   │       │   ├── chat.service.ts
    │   │       │   ├── dto/
    │   │       │   │   ├── create-chat.dto.ts
    │   │       │   │   └── update-chat.dto.ts
    │   │       │   └── entities/
    │   │       │       └── chat.entity.ts
    │   │       ├── circular-hello/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   ├── guards/
    │   │       │   │   └── request-scoped.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       ├── circular-modules/
    │   │       │   ├── circular.module.ts
    │   │       │   ├── circular.service.ts
    │   │       │   ├── input.module.ts
    │   │       │   └── input.service.ts
    │   │       ├── common/
    │   │       │   ├── filters/
    │   │       │   │   └── http-exception.filter.ts
    │   │       │   ├── guards/
    │   │       │   │   └── roles.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── timeout.interceptor.ts
    │   │       │   ├── middleware/
    │   │       │   │   └── logger.middleware.ts
    │   │       │   └── pipes/
    │   │       │       └── parse-int.pipe.ts
    │   │       ├── core/
    │   │       │   ├── core.module.ts
    │   │       │   └── interceptors/
    │   │       │       ├── logging.interceptor.ts
    │   │       │       └── transform.interceptor.ts
    │   │       ├── database/
    │   │       │   ├── database.controller.ts
    │   │       │   ├── database.module.ts
    │   │       │   ├── database.service.ts
    │   │       │   ├── dto/
    │   │       │   │   ├── create-database.dto.ts
    │   │       │   │   └── update-database.dto.ts
    │   │       │   └── entities/
    │   │       │       └── database.entity.ts
    │   │       ├── defaults/
    │   │       │   ├── core.service.ts
    │   │       │   ├── defaults.module.ts
    │   │       │   └── defaults.service.ts
    │   │       ├── dogs/
    │   │       │   ├── dogs.controller.ts
    │   │       │   ├── dogs.module.ts
    │   │       │   ├── dogs.service.ts
    │   │       │   ├── dto/
    │   │       │   │   ├── create-dog.dto.ts
    │   │       │   │   └── update-dog.dto.ts
    │   │       │   └── entities/
    │   │       │       └── dog.entity.ts
    │   │       ├── durable/
    │   │       │   ├── durable-context-id.strategy.ts
    │   │       │   ├── durable.controller.ts
    │   │       │   ├── durable.module.ts
    │   │       │   └── durable.service.ts
    │   │       ├── external-svc/
    │   │       │   ├── external-svc.controller.ts
    │   │       │   ├── external-svc.module.ts
    │   │       │   ├── external-svc.service.ts
    │   │       │   ├── dto/
    │   │       │   │   ├── create-external-svc.dto.ts
    │   │       │   │   └── update-external-svc.dto.ts
    │   │       │   └── entities/
    │   │       │       └── external-svc.entity.ts
    │   │       ├── properties/
    │   │       │   ├── dependency.service.ts
    │   │       │   ├── properties.module.ts
    │   │       │   └── properties.service.ts
    │   │       ├── request-chain/
    │   │       │   ├── request-chain.controller.ts
    │   │       │   ├── request-chain.module.ts
    │   │       │   ├── request-chain.service.ts
    │   │       │   ├── helper/
    │   │       │   │   ├── helper.module.ts
    │   │       │   │   └── helper.service.ts
    │   │       │   └── interceptors/
    │   │       │       └── logging.interceptor.ts
    │   │       └── users/
    │   │           ├── users.controller.ts
    │   │           ├── users.module.ts
    │   │           ├── users.service.ts
    │   │           ├── dto/
    │   │           │   ├── create-user.dto.ts
    │   │           │   └── update-user.dto.ts
    │   │           └── entities/
    │   │               └── user.entity.ts
    │   ├── lazy-modules/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── lazy-import-global-modules.spec.ts
    │   │   │   ├── lazy-import-request-providers.spec.ts
    │   │   │   └── lazy-import-transient-providers.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── eager.module.ts
    │   │       ├── global.module.ts
    │   │       ├── lazy.controller.ts
    │   │       ├── lazy.module.ts
    │   │       ├── main.ts
    │   │       ├── request.module.ts
    │   │       ├── request.service.ts
    │   │       ├── transient.module.ts
    │   │       └── transient.service.ts
    │   ├── microservices/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── broadcast-mqtt.spec.ts
    │   │   │   ├── broadcast-nats.spec.ts
    │   │   │   ├── broadcast-redis.spec.ts
    │   │   │   ├── concurrent-kafka.spec.ts
    │   │   │   ├── disconnected-client.spec.ts
    │   │   │   ├── math-grpc.spec.ts
    │   │   │   ├── mqtt-record-builder.spec.ts
    │   │   │   ├── orders-grpc.spec.ts
    │   │   │   ├── sum-kafka.spec.ts
    │   │   │   ├── sum-mqtt.spec.ts
    │   │   │   ├── sum-nats.spec.ts
    │   │   │   ├── sum-redis.spec.ts
    │   │   │   ├── sum-rmq.spec.ts
    │   │   │   ├── sum-rpc-async.spec.ts
    │   │   │   ├── sum-rpc-tls.spec.ts
    │   │   │   └── sum-rpc.spec.ts
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── disconnected.controller.ts
    │   │       ├── main.ts
    │   │       ├── grpc/
    │   │       │   ├── grpc.controller.ts
    │   │       │   ├── math.proto
    │   │       │   └── math2.proto
    │   │       ├── grpc-advanced/
    │   │       │   ├── advanced.grpc.controller.ts
    │   │       │   └── proto/
    │   │       │       ├── root.proto
    │   │       │       ├── common/
    │   │       │       │   ├── item_types.proto
    │   │       │       │   └── shipment_types.proto
    │   │       │       └── orders/
    │   │       │           ├── message.proto
    │   │       │           └── service.proto
    │   │       ├── kafka/
    │   │       │   ├── kafka.controller.ts
    │   │       │   ├── kafka.messages.controller.ts
    │   │       │   ├── dtos/
    │   │       │   │   ├── business.dto.ts
    │   │       │   │   └── user.dto.ts
    │   │       │   └── entities/
    │   │       │       ├── business.entity.ts
    │   │       │       └── user.entity.ts
    │   │       ├── kafka-concurrent/
    │   │       │   ├── kafka-concurrent.controller.ts
    │   │       │   ├── kafka-concurrent.messages.controller.ts
    │   │       │   └── dto/
    │   │       │       └── sum.dto.ts
    │   │       ├── mqtt/
    │   │       │   ├── mqtt-broadcast.controller.ts
    │   │       │   └── mqtt.controller.ts
    │   │       ├── nats/
    │   │       │   ├── nats-broadcast.controller.ts
    │   │       │   ├── nats.controller.ts
    │   │       │   └── nats.service.ts
    │   │       ├── redis/
    │   │       │   ├── redis-broadcast.controller.ts
    │   │       │   └── redis.controller.ts
    │   │       ├── rmq/
    │   │       │   ├── rmq-broadcast.controller.ts
    │   │       │   └── rmq.controller.ts
    │   │       └── tcp-tls/
    │   │           ├── app.controller.ts
    │   │           ├── app.module.ts
    │   │           ├── ca.cert.pem
    │   │           └── privkey.pem
    │   ├── module-utils/
    │   │   ├── tsconfig.json
    │   │   ├── src/
    │   │   │   ├── integration.module-definition.ts
    │   │   │   ├── integration.module.ts
    │   │   │   └── interfaces/
    │   │   │       └── integration-module-options.interface.ts
    │   │   └── test/
    │   │       └── integration-module.spec.ts
    │   ├── mongoose/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── async-class-options.spec.ts
    │   │   │   ├── async-existing-options.spec.ts
    │   │   │   ├── async-options.spec.ts
    │   │   │   └── mongoose.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── async-class-options.module.ts
    │   │       ├── async-existing-options.module.ts
    │   │       ├── async-options.module.ts
    │   │       ├── main.ts
    │   │       └── cats/
    │   │           ├── cats.controller.ts
    │   │           ├── cats.module.ts
    │   │           ├── cats.service.ts
    │   │           ├── dto/
    │   │           │   └── create-cat.dto.ts
    │   │           ├── interfaces/
    │   │           │   └── cat.interface.ts
    │   │           └── schemas/
    │   │               └── cat.schema.ts
    │   ├── nest-application/
    │   │   ├── app-locals/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   └── express.spec.ts
    │   │   │   └── src/
    │   │   │       ├── app.controller.ts
    │   │   │       └── app.module.ts
    │   │   ├── get-url/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   ├── express.spec.ts
    │   │   │   │   ├── fastify.spec.ts
    │   │   │   │   └── utils.ts
    │   │   │   └── src/
    │   │   │       ├── app.controller.ts
    │   │   │       ├── app.module.ts
    │   │   │       └── app.service.ts
    │   │   ├── global-prefix/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   └── global-prefix.spec.ts
    │   │   │   └── src/
    │   │   │       ├── app.controller.ts
    │   │   │       └── app.module.ts
    │   │   ├── listen/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   ├── express.spec.ts
    │   │   │   │   └── fastify.spec.ts
    │   │   │   └── src/
    │   │   │       ├── app.controller.ts
    │   │   │       ├── app.module.ts
    │   │   │       └── app.service.ts
    │   │   ├── raw-body/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   ├── express.spec.ts
    │   │   │   │   └── fastify.spec.ts
    │   │   │   └── src/
    │   │   │       ├── express.controller.ts
    │   │   │       ├── express.module.ts
    │   │   │       ├── fastify.controller.ts
    │   │   │       └── fastify.module.ts
    │   │   ├── sse/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── e2e/
    │   │   │   │   ├── express.spec.ts
    │   │   │   │   └── fastify.spec.ts
    │   │   │   └── src/
    │   │   │       ├── app.controller.ts
    │   │   │       └── app.module.ts
    │   │   └── use-body-parser/
    │   │       ├── tsconfig.json
    │   │       ├── e2e/
    │   │       │   ├── express.spec.ts
    │   │       │   └── fastify.spec.ts
    │   │       └── src/
    │   │           ├── app.controller.ts
    │   │           └── app.module.ts
    │   ├── repl/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   └── repl.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       └── users/
    │   │           ├── users.controller.ts
    │   │           ├── users.module.ts
    │   │           ├── users.repository.ts
    │   │           ├── users.service.ts
    │   │           ├── dto/
    │   │           │   ├── create-user.dto.ts
    │   │           │   └── update-user.dto.ts
    │   │           └── entities/
    │   │               └── user.entity.ts
    │   ├── scopes/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── circular-request-scope.spec.ts
    │   │   │   ├── circular-transient-scope.spec.ts
    │   │   │   ├── durable-providers.spec.ts
    │   │   │   ├── inject-inquirer.spec.ts
    │   │   │   ├── msvc-request-scope.spec.ts
    │   │   │   ├── request-modules-scope.spec.ts
    │   │   │   ├── request-scope.spec.ts
    │   │   │   ├── resolve-scoped.spec.ts
    │   │   │   └── transient-scope.spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── circular-hello/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   ├── guards/
    │   │       │   │   └── request-scoped.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       ├── circular-transient/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── test.controller.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   ├── guards/
    │   │       │   │   └── request-scoped.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       ├── durable/
    │   │       │   ├── durable-context-id.strategy.ts
    │   │       │   ├── durable.controller.ts
    │   │       │   ├── durable.guard.ts
    │   │       │   ├── durable.module.ts
    │   │       │   ├── durable.service.ts
    │   │       │   └── non-durable.service.ts
    │   │       ├── hello/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   ├── guards/
    │   │       │   │   └── request-scoped.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── users/
    │   │       │       ├── user-by-id.pipe.ts
    │   │       │       └── users.service.ts
    │   │       ├── inject-inquirer/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello-request/
    │   │       │   │   ├── hello-request.service.ts
    │   │       │   │   └── request-logger.service.ts
    │   │       │   └── hello-transient/
    │   │       │       ├── hello-transient.service.ts
    │   │       │       └── transient-logger.service.ts
    │   │       ├── msvc/
    │   │       │   ├── hello.controller.ts
    │   │       │   ├── hello.module.ts
    │   │       │   ├── hello.service.ts
    │   │       │   ├── http.controller.ts
    │   │       │   ├── dto/
    │   │       │   │   └── test.dto.ts
    │   │       │   ├── guards/
    │   │       │   │   └── request-scoped.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── users/
    │   │       │       └── users.service.ts
    │   │       ├── request-chain/
    │   │       │   ├── request-chain.controller.ts
    │   │       │   ├── request-chain.module.ts
    │   │       │   ├── request-chain.service.ts
    │   │       │   ├── helper/
    │   │       │   │   ├── helper.module.ts
    │   │       │   │   └── helper.service.ts
    │   │       │   └── interceptors/
    │   │       │       └── logging.interceptor.ts
    │   │       ├── resolve-scoped/
    │   │       │   ├── logger.provider.ts
    │   │       │   ├── logger.service.ts
    │   │       │   └── request-logger.service.ts
    │   │       └── transient/
    │   │           ├── hello.controller.ts
    │   │           ├── hello.module.ts
    │   │           ├── hello.service.ts
    │   │           ├── test.controller.ts
    │   │           ├── dto/
    │   │           │   └── test.dto.ts
    │   │           ├── guards/
    │   │           │   └── request-scoped.guard.ts
    │   │           ├── interceptors/
    │   │           │   └── logging.interceptor.ts
    │   │           └── users/
    │   │               ├── user-by-id.pipe.ts
    │   │               └── users.service.ts
    │   ├── send-files/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── express.spec.ts
    │   │   │   ├── fastify.spec.ts
    │   │   │   └── utils.ts
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── app.service.ts
    │   │       └── non-file.ts
    │   ├── testing-module-override/
    │   │   ├── tsconfig.json
    │   │   ├── circular-dependency/
    │   │   │   ├── a.module.ts
    │   │   │   └── b.module.ts
    │   │   └── e2e/
    │   │       └── modules-override.spec.ts
    │   ├── typeorm/
    │   │   ├── ormconfig.json
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── typeorm-async-class.spec.ts
    │   │   │   ├── typeorm-async-existing.spec.ts
    │   │   │   ├── typeorm-async-options.spec.ts
    │   │   │   ├── typeorm-async.spec.ts
    │   │   │   └── typeorm.spec.ts
    │   │   └── src/
    │   │       ├── app-async.module.ts
    │   │       ├── app.module.ts
    │   │       ├── async-class-options.module.ts
    │   │       ├── async-existing-options.module.ts
    │   │       ├── async-options.module.ts
    │   │       ├── database.module.ts
    │   │       ├── main.ts
    │   │       └── photo/
    │   │           ├── photo.controller.ts
    │   │           ├── photo.entity.ts
    │   │           ├── photo.module.ts
    │   │           └── photo.service.ts
    │   ├── versioning/
    │   │   ├── tsconfig.json
    │   │   ├── e2e/
    │   │   │   ├── custom-versioning-fastify.spec.ts
    │   │   │   ├── custom-versioning.spec.ts
    │   │   │   ├── default-versioning.spec.ts
    │   │   │   ├── header-versioning-fastify.spec.ts
    │   │   │   ├── header-versioning.spec.ts
    │   │   │   ├── media-type-versioning-fastify.spec.ts
    │   │   │   ├── media-type-versioning.spec.ts
    │   │   │   ├── uri-versioning-fastify.spec.ts
    │   │   │   └── uri-versioning.spec.ts
    │   │   └── src/
    │   │       ├── app-v1.controller.ts
    │   │       ├── app-v2.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── middleware.controller.ts
    │   │       ├── multiple-middleware.controller.ts
    │   │       ├── multiple.controller.ts
    │   │       ├── neutral-middleware.controller.ts
    │   │       ├── neutral.controller.ts
    │   │       ├── no-versioning.controller.ts
    │   │       ├── override-partial.controller.ts
    │   │       └── override.controller.ts
    │   └── websockets/
    │       ├── tsconfig.json
    │       ├── e2e/
    │       │   ├── error-gateway.spec.ts
    │       │   ├── gateway-ack.spec.ts
    │       │   ├── gateway.spec.ts
    │       │   └── ws-gateway.spec.ts
    │       └── src/
    │           ├── ack.gateway.ts
    │           ├── app.gateway.ts
    │           ├── app.module.ts
    │           ├── core.gateway.ts
    │           ├── error.gateway.ts
    │           ├── example-path.gateway.ts
    │           ├── namespace.gateway.ts
    │           ├── request.filter.ts
    │           ├── request.interceptor.ts
    │           ├── server.gateway.ts
    │           ├── ws-path.gateway.ts
    │           └── ws-path2.gateway.ts
    ├── packages/
    │   ├── tsconfig.build.json
    │   ├── tsconfig.json
    │   ├── common/
    │   │   ├── Readme.md
    │   │   ├── constants.ts
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── PACKAGE.md
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── decorators/
    │   │   │   ├── index.ts
    │   │   │   ├── core/
    │   │   │   │   ├── apply-decorators.ts
    │   │   │   │   ├── bind.decorator.ts
    │   │   │   │   ├── catch.decorator.ts
    │   │   │   │   ├── controller.decorator.ts
    │   │   │   │   ├── dependencies.decorator.ts
    │   │   │   │   ├── exception-filters.decorator.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── inject.decorator.ts
    │   │   │   │   ├── injectable.decorator.ts
    │   │   │   │   ├── optional.decorator.ts
    │   │   │   │   ├── set-metadata.decorator.ts
    │   │   │   │   ├── use-guards.decorator.ts
    │   │   │   │   ├── use-interceptors.decorator.ts
    │   │   │   │   ├── use-pipes.decorator.ts
    │   │   │   │   └── version.decorator.ts
    │   │   │   ├── http/
    │   │   │   │   ├── create-route-param-metadata.decorator.ts
    │   │   │   │   ├── header.decorator.ts
    │   │   │   │   ├── http-code.decorator.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── redirect.decorator.ts
    │   │   │   │   ├── render.decorator.ts
    │   │   │   │   ├── request-mapping.decorator.ts
    │   │   │   │   ├── route-params.decorator.ts
    │   │   │   │   └── sse.decorator.ts
    │   │   │   └── modules/
    │   │   │       ├── global.decorator.ts
    │   │   │       ├── index.ts
    │   │   │       └── module.decorator.ts
    │   │   ├── enums/
    │   │   │   ├── http-status.enum.ts
    │   │   │   ├── index.ts
    │   │   │   ├── request-method.enum.ts
    │   │   │   ├── route-paramtypes.enum.ts
    │   │   │   ├── shutdown-signal.enum.ts
    │   │   │   └── version-type.enum.ts
    │   │   ├── exceptions/
    │   │   │   ├── bad-gateway.exception.ts
    │   │   │   ├── bad-request.exception.ts
    │   │   │   ├── conflict.exception.ts
    │   │   │   ├── forbidden.exception.ts
    │   │   │   ├── gateway-timeout.exception.ts
    │   │   │   ├── gone.exception.ts
    │   │   │   ├── http-version-not-supported.exception.ts
    │   │   │   ├── http.exception.ts
    │   │   │   ├── im-a-teapot.exception.ts
    │   │   │   ├── index.ts
    │   │   │   ├── internal-server-error.exception.ts
    │   │   │   ├── intrinsic.exception.ts
    │   │   │   ├── method-not-allowed.exception.ts
    │   │   │   ├── misdirected.exception.ts
    │   │   │   ├── not-acceptable.exception.ts
    │   │   │   ├── not-found.exception.ts
    │   │   │   ├── not-implemented.exception.ts
    │   │   │   ├── payload-too-large.exception.ts
    │   │   │   ├── precondition-failed.exception.ts
    │   │   │   ├── request-timeout.exception.ts
    │   │   │   ├── service-unavailable.exception.ts
    │   │   │   ├── unauthorized.exception.ts
    │   │   │   ├── unprocessable-entity.exception.ts
    │   │   │   └── unsupported-media-type.exception.ts
    │   │   ├── file-stream/
    │   │   │   ├── index.ts
    │   │   │   ├── streamable-file.ts
    │   │   │   └── interfaces/
    │   │   │       ├── index.ts
    │   │   │       ├── streamable-handler-response.interface.ts
    │   │   │       └── streamable-options.interface.ts
    │   │   ├── interfaces/
    │   │   │   ├── abstract.interface.ts
    │   │   │   ├── global-prefix-options.interface.ts
    │   │   │   ├── index.ts
    │   │   │   ├── injectable.interface.ts
    │   │   │   ├── nest-application-context-options.interface.ts
    │   │   │   ├── nest-application-context.interface.ts
    │   │   │   ├── nest-application-options.interface.ts
    │   │   │   ├── nest-application.interface.ts
    │   │   │   ├── nest-microservice.interface.ts
    │   │   │   ├── scope-options.interface.ts
    │   │   │   ├── type.interface.ts
    │   │   │   ├── version-options.interface.ts
    │   │   │   ├── controllers/
    │   │   │   │   ├── controller-metadata.interface.ts
    │   │   │   │   ├── controller.interface.ts
    │   │   │   │   └── index.ts
    │   │   │   ├── exceptions/
    │   │   │   │   ├── exception-filter-metadata.interface.ts
    │   │   │   │   ├── exception-filter.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── rpc-exception-filter-metadata.interface.ts
    │   │   │   │   ├── rpc-exception-filter.interface.ts
    │   │   │   │   └── ws-exception-filter.interface.ts
    │   │   │   ├── external/
    │   │   │   │   ├── class-transform-options.interface.ts
    │   │   │   │   ├── cors-options.interface.ts
    │   │   │   │   ├── https-options.interface.ts
    │   │   │   │   ├── transformer-package.interface.ts
    │   │   │   │   ├── validation-error.interface.ts
    │   │   │   │   ├── validator-options.interface.ts
    │   │   │   │   └── validator-package.interface.ts
    │   │   │   ├── features/
    │   │   │   │   ├── arguments-host.interface.ts
    │   │   │   │   ├── can-activate.interface.ts
    │   │   │   │   ├── custom-route-param-factory.interface.ts
    │   │   │   │   ├── execution-context.interface.ts
    │   │   │   │   ├── nest-interceptor.interface.ts
    │   │   │   │   ├── paramtype.interface.ts
    │   │   │   │   └── pipe-transform.interface.ts
    │   │   │   ├── hooks/
    │   │   │   │   ├── before-application-shutdown.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── on-application-bootstrap.interface.ts
    │   │   │   │   ├── on-application-shutdown.interface.ts
    │   │   │   │   ├── on-destroy.interface.ts
    │   │   │   │   └── on-init.interface.ts
    │   │   │   ├── http/
    │   │   │   │   ├── http-exception-body.interface.ts
    │   │   │   │   ├── http-redirect-response.interface.ts
    │   │   │   │   ├── http-server.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── message-event.interface.ts
    │   │   │   │   └── raw-body-request.interface.ts
    │   │   │   ├── microservices/
    │   │   │   │   ├── nest-hybrid-application-options.interface.ts
    │   │   │   │   └── nest-microservice-options.interface.ts
    │   │   │   ├── middleware/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── middleware-config-proxy.interface.ts
    │   │   │   │   ├── middleware-configuration.interface.ts
    │   │   │   │   ├── middleware-consumer.interface.ts
    │   │   │   │   └── nest-middleware.interface.ts
    │   │   │   ├── modules/
    │   │   │   │   ├── dynamic-module.interface.ts
    │   │   │   │   ├── forward-reference.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── injection-token.interface.ts
    │   │   │   │   ├── introspection-result.interface.ts
    │   │   │   │   ├── module-metadata.interface.ts
    │   │   │   │   ├── nest-module.interface.ts
    │   │   │   │   ├── optional-factory-dependency.interface.ts
    │   │   │   │   └── provider.interface.ts
    │   │   │   └── websockets/
    │   │   │       └── web-socket-adapter.interface.ts
    │   │   ├── module-utils/
    │   │   │   ├── configurable-module.builder.ts
    │   │   │   ├── constants.ts
    │   │   │   ├── index.ts
    │   │   │   ├── interfaces/
    │   │   │   │   ├── configurable-module-async-options.interface.ts
    │   │   │   │   ├── configurable-module-cls.interface.ts
    │   │   │   │   ├── configurable-module-host.interface.ts
    │   │   │   │   └── index.ts
    │   │   │   └── utils/
    │   │   │       ├── generate-options-injection-token.util.ts
    │   │   │       ├── get-injection-providers.util.ts
    │   │   │       └── index.ts
    │   │   ├── pipes/
    │   │   │   ├── default-value.pipe.ts
    │   │   │   ├── index.ts
    │   │   │   ├── parse-array.pipe.ts
    │   │   │   ├── parse-bool.pipe.ts
    │   │   │   ├── parse-date.pipe.ts
    │   │   │   ├── parse-enum.pipe.ts
    │   │   │   ├── parse-float.pipe.ts
    │   │   │   ├── parse-int.pipe.ts
    │   │   │   ├── parse-uuid.pipe.ts
    │   │   │   ├── validation.pipe.ts
    │   │   │   └── file/
    │   │   │       ├── file-type.validator.ts
    │   │   │       ├── file-validator.interface.ts
    │   │   │       ├── index.ts
    │   │   │       ├── max-file-size.validator.ts
    │   │   │       ├── parse-file-options.interface.ts
    │   │   │       ├── parse-file-pipe.builder.ts
    │   │   │       ├── parse-file.pipe.ts
    │   │   │       └── interfaces/
    │   │   │           ├── file.interface.ts
    │   │   │           └── index.ts
    │   │   ├── serializer/
    │   │   │   ├── class-serializer.constants.ts
    │   │   │   ├── class-serializer.interceptor.ts
    │   │   │   ├── class-serializer.interfaces.ts
    │   │   │   ├── index.ts
    │   │   │   └── decorators/
    │   │   │       ├── index.ts
    │   │   │       └── serialize-options.decorator.ts
    │   │   ├── services/
    │   │   │   ├── console-logger.service.ts
    │   │   │   ├── index.ts
    │   │   │   ├── logger.service.ts
    │   │   │   └── utils/
    │   │   │       ├── index.ts
    │   │   │       └── is-log-level-enabled.util.ts
    │   │   ├── test/
    │   │   │   ├── tsconfig.json
    │   │   │   ├── decorators/
    │   │   │   │   ├── apply-decorators.spec.ts
    │   │   │   │   ├── bind.decorator.spec.ts
    │   │   │   │   ├── catch.decorator.spec.ts
    │   │   │   │   ├── controller.decorator.spec.ts
    │   │   │   │   ├── create-param-decorator.spec.ts
    │   │   │   │   ├── dependencies.decorator.spec.ts
    │   │   │   │   ├── exception-filters.decorator.spec.ts
    │   │   │   │   ├── global.decorator.spec.ts
    │   │   │   │   ├── header.decorator.spec.ts
    │   │   │   │   ├── http-code.decorator.spec.ts
    │   │   │   │   ├── inject.decorator.spec.ts
    │   │   │   │   ├── injectable.decorator.spec.ts
    │   │   │   │   ├── module.decorator.spec.ts
    │   │   │   │   ├── redirect.decorator.spec.ts
    │   │   │   │   ├── render.decorator.spec.ts
    │   │   │   │   ├── request-mapping.decorator.spec.ts
    │   │   │   │   ├── route-params.decorator.spec.ts
    │   │   │   │   ├── set-metadata.decorator.spec.ts
    │   │   │   │   ├── sse.decorator.spec.ts
    │   │   │   │   ├── use-guards.decorator.spec.ts
    │   │   │   │   ├── use-interceptors.decorator.spec.ts
    │   │   │   │   ├── use-pipes.decorator.spec.ts
    │   │   │   │   └── version.decorator.spec.ts
    │   │   │   ├── exceptions/
    │   │   │   │   └── http.exception.spec.ts
    │   │   │   ├── file-stream/
    │   │   │   │   └── streamable-file.spec.ts
    │   │   │   ├── module-utils/
    │   │   │   │   ├── configurable-module.builder.spec.ts
    │   │   │   │   └── utils/
    │   │   │   │       └── get-injection-providers.util.spec.ts
    │   │   │   ├── pipes/
    │   │   │   │   ├── default-value.pipe.spec.ts
    │   │   │   │   ├── parse-array.pipe.spec.ts
    │   │   │   │   ├── parse-bool.pipe.spec.ts
    │   │   │   │   ├── parse-date.pipe.spec.ts
    │   │   │   │   ├── parse-enum.pipe.spec.ts
    │   │   │   │   ├── parse-float.pipe.spec.ts
    │   │   │   │   ├── parse-int.pipe.spec.ts
    │   │   │   │   ├── parse-uuid.pipe.spec.ts
    │   │   │   │   ├── validation.pipe.spec.ts
    │   │   │   │   └── file/
    │   │   │   │       ├── file-type.validator.spec.ts
    │   │   │   │       ├── max-file-size.validator.spec.ts
    │   │   │   │       ├── parse-file-pipe.builder.spec.ts
    │   │   │   │       └── parse-file.pipe.spec.ts
    │   │   │   ├── services/
    │   │   │   │   ├── logger.service.spec.ts
    │   │   │   │   └── utils/
    │   │   │   │       └── is-log-level-enabled.util.spec.ts
    │   │   │   └── utils/
    │   │   │       ├── forward-ref.util.spec.ts
    │   │   │       ├── load-package.util.spec.ts
    │   │   │       ├── merge-with-values.util.spec.ts
    │   │   │       ├── random-string-generator.util.spec.ts
    │   │   │       ├── select-exception-filter-metadata.util.spec.ts
    │   │   │       ├── shared.utils.spec.ts
    │   │   │       └── validate-each.util.spec.ts
    │   │   └── utils/
    │   │       ├── assign-custom-metadata.util.ts
    │   │       ├── cli-colors.util.ts
    │   │       ├── extend-metadata.util.ts
    │   │       ├── forward-ref.util.ts
    │   │       ├── http-error-by-code.util.ts
    │   │       ├── index.ts
    │   │       ├── load-package.util.ts
    │   │       ├── merge-with-values.util.ts
    │   │       ├── random-string-generator.util.ts
    │   │       ├── select-exception-filter-metadata.util.ts
    │   │       ├── shared.utils.ts
    │   │       ├── validate-each.util.ts
    │   │       └── validate-module-keys.util.ts
    │   ├── core/
    │   │   ├── Readme.md
    │   │   ├── application-config.ts
    │   │   ├── constants.ts
    │   │   ├── index.ts
    │   │   ├── metadata-scanner.ts
    │   │   ├── nest-application-context.ts
    │   │   ├── nest-application.ts
    │   │   ├── nest-factory.ts
    │   │   ├── package.json
    │   │   ├── PACKAGE.md
    │   │   ├── scanner.ts
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── adapters/
    │   │   │   ├── http-adapter.ts
    │   │   │   └── index.ts
    │   │   ├── discovery/
    │   │   │   ├── discoverable-meta-host-collection.ts
    │   │   │   ├── discovery-module.ts
    │   │   │   ├── discovery-service.ts
    │   │   │   └── index.ts
    │   │   ├── errors/
    │   │   │   ├── exception-handler.ts
    │   │   │   ├── exceptions-zone.ts
    │   │   │   ├── messages.ts
    │   │   │   └── exceptions/
    │   │   │       ├── circular-dependency.exception.ts
    │   │   │       ├── index.ts
    │   │   │       ├── invalid-class-module.exception.ts
    │   │   │       ├── invalid-class-scope.exception.ts
    │   │   │       ├── invalid-class.exception.ts
    │   │   │       ├── invalid-exception-filter.exception.ts
    │   │   │       ├── invalid-middleware-configuration.exception.ts
    │   │   │       ├── invalid-middleware.exception.ts
    │   │   │       ├── invalid-module.exception.ts
    │   │   │       ├── runtime.exception.ts
    │   │   │       ├── undefined-dependency.exception.ts
    │   │   │       ├── undefined-forwardref.exception.ts
    │   │   │       ├── undefined-module.exception.ts
    │   │   │       ├── unknown-dependencies.exception.ts
    │   │   │       ├── unknown-element.exception.ts
    │   │   │       ├── unknown-export.exception.ts
    │   │   │       ├── unknown-module.exception.ts
    │   │   │       └── unknown-request-mapping.exception.ts
    │   │   ├── exceptions/
    │   │   │   ├── base-exception-filter-context.ts
    │   │   │   ├── base-exception-filter.ts
    │   │   │   ├── exceptions-handler.ts
    │   │   │   ├── external-exception-filter-context.ts
    │   │   │   ├── external-exception-filter.ts
    │   │   │   ├── external-exceptions-handler.ts
    │   │   │   └── index.ts
    │   │   ├── guards/
    │   │   │   ├── constants.ts
    │   │   │   ├── guards-consumer.ts
    │   │   │   ├── guards-context-creator.ts
    │   │   │   └── index.ts
    │   │   ├── helpers/
    │   │   │   ├── context-creator.ts
    │   │   │   ├── context-id-factory.ts
    │   │   │   ├── context-utils.ts
    │   │   │   ├── execution-context-host.ts
    │   │   │   ├── external-context-creator.ts
    │   │   │   ├── external-proxy.ts
    │   │   │   ├── get-class-scope.ts
    │   │   │   ├── handler-metadata-storage.ts
    │   │   │   ├── http-adapter-host.ts
    │   │   │   ├── index.ts
    │   │   │   ├── is-durable.ts
    │   │   │   ├── load-adapter.ts
    │   │   │   ├── messages.ts
    │   │   │   ├── optional-require.ts
    │   │   │   ├── rethrow.ts
    │   │   │   ├── router-method-factory.ts
    │   │   │   └── interfaces/
    │   │   │       ├── external-handler-metadata.interface.ts
    │   │   │       ├── index.ts
    │   │   │       └── params-metadata.interface.ts
    │   │   ├── hooks/
    │   │   │   ├── before-app-shutdown.hook.ts
    │   │   │   ├── index.ts
    │   │   │   ├── on-app-bootstrap.hook.ts
    │   │   │   ├── on-app-shutdown.hook.ts
    │   │   │   ├── on-module-destroy.hook.ts
    │   │   │   └── on-module-init.hook.ts
    │   │   ├── injector/
    │   │   │   ├── abstract-instance-resolver.ts
    │   │   │   ├── compiler.ts
    │   │   │   ├── constants.ts
    │   │   │   ├── container.ts
    │   │   │   ├── index.ts
    │   │   │   ├── injector.ts
    │   │   │   ├── instance-links-host.ts
    │   │   │   ├── instance-loader.ts
    │   │   │   ├── instance-wrapper.ts
    │   │   │   ├── internal-providers-storage.ts
    │   │   │   ├── module-ref.ts
    │   │   │   ├── module.ts
    │   │   │   ├── modules-container.ts
    │   │   │   ├── settlement-signal.ts
    │   │   │   ├── helpers/
    │   │   │   │   ├── provider-classifier.ts
    │   │   │   │   ├── silent-logger.ts
    │   │   │   │   └── transient-instances.ts
    │   │   │   ├── inquirer/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── inquirer-constants.ts
    │   │   │   │   └── inquirer-providers.ts
    │   │   │   ├── internal-core-module/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── internal-core-module-factory.ts
    │   │   │   │   └── internal-core-module.ts
    │   │   │   ├── lazy-module-loader/
    │   │   │   │   ├── lazy-module-loader-options.interface.ts
    │   │   │   │   └── lazy-module-loader.ts
    │   │   │   ├── opaque-key-factory/
    │   │   │   │   ├── by-reference-module-opaque-key-factory.ts
    │   │   │   │   ├── deep-hashed-module-opaque-key-factory.ts
    │   │   │   │   └── interfaces/
    │   │   │   │       └── module-opaque-key-factory.interface.ts
    │   │   │   └── topology-tree/
    │   │   │       ├── topology-tree.ts
    │   │   │       └── tree-node.ts
    │   │   ├── inspector/
    │   │   │   ├── deterministic-uuid-registry.ts
    │   │   │   ├── graph-inspector.ts
    │   │   │   ├── index.ts
    │   │   │   ├── initialize-on-preview.allowlist.ts
    │   │   │   ├── noop-graph-inspector.ts
    │   │   │   ├── partial-graph.host.ts
    │   │   │   ├── serialized-graph.ts
    │   │   │   ├── uuid-factory.ts
    │   │   │   └── interfaces/
    │   │   │       ├── edge.interface.ts
    │   │   │       ├── enhancer-metadata-cache-entry.interface.ts
    │   │   │       ├── entrypoint.interface.ts
    │   │   │       ├── extras.interface.ts
    │   │   │       ├── node.interface.ts
    │   │   │       ├── serialized-graph-json.interface.ts
    │   │   │       └── serialized-graph-metadata.interface.ts
    │   │   ├── interceptors/
    │   │   │   ├── index.ts
    │   │   │   ├── interceptors-consumer.ts
    │   │   │   └── interceptors-context-creator.ts
    │   │   ├── interfaces/
    │   │   │   ├── module-definition.interface.ts
    │   │   │   └── module-override.interface.ts
    │   │   ├── middleware/
    │   │   │   ├── builder.ts
    │   │   │   ├── container.ts
    │   │   │   ├── index.ts
    │   │   │   ├── middleware-module.ts
    │   │   │   ├── resolver.ts
    │   │   │   ├── route-info-path-extractor.ts
    │   │   │   ├── routes-mapper.ts
    │   │   │   └── utils.ts
    │   │   ├── pipes/
    │   │   │   ├── index.ts
    │   │   │   ├── params-token-factory.ts
    │   │   │   ├── pipes-consumer.ts
    │   │   │   └── pipes-context-creator.ts
    │   │   ├── repl/
    │   │   │   ├── assign-to-object.util.ts
    │   │   │   ├── constants.ts
    │   │   │   ├── index.ts
    │   │   │   ├── repl-context.ts
    │   │   │   ├── repl-function.ts
    │   │   │   ├── repl-logger.ts
    │   │   │   ├── repl-native-commands.ts
    │   │   │   ├── repl.interfaces.ts
    │   │   │   ├── repl.ts
    │   │   │   └── native-functions/
    │   │   │       ├── debug-repl-fn.ts
    │   │   │       ├── get-relp-fn.ts
    │   │   │       ├── help-repl-fn.ts
    │   │   │       ├── index.ts
    │   │   │       ├── methods-repl-fn.ts
    │   │   │       ├── resolve-repl-fn.ts
    │   │   │       └── select-relp-fn.ts
    │   │   ├── router/
    │   │   │   ├── index.ts
    │   │   │   ├── legacy-route-converter.ts
    │   │   │   ├── paths-explorer.ts
    │   │   │   ├── route-params-factory.ts
    │   │   │   ├── route-path-factory.ts
    │   │   │   ├── router-exception-filters.ts
    │   │   │   ├── router-execution-context.ts
    │   │   │   ├── router-explorer.ts
    │   │   │   ├── router-module.ts
    │   │   │   ├── router-proxy.ts
    │   │   │   ├── router-response-controller.ts
    │   │   │   ├── routes-resolver.ts
    │   │   │   ├── sse-stream.ts
    │   │   │   ├── interfaces/
    │   │   │   │   ├── exceptions-filter.interface.ts
    │   │   │   │   ├── exclude-route-metadata.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── resolver.interface.ts
    │   │   │   │   ├── route-params-factory.interface.ts
    │   │   │   │   ├── route-path-metadata.interface.ts
    │   │   │   │   └── routes.interface.ts
    │   │   │   ├── request/
    │   │   │   │   ├── index.ts
    │   │   │   │   ├── request-constants.ts
    │   │   │   │   └── request-providers.ts
    │   │   │   └── utils/
    │   │   │       ├── exclude-route.util.ts
    │   │   │       ├── flatten-route-paths.util.ts
    │   │   │       └── index.ts
    │   │   ├── services/
    │   │   │   ├── index.ts
    │   │   │   └── reflector.service.ts
    │   │   └── test/
    │   │       ├── application-config.spec.ts
    │   │       ├── metadata-scanner.spec.ts
    │   │       ├── nest-application-context.spec.ts
    │   │       ├── nest-application.spec.ts
    │   │       ├── scanner.spec.ts
    │   │       ├── tsconfig.json
    │   │       ├── errors/
    │   │       │   └── test/
    │   │       │       ├── exception-handler.spec.ts
    │   │       │       ├── exceptions-zone.spec.ts
    │   │       │       └── messages.spec.ts
    │   │       ├── exceptions/
    │   │       │   ├── base-exception-filter.spec.ts
    │   │       │   ├── exceptions-handler.spec.ts
    │   │       │   ├── external-exception-filter-context.spec.ts
    │   │       │   └── external-exceptions-handler.spec.ts
    │   │       ├── guards/
    │   │       │   ├── guards-consumer.spec.ts
    │   │       │   └── guards-context-creator.spec.ts
    │   │       ├── helpers/
    │   │       │   ├── application-ref-host.spec.ts
    │   │       │   ├── context-id-factory.spec.ts
    │   │       │   ├── context-utils.spec.ts
    │   │       │   ├── execution-context-host.spec.ts
    │   │       │   ├── external-context-creator.spec.ts
    │   │       │   ├── external-proxy.spec.ts
    │   │       │   └── router-method-factory.spec.ts
    │   │       ├── hooks/
    │   │       │   ├── before-app-shutdown.hook.spec.ts
    │   │       │   ├── on-app-bootstrap.hook.spec.ts
    │   │       │   ├── on-app-shutdown.hook.spec.ts
    │   │       │   ├── on-module-destroy.hook.spec.ts
    │   │       │   └── on-module-init.hook.spec.ts
    │   │       ├── injector/
    │   │       │   ├── compiler.spec.ts
    │   │       │   ├── container.spec.ts
    │   │       │   ├── injector.spec.ts
    │   │       │   ├── instance-loader.spec.ts
    │   │       │   ├── instance-wrapper.spec.ts
    │   │       │   ├── module.spec.ts
    │   │       │   ├── helpers/
    │   │       │   │   └── provider-classifier.spec.ts
    │   │       │   ├── internal-core-module/
    │   │       │   │   └── internal-core-module-factory.spec.ts
    │   │       │   ├── lazy-module-loader/
    │   │       │   │   └── lazy-module-loader.spec.ts
    │   │       │   └── opaque-key-factory/
    │   │       │       ├── by-reference-module-opaque-key-factory.spec.ts
    │   │       │       └── deep-hashed-module-opaque-key-factory.spec.ts
    │   │       ├── inspector/
    │   │       │   ├── graph-inspector.spec.ts
    │   │       │   └── serialized-graph.spec.ts
    │   │       ├── interceptors/
    │   │       │   ├── interceptors-consumer.spec.ts
    │   │       │   └── interceptors-context-creator.spec.ts
    │   │       ├── middleware/
    │   │       │   ├── builder.spec.ts
    │   │       │   ├── container.spec.ts
    │   │       │   ├── middleware-module.spec.ts
    │   │       │   ├── resolver.spec.ts
    │   │       │   ├── route-info-path-extractor.spec.ts
    │   │       │   ├── routes-mapper.spec.ts
    │   │       │   └── utils.spec.ts
    │   │       ├── pipes/
    │   │       │   ├── params-token-factory.spec.ts
    │   │       │   ├── pipes-consumer.spec.ts
    │   │       │   └── pipes-context-creator.spec.ts
    │   │       ├── repl/
    │   │       │   ├── assign-to-object.util.spec.ts
    │   │       │   ├── repl-context.spec.ts
    │   │       │   └── native-functions/
    │   │       │       ├── debug-repl-fn.spec.ts
    │   │       │       ├── get-repl-fn.spec.ts
    │   │       │       ├── help-repl-fn.spec.ts
    │   │       │       ├── methods-repl-fn.spec.ts
    │   │       │       ├── resolve-repl-fn.spec.ts
    │   │       │       └── select-repl-fn.spec.ts
    │   │       ├── router/
    │   │       │   ├── paths-explorer.spec.ts
    │   │       │   ├── route-params-factory.spec.ts
    │   │       │   ├── route-path-factory.spec.ts
    │   │       │   ├── router-exception-filters.spec.ts
    │   │       │   ├── router-execution-context.spec.ts
    │   │       │   ├── router-explorer.spec.ts
    │   │       │   ├── router-module.spec.ts
    │   │       │   ├── router-proxy.spec.ts
    │   │       │   ├── router-response-controller.spec.ts
    │   │       │   ├── routes-resolver.spec.ts
    │   │       │   ├── sse-stream.spec.ts
    │   │       │   └── utils/
    │   │       │       └── flat-routes.spec.ts
    │   │       ├── services/
    │   │       │   └── reflector.service.spec.ts
    │   │       └── utils/
    │   │           ├── noop-adapter.spec.ts
    │   │           └── string.cleaner.ts
    │   ├── microservices/
    │   │   ├── Readme.md
    │   │   ├── constants.ts
    │   │   ├── container.ts
    │   │   ├── index.ts
    │   │   ├── listener-metadata-explorer.ts
    │   │   ├── listeners-controller.ts
    │   │   ├── microservices-module.ts
    │   │   ├── nest-microservice.ts
    │   │   ├── package.json
    │   │   ├── tokens.ts
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── client/
    │   │   │   ├── client-grpc.ts
    │   │   │   ├── client-kafka.ts
    │   │   │   ├── client-mqtt.ts
    │   │   │   ├── client-nats.ts
    │   │   │   ├── client-proxy-factory.ts
    │   │   │   ├── client-proxy.ts
    │   │   │   ├── client-redis.ts
    │   │   │   ├── client-rmq.ts
    │   │   │   ├── client-tcp.ts
    │   │   │   └── index.ts
    │   │   ├── context/
    │   │   │   ├── exception-filters-context.ts
    │   │   │   ├── request-context-host.ts
    │   │   │   ├── rpc-context-creator.ts
    │   │   │   ├── rpc-metadata-constants.ts
    │   │   │   └── rpc-proxy.ts
    │   │   ├── ctx-host/
    │   │   │   ├── base-rpc.context.ts
    │   │   │   ├── index.ts
    │   │   │   ├── kafka.context.ts
    │   │   │   ├── mqtt.context.ts
    │   │   │   ├── nats.context.ts
    │   │   │   ├── redis.context.ts
    │   │   │   ├── rmq.context.ts
    │   │   │   └── tcp.context.ts
    │   │   ├── decorators/
    │   │   │   ├── client.decorator.ts
    │   │   │   ├── ctx.decorator.ts
    │   │   │   ├── event-pattern.decorator.ts
    │   │   │   ├── grpc-service.decorator.ts
    │   │   │   ├── index.ts
    │   │   │   ├── message-pattern.decorator.ts
    │   │   │   └── payload.decorator.ts
    │   │   ├── deserializers/
    │   │   │   ├── identity.deserializer.ts
    │   │   │   ├── incoming-request.deserializer.ts
    │   │   │   ├── incoming-response.deserializer.ts
    │   │   │   ├── index.ts
    │   │   │   ├── kafka-request.deserializer.ts
    │   │   │   ├── kafka-response.deserializer.ts
    │   │   │   ├── nats-request-json.deserializer.ts
    │   │   │   └── nats-response-json.deserializer.ts
    │   │   ├── enums/
    │   │   │   ├── index.ts
    │   │   │   ├── kafka-headers.enum.ts
    │   │   │   ├── pattern-handler.enum.ts
    │   │   │   ├── rpc-paramtype.enum.ts
    │   │   │   └── transport.enum.ts
    │   │   ├── errors/
    │   │   │   ├── corrupted-packet-length.exception.ts
    │   │   │   ├── empty-response.exception.ts
    │   │   │   ├── invalid-grpc-message-decorator.exception.ts
    │   │   │   ├── invalid-grpc-package-definition-missing-package-definition.exception.ts
    │   │   │   ├── invalid-grpc-package-definition-mutex.exception.ts
    │   │   │   ├── invalid-grpc-package.exception.ts
    │   │   │   ├── invalid-grpc-service.exception.ts
    │   │   │   ├── invalid-json-format.exception.ts
    │   │   │   ├── invalid-kafka-client-topic.exception.ts
    │   │   │   ├── invalid-message.exception.ts
    │   │   │   ├── invalid-proto-definition.exception.ts
    │   │   │   ├── max-packet-length-exceeded.exception.ts
    │   │   │   └── net-socket-closed.exception.ts
    │   │   ├── events/
    │   │   │   ├── index.ts
    │   │   │   ├── kafka.events.ts
    │   │   │   ├── mqtt.events.ts
    │   │   │   ├── nats.events.ts
    │   │   │   ├── redis.events.ts
    │   │   │   ├── rmq.events.ts
    │   │   │   └── tcp.events.ts
    │   │   ├── exceptions/
    │   │   │   ├── base-rpc-exception-filter.ts
    │   │   │   ├── index.ts
    │   │   │   ├── kafka-retriable-exception.ts
    │   │   │   ├── rpc-exception.ts
    │   │   │   └── rpc-exceptions-handler.ts
    │   │   ├── external/
    │   │   │   ├── grpc-options.interface.ts
    │   │   │   ├── kafka.interface.ts
    │   │   │   ├── mqtt-options.interface.ts
    │   │   │   ├── nats-codec.interface.ts
    │   │   │   ├── redis.interface.ts
    │   │   │   └── rmq-url.interface.ts
    │   │   ├── factories/
    │   │   │   └── rpc-params-factory.ts
    │   │   ├── helpers/
    │   │   │   ├── grpc-helpers.ts
    │   │   │   ├── index.ts
    │   │   │   ├── json-socket.ts
    │   │   │   ├── kafka-logger.ts
    │   │   │   ├── kafka-parser.ts
    │   │   │   ├── kafka-reply-partition-assigner.ts
    │   │   │   └── tcp-socket.ts
    │   │   ├── interfaces/
    │   │   │   ├── client-grpc.interface.ts
    │   │   │   ├── client-kafka-proxy.interface.ts
    │   │   │   ├── client-metadata.interface.ts
    │   │   │   ├── custom-transport-strategy.interface.ts
    │   │   │   ├── deserializer.interface.ts
    │   │   │   ├── index.ts
    │   │   │   ├── message-handler.interface.ts
    │   │   │   ├── microservice-configuration.interface.ts
    │   │   │   ├── microservice-entrypoint-metadata.interface.ts
    │   │   │   ├── packet.interface.ts
    │   │   │   ├── pattern-metadata.interface.ts
    │   │   │   ├── pattern.interface.ts
    │   │   │   ├── request-context.interface.ts
    │   │   │   └── serializer.interface.ts
    │   │   ├── module/
    │   │   │   ├── clients.module.ts
    │   │   │   ├── index.ts
    │   │   │   └── interfaces/
    │   │   │       ├── clients-module.interface.ts
    │   │   │       └── index.ts
    │   │   ├── record-builders/
    │   │   │   ├── index.ts
    │   │   │   ├── mqtt.record-builder.ts
    │   │   │   ├── nats.record-builder.ts
    │   │   │   └── rmq.record-builder.ts
    │   │   ├── serializers/
    │   │   │   ├── identity.serializer.ts
    │   │   │   ├── index.ts
    │   │   │   ├── kafka-request.serializer.ts
    │   │   │   ├── mqtt-record.serializer.ts
    │   │   │   ├── nats-record.serializer.ts
    │   │   │   └── rmq-record.serializer.ts
    │   │   ├── server/
    │   │   │   ├── index.ts
    │   │   │   ├── server-factory.ts
    │   │   │   ├── server-grpc.ts
    │   │   │   ├── server-kafka.ts
    │   │   │   ├── server-mqtt.ts
    │   │   │   ├── server-nats.ts
    │   │   │   ├── server-redis.ts
    │   │   │   ├── server-rmq.ts
    │   │   │   ├── server-tcp.ts
    │   │   │   └── server.ts
    │   │   ├── test/
    │   │   │   ├── container.spec.ts
    │   │   │   ├── listeners-controller.spec.ts
    │   │   │   ├── listeners-metadata-explorer.spec.ts
    │   │   │   ├── tsconfig.json
    │   │   │   ├── client/
    │   │   │   │   ├── client-grpc.spec.ts
    │   │   │   │   ├── client-kafka.spec.ts
    │   │   │   │   ├── client-mqtt.spec.ts
    │   │   │   │   ├── client-nats.spec.ts
    │   │   │   │   ├── client-proxy-factory.spec.ts
    │   │   │   │   ├── client-proxy.spec.ts
    │   │   │   │   ├── client-redis.spec.ts
    │   │   │   │   ├── client-rmq.spec.ts
    │   │   │   │   ├── client-tcp.spec.ts
    │   │   │   │   ├── test.proto
    │   │   │   │   └── test2.proto
    │   │   │   ├── context/
    │   │   │   │   ├── exception-filters-context.spec.ts
    │   │   │   │   ├── request-context-host.spec.ts
    │   │   │   │   ├── rpc-context-creator.spec.ts
    │   │   │   │   └── rpc-proxy.spec.ts
    │   │   │   ├── ctx-host/
    │   │   │   │   ├── base-rpc-context.spec.ts
    │   │   │   │   ├── kafka.context.spec.ts
    │   │   │   │   ├── mqtt.context.spec.ts
    │   │   │   │   ├── nats.context.spec.ts
    │   │   │   │   ├── redis.context.spec.ts
    │   │   │   │   ├── rmq.context.spec.ts
    │   │   │   │   └── tcp.context.spec.ts
    │   │   │   ├── decorators/
    │   │   │   │   ├── client.decorator.spec.ts
    │   │   │   │   ├── ctx.decorator.spec.ts
    │   │   │   │   ├── event-pattern.decorator.spec.ts
    │   │   │   │   ├── message-pattern.decorator.spec.ts
    │   │   │   │   └── payload.decorator.spec.ts
    │   │   │   ├── deserializers/
    │   │   │   │   ├── identity.deserializer.spec.ts
    │   │   │   │   ├── incoming-request.deserializer.spec.ts
    │   │   │   │   ├── incoming-response.deserializer.spec.ts
    │   │   │   │   └── kafka-response.deserializer.spec.ts
    │   │   │   ├── exceptions/
    │   │   │   │   ├── rpc-exception.spec.ts
    │   │   │   │   └── rpc-exceptions-handler.spec.ts
    │   │   │   ├── factories/
    │   │   │   │   └── rpc-params-factory.spec.ts
    │   │   │   ├── helpers/
    │   │   │   │   ├── grpc-helpers.spec.ts
    │   │   │   │   ├── kafka-logger.spec.ts
    │   │   │   │   ├── kafka-parser.spec.ts
    │   │   │   │   └── kafka-reply-partition-assigner.spec.ts
    │   │   │   ├── json-socket/
    │   │   │   │   ├── connection.spec.ts
    │   │   │   │   ├── helpers.ts
    │   │   │   │   ├── listener-chaining.spec.ts
    │   │   │   │   ├── message-parsing.spec.ts
    │   │   │   │   └── data/
    │   │   │   │       └── long-payload-with-special-chars.ts
    │   │   │   ├── module/
    │   │   │   │   └── clients.module.spec.ts
    │   │   │   ├── serializers/
    │   │   │   │   ├── identity.serializer.spec.ts
    │   │   │   │   ├── kafka-request.serializer.spec.ts
    │   │   │   │   ├── mqtt-record.serializer.spec.ts
    │   │   │   │   ├── nats-record.serializer.spec.ts
    │   │   │   │   └── rmq-record.serializer.spec.ts
    │   │   │   ├── server/
    │   │   │   │   ├── server-factory.spec.ts
    │   │   │   │   ├── server-grpc.spec.ts
    │   │   │   │   ├── server-kafka.spec.ts
    │   │   │   │   ├── server-mqtt.spec.ts
    │   │   │   │   ├── server-nats.spec.ts
    │   │   │   │   ├── server-redis.spec.ts
    │   │   │   │   ├── server-rmq.spec.ts
    │   │   │   │   ├── server-tcp.spec.ts
    │   │   │   │   ├── server.spec.ts
    │   │   │   │   ├── test.proto
    │   │   │   │   ├── test2.proto
    │   │   │   │   └── utils/
    │   │   │   │       └── object-to-map.ts
    │   │   │   └── utils/
    │   │   │       └── transform-pattern.utils.spec.ts
    │   │   └── utils/
    │   │       ├── index.ts
    │   │       ├── param.utils.ts
    │   │       └── transform-pattern.utils.ts
    │   ├── platform-express/
    │   │   ├── Readme.md
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── adapters/
    │   │   │   ├── express-adapter.ts
    │   │   │   ├── index.ts
    │   │   │   └── utils/
    │   │   │       └── get-body-parser-options.util.ts
    │   │   ├── interfaces/
    │   │   │   ├── index.ts
    │   │   │   ├── nest-express-application.interface.ts
    │   │   │   ├── nest-express-body-parser-options.interface.ts
    │   │   │   ├── nest-express-body-parser.interface.ts
    │   │   │   └── serve-static-options.interface.ts
    │   │   ├── multer/
    │   │   │   ├── files.constants.ts
    │   │   │   ├── index.ts
    │   │   │   ├── multer.constants.ts
    │   │   │   ├── multer.module.ts
    │   │   │   ├── interceptors/
    │   │   │   │   ├── any-files.interceptor.ts
    │   │   │   │   ├── file-fields.interceptor.ts
    │   │   │   │   ├── file.interceptor.ts
    │   │   │   │   ├── files.interceptor.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── no-files.interceptor.ts
    │   │   │   ├── interfaces/
    │   │   │   │   ├── files-upload-module.interface.ts
    │   │   │   │   ├── index.ts
    │   │   │   │   └── multer-options.interface.ts
    │   │   │   └── multer/
    │   │   │       ├── multer.constants.ts
    │   │   │       └── multer.utils.ts
    │   │   └── test/
    │   │       ├── tsconfig.json
    │   │       ├── adapters/
    │   │       │   └── express-adapter.spec.ts
    │   │       └── multer/
    │   │           ├── interceptors/
    │   │           │   ├── any-files.interceptor.spec.ts
    │   │           │   ├── file-fields.interceptor.spec.ts
    │   │           │   ├── file.interceptor.spec.ts
    │   │           │   ├── files.interceptor.spec.ts
    │   │           │   └── no-files.inteceptor.spec.ts
    │   │           └── multer/
    │   │               ├── multer.module.spec.ts
    │   │               └── multer.utils.spec.ts
    │   ├── platform-fastify/
    │   │   ├── Readme.md
    │   │   ├── constants.ts
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── adapters/
    │   │   │   ├── fastify-adapter.ts
    │   │   │   └── index.ts
    │   │   ├── decorators/
    │   │   │   ├── index.ts
    │   │   │   ├── route-config.decorator.ts
    │   │   │   └── route-constraints.decorator.ts
    │   │   ├── interfaces/
    │   │   │   ├── index.ts
    │   │   │   ├── nest-fastify-application.interface.ts
    │   │   │   ├── nest-fastify-body-parser-options.interface.ts
    │   │   │   └── external/
    │   │   │       ├── fastify-static-options.interface.ts
    │   │   │       ├── fastify-view-options.interface.ts
    │   │   │       └── index.ts
    │   │   └── test/
    │   │       ├── tsconfig.json
    │   │       └── decorators/
    │   │           ├── router-config.decorator.spec.ts
    │   │           └── router-constraints.decorator.spec.ts
    │   ├── platform-socket.io/
    │   │   ├── Readme.md
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   └── adapters/
    │   │       ├── index.ts
    │   │       └── io-adapter.ts
    │   ├── platform-ws/
    │   │   ├── Readme.md
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   └── adapters/
    │   │       ├── index.ts
    │   │       └── ws-adapter.ts
    │   ├── testing/
    │   │   ├── Readme.md
    │   │   ├── index.ts
    │   │   ├── package.json
    │   │   ├── test.ts
    │   │   ├── testing-injector.ts
    │   │   ├── testing-instance-loader.ts
    │   │   ├── testing-module.builder.ts
    │   │   ├── testing-module.ts
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── interfaces/
    │   │   │   ├── index.ts
    │   │   │   ├── mock-factory.ts
    │   │   │   ├── override-by-factory-options.interface.ts
    │   │   │   ├── override-by.interface.ts
    │   │   │   └── override-module.interface.ts
    │   │   └── services/
    │   │       └── testing-logger.service.ts
    │   └── websockets/
    │       ├── Readme.md
    │       ├── constants.ts
    │       ├── gateway-metadata-explorer.ts
    │       ├── index.ts
    │       ├── package.json
    │       ├── socket-module.ts
    │       ├── socket-server-provider.ts
    │       ├── sockets-container.ts
    │       ├── tsconfig.build.json
    │       ├── tsconfig.json
    │       ├── web-sockets-controller.ts
    │       ├── adapters/
    │       │   ├── index.ts
    │       │   └── ws-adapter.ts
    │       ├── context/
    │       │   ├── exception-filters-context.ts
    │       │   ├── ws-context-creator.ts
    │       │   ├── ws-metadata-constants.ts
    │       │   └── ws-proxy.ts
    │       ├── decorators/
    │       │   ├── connected-socket.decorator.ts
    │       │   ├── gateway-server.decorator.ts
    │       │   ├── index.ts
    │       │   ├── message-body.decorator.ts
    │       │   ├── socket-gateway.decorator.ts
    │       │   └── subscribe-message.decorator.ts
    │       ├── enums/
    │       │   └── ws-paramtype.enum.ts
    │       ├── errors/
    │       │   ├── index.ts
    │       │   ├── invalid-socket-port.exception.ts
    │       │   └── ws-exception.ts
    │       ├── exceptions/
    │       │   ├── base-ws-exception-filter.ts
    │       │   ├── index.ts
    │       │   └── ws-exceptions-handler.ts
    │       ├── factories/
    │       │   ├── server-and-event-streams-factory.ts
    │       │   └── ws-params-factory.ts
    │       ├── interfaces/
    │       │   ├── gateway-metadata.interface.ts
    │       │   ├── index.ts
    │       │   ├── nest-gateway.interface.ts
    │       │   ├── server-and-event-streams-host.interface.ts
    │       │   ├── web-socket-server.interface.ts
    │       │   ├── websockets-entrypoint-metadata.interface.ts
    │       │   ├── ws-response.interface.ts
    │       │   └── hooks/
    │       │       ├── index.ts
    │       │       ├── on-gateway-connection.interface.ts
    │       │       ├── on-gateway-disconnect.interface.ts
    │       │       └── on-gateway-init.interface.ts
    │       ├── test/
    │       │   ├── container.spec.ts
    │       │   ├── gateway-metadata-explorer.spec.ts
    │       │   ├── socket-server-provider.spec.ts
    │       │   ├── tsconfig.json
    │       │   ├── web-sockets-controller.spec.ts
    │       │   ├── context/
    │       │   │   ├── exception-filters.context.spec.ts
    │       │   │   ├── ws-context-creator.spec.ts
    │       │   │   └── ws-proxy.spec.ts
    │       │   ├── decorators/
    │       │   │   ├── connected-socket.decorator.spec.ts
    │       │   │   └── message-body.decorator.spec.ts
    │       │   ├── exceptions/
    │       │   │   ├── ws-exception.spec.ts
    │       │   │   └── ws-exceptions-handler.spec.ts
    │       │   ├── factories/
    │       │   │   ├── server-and-event-streams-factory.spec.ts
    │       │   │   └── ws-params-factory.spec.ts
    │       │   └── utils/
    │       │       ├── compare-element.util.spec.ts
    │       │       ├── gateway-server.decorator.spec.ts
    │       │       ├── socket-gateway.decorator.spec.ts
    │       │       └── subscribe-message.decorator.spec.ts
    │       └── utils/
    │           ├── compare-element.util.ts
    │           ├── index.ts
    │           └── param.utils.ts
    ├── sample/
    │   ├── 01-cats-app/
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── e2e/
    │   │   │   ├── jest-e2e.json
    │   │   │   └── cats/
    │   │   │       └── cats.e2e-spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── cats/
    │   │       │   ├── cats.controller.spec.ts
    │   │       │   ├── cats.controller.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.service.spec.ts
    │   │       │   ├── cats.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── create-cat.dto.ts
    │   │       │   └── interfaces/
    │   │       │       └── cat.interface.ts
    │   │       ├── common/
    │   │       │   ├── decorators/
    │   │       │   │   └── roles.decorator.ts
    │   │       │   ├── filters/
    │   │       │   │   └── http-exception.filter.ts
    │   │       │   ├── guards/
    │   │       │   │   └── roles.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   ├── exception.interceptor.ts
    │   │       │   │   └── timeout.interceptor.ts
    │   │       │   ├── middleware/
    │   │       │   │   └── logger.middleware.ts
    │   │       │   └── pipes/
    │   │       │       ├── parse-int.pipe.ts
    │   │       │       └── validation.pipe.ts
    │   │       └── core/
    │   │           ├── core.module.ts
    │   │           └── interceptors/
    │   │               ├── logging.interceptor.ts
    │   │               └── transform.interceptor.ts
    │   ├── 02-gateways/
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── client/
    │   │   │   └── index.html
    │   │   ├── e2e/
    │   │   │   ├── jest-e2e.json
    │   │   │   └── events-gateway/
    │   │   │       └── gateway.e2e-spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── adapters/
    │   │       │   └── redis-io.adapter.ts
    │   │       └── events/
    │   │           ├── events.gateway.spec.ts
    │   │           ├── events.gateway.ts
    │   │           └── events.module.ts
    │   ├── 03-microservices/
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── common/
    │   │       │   ├── filters/
    │   │       │   │   └── rpc-exception.filter.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── logging.interceptor.ts
    │   │       │   └── strategies/
    │   │       │       └── nats.strategy.ts
    │   │       └── math/
    │   │           ├── math.constants.ts
    │   │           ├── math.controller.ts
    │   │           └── math.module.ts
    │   ├── 04-grpc/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── grpc-client.options.ts
    │   │       ├── main.ts
    │   │       └── hero/
    │   │           ├── hero.controller.ts
    │   │           ├── hero.module.ts
    │   │           ├── hero.proto
    │   │           └── interfaces/
    │   │               ├── hero-by-id.interface.ts
    │   │               └── hero.interface.ts
    │   ├── 05-sql-typeorm/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── src/
    │   │   │   ├── app.module.ts
    │   │   │   ├── main.ts
    │   │   │   └── users/
    │   │   │       ├── user.entity.ts
    │   │   │       ├── users.controller.spec.ts
    │   │   │       ├── users.controller.ts
    │   │   │       ├── users.module.ts
    │   │   │       ├── users.service.spec.ts
    │   │   │       ├── users.service.ts
    │   │   │       └── dto/
    │   │   │           └── create-user.dto.ts
    │   │   └── test/
    │   │       ├── jest-e2e.json
    │   │       └── users/
    │   │           └── users.e2e-spec.ts
    │   ├── 06-mongoose/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── cats/
    │   │           ├── cats.controller.spec.ts
    │   │           ├── cats.controller.ts
    │   │           ├── cats.module.ts
    │   │           ├── cats.service.spec.ts
    │   │           ├── cats.service.ts
    │   │           ├── dto/
    │   │           │   ├── create-cat.dto.ts
    │   │           │   └── update-cat.dto.ts
    │   │           └── schemas/
    │   │               └── cat.schema.ts
    │   ├── 07-sequelize/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── users/
    │   │           ├── users.controller.spec.ts
    │   │           ├── users.controller.ts
    │   │           ├── users.module.ts
    │   │           ├── users.service.spec.ts
    │   │           ├── users.service.ts
    │   │           ├── dto/
    │   │           │   └── create-user.dto.ts
    │   │           └── models/
    │   │               └── user.model.ts
    │   ├── 08-webpack/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── webpack-hmr.config.js
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── app.service.ts
    │   │       └── main.ts
    │   ├── 09-babel-example/
    │   │   ├── index.js
    │   │   ├── jsconfig.json
    │   │   ├── nodemon.json
    │   │   ├── package.json
    │   │   ├── .babelrc
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.js
    │   │       ├── main.js
    │   │       └── cats/
    │   │           ├── cats.controller.js
    │   │           ├── cats.module.js
    │   │           └── cats.service.js
    │   ├── 10-fastify/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── cats/
    │   │       │   ├── cats.controller.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── create-cat.dto.ts
    │   │       │   └── interfaces/
    │   │       │       └── cat.interface.ts
    │   │       ├── common/
    │   │       │   ├── decorators/
    │   │       │   │   └── roles.decorator.ts
    │   │       │   ├── guards/
    │   │       │   │   └── roles.guard.ts
    │   │       │   ├── interceptors/
    │   │       │   │   └── exception.interceptor.ts
    │   │       │   ├── middleware/
    │   │       │   │   └── logger.middleware.ts
    │   │       │   └── pipes/
    │   │       │       ├── parse-int.pipe.ts
    │   │       │       └── validation.pipe.ts
    │   │       └── core/
    │   │           ├── core.module.ts
    │   │           └── interceptors/
    │   │               ├── logging.interceptor.ts
    │   │               └── transform.interceptor.ts
    │   ├── 11-swagger/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── cats/
    │   │           ├── cats.controller.ts
    │   │           ├── cats.module.ts
    │   │           ├── cats.service.ts
    │   │           ├── dto/
    │   │           │   └── create-cat.dto.ts
    │   │           └── entities/
    │   │               └── cat.entity.ts
    │   ├── 12-graphql-schema-first/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── generate-typings.ts
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── e2e/
    │   │   │   ├── jest-e2e.json
    │   │   │   └── cats/
    │   │   │       └── cats.e2e-spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── graphql.schema.ts
    │   │       ├── main.ts
    │   │       ├── cats/
    │   │       │   ├── cat-owner.resolver.spec.ts
    │   │       │   ├── cat-owner.resolver.ts
    │   │       │   ├── cats.graphql
    │   │       │   ├── cats.guard.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.resolver.spec.ts
    │   │       │   ├── cats.resolver.ts
    │   │       │   ├── cats.service.spec.ts
    │   │       │   ├── cats.service.ts
    │   │       │   └── dto/
    │   │       │       └── create-cat.dto.ts
    │   │       ├── common/
    │   │       │   ├── directives/
    │   │       │   │   └── upper-case.directive.ts
    │   │       │   ├── plugins/
    │   │       │   │   └── logging.plugin.ts
    │   │       │   └── scalars/
    │   │       │       └── date.scalar.ts
    │   │       └── owners/
    │   │           ├── owners.module.ts
    │   │           ├── owners.service.spec.ts
    │   │           └── owners.service.ts
    │   ├── 13-mongo-typeorm/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── photo/
    │   │           ├── photo.controller.spec.ts
    │   │           ├── photo.controller.ts
    │   │           ├── photo.entity.ts
    │   │           ├── photo.module.ts
    │   │           ├── photo.service.spec.ts
    │   │           └── photo.service.ts
    │   ├── 14-mongoose-base/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── cats/
    │   │       │   ├── cats.controller.spec.ts
    │   │       │   ├── cats.controller.ts
    │   │       │   ├── cats.module.ts
    │   │       │   ├── cats.providers.ts
    │   │       │   ├── cats.service.spec.ts
    │   │       │   ├── cats.service.ts
    │   │       │   ├── dto/
    │   │       │   │   └── create-cat.dto.ts
    │   │       │   ├── interfaces/
    │   │       │   │   └── cat.interface.ts
    │   │       │   └── schemas/
    │   │       │       └── cat.schema.ts
    │   │       └── database/
    │   │           ├── database.module.ts
    │   │           └── database.providers.ts
    │   ├── 15-mvc/
    │   │   ├── eslint.config.mjs
    │   │   ├── nodemon.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── public/
    │   │   │   └── .gitkeep
    │   │   ├── src/
    │   │   │   ├── app.controller.ts
    │   │   │   ├── app.module.ts
    │   │   │   └── main.ts
    │   │   └── views/
    │   │       └── index.hbs
    │   ├── 16-gateways-ws/
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── client/
    │   │   │   └── index.html
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── events/
    │   │           ├── events.gateway.ts
    │   │           └── events.module.ts
    │   ├── 17-mvc-fastify/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── nodemon.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── public/
    │   │   │   └── .gitkeep
    │   │   ├── src/
    │   │   │   ├── app.controller.ts
    │   │   │   ├── app.module.ts
    │   │   │   └── main.ts
    │   │   └── views/
    │   │       └── index.hbs
    │   ├── 18-context/
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── app.service.ts
    │   │       ├── main.ts
    │   │       └── my-dynamic.module.ts
    │   ├── 19-auth-jwt/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── e2e/
    │   │   │   ├── jest-e2e.json
    │   │   │   └── app/
    │   │   │       └── app.e2e-spec.ts
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── auth/
    │   │       │   ├── auth.controller.ts
    │   │       │   ├── auth.guard.ts
    │   │       │   ├── auth.module.ts
    │   │       │   ├── auth.service.ts
    │   │       │   ├── constants.ts
    │   │       │   └── decorators/
    │   │       │       └── public.decorator.ts
    │   │       └── users/
    │   │           ├── users.module.ts
    │   │           ├── users.service.spec.ts
    │   │           └── users.service.ts
    │   ├── 20-cache/
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── common/
    │   │           └── http-cache.interceptor.ts
    │   ├── 21-serializer/
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── entities/
    │   │           ├── role.entity.ts
    │   │           └── user.entity.ts
    │   ├── 22-graphql-prisma/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── generate-typings.ts
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── prisma/
    │   │   │   └── schema.prisma
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── graphql.schema.ts
    │   │       ├── main.ts
    │   │       ├── posts/
    │   │       │   ├── posts.module.ts
    │   │       │   ├── posts.resolvers.ts
    │   │       │   ├── posts.service.ts
    │   │       │   └── schema.graphql
    │   │       └── prisma/
    │   │           ├── prisma.module.ts
    │   │           └── prisma.service.ts
    │   ├── 23-graphql-code-first/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── schema.gql
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── common/
    │   │       │   ├── directives/
    │   │       │   │   └── upper-case.directive.ts
    │   │       │   ├── plugins/
    │   │       │   │   ├── complexity.plugin.ts
    │   │       │   │   └── logging.plugin.ts
    │   │       │   └── scalars/
    │   │       │       └── date.scalar.ts
    │   │       └── recipes/
    │   │           ├── recipes.module.ts
    │   │           ├── recipes.resolver.ts
    │   │           ├── recipes.service.ts
    │   │           ├── dto/
    │   │           │   ├── new-recipe.input.ts
    │   │           │   └── recipes.args.ts
    │   │           └── models/
    │   │               └── recipe.model.ts
    │   ├── 24-serve-static/
    │   │   ├── eslint.config.mjs
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── client/
    │   │   │   └── index.html
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       └── main.ts
    │   ├── 25-dynamic-modules/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   ├── config/
    │   │   │   └── development.env
    │   │   └── src/
    │   │       ├── app.controller.spec.ts
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── app.service.ts
    │   │       ├── main.ts
    │   │       └── config/
    │   │           ├── config.module.ts
    │   │           ├── config.service.spec.ts
    │   │           ├── config.service.ts
    │   │           ├── constants.ts
    │   │           └── interfaces/
    │   │               ├── config-options.interface.ts
    │   │               ├── envconfig.interface.ts
    │   │               └── index.ts
    │   ├── 26-queues/
    │   │   ├── README.md
    │   │   ├── docker-compose.yml
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── audio/
    │   │           ├── audio.controller.ts
    │   │           ├── audio.module.ts
    │   │           └── audio.processor.ts
    │   ├── 27-scheduling/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       └── tasks/
    │   │           ├── tasks.module.ts
    │   │           └── tasks.service.ts
    │   ├── 28-sse/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── index.html
    │   │       └── main.ts
    │   ├── 29-file-upload/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── jest.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── e2e/
    │   │   │   ├── jest-e2e.json
    │   │   │   └── app/
    │   │   │       └── app.e2e-spec.ts
    │   │   └── src/
    │   │       ├── app.controller.ts
    │   │       ├── app.module.ts
    │   │       ├── app.service.ts
    │   │       ├── main.ts
    │   │       └── sample.dto.ts
    │   ├── 30-event-emitter/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   ├── src/
    │   │   │   ├── app.module.ts
    │   │   │   ├── main.ts
    │   │   │   └── orders/
    │   │   │       ├── orders.controller.ts
    │   │   │       ├── orders.module.ts
    │   │   │       ├── orders.service.ts
    │   │   │       ├── dto/
    │   │   │       │   └── create-order.dto.ts
    │   │   │       ├── entities/
    │   │   │       │   └── order.entity.ts
    │   │   │       ├── events/
    │   │   │       │   └── order-created.event.ts
    │   │   │       └── listeners/
    │   │   │           └── order-created.listener.ts
    │   │   └── test/
    │   │       ├── app.e2e-spec.ts
    │   │       └── jest-e2e.json
    │   ├── 31-graphql-federation-code-first/
    │   │   ├── README.md
    │   │   ├── gateway/
    │   │   │   ├── README.md
    │   │   │   ├── eslint.config.mjs
    │   │   │   ├── nest-cli.json
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.build.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── .gitignore
    │   │   │   ├── .prettierrc
    │   │   │   └── src/
    │   │   │       ├── app.module.ts
    │   │   │       └── main.ts
    │   │   ├── posts-application/
    │   │   │   ├── README.md
    │   │   │   ├── eslint.config.mjs
    │   │   │   ├── nest-cli.json
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.build.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── .gitignore
    │   │   │   ├── .prettierrc
    │   │   │   └── src/
    │   │   │       ├── app.module.ts
    │   │   │       ├── main.ts
    │   │   │       └── posts/
    │   │   │           ├── posts.module.ts
    │   │   │           ├── posts.resolver.spec.ts
    │   │   │           ├── posts.resolver.ts
    │   │   │           ├── posts.service.spec.ts
    │   │   │           ├── posts.service.ts
    │   │   │           ├── users.resolver.spec.ts
    │   │   │           ├── users.resolver.ts
    │   │   │           └── models/
    │   │   │               ├── post.model.ts
    │   │   │               └── user.model.ts
    │   │   └── users-application/
    │   │       ├── README.md
    │   │       ├── eslint.config.mjs
    │   │       ├── nest-cli.json
    │   │       ├── package.json
    │   │       ├── tsconfig.build.json
    │   │       ├── tsconfig.json
    │   │       ├── .gitignore
    │   │       ├── .prettierrc
    │   │       └── src/
    │   │           ├── app.module.ts
    │   │           ├── main.ts
    │   │           └── users/
    │   │               ├── users.module.ts
    │   │               ├── users.resolver.spec.ts
    │   │               ├── users.resolver.ts
    │   │               ├── users.service.spec.ts
    │   │               ├── users.service.ts
    │   │               └── models/
    │   │                   └── user.model.ts
    │   ├── 32-graphql-federation-schema-first/
    │   │   ├── README.md
    │   │   ├── gateway/
    │   │   │   ├── README.md
    │   │   │   ├── eslint.config.mjs
    │   │   │   ├── nest-cli.json
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.build.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── .gitignore
    │   │   │   ├── .prettierrc
    │   │   │   └── src/
    │   │   │       ├── app.module.ts
    │   │   │       └── main.ts
    │   │   ├── posts-application/
    │   │   │   ├── README.md
    │   │   │   ├── eslint.config.mjs
    │   │   │   ├── nest-cli.json
    │   │   │   ├── package.json
    │   │   │   ├── tsconfig.build.json
    │   │   │   ├── tsconfig.json
    │   │   │   ├── .gitignore
    │   │   │   ├── .prettierrc
    │   │   │   └── src/
    │   │   │       ├── app.module.ts
    │   │   │       ├── main.ts
    │   │   │       └── posts/
    │   │   │           ├── posts.graphql
    │   │   │           ├── posts.interfaces.ts
    │   │   │           ├── posts.module.ts
    │   │   │           ├── posts.resolver.spec.ts
    │   │   │           ├── posts.resolver.ts
    │   │   │           ├── posts.service.spec.ts
    │   │   │           ├── posts.service.ts
    │   │   │           ├── users.interfaces.ts
    │   │   │           ├── users.resolver.spec.ts
    │   │   │           ├── users.resolver.ts
    │   │   │           └── models/
    │   │   │               ├── post.model.ts
    │   │   │               └── user.model.ts
    │   │   └── users-application/
    │   │       ├── README.md
    │   │       ├── eslint.config.mjs
    │   │       ├── nest-cli.json
    │   │       ├── package.json
    │   │       ├── tsconfig.build.json
    │   │       ├── tsconfig.json
    │   │       ├── .gitignore
    │   │       ├── .prettierrc
    │   │       └── src/
    │   │           ├── app.module.ts
    │   │           ├── main.ts
    │   │           └── users/
    │   │               ├── users.graphql
    │   │               ├── users.module.ts
    │   │               ├── users.resolver.spec.ts
    │   │               ├── users.resolver.ts
    │   │               ├── users.service.spec.ts
    │   │               ├── users.service.ts
    │   │               └── models/
    │   │                   └── user.model.ts
    │   ├── 33-graphql-mercurius/
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── schema.gql
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   └── src/
    │   │       ├── app.module.ts
    │   │       ├── main.ts
    │   │       ├── common/
    │   │       │   └── scalars/
    │   │       │       └── date.scalar.ts
    │   │       └── recipes/
    │   │           ├── recipes.module.ts
    │   │           ├── recipes.resolver.ts
    │   │           ├── recipes.service.ts
    │   │           ├── dto/
    │   │           │   ├── new-recipe.input.ts
    │   │           │   └── recipes.args.ts
    │   │           └── models/
    │   │               └── recipe.model.ts
    │   ├── 34-using-esm-packages/
    │   │   ├── README.md
    │   │   ├── eslint.config.mjs
    │   │   ├── nest-cli.json
    │   │   ├── package.json
    │   │   ├── tsconfig.build.json
    │   │   ├── tsconfig.json
    │   │   ├── .gitignore
    │   │   ├── .prettierrc
    │   │   ├── src/
    │   │   │   ├── app.controller.spec.ts
    │   │   │   ├── app.controller.ts
    │   │   │   ├── app.module.ts
    │   │   │   ├── app.service.ts
    │   │   │   ├── import-esm-package.ts
    │   │   │   ├── main.ts
    │   │   │   └── superjson.provider.ts
    │   │   └── test/
    │   │       ├── app.e2e-spec.ts
    │   │       └── jest-e2e.json
    │   └── 35-use-esm-package-after-node22/
    │       ├── README.md
    │       ├── eslint.config.mjs
    │       ├── nest-cli.json
    │       ├── package.json
    │       ├── tsconfig.build.json
    │       ├── tsconfig.json
    │       ├── .gitignore
    │       ├── .prettierrc
    │       └── src/
    │           ├── app.controller.ts
    │           ├── app.module.ts
    │           ├── app.service.ts
    │           └── main.ts
    ├── scripts/
    │   ├── prepare.sh
    │   ├── run-integration.sh
    │   ├── test.sh
    │   └── update-samples.sh
    ├── tools/
    │   ├── benchmarks/
    │   │   ├── check-benchmarks.ts
    │   │   ├── get-benchmarks.ts
    │   │   └── report-contents.md
    │   └── gulp/
    │       ├── config.ts
    │       ├── gulpfile.ts
    │       ├── tsconfig.json
    │       ├── tasks/
    │       │   ├── clean.ts
    │       │   ├── copy-misc.ts
    │       │   ├── move.ts
    │       │   └── samples.ts
    │       └── util/
    │           └── task-helpers.ts
    ├── .circleci/
    │   ├── config.yml
    │   └── install-wrk.sh
    ├── .github/
    │   ├── dependabot.yml
    │   ├── FUNDING.yml
    │   ├── lock.yml
    │   ├── PULL_REQUEST_TEMPLATE.md
    │   ├── ISSUE_TEMPLATE/
    │   │   ├── Bug_report.yml
    │   │   ├── config.yml
    │   │   ├── Feature_request.yml
    │   │   ├── Regression.yml
    │   │   └── Suggestion_improve_performance.yml
    │   └── workflows/
    │       └── codeql-analysis.yml
    └── .husky/
        ├── commit-msg
        └── pre-commit

================================================
FILE: Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: CODE_OF_CONDUCT.md
================================================
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at support@nestjs.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq



================================================
FILE: CONTRIBUTING.md
================================================
# Contributing to Nest

We would love for you to contribute to Nest and help make it even better than it is
today! As a contributor, here are the guidelines we would like you to follow:

<!--* [Code of Conduct](#coc)-->

- [Question or Problem?](#question)
- [Issues and Bugs](#issue)
- [Feature Requests](#feature)
- [Submission Guidelines](#submit)
- [Development Setup](#development)
- [Coding Rules](#rules)
- [Commit Message Guidelines](#commit)
  <!-- - [Signing the CLA](#cla) -->

<!-- ## <a name="coc"></a> Code of Conduct
Help us keep Nest open and inclusive. Please read and follow our [Code of Conduct][coc]. -->

## <a name="question"></a> Got a Question or Problem?

**Do not open issues for general support questions as we want to keep GitHub issues for bug reports and feature requests.** You've got much better chances of getting your question answered on [Stack Overflow][stackoverflow] where the questions should be tagged with tag `nestjs`.

Stack Overflow is a much better place to ask questions since:

<!-- - there are thousands of people willing to help on Stack Overflow [maybe one day] -->

- questions and answers stay available for public viewing so your question / answer might help someone else.
- Stack Overflow's voting system assures that the best answers are prominently visible.

To save your and our time, we will systematically close all issues that are requests for general support and redirect people to Stack Overflow.

If you would like to chat about the question in real-time, you can reach out via [our discord channel][discord].

## <a name="issue"></a> Found a Bug?

If you find a bug in the source code, you can help us by
[submitting an issue](#submit-issue) to our [GitHub Repository][github]. Even better, you can
[submit a Pull Request](#submit-pr) with a fix.

## <a name="feature"></a> Missing a Feature?

You can _request_ a new feature by [submitting an issue](#submit-issue) to our GitHub
Repository. If you would like to _implement_ a new feature, please submit an issue with
a proposal for your work first, to be sure that we can use it.
Please consider what kind of change it is:

- For a **Major Feature**, first open an issue and outline your proposal so that it can be
  discussed. This will also allow us to better coordinate our efforts, prevent duplication of work,
  and help you to craft the change so that it is successfully accepted into the project. For your issue name, please prefix your proposal with `[discussion]`, for example "[discussion]: your feature idea".
- **Small Features** can be crafted and directly [submitted as a Pull Request](#submit-pr).

## <a name="submit"></a> Submission Guidelines

### <a name="submit-issue"></a> Submitting an Issue

Before you submit an issue, please search the issue tracker, maybe an issue for your problem already exists and the discussion might inform you of workarounds readily available.

We want to fix all the issues as soon as possible, but before fixing a bug we need to reproduce and confirm it. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction scenario using a repository or [Gist](https://gist.github.com/). Having a live, reproducible scenario gives us wealth of important information without going back & forth to you with additional questions like:

- version of NestJS used
- 3rd-party libraries and their versions
- and most importantly - a use-case that fails

<!--
// TODO we need to create a playground, similar to plunkr

A minimal reproduce scenario using a repository or Gist allows us to quickly confirm a bug (or point out coding problem) as well as confirm that we are fixing the right problem. If neither of these are not a suitable way to demonstrate the problem (for example for issues related to our npm packaging), please create a standalone git repository demonstrating the problem. -->

<!-- We will be insisting on a minimal reproduce scenario in order to save maintainers time and ultimately be able to fix more bugs. Interestingly, from our experience users often find coding problems themselves while preparing a minimal plunk. We understand that sometimes it might be hard to extract essentials bits of code from a larger code-base but we really need to isolate the problem before we can fix it. -->

Unfortunately, we are not able to investigate / fix bugs without a minimal reproduction, so if we don't hear back from you we are going to close an issue that doesn't have enough info to be reproduced.

You can file new issues by filling out our [new issue form][new_issue].

### <a name="submit-pr"></a> Submitting a Pull Request (PR)

Before you submit your Pull Request (PR) consider the following guidelines:

<!--
To the first point

1. Please sign our [Contributor License Agreement (CLA)](#cla) before sending PRs.
We cannot accept code without this.
-->

1. Search [GitHub Pull Requests][gh_prs] for an open or closed PR
   that relates to your submission. You don't want to duplicate effort.
1. Fork this repository.
1. Make your changes in a new git branch:

   ```shell
   git checkout -b my-fix-branch master
   ```

1. Create your patch, **including appropriate test cases**.
1. Follow our [Coding Rules](#rules).
1. Run the full Nest test suite (see [common scripts](#common-scripts)),
   and ensure that all tests pass.
1. Commit your changes using a descriptive commit message that follows our
   [commit message conventions](#commit). Adherence to these conventions
   is necessary because release notes are automatically generated from these messages.

   ```shell
   git commit -a
   ```

   Note: the optional commit `-a` command line option will automatically "add" and "rm" edited files.

1. Push your branch to GitHub:

   ```shell
   git push origin my-fix-branch
   ```

1. In GitHub, send a pull request to `nestjs:master`.

- If we suggest changes then:

  - Make the required updates.
  - Re-run the Nest test suites to ensure tests are still passing.
  - Rebase your branch and force push to your GitHub repository (this will update your Pull Request):

    ```shell
    git rebase master -i
    git push -f
    ```

That's it! Thank you for your contribution!

#### After your pull request is merged

After your pull request is merged, you can safely delete your branch and pull the changes
from the main (upstream) repository:

- Delete the remote branch on GitHub either through the GitHub web UI or your local shell as follows:

  ```shell
  git push origin --delete my-fix-branch
  ```

- Check out the master branch:

  ```shell
  git checkout master -f
  ```

- Delete the local branch:

  ```shell
  git branch -D my-fix-branch
  ```

- Update your master with the latest upstream version:

  ```shell
  git pull --ff upstream master
  ```

## <a name="development"></a> Development Setup

You will need [Node.js](https://nodejs.org) version >= 10.13.0 (except for v13).

1. After cloning the repo, run:

```bash
$ npm ci --legacy-peer-deps # (or yarn install)
```

2. In order to prepare your environment run `prepare.sh` shell script:

```bash
$ sh scripts/prepare.sh
```

That will compile fresh packages and afterward, move them all to `sample` directories.

### <a name="common-scripts"></a>Commonly used NPM scripts

```bash
# build all packages and move to "sample" directories
$ npm run build

# run the full unit tests suite
$ npm run test

# run integration tests
# docker is required(!)
$ sh scripts/run-integration.sh

# run linter
$ npm run lint

# build all packages and put them near to their source .ts files
$ npm run build:prod
```

## <a name="rules"></a> Coding Rules

To ensure consistency throughout the source code, keep these rules in mind as you are working:

<!--
// We're working on auto-documentation.
* All public API methods **must be documented**. (Details TBC). -->

- All features or bug fixes **must be tested** by one or more specs (unit-tests).
- We follow [Google's JavaScript Style Guide][js-style-guide], but wrap all code at
  **100 characters**. An automated formatter is available (`npm run format`).

## <a name="commit"></a> Commit Message Guidelines

We have very precise rules over how our git commit messages can be formatted. This leads to **more
readable messages** that are easy to follow when looking through the **project history**. But also,
we use the git commit messages to **generate the Nest change log**.

### Commit Message Format

Each commit message consists of a **header**, a **body** and a **footer**. The header has a special
format that includes a **type**, a **scope** and a **subject**:

```
<type>(<scope>): <subject>
<BLANK LINE>
<body>
<BLANK LINE>
<footer>
```

The **header** is mandatory and the **scope** of the header is optional.

Any line of the commit message cannot be longer than 100 characters! This allows the message to be easier
to read on GitHub as well as in various git tools.

Footer should contain a [closing reference to an issue](https://help.github.com/articles/closing-issues-via-commit-messages/) if any.

Samples: (even more [samples][commits_samples])

```
docs(changelog): update change log to beta.5
fix(core): need to depend on latest rxjs and zone.js
```

### Revert

If the commit reverts a previous commit, it should begin with `revert:`, followed by the header of the reverted commit. In the body it should say: `This reverts commit <hash>.`, where the hash is the SHA of the commit being reverted.

### Type

Must be one of the following:

- **build**: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm)
- **chore**: Updating tasks etc; no production code change
- **ci**: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs)
- **docs**: Documentation only changes
- **feat**: A new feature
- **fix**: A bug fix
- **perf**: A code change that improves performance
- **refactor**: A code change that neither fixes a bug nor adds a feature
- **style**: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)
- **test**: Adding missing tests or correcting existing tests
- **sample**: A change to the samples

### Scope

The scope should have the name of the npm package affected (as perceived by person reading changelog generated from commit messages).

The following is the list of supported scopes:

- **common**: for changes made on `packages/common` directory
- **core**: for changes made on `packages/core` directory
- **sample**: for changes made on `packages/sample` directory
- **microservices**: for changes made on `packages/microservices` directory
- **express**: for changes made on `packages/platform-express` directory
- **fastify**: for changes made on `packages/platform-fastify` directory
- **socket.io**: for changes made on `packages/platform-socket.io` directory
- **ws**: for changes made on `packages/platform-ws` directory
- **testing**: for changes made on `packages/testing` directory
- **websockets**: for changes made on `packages/websockets` directory

If your change affect more than one package, separate the scopes with a comma (e.g. `common,core`).

There are currently a few exceptions to the "use package name" rule:

- **packaging**: used for changes that change the npm package layout in all of our packages, e.g. public path changes, package.json changes done to all packages, d.ts file/format changes, changes to bundles, etc.
- **changelog**: used for updating the release notes in CHANGELOG.md
- **sample/#**: for the example apps directory, replacing # with the example app number
- none/empty string: useful for `style`, `test` and `refactor` changes that are done across all packages (e.g. `style: add missing semicolons`)

### Subject

The subject contains succinct description of the change:

- use the imperative, present tense: "change" not "changed" nor "changes"
- don't capitalize first letter
- no dot (.) at the end

### Body

Just as in the **subject**, use the imperative, present tense: "change" not "changed" nor "changes".
The body should include the motivation for the change and contrast this with previous behavior.

### Footer

The footer should contain any information about **Breaking Changes** and is also the place to
reference GitHub issues that this commit **Closes**.

**Breaking Changes** should start with the word `BREAKING CHANGE:` with a space or two newlines. The rest of the commit message is then used for this.

A detailed explanation can be found in this [document][commit-message-format].

<!-- ## <a name="cla"></a> Signing the CLA

Please sign our Contributor License Agreement (CLA) before sending pull requests. For any code
changes to be accepted, the CLA must be signed. It's a quick process, we promise!

* For individuals we have a [simple click-through form][individual-cla].
* For corporations we'll need you to
  [print, sign and one of scan+email, fax or mail the form][corporate-cla]. -->

<!-- [angular-group]: https://groups.google.com/forum/#!forum/angular -->

<!-- [coc]: https://github.com/angular/code-of-conduct/blob/master/CODE_OF_CONDUCT.md -->

[commit-message-format]: https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#
<!-- [individual-cla]: http://code.google.com/legal/individual-cla-v1.0.html -->
<!-- [corporate-cla]: http://code.google.com/legal/corporate-cla-v1.0.html -->
[dev-doc]: https://github.com/nestjs/nest/blob/master/docs/DEVELOPER.md
[github]: https://github.com/nestjs/nest
[stackoverflow]: https://stackoverflow.com/questions/tagged/nestjs
[discord]: https://discordapp.com/invite/G7Qnnhy
[js-style-guide]: https://google.github.io/styleguide/jsguide.html
[new_issue]: https://github.com/nestjs/nest/issues/new
[gh_prs]: https://github.com/nestjs/nest/pulls
[commits_samples]: https://github.com/nestjs/nest/commits/master



================================================
FILE: eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['node_modules', '**/node_modules/**', '**/*.js', '**/*.d.ts'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        project: ['tsconfig.json', 'tsconfig.spec.json'],
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'off',
      '@typescript-eslint/no-unsafe-call': 'off',
      '@typescript-eslint/no-unsafe-member-access': 'off',
      '@typescript-eslint/no-unsafe-function-type': 'off',
      '@typescript-eslint/no-unsafe-argument': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unused-expressions': 'off',
      '@typescript-eslint/no-require-imports': 'off',
      '@typescript-eslint/no-unused-vars': 'off',
      "@typescript-eslint/no-misused-promises": [
        "error",
        {
          "checksVoidReturn": false,
          "checksConditionals": false
        }
      ],
      "@typescript-eslint/require-await": "off",
      '@typescript-eslint/prefer-promise-reject-errors': 'off',
      '@typescript-eslint/no-base-to-string': 'off',
      '@typescript-eslint/unbound-method': 'off',
      '@typescript-eslint/only-throw-error': 'off',
    },
  },
);


================================================
FILE: gulpfile.js
================================================
'use strict';
/**
 * Load the TypeScript compiler, then load the TypeScript gulpfile which simply loads all
 * the tasks. The tasks are really inside tools/gulp/tasks.
 */

const path = require('path');

const projectDir = __dirname;
const tsconfigPath = path.join(projectDir, 'tools/gulp/tsconfig.json');

require('ts-node').register({
  project: tsconfigPath
});

require('./tools/gulp/gulpfile');


================================================
FILE: lerna.json
================================================
{
  "lerna": "2.4.0",
  "packages": [
    "packages/*"
  ],
  "version": "11.0.13"
}



================================================
FILE: LICENSE
================================================
(The MIT License)

Copyright (c) 2017-2025 Kamil Mysliwiec <https://kamilmysliwiec.com>

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
'Software'), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.



================================================
FILE: package.json
================================================
{
  "name": "@nestjs/core",
  "version": "11.0.10",
  "description": "Modern, fast, powerful node.js web framework",
  "homepage": "https://nestjs.com",
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git"
  },
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "license": "MIT",
  "author": "Kamil Mysliwiec",
  "scripts": {
    "build": "tsc -b -v packages",
    "postbuild": "npm run move:node_modules",
    "build:dev": "tsc -b -v packages --watch",
    "prebuild:prod": "npm run clean",
    "build:prod": "tsc -b -v packages",
    "changelog": "lerna-changelog",
    "clean": "tsc -b --clean packages",
    "move:samples": "gulp move:samples",
    "move:node_modules": "gulp move:node_modules",
    "build:samples": "gulp install:samples && npm run build && npm run move:samples && gulp build:samples && gulp test:samples && gulp test:e2e:samples",
    "codechecks:benchmarks": "codechecks ./tools/benchmarks/check-benchmarks.ts",
    "coverage": "nyc report --reporter=text-lcov | coveralls -v",
    "format": "prettier \"**/*.ts\" \"packages/**/*.json\" --ignore-path ./.prettierignore --write && git status",
    "postinstall": "opencollective",
    "test": "mocha packages/**/*.spec.ts",
    "test:dev": "mocha -w --watch-files \"packages\" packages/**/*.spec.ts",
    "pretest:cov": "npm run clean",
    "test:cov": "nyc mocha packages/**/*.spec.ts --reporter spec",
    "test:integration": "mocha --reporter-option maxDiffSize=0 \"integration/*/{,!(node_modules)/**/}/*.spec.ts\"",
    "test:docker:up": "docker-compose -f integration/docker-compose.yml up -d",
    "test:docker:down": "docker-compose -f integration/docker-compose.yml down",
    "lint": "concurrently 'npm run lint:packages' 'npm run lint:integration' 'npm run lint:spec'",
    "lint:fix": "concurrently 'npm run lint:packages -- --fix' 'npm run lint:integration -- --fix' 'npm run lint:spec -- --fix'",
    "lint:integration": "node --max-old-space-size=4096 ./node_modules/.bin/eslint 'integration/**/*.ts'",
    "lint:packages": "node --max-old-space-size=4096 ./node_modules/.bin/eslint 'packages/**/**.ts' --ignore-pattern 'packages/**/*.spec.ts'",
    "lint:spec": "node --max-old-space-size=4096 ./node_modules/.bin/eslint 'packages/**/**.spec.ts'",
    "lint:ci": "concurrently 'npm run lint:packages' 'npm run lint:spec'",
    "prerelease": "gulp copy-misc",
    "publish": "npm run prerelease && npm run build:prod && ./node_modules/.bin/lerna publish --force-publish --access public --exact -m \"chore(@nestjs) publish %s release\"",
    "prepublishOnly": "npm run changelog | pbcopy",
    "publish:beta": "npm run prerelease && npm run build:prod && ./node_modules/.bin/lerna publish --npm-tag=beta --access public -m \"chore(@nestjs) publish %s release\"",
    "publish:next": "npm run prerelease && npm run build:prod && ./node_modules/.bin/lerna publish --npm-tag=next --access public --skip-git -m \"chore(@nestjs) publish %s release\"",
    "publish:rc": "npm run prerelease && npm run build:prod && ./node_modules/.bin/lerna publish --npm-tag=rc --access public -m \"chore(@nestjs) publish %s release\"",
    "publish:test": "npm run prerelease && npm run build:prod && ./node_modules/.bin/lerna publish --force-publish --access public --npm-tag=test --skip-git -m \"chore(@nestjs) publish %s release\"",
    "prepare": "husky"
  },
  "lint-staged": {
    "**/*.ts": [
      "prettier --ignore-path ./.prettierignore --write"
    ],
    "packages/**/*.json": [
      "prettier --ignore-path ./.prettierignore --write"
    ]
  },
  "dependencies": {
    "@nuxt/opencollective": "0.4.1",
    "ansis": "3.17.0",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "cors": "2.8.5",
    "express": "5.1.0",
    "fast-json-stringify": "6.0.1",
    "fast-safe-stringify": "2.1.1",
    "iterare": "1.2.1",
    "object-hash": "3.0.0",
    "path-to-regexp": "8.2.0",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2",
    "socket.io": "4.8.1",
    "tslib": "2.8.1",
    "uid": "2.0.2",
    "uuid": "11.1.0"
  },
  "devDependencies": {
    "@apollo/server": "4.11.3",
    "@codechecks/client": "0.1.12",
    "@commitlint/cli": "19.8.0",
    "@commitlint/config-angular": "19.8.0",
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@fastify/cors": "11.0.1",
    "@fastify/formbody": "8.0.2",
    "@fastify/middie": "9.0.3",
    "@fastify/multipart": "9.0.3",
    "@fastify/static": "8.1.1",
    "@fastify/view": "11.0.0",
    "@grpc/grpc-js": "1.13.2",
    "@grpc/proto-loader": "0.7.13",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/mongoose": "11.0.3",
    "@nestjs/typeorm": "11.0.0",
    "@types/amqplib": "0.10.7",
    "@types/bytes": "3.1.5",
    "@types/chai": "4.3.20",
    "@types/chai-as-promised": "7.1.8",
    "@types/cors": "2.8.17",
    "@types/eslint__js": "8.42.3",
    "@types/express": "5.0.1",
    "@types/gulp": "4.0.17",
    "@types/http-errors": "2.0.4",
    "@types/mocha": "10.0.10",
    "@types/node": "22.14.0",
    "@types/sinon": "17.0.4",
    "@types/supertest": "6.0.3",
    "@types/ws": "8.18.1",
    "amqp-connection-manager": "4.1.14",
    "amqplib": "0.10.7",
    "artillery": "2.0.22",
    "body-parser": "2.2.0",
    "bytes": "3.1.2",
    "cache-manager": "6.4.1",
    "cache-manager-redis-store": "3.0.1",
    "chai": "4.5.0",
    "chai-as-promised": "7.1.2",
    "clang-format": "1.8.0",
    "concurrently": "9.1.2",
    "conventional-changelog": "6.0.0",
    "core-js": "3.41.0",
    "coveralls": "3.1.1",
    "delete-empty": "3.0.0",
    "engine.io-client": "6.6.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "eventsource": "3.0.6",
    "fancy-log": "2.0.0",
    "fastify": "5.2.2",
    "globals": "16.0.0",
    "graphql": "16.10.0",
    "graphql-subscriptions": "3.0.0",
    "graphql-tools": "9.0.18",
    "gulp": "5.0.0",
    "gulp-clang-format": "1.0.27",
    "gulp-clean": "0.4.0",
    "gulp-sourcemaps": "3.0.0",
    "gulp-typescript": "5.0.1",
    "gulp-watch": "5.0.1",
    "http-errors": "2.0.0",
    "husky": "9.1.7",
    "imports-loader": "5.0.0",
    "ioredis": "5.6.0",
    "json-loader": "0.5.7",
    "kafkajs": "2.2.4",
    "lerna": "2.11.0",
    "lerna-changelog": "2.2.0",
    "light-my-request": "6.6.0",
    "lint-staged": "15.5.0",
    "markdown-table": "2.0.0",
    "mocha": "11.1.0",
    "mongoose": "8.13.2",
    "mqtt": "5.10.4",
    "multer": "1.4.5-lts.2",
    "mysql2": "3.14.0",
    "nats": "2.29.3",
    "nodemon": "3.1.9",
    "nyc": "14.1.1",
    "prettier": "3.5.3",
    "redis": "4.7.0",
    "rxjs-compat": "6.6.7",
    "sinon": "20.0.0",
    "sinon-chai": "3.7.0",
    "socket.io-client": "4.8.1",
    "subscriptions-transport-ws": "0.11.0",
    "supertest": "7.1.0",
    "ts-morph": "25.0.1",
    "ts-node": "10.9.2",
    "typeorm": "0.3.22",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0",
    "wrk": "1.2.1",
    "ws": "8.18.1"
  },
  "engines": {
    "node": ">= 20"
  },
  "collective": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest",
    "donation": {
      "text": "Become a partner:"
    }
  },
  "changelog": {
    "labels": {
      "type: feature :tada:": "Features",
      "type: bug :sob:": "Bug fixes",
      "type: enhancement :wolf:": "Enhancements",
      "type: docs :page_facing_up:": "Docs",
      "type: code style": "Code style tweaks",
      "dependencies": "Dependencies"
    }
  },
  "nyc": {
    "include": [
      "packages/**/*.ts"
    ],
    "exclude": [
      "**/*.js",
      "**/*.d.ts",
      "**/*.spec.ts",
      "packages/**/adapters/*.ts",
      "packages/**/nest-*.ts",
      "packages/**/test/**/*.ts",
      "packages/core/errors/**/*",
      "packages/common/exceptions/*.ts",
      "packages/common/utils/load-package.util.ts",
      "packages/microservices/exceptions/",
      "packages/microservices/microservices-module.ts",
      "packages/core/middleware/middleware-module.ts",
      "packages/core/discovery/discovery-service.ts",
      "packages/core/injector/module-ref.ts",
      "packages/core/injector/instance-links-host.ts",
      "packages/core/helpers/context-id-factory.ts",
      "packages/websockets/socket-module.ts",
      "packages/common/cache/**/*",
      "packages/common/serializer/**/*",
      "packages/common/services/*.ts"
    ],
    "extension": [
      ".ts"
    ],
    "require": [
      "ts-node/register"
    ],
    "reporter": [
      "text-summary",
      "html"
    ],
    "sourceMap": true,
    "instrument": true
  },
  "mocha": {
    "require": [
      "ts-node/register",
      "tsconfig-paths/register",
      "node_modules/reflect-metadata/Reflect.js",
      "hooks/mocha-init-hook.ts"
    ],
    "exit": true
  }
}



================================================
FILE: readme_jp.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

<p align="center">すばやくスケーラブルなサーバーサイドアプリケーションを構築するための革新的な<a href="https://nodejs.org" target="_blank">Node.js</a>フレームワークです。</p>
<p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## 概要

すばやくスケーラブルなサーバーサイドアプリケーションを構築するための革新的な<a href="https://nodejs.org" target="_blank">Node.js</a>フレームワークです。最新のJavaScriptを使用し、<a href="https://www.typescriptlang.org" target="_blank">TypeScript</a>（JavaScriptを拡張したスーパーセット）で構築され 、OOP（オブジェクト指向プログラミング）、FP（関数型プログラミング）、およびFRP（関数型リアクティブプログラミング）の要素を取り入れています。

<p>Nestは<a href="https://expressjs.com/" target="_blank">Express</a>(デフォルト)や<a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>などのさまざまなライブラリとの互換性を提供することで、たくさんのサードパーティプラグインを簡単に使用することができます。
</p>

## 哲学

<p>
近年、Node.jsの発展によって、JavaScriptはフロントエンドとバックエンドの両方でWebの「共通言語」になりました。そしてフロントエンドでは、<a href="https://angular.io/" target="_blank">Angular</a>、<a href="https://github.com/facebook/react" target="_blank">React</a>、<a href="https://github.com/vuejs/vue" target="_blank">Vue</a>などの素晴らしいプロジェクトが生まれ、開発効率が飛躍的に向上しました。一方で、サーバーサイドでは、Node.jsエコシステム上に優れたライブラリ、ヘルパー、ツールがたくさんありますが、それらのどれもが主要な問題であるアーキテクチャを効果的に解決するものではありませんでした。
</p>

<p>Nestは、実用的なアーキテクチャをすぐに構築できることを目的としています。具体的には、テストフレンドリーで、スケーラブルで、疎結合で、運用にやさしいアプリケーションを構築できるようになっています。また、アーキテクチャはAngularにインスパイアされています。</p>

## はじめに

* To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
* 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
* [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
* [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## 質問

質問やサポートについては、公式の[Discordチャンネル](https://discord.gg/G7Qnnhy)を使用してください。また、このリポジトリのissueリストは、バグレポートと機能リクエスト **専用** です。

## イシュー(Issues)

issueを作成する前に、必ず[Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue)をお読みください。ガイドラインに準拠していないissueは、クローズされる場合があります。

## コンサルティング

公式サポートを利用することで、Nestコアチームからのテクニカルサポート、移行戦略、ベストプラクティスの提供、アーキテクチャの相談、PRレビュー、メンタリングを受けることができます。詳しくは[こちら](https://enterprise.nestjs.com)をご覧ください。

## サポート

Nestは、MITライセンスのオープンソースプロジェクトです。スポンサーと支援者による素晴らしいサポートによって、その発展を支えられています。参加したい場合は[こちら](https://docs.nestjs.com/support)をご覧ください。

## 連絡先

* 著者 - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
* ウェブサイト - [https://nestjs.com](https://nestjs.com/)
* X - [@nestframework](https://twitter.com/nestframework)

## ライセンス

Nest は [MIT ライセンス](LICENSE) です。



================================================
FILE: readme_kr.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">효율적이고 확장 가능한 서버 사이드 애플리케이션을 위한 혁신적 <a href="https://nodejs.org" target="_blank">Node.js</a> 프레임워크.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## 개요

Nest는 효율적이고 확장 가능한 <a href="https://nodejs.org" target="_blank">Node.js</a> 서버 사이드 애플리케이션을 빌드하기 위한 프레임워크입니다. Nest는 모던 Javascript를 사용하고 <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a>로 빌드되었으며(순수 자바스크립트와 호환), OOP(객체 지향 프로그래밍), FP(함수형 프로그래밍), FRP(함수 반응형 프로그래밍)의 요소들이 결합되어 있습니다.

<p>Nest는 내부적으로 <a href="https://expressjs.com/" target="_blank">Express</a>를 사용하지만, <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>와 같은 타 라이브러리들과의 호환성을 광범위하게 제공하며 많은 서드파티 플러그인들을 손쉽게 사용할 수 있게 해줍니다.</p>

## 철학

<p>최근 몇 년간 Javascript는 Node.js의 발전에 따라 웹의 프론트엔드와 백엔드에 있어서 "공용어"가 되었습니다. 그리고 프론트엔드에서는 <a href="https://angular.io/" target="_blank">Angular</a>와 <a href="https://github.com/facebook/react" target="_blank">React</a>, <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>와 같이 멋진 프로젝트들이 등장하여 개발자의 생산성을 향상시켰으며, 빠르고 테스트와 확장이 가능한 프론트엔드 애플리케이션을 만들 수 있게 해주었습니다. 하지만 서버 사이드에서는 Node.js를 위한 우수한 라이브러리와 툴이 많은 가운데, 주요 문제를 효과적으로 해결하는 것은 없었습니다. 그 주요 문제란 바로 아키텍처(architecture)입니다.</p>
<p>Nest는 테스트 친화적이면서 확장이 가능하고 결합이 느슨하며, 유지 관리가 용이한 애플리케이션을 손쉽게 만들 수 있는 애플리케이션 아키텍처 제공을 목표로 합니다. 이 아키텍처는 Angular에서 많은 영감을 받았습니다.</p>

## 시작하기

* To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
* 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
* [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
* [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## 질문

질문이 있거나 지원을 받고 싶으실 경우 공식 [디스코드 채널](https://discord.gg/G7Qnnhy)을 이용해주세요.
이 저장소의 이슈 목록은 버그 리포트와 기능 요청 **전용**으로 사용되고 있습니다.

## 이슈

이슈를 올리기 전에 반드시 [이슈 보고 체크리스트](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue)를 확인해주세요. 가이드라인에 맞지 않는 이슈는 바로 클로즈될 수 있습니다.

## 자문

공식 지원을 통해 Nest core 팀의 전문적인 도움을 받을 수 있습니다. 우리는 전담 기술 지원, 마이그레이션 전략, 모범 사례 및 설계에 대한 조언, PR 리뷰, 팀 보강에 대한 도움을 제공합니다. 더 자세한 내용은 [공식 지원 페이지](https://enterprise.nestjs.com)에서 확인해주세요.

## 서포트

Nest는 MIT License 오픈 소스 프로젝트이며, 감사하게도 후원자들과 굉장한 기여자들의 서포트를 통해서 더욱 성장할 수 있습니다. 참여하고 싶으시다면 [서포트 문서](https://docs.nestjs.com/support)를 확인해주세요.

## 연락처

* Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
* Website - [https://nestjs.com](https://nestjs.com/)
* Twitter - [@nestframework](https://twitter.com/nestframework)

## 라이센스

Nest is [MIT licensed](LICENSE).



================================================
FILE: readme_zh.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">用于构建高效且可扩展的服务器端应用程序的渐进式 <a href="https://nodejs.cn" target="blank">Node.js</a> 框架，深受 <a href="https://angular.cn" target="_blank">Angular</a> 的启发。</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->


### [English](Readme.md)

## 介绍

<p>Nest是构建高效，可扩展的 <a href="https://nodejs.cn" target="blank">Node.js</a> Web 应用程序的框架。 它使用现代的 JavaScript 或 <a href="https://www.tslang.cn" target="_blank">TypeScript</a>（保留与纯 JavaScript 的兼容性），并结合 OOP（面向对象编程），FP（函数式编程）和FRP（函数响应式编程）的元素。</p>
<p>在底层，Nest 使用了 <a href="https://www.expressjs.com.cn" target="_blank">Express</a>，但也提供了与其他各种库的兼容，例如<a href="https://github.com/fastify/fastify" target="blank">Fastify</a>，可以方便地使用各种可用的第三方插件。</p>

## 设计哲学

<p>近几年，由于 Node.js，JavaScript 已经成为 Web 前端和后端应用程序的「通用语言」，从而产生了像<a href="https://angular.cn" target="_blank">Angular</a>、<a href="https://github.com/facebook/react">React</a>、<a href="https://github.com/vuejs/vue" target="_blank">Vue</a>等令人耳目一新的项目，这些项目提高了开发人员的生产力，使得可以快速构建可测试的且可扩展的前端应用程序。 然而，在服务器端，虽然有很多优秀的库、helper 和 Node 工具，但是它们都没有有效地解决主要问题 - 架构。</p>

<p>Nest 旨在提供一个开箱即用的应用程序体系结构，允许轻松创建高度可测试，可扩展，松散耦合且易于维护的应用程序。</p>

## 开始

* 要查看 [指南](https://docs.nestjs.cn), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
* 要查看 [English指南](https://docs.nestjs.com), 请访问 [docs.nestjs.com](https://docs.nestjs.com). :books:

### 国内开发者交流群

QQ群：277386223
QQ群：336289049
QQ群：489719517

> 注意：这个交流群不是 NestJS 官方支持和维护的，只是为了方便国内开发者交流而建立的。
> （Note: This channel is not officially supported and maintained by the NestJS org members.）

## 赞助商

Nest是一个MIT许可的开源项目。它的发展得益于赞助商和支持者的支持。如果你想加入他们，请[查看更多](https://opencollective.com/nest)。谢谢！ :heart_eyes:

## 支持者

<a href="https://opencollective.com/nest"><img src="https://opencollective.com/nest/backers.svg?width=890"></a>

## 相关人员

* 作者 - [Kamil Myśliwiec](https://kamilmysliwiec.com)
* 网站 - [https://nestjs.com](https://nestjs.com/)
* Twitter - [@nestframework](https://twitter.com/nestframework)

## License

  Nest is [MIT licensed](LICENSE).



================================================
FILE: renovate.json
================================================
{
  "extends": ["config:base", ":dependencyDashboard"],
  "labels": ["dependencies"],
  "packageRules": [
    {
      "matchDepTypes": ["devDependencies"],
      "automerge": true
    }
  ]
}



================================================
FILE: SECURITY.md
================================================
# Security Policy

## Reporting a Vulnerability

Please report security issues to `support@nestjs.com`.



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "noImplicitAny": false,
    "noUnusedLocals": false,
    "removeComments": true,
    "strictNullChecks": true,
    "strictPropertyInitialization": false,
    "forceConsistentCasingInFileNames": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "useUnknownInCatchVariables": false,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": false,
    "outDir": "dist",
    "baseUrl": ".",
    "paths": {
      "@nestjs/common": ["./packages/common"],
      "@nestjs/common/*": ["./packages/common/*"],
      "@nestjs/core": ["./packages/core"],
      "@nestjs/core/*": ["./packages/core/*"],
      "@nestjs/microservices": ["./packages/microservices"],
      "@nestjs/microservices/*": ["./packages/microservices/*"],
      "@nestjs/websockets": ["./packages/websockets"],
      "@nestjs/websockets/*": ["./packages/websockets/*"],
      "@nestjs/testing": ["./packages/testing"],
      "@nestjs/testing/*": ["./packages/testing/*"],
      "@nestjs/platform-express": ["./packages/platform-express"],
      "@nestjs/platform-express/*": ["./packages/platform-express/*"],
      "@nestjs/platform-ws": ["./packages/platform-ws"],
      "@nestjs/platform-ws/*": ["./packages/platform-ws/*"],
      "@nestjs/platform-fastify": ["./packages/platform-fastify"],
      "@nestjs/platform-fastify/*": ["./packages/platform-fastify/*"],
      "@nestjs/platform-socket.io": ["./packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["./packages/platform-socket.io/*"],
    }
  },
  "include": ["packages/**/*", "integration/**/*"],
  "exclude": ["node_modules", "**/*.spec.ts"]
}



================================================
FILE: tsconfig.spec.json
================================================
{
  "extends": "./tsconfig.json",
  "include": ["integration/**/*", "integration/**/*.spec.ts", "packages/**/*.spec.ts"],
  "exclude": ["node_modules", "dist"]
}


================================================
FILE: .commitlintrc.json
================================================
{
  "extends": ["@commitlint/config-angular"],
  "rules": {
    "subject-case": [
      2,
      "always",
      ["sentence-case", "start-case", "pascal-case", "upper-case", "lower-case"]
    ],
    "type-enum": [
      2,
      "always",
      [
        "build",
        "chore",
        "ci",
        "docs",
        "feat",
        "fix",
        "perf",
        "refactor",
        "revert",
        "style",
        "test",
        "sample"
      ]
    ],
    "scope-enum": [
      1,
      "always",
      [
        "common",
        "core",
        "sample",
        "microservices",
        "express",
        "fastify",
        "socket.io",
        "ws",
        "testing",
        "websockets"
      ]
    ]
  }
}



================================================
FILE: .npmignore
================================================
# source
**/*.ts
*.ts

# definitions
!**/*.d.ts
!*.d.ts

# configuration
package-lock.json
tslint.json
tsconfig.json
.prettierrc

*.tsbuildinfo


================================================
FILE: .prettierignore
================================================
packages/**/*.d.ts
packages/**/*.js
.nyc_output



================================================
FILE: .prettierrc
================================================
{
  "singleQuote": true,
  "arrowParens": "avoid",
  "trailingComma": "all"
}



================================================
FILE: benchmarks/all_output.txt
================================================
-----------------------
express
-----------------------
Running 10s test @ http://localhost:3000
1024 connections

┌─────────┬───────┬───────┬───────┬────────┬──────────┬──────────┬────────┐
│ Stat    │ 2.5%  │ 50%   │ 97.5% │ 99%    │ Avg      │ Stdev    │ Max    │
├─────────┼───────┼───────┼───────┼────────┼──────────┼──────────┼────────┤
│ Latency │ 55 ms │ 58 ms │ 91 ms │ 138 ms │ 61.88 ms │ 23.95 ms │ 747 ms │
└─────────┴───────┴───────┴───────┴────────┴──────────┴──────────┴────────┘
┌───────────┬─────────┬─────────┬─────────┬─────────┬──────────┬─────────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg      │ Stdev   │ Min     │
├───────────┼─────────┼─────────┼─────────┼─────────┼──────────┼─────────┼─────────┤
│ Req/Sec   │ 8407    │ 8407    │ 17407   │ 17743   │ 16454.41 │ 2716.94 │ 8402    │
├───────────┼─────────┼─────────┼─────────┼─────────┼──────────┼─────────┼─────────┤
│ Bytes/Sec │ 1.81 MB │ 1.81 MB │ 3.74 MB │ 3.81 MB │ 3.54 MB  │ 584 kB  │ 1.81 MB │
└───────────┴─────────┴─────────┴─────────┴─────────┴──────────┴─────────┴─────────┘

Req/Bytes counts sampled once per second.

165k requests in 10.17s, 35.4 MB read
-----------------------
nest (with "@nestjs/platform-express")
-----------------------
Running 10s test @ http://localhost:3000
1024 connections

┌─────────┬───────┬───────┬───────┬───────┬──────────┬──────────┬────────┐
│ Stat    │ 2.5%  │ 50%   │ 97.5% │ 99%   │ Avg      │ Stdev    │ Max    │
├─────────┼───────┼───────┼───────┼───────┼──────────┼──────────┼────────┤
│ Latency │ 61 ms │ 64 ms │ 71 ms │ 94 ms │ 65.44 ms │ 17.35 ms │ 325 ms │
└─────────┴───────┴───────┴───────┴───────┴──────────┴──────────┴────────┘
┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬────────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg     │ Stdev  │ Min     │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────┼─────────┤
│ Req/Sec   │ 14183   │ 14183   │ 15767   │ 15991   │ 15640   │ 501.13 │ 14182   │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼────────┼─────────┤
│ Bytes/Sec │ 3.06 MB │ 3.06 MB │ 3.41 MB │ 3.45 MB │ 3.38 MB │ 108 kB │ 3.06 MB │
└───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴────────┴─────────┘

Req/Bytes counts sampled once per second.

156k requests in 10.24s, 33.8 MB read
-----------------------
fastify
-----------------------
Running 10s test @ http://localhost:3000
1024 connections

┌─────────┬───────┬───────┬───────┬───────┬──────────┬──────────┬─────────┐
│ Stat    │ 2.5%  │ 50%   │ 97.5% │ 99%   │ Avg      │ Stdev    │ Max     │
├─────────┼───────┼───────┼───────┼───────┼──────────┼──────────┼─────────┤
│ Latency │ 27 ms │ 30 ms │ 39 ms │ 78 ms │ 31.62 ms │ 26.59 ms │ 1232 ms │
└─────────┴───────┴───────┴───────┴───────┴──────────┴──────────┴─────────┘
┌───────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%     │ 97.5%   │ Avg     │ Stdev   │ Min     │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ Req/Sec   │ 19935   │ 19935   │ 33247   │ 34111   │ 32030.4 │ 4103.84 │ 19931   │
├───────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┼─────────┤
│ Bytes/Sec │ 3.03 MB │ 3.03 MB │ 5.05 MB │ 5.19 MB │ 4.87 MB │ 624 kB  │ 3.03 MB │
└───────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┴─────────┘

Req/Bytes counts sampled once per second.

320k requests in 10.18s, 48.7 MB read
-----------------------
nest (with "@nestjs/platform-fastify")
-----------------------
Running 10s test @ http://localhost:3000
1024 connections

┌─────────┬───────┬───────┬───────┬───────┬──────────┬──────────┬────────┐
│ Stat    │ 2.5%  │ 50%   │ 97.5% │ 99%   │ Avg      │ Stdev    │ Max    │
├─────────┼───────┼───────┼───────┼───────┼──────────┼──────────┼────────┤
│ Latency │ 31 ms │ 33 ms │ 38 ms │ 52 ms │ 34.41 ms │ 11.73 ms │ 245 ms │
└─────────┴───────┴───────┴───────┴───────┴──────────┴──────────┴────────┘
┌───────────┬─────────┬─────────┬────────┬─────────┬─────────┬─────────┬─────────┐
│ Stat      │ 1%      │ 2.5%    │ 50%    │ 97.5%   │ Avg     │ Stdev   │ Min     │
├───────────┼─────────┼─────────┼────────┼─────────┼─────────┼─────────┼─────────┤
│ Req/Sec   │ 24911   │ 24911   │ 30031  │ 30335   │ 29470.4 │ 1564.48 │ 24907   │
├───────────┼─────────┼─────────┼────────┼─────────┼─────────┼─────────┼─────────┤
│ Bytes/Sec │ 3.81 MB │ 3.81 MB │ 4.6 MB │ 4.64 MB │ 4.51 MB │ 239 kB  │ 3.81 MB │
└───────────┴─────────┴─────────┴────────┴─────────┴─────────┴─────────┴─────────┘

Req/Bytes counts sampled once per second.

295k requests in 10.17s, 45.1 MB read


================================================
FILE: benchmarks/express.js
================================================
'use strict';

const express = require('express');
const app = express();

app.get('/', async (req, res) => res.send('Hello world'));
app.listen(3000);



================================================
FILE: benchmarks/fastify.js
================================================
'use strict';

const fastify = require('fastify')();
fastify.get('/', async (req, reply) => reply.send('Hello world'));
fastify.listen({
  port: 3000
});



================================================
FILE: benchmarks/nest-fastify.js
================================================
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const core_1 = require('@nestjs/core');
const fastify_platform_1 = require('@nestjs/platform-fastify');
const app_module_1 = require('./nest/app.module');
core_1.NestFactory.create(
  app_module_1.AppModule,
  new fastify_platform_1.FastifyAdapter(),
  {
    logger: false,
    bodyParser: false,
  },
).then(app => app.listen(3000));
//# sourceMappingURL=main.js.map



================================================
FILE: benchmarks/nest.js
================================================
'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
const core_1 = require('@nestjs/core');
const app_module_1 = require('./nest/app.module');
core_1.NestFactory.create(app_module_1.AppModule, {
  logger: false,
  bodyParser: false,
}).then(app => app.listen(3000));
//# sourceMappingURL=main.js.map



================================================
FILE: benchmarks/nest/app.controller.d.ts
================================================
export declare class AppController {
  root(): string;
}



================================================
FILE: benchmarks/nest/app.controller.js
================================================
'use strict';
var __decorate =
  (this && this.__decorate) ||
  function(decorators, target, key, desc) {
    var c = arguments.length,
      r =
        c < 3
          ? target
          : desc === null
          ? (desc = Object.getOwnPropertyDescriptor(target, key))
          : desc,
      d;
    if (typeof Reflect === 'object' && typeof Reflect.decorate === 'function')
      r = Reflect.decorate(decorators, target, key, desc);
    else
      for (var i = decorators.length - 1; i >= 0; i--)
        if ((d = decorators[i]))
          r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  };
var __metadata =
  (this && this.__metadata) ||
  function(k, v) {
    if (typeof Reflect === 'object' && typeof Reflect.metadata === 'function')
      return Reflect.metadata(k, v);
  };
Object.defineProperty(exports, '__esModule', { value: true });
const common_1 = require('@nestjs/common');
let AppController = class AppController {
  root() {
    return 'Hello world!';
  }
};
__decorate(
  [
    common_1.Get(),
    __metadata('design:type', Function),
    __metadata('design:paramtypes', []),
    __metadata('design:returntype', String),
  ],
  AppController.prototype,
  'root',
  null,
);
AppController = __decorate([common_1.Controller()], AppController);
exports.AppController = AppController;
//# sourceMappingURL=app.controller.js.map



================================================
FILE: benchmarks/nest/app.module.d.ts
================================================
export declare class AppModule {}



================================================
FILE: benchmarks/nest/app.module.js
================================================
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const common_1 = require("@nestjs/common");
const app_controller_1 = require("./app.controller");
let AppModule = class AppModule {
};
AppModule = __decorate([
    common_1.Module({
        imports: [],
        controllers: [app_controller_1.AppController],
    })
], AppModule);
exports.AppModule = AppModule;
//# sourceMappingURL=app.module.js.map


================================================
FILE: benchmarks/nest/main.d.ts
================================================
export {};



================================================
FILE: hooks/mocha-init-hook.ts
================================================
export const mochaHooks = (): Mocha.RootHookObject => {
  return {
    async beforeAll(this: Mocha.Context) {
      await import('reflect-metadata');
    },
  };
};



================================================
FILE: integration/docker-compose.yml
================================================
version: "3"

services:
  redis:
    container_name: test-redis
    image: redis
    ports:
      - "6379:6379"
    restart: always
  nats:
    container_name: test-nats
    image: nats
    ports:
      - "8222:8222"
      - "4222:4222"
      - "6222:6222"
    restart: always
  mqtt:
    container_name: test-mqtt
    image: eclipse-mosquitto
    volumes:
      - ./mosquitto.conf:/mosquitto/config/mosquitto.conf
    ports:
      - "1883:1883"
      - "9001:9001"
    restart: always
  mysql:
    image: mysql:9.2.0
    environment:
      MYSQL_ROOT_HOST: '%'
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
    ports:
      - "3306:3306"
    restart: always
  mongodb:
    container_name: test-mongodb
    image: mongo:latest
    environment:
      - MONGODB_DATABASE="test"
    ports:
      - 27017:27017
  rabbit:
    container_name: test-rabbit
    hostname: rabbit
    image: "rabbitmq:management"
    ports:
      - "15672:15672"
      - "5672:5672"
    tty: true
  zookeeper:
    container_name: test-zookeeper
    hostname: zookeeper
    image: confluentinc/cp-zookeeper:7.9.0
    ports:
      - "2181:2181"
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_TICK_TIME: 2000
  kafka:
    container_name: test-kafka
    hostname: kafka
    image: confluentinc/cp-kafka:7.9.0
    depends_on:
      - zookeeper
    ports:
      - "29092:29092"
      - "9092:9092"
    environment:
      KAFKA_BROKER_ID: 1
      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
      KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:29092,PLAINTEXT_HOST://localhost:9092
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_GROUP_INITIAL_REBALANCE_DELAY_MS: 0
      KAFKA_DELETE_TOPIC_ENABLE: 'true'



================================================
FILE: integration/mosquitto.conf
================================================
# Config file for mosquitto
#
# See mosquitto.conf(5) for more information.
#
# Default values are shown, uncomment to change.
#
# Use the # character to indicate a comment, but only if it is the
# very first character on the line.

# =================================================================
# General configuration
# =================================================================

# Use per listener security settings.
#
# It is recommended this option be set before any other options.
#
# If this option is set to true, then all authentication and access control
# options are controlled on a per listener basis. The following options are
# affected:
#
# acl_file
# allow_anonymous
# allow_zero_length_clientid
# auto_id_prefix
# password_file
# plugin
# plugin_opt_*
# psk_file
#
# Note that if set to true, then a durable client (i.e. with clean session set
# to false) that has disconnected will use the ACL settings defined for the
# listener that it was most recently connected to.
#
# The default behaviour is for this to be set to false, which maintains the
# setting behaviour from previous versions of mosquitto.
#per_listener_settings false


# This option controls whether a client is allowed to connect with a zero
# length client id or not. This option only affects clients using MQTT v3.1.1
# and later. If set to false, clients connecting with a zero length client id
# are disconnected. If set to true, clients will be allocated a client id by
# the broker. This means it is only useful for clients with clean session set
# to true.
#allow_zero_length_clientid true

# If allow_zero_length_clientid is true, this option allows you to set a prefix
# to automatically generated client ids to aid visibility in logs.
# Defaults to 'auto-'
#auto_id_prefix auto-

# This option affects the scenario when a client subscribes to a topic that has
# retained messages. It is possible that the client that published the retained
# message to the topic had access at the time they published, but that access
# has been subsequently removed. If check_retain_source is set to true, the
# default, the source of a retained message will be checked for access rights
# before it is republished. When set to false, no check will be made and the
# retained message will always be published. This affects all listeners.
#check_retain_source true

# QoS 1 and 2 messages will be allowed inflight per client until this limit
# is exceeded.  Defaults to 0. (No maximum)
# See also max_inflight_messages
#max_inflight_bytes 0

# The maximum number of QoS 1 and 2 messages currently inflight per
# client.
# This includes messages that are partway through handshakes and
# those that are being retried. Defaults to 20. Set to 0 for no
# maximum. Setting to 1 will guarantee in-order delivery of QoS 1
# and 2 messages.
#max_inflight_messages 20

# For MQTT v5 clients, it is possible to have the server send a "server
# keepalive" value that will override the keepalive value set by the client.
# This is intended to be used as a mechanism to say that the server will
# disconnect the client earlier than it anticipated, and that the client should
# use the new keepalive value. The max_keepalive option allows you to specify
# that clients may only connect with keepalive less than or equal to this
# value, otherwise they will be sent a server keepalive telling them to use
# max_keepalive. This only applies to MQTT v5 clients. The default, and maximum
# value allowable, is 65535.
#
# Set to 0 to allow clients to set keepalive = 0, which means no keepalive
# checks are made and the client will never be disconnected by the broker if no
# messages are received. You should be very sure this is the behaviour that you
# want.
#
# For MQTT v3.1.1 and v3.1 clients, there is no mechanism to tell the client
# what keepalive value they should use. If an MQTT v3.1.1 or v3.1 client
# specifies a keepalive time greater than max_keepalive they will be sent a
# CONNACK message with the "identifier rejected" reason code, and disconnected.
#
#max_keepalive 65535

# For MQTT v5 clients, it is possible to have the server send a "maximum packet
# size" value that will instruct the client it will not accept MQTT packets
# with size greater than max_packet_size bytes. This applies to the full MQTT
# packet, not just the payload. Setting this option to a positive value will
# set the maximum packet size to that number of bytes. If a client sends a
# packet which is larger than this value, it will be disconnected. This applies
# to all clients regardless of the protocol version they are using, but v3.1.1
# and earlier clients will of course not have received the maximum packet size
# information. Defaults to no limit. Setting below 20 bytes is forbidden
# because it is likely to interfere with ordinary client operation, even with
# very small payloads.
#max_packet_size 0

# QoS 1 and 2 messages above those currently in-flight will be queued per
# client until this limit is exceeded.  Defaults to 0. (No maximum)
# See also max_queued_messages.
# If both max_queued_messages and max_queued_bytes are specified, packets will
# be queued until the first limit is reached.
#max_queued_bytes 0

# Set the maximum QoS supported. Clients publishing at a QoS higher than
# specified here will be disconnected.
#max_qos 2

# The maximum number of QoS 1 and 2 messages to hold in a queue per client
# above those that are currently in-flight.  Defaults to 1000. Set
# to 0 for no maximum (not recommended).
# See also queue_qos0_messages.
# See also max_queued_bytes.
#max_queued_messages 1000
#
# This option sets the maximum number of heap memory bytes that the broker will
# allocate, and hence sets a hard limit on memory use by the broker.  Memory
# requests that exceed this value will be denied. The effect will vary
# depending on what has been denied. If an incoming message is being processed,
# then the message will be dropped and the publishing client will be
# disconnected. If an outgoing message is being sent, then the individual
# message will be dropped and the receiving client will be disconnected.
# Defaults to no limit.
#memory_limit 0

# This option sets the maximum publish payload size that the broker will allow.
# Received messages that exceed this size will not be accepted by the broker.
# The default value is 0, which means that all valid MQTT messages are
# accepted. MQTT imposes a maximum payload size of 268435455 bytes.
#message_size_limit 0

# This option allows persistent clients (those with clean session set to false)
# to be removed if they do not reconnect within a certain time frame.
#
# This is a non-standard option in MQTT V3.1 but allowed in MQTT v3.1.1.
#
# Badly designed clients may set clean session to false whilst using a randomly
# generated client id. This leads to persistent clients that will never
# reconnect. This option allows these clients to be removed.
#
# The expiration period should be an integer followed by one of h d w m y for
# hour, day, week, month and year respectively. For example
#
# persistent_client_expiration 2m
# persistent_client_expiration 14d
# persistent_client_expiration 1y
#
# The default if not set is to never expire persistent clients.
#persistent_client_expiration

# Write process id to a file. Default is a blank string which means
# a pid file shouldn't be written.
# This should be set to /var/run/mosquitto/mosquitto.pid if mosquitto is
# being run automatically on boot with an init script and
# start-stop-daemon or similar.
#pid_file

# Set to true to queue messages with QoS 0 when a persistent client is
# disconnected. These messages are included in the limit imposed by
# max_queued_messages and max_queued_bytes
# Defaults to false.
# This is a non-standard option for the MQTT v3.1 spec but is allowed in
# v3.1.1.
#queue_qos0_messages false

# Set to false to disable retained message support. If a client publishes a
# message with the retain bit set, it will be disconnected if this is set to
# false.
#retain_available true

# Disable Nagle's algorithm on client sockets. This has the effect of reducing
# latency of individual messages at the potential cost of increasing the number
# of packets being sent.
#set_tcp_nodelay false

# Time in seconds between updates of the $SYS tree.
# Set to 0 to disable the publishing of the $SYS tree.
#sys_interval 10

# The MQTT specification requires that the QoS of a message delivered to a
# subscriber is never upgraded to match the QoS of the subscription. Enabling
# this option changes this behaviour. If upgrade_outgoing_qos is set true,
# messages sent to a subscriber will always match the QoS of its subscription.
# This is a non-standard option explicitly disallowed by the spec.
#upgrade_outgoing_qos false

# When run as root, drop privileges to this user and its primary
# group.
# Set to root to stay as root, but this is not recommended.
# If set to "mosquitto", or left unset, and the "mosquitto" user does not exist
# then it will drop privileges to the "nobody" user instead.
# If run as a non-root user, this setting has no effect.
# Note that on Windows this has no effect and so mosquitto should be started by
# the user you wish it to run as.
#user mosquitto

# =================================================================
# Listeners
# =================================================================

# Listen on a port/ip address combination. By using this variable
# multiple times, mosquitto can listen on more than one port. If
# this variable is used and neither bind_address nor port given,
# then the default listener will not be started.
# The port number to listen on must be given. Optionally, an ip
# address or host name may be supplied as a second argument. In
# this case, mosquitto will attempt to bind the listener to that
# address and so restrict access to the associated network and
# interface. By default, mosquitto will listen on all interfaces.
# Note that for a websockets listener it is not possible to bind to a host
# name.
#
# On systems that support Unix Domain Sockets, it is also possible
# to create a # Unix socket rather than opening a TCP socket. In
# this case, the port number should be set to 0 and a unix socket
# path must be provided, e.g.
# listener 0 /tmp/mosquitto.sock
#
# listener port-number [ip address/host name/unix socket path]
#listener

# By default, a listener will attempt to listen on all supported IP protocol
# versions. If you do not have an IPv4 or IPv6 interface you may wish to
# disable support for either of those protocol versions. In particular, note
# that due to the limitations of the websockets library, it will only ever
# attempt to open IPv6 sockets if IPv6 support is compiled in, and so will fail
# if IPv6 is not available.
#
# Set to `ipv4` to force the listener to only use IPv4, or set to `ipv6` to
# force the listener to only use IPv6. If you want support for both IPv4 and
# IPv6, then do not use the socket_domain option.
#
#socket_domain

# Bind the listener to a specific interface. This is similar to
# the [ip address/host name] part of the listener definition, but is useful
# when an interface has multiple addresses or the address may change. If used
# with the [ip address/host name] part of the listener definition, then the
# bind_interface option will take priority.
# Not available on Windows.
#
# Example: bind_interface eth0
#bind_interface

# When a listener is using the websockets protocol, it is possible to serve
# http data as well. Set http_dir to a directory which contains the files you
# wish to serve. If this option is not specified, then no normal http
# connections will be possible.
#http_dir

# The maximum number of client connections to allow. This is
# a per listener setting.
# Default is -1, which means unlimited connections.
# Note that other process limits mean that unlimited connections
# are not really possible. Typically the default maximum number of
# connections possible is around 1024.
#max_connections -1

# The listener can be restricted to operating within a topic hierarchy using
# the mount_point option. This is achieved be prefixing the mount_point string
# to all topics for any clients connected to this listener. This prefixing only
# happens internally to the broker; the client will not see the prefix.
#mount_point

# Choose the protocol to use when listening.
# This can be either mqtt or websockets.
# Certificate based TLS may be used with websockets, except that only the
# cafile, certfile, keyfile, ciphers, and ciphers_tls13 options are supported.
#protocol mqtt
listener 1883
protocol mqtt

listener 9001
protocol websockets

# Set use_username_as_clientid to true to replace the clientid that a client
# connected with with its username. This allows authentication to be tied to
# the clientid, which means that it is possible to prevent one client
# disconnecting another by using the same clientid.
# If a client connects with no username it will be disconnected as not
# authorised when this option is set to true.
# Do not use in conjunction with clientid_prefixes.
# See also use_identity_as_username.
#use_username_as_clientid

# Change the websockets headers size. This is a global option, it is not
# possible to set per listener. This option sets the size of the buffer used in
# the libwebsockets library when reading HTTP headers. If you are passing large
# header data such as cookies then you may need to increase this value. If left
# unset, or set to 0, then the default of 1024 bytes will be used.
#websockets_headers_size

# -----------------------------------------------------------------
# Certificate based SSL/TLS support
# -----------------------------------------------------------------
# The following options can be used to enable certificate based SSL/TLS support
# for this listener. Note that the recommended port for MQTT over TLS is 8883,
# but this must be set manually.
#
# See also the mosquitto-tls man page and the "Pre-shared-key based SSL/TLS
# support" section. Only one of certificate or PSK encryption support can be
# enabled for any listener.

# Both of certfile and keyfile must be defined to enable certificate based
# TLS encryption.

# Path to the PEM encoded server certificate.
#certfile

# Path to the PEM encoded keyfile.
#keyfile

# If you wish to control which encryption ciphers are used, use the ciphers
# option. The list of available ciphers can be optained using the "openssl
# ciphers" command and should be provided in the same format as the output of
# that command. This applies to TLS 1.2 and earlier versions only. Use
# ciphers_tls1.3 for TLS v1.3.
#ciphers

# Choose which TLS v1.3 ciphersuites are used for this listener.
# Defaults to "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256"
#ciphers_tls1.3

# If you have require_certificate set to true, you can create a certificate
# revocation list file to revoke access to particular client certificates. If
# you have done this, use crlfile to point to the PEM encoded revocation file.
#crlfile

# To allow the use of ephemeral DH key exchange, which provides forward
# security, the listener must load DH parameters. This can be specified with
# the dhparamfile option. The dhparamfile can be generated with the command
# e.g. "openssl dhparam -out dhparam.pem 2048"
#dhparamfile

# By default an TLS enabled listener will operate in a similar fashion to a
# https enabled web server, in that the server has a certificate signed by a CA
# and the client will verify that it is a trusted certificate. The overall aim
# is encryption of the network traffic. By setting require_certificate to true,
# the client must provide a valid certificate in order for the network
# connection to proceed. This allows access to the broker to be controlled
# outside of the mechanisms provided by MQTT.
#require_certificate false

# cafile and capath define methods of accessing the PEM encoded
# Certificate Authority certificates that will be considered trusted when
# checking incoming client certificates.
# cafile defines the path to a file containing the CA certificates.
# capath defines a directory that will be searched for files
# containing the CA certificates. For capath to work correctly, the
# certificate files must have ".crt" as the file ending and you must run
# "openssl rehash <path to capath>" each time you add/remove a certificate.
#cafile
#capath


# If require_certificate is true, you may set use_identity_as_username to true
# to use the CN value from the client certificate as a username. If this is
# true, the password_file option will not be used for this listener.
#use_identity_as_username false

# -----------------------------------------------------------------
# Pre-shared-key based SSL/TLS support
# -----------------------------------------------------------------
# The following options can be used to enable PSK based SSL/TLS support for
# this listener. Note that the recommended port for MQTT over TLS is 8883, but
# this must be set manually.
#
# See also the mosquitto-tls man page and the "Certificate based SSL/TLS
# support" section. Only one of certificate or PSK encryption support can be
# enabled for any listener.

# The psk_hint option enables pre-shared-key support for this listener and also
# acts as an identifier for this listener. The hint is sent to clients and may
# be used locally to aid authentication. The hint is a free form string that
# doesn't have much meaning in itself, so feel free to be creative.
# If this option is provided, see psk_file to define the pre-shared keys to be
# used or create a security plugin to handle them.
#psk_hint

# When using PSK, the encryption ciphers used will be chosen from the list of
# available PSK ciphers. If you want to control which ciphers are available,
# use the "ciphers" option.  The list of available ciphers can be optained
# using the "openssl ciphers" command and should be provided in the same format
# as the output of that command.
#ciphers

# Set use_identity_as_username to have the psk identity sent by the client used
# as its username. Authentication will be carried out using the PSK rather than
# the MQTT username/password and so password_file will not be used for this
# listener.
#use_identity_as_username false


# =================================================================
# Persistence
# =================================================================

# If persistence is enabled, save the in-memory database to disk
# every autosave_interval seconds. If set to 0, the persistence
# database will only be written when mosquitto exits. See also
# autosave_on_changes.
# Note that writing of the persistence database can be forced by
# sending mosquitto a SIGUSR1 signal.
#autosave_interval 1800

# If true, mosquitto will count the number of subscription changes, retained
# messages received and queued messages and if the total exceeds
# autosave_interval then the in-memory database will be saved to disk.
# If false, mosquitto will save the in-memory database to disk by treating
# autosave_interval as a time in seconds.
#autosave_on_changes false

# Save persistent message data to disk (true/false).
# This saves information about all messages, including
# subscriptions, currently in-flight messages and retained
# messages.
# retained_persistence is a synonym for this option.
#persistence false

# The filename to use for the persistent database, not including
# the path.
#persistence_file mosquitto.db

# Location for persistent database.
# Default is an empty string (current directory).
# Set to e.g. /var/lib/mosquitto if running as a proper service on Linux or
# similar.
#persistence_location


# =================================================================
# Logging
# =================================================================

# Places to log to. Use multiple log_dest lines for multiple
# logging destinations.
# Possible destinations are: stdout stderr syslog topic file dlt
#
# stdout and stderr log to the console on the named output.
#
# syslog uses the userspace syslog facility which usually ends up
# in /var/log/messages or similar.
#
# topic logs to the broker topic '$SYS/broker/log/<severity>',
# where severity is one of D, E, W, N, I, M which are debug, error,
# warning, notice, information and message. Message type severity is used by
# the subscribe/unsubscribe log_types and publishes log messages to
# $SYS/broker/log/M/susbcribe or $SYS/broker/log/M/unsubscribe.
#
# The file destination requires an additional parameter which is the file to be
# logged to, e.g. "log_dest file /var/log/mosquitto.log". The file will be
# closed and reopened when the broker receives a HUP signal. Only a single file
# destination may be configured.
#
# The dlt destination is for the automotive `Diagnostic Log and Trace` tool.
# This requires that Mosquitto has been compiled with DLT support.
#
# Note that if the broker is running as a Windows service it will default to
# "log_dest none" and neither stdout nor stderr logging is available.
# Use "log_dest none" if you wish to disable logging.
#log_dest stderr

# Types of messages to log. Use multiple log_type lines for logging
# multiple types of messages.
# Possible types are: debug, error, warning, notice, information,
# none, subscribe, unsubscribe, websockets, all.
# Note that debug type messages are for decoding the incoming/outgoing
# network packets. They are not logged in "topics".
#log_type error
#log_type warning
#log_type notice
#log_type information


# If set to true, client connection and disconnection messages will be included
# in the log.
#connection_messages true

# If using syslog logging (not on Windows), messages will be logged to the
# "daemon" facility by default. Use the log_facility option to choose which of
# local0 to local7 to log to instead. The option value should be an integer
# value, e.g. "log_facility 5" to use local5.
#log_facility

# If set to true, add a timestamp value to each log message.
#log_timestamp true

# Set the format of the log timestamp. If left unset, this is the number of
# seconds since the Unix epoch.
# This is a free text string which will be passed to the strftime function. To
# get an ISO 8601 datetime, for example:
# log_timestamp_format %Y-%m-%dT%H:%M:%S
#log_timestamp_format

# Change the websockets logging level. This is a global option, it is not
# possible to set per listener. This is an integer that is interpreted by
# libwebsockets as a bit mask for its lws_log_levels enum. See the
# libwebsockets documentation for more details. "log_type websockets" must also
# be enabled.
#websockets_log_level 0


# =================================================================
# Security
# =================================================================

# If set, only clients that have a matching prefix on their
# clientid will be allowed to connect to the broker. By default,
# all clients may connect.
# For example, setting "secure-" here would mean a client "secure-
# client" could connect but another with clientid "mqtt" couldn't.
#clientid_prefixes

# Boolean value that determines whether clients that connect
# without providing a username are allowed to connect. If set to
# false then a password file should be created (see the
# password_file option) to control authenticated client access.
#
# Defaults to false, unless there are no listeners defined in the configuration
# file, in which case it is set to true, but connections are only allowed from
# the local machine.
allow_anonymous true

# -----------------------------------------------------------------
# Default authentication and topic access control
# -----------------------------------------------------------------

# Control access to the broker using a password file. This file can be
# generated using the mosquitto_passwd utility. If TLS support is not compiled
# into mosquitto (it is recommended that TLS support should be included) then
# plain text passwords are used, in which case the file should be a text file
# with lines in the format:
# username:password
# The password (and colon) may be omitted if desired, although this
# offers very little in the way of security.
#
# See the TLS client require_certificate and use_identity_as_username options
# for alternative authentication options. If a plugin is used as well as
# password_file, the plugin check will be made first.
#password_file

# Access may also be controlled using a pre-shared-key file. This requires
# TLS-PSK support and a listener configured to use it. The file should be text
# lines in the format:
# identity:key
# The key should be in hexadecimal format without a leading "0x".
# If an plugin is used as well, the plugin check will be made first.
#psk_file

# Control access to topics on the broker using an access control list
# file. If this parameter is defined then only the topics listed will
# have access.
# If the first character of a line of the ACL file is a # it is treated as a
# comment.
# Topic access is added with lines of the format:
#
# topic [read|write|readwrite|deny] <topic>
#
# The access type is controlled using "read", "write", "readwrite" or "deny".
# This parameter is optional (unless <topic> contains a space character) - if
# not given then the access is read/write.  <topic> can contain the + or #
# wildcards as in subscriptions.
#
# The "deny" option can used to explicitly deny access to a topic that would
# otherwise be granted by a broader read/write/readwrite statement. Any "deny"
# topics are handled before topics that grant read/write access.
#
# The first set of topics are applied to anonymous clients, assuming
# allow_anonymous is true. User specific topic ACLs are added after a
# user line as follows:
#
# user <username>
#
# The username referred to here is the same as in password_file. It is
# not the clientid.
#
#
# If is also possible to define ACLs based on pattern substitution within the
# topic. The patterns available for substition are:
#
# %c to match the client id of the client
# %u to match the username of the client
#
# The substitution pattern must be the only text for that level of hierarchy.
#
# The form is the same as for the topic keyword, but using pattern as the
# keyword.
# Pattern ACLs apply to all users even if the "user" keyword has previously
# been given.
#
# If using bridges with usernames and ACLs, connection messages can be allowed
# with the following pattern:
# pattern write $SYS/broker/connection/%c/state
#
# pattern [read|write|readwrite] <topic>
#
# Example:
#
# pattern write sensor/%u/data
#
# If an plugin is used as well as acl_file, the plugin check will be
# made first.
#acl_file

# -----------------------------------------------------------------
# External authentication and topic access plugin options
# -----------------------------------------------------------------

# External authentication and access control can be supported with the
# plugin option. This is a path to a loadable plugin. See also the
# plugin_opt_* options described below.
#
# The plugin option can be specified multiple times to load multiple
# plugins. The plugins will be processed in the order that they are specified
# here. If the plugin option is specified alongside either of
# password_file or acl_file then the plugin checks will be made first.
#
# If the per_listener_settings option is false, the plugin will be apply to all
# listeners. If per_listener_settings is true, then the plugin will apply to
# the current listener being defined only.
#
# This option is also available as `auth_plugin`, but this use is deprecated
# and will be removed in the future.
#
#plugin

# If the plugin option above is used, define options to pass to the
# plugin here as described by the plugin instructions. All options named
# using the format plugin_opt_* will be passed to the plugin, for example:
#
# This option is also available as `auth_opt_*`, but this use is deprecated
# and will be removed in the future.
#
# plugin_opt_db_host
# plugin_opt_db_port
# plugin_opt_db_username
# plugin_opt_db_password


# =================================================================
# Bridges
# =================================================================

# A bridge is a way of connecting multiple MQTT brokers together.
# Create a new bridge using the "connection" option as described below. Set
# options for the bridges using the remaining parameters. You must specify the
# address and at least one topic to subscribe to.
#
# Each connection must have a unique name.
#
# The address line may have multiple host address and ports specified. See
# below in the round_robin description for more details on bridge behaviour if
# multiple addresses are used. Note that if you use an IPv6 address, then you
# are required to specify a port.
#
# The direction that the topic will be shared can be chosen by
# specifying out, in or both, where the default value is out.
# The QoS level of the bridged communication can be specified with the next
# topic option. The default QoS level is 0, to change the QoS the topic
# direction must also be given.
#
# The local and remote prefix options allow a topic to be remapped when it is
# bridged to/from the remote broker. This provides the ability to place a topic
# tree in an appropriate location.
#
# For more details see the mosquitto.conf man page.
#
# Multiple topics can be specified per connection, but be careful
# not to create any loops.
#
# If you are using bridges with cleansession set to false (the default), then
# you may get unexpected behaviour from incoming topics if you change what
# topics you are subscribing to. This is because the remote broker keeps the
# subscription for the old topic. If you have this problem, connect your bridge
# with cleansession set to true, then reconnect with cleansession set to false
# as normal.
#connection <name>
#address <host>[:<port>] [<host>[:<port>]]
#topic <topic> [[[out | in | both] qos-level] local-prefix remote-prefix]

# If you need to have the bridge connect over a particular network interface,
# use bridge_bind_address to tell the bridge which local IP address the socket
# should bind to, e.g. `bridge_bind_address 192.168.1.10`
#bridge_bind_address

# If a bridge has topics that have "out" direction, the default behaviour is to
# send an unsubscribe request to the remote broker on that topic. This means
# that changing a topic direction from "in" to "out" will not keep receiving
# incoming messages. Sending these unsubscribe requests is not always
# desirable, setting bridge_attempt_unsubscribe to false will disable sending
# the unsubscribe request.
#bridge_attempt_unsubscribe true

# Set the version of the MQTT protocol to use with for this bridge. Can be one
# of mqttv50, mqttv311 or mqttv31. Defaults to mqttv311.
#bridge_protocol_version mqttv311

# Set the clean session variable for this bridge.
# When set to true, when the bridge disconnects for any reason, all
# messages and subscriptions will be cleaned up on the remote
# broker. Note that with cleansession set to true, there may be a
# significant amount of retained messages sent when the bridge
# reconnects after losing its connection.
# When set to false, the subscriptions and messages are kept on the
# remote broker, and delivered when the bridge reconnects.
#cleansession false

# Set the amount of time a bridge using the lazy start type must be idle before
# it will be stopped. Defaults to 60 seconds.
#idle_timeout 60

# Set the keepalive interval for this bridge connection, in
# seconds.
#keepalive_interval 60

# Set the clientid to use on the local broker. If not defined, this defaults to
# 'local.<clientid>'. If you are bridging a broker to itself, it is important
# that local_clientid and clientid do not match.
#local_clientid

# If set to true, publish notification messages to the local and remote brokers
# giving information about the state of the bridge connection. Retained
# messages are published to the topic $SYS/broker/connection/<clientid>/state
# unless the notification_topic option is used.
# If the message is 1 then the connection is active, or 0 if the connection has
# failed.
# This uses the last will and testament feature.
#notifications true

# Choose the topic on which notification messages for this bridge are
# published. If not set, messages are published on the topic
# $SYS/broker/connection/<clientid>/state
#notification_topic

# Set the client id to use on the remote end of this bridge connection. If not
# defined, this defaults to 'name.hostname' where name is the connection name
# and hostname is the hostname of this computer.
# This replaces the old "clientid" option to avoid confusion. "clientid"
# remains valid for the time being.
#remote_clientid

# Set the password to use when connecting to a broker that requires
# authentication. This option is only used if remote_username is also set.
# This replaces the old "password" option to avoid confusion. "password"
# remains valid for the time being.
#remote_password

# Set the username to use when connecting to a broker that requires
# authentication.
# This replaces the old "username" option to avoid confusion. "username"
# remains valid for the time being.
#remote_username

# Set the amount of time a bridge using the automatic start type will wait
# until attempting to reconnect.
# This option can be configured to use a constant delay time in seconds, or to
# use a backoff mechanism based on "Decorrelated Jitter", which adds a degree
# of randomness to when the restart occurs.
#
# Set a constant timeout of 20 seconds:
# restart_timeout 20
#
# Set backoff with a base (start value) of 10 seconds and a cap (upper limit) of
# 60 seconds:
# restart_timeout 10 30
#
# Defaults to jitter with a base of 5 and cap of 30
#restart_timeout 5 30

# If the bridge has more than one address given in the address/addresses
# configuration, the round_robin option defines the behaviour of the bridge on
# a failure of the bridge connection. If round_robin is false, the default
# value, then the first address is treated as the main bridge connection. If
# the connection fails, the other secondary addresses will be attempted in
# turn. Whilst connected to a secondary bridge, the bridge will periodically
# attempt to reconnect to the main bridge until successful.
# If round_robin is true, then all addresses are treated as equals. If a
# connection fails, the next address will be tried and if successful will
# remain connected until it fails
#round_robin false

# Set the start type of the bridge. This controls how the bridge starts and
# can be one of three types: automatic, lazy and once. Note that RSMB provides
# a fourth start type "manual" which isn't currently supported by mosquitto.
#
# "automatic" is the default start type and means that the bridge connection
# will be started automatically when the broker starts and also restarted
# after a short delay (30 seconds) if the connection fails.
#
# Bridges using the "lazy" start type will be started automatically when the
# number of queued messages exceeds the number set with the "threshold"
# parameter. It will be stopped automatically after the time set by the
# "idle_timeout" parameter. Use this start type if you wish the connection to
# only be active when it is needed.
#
# A bridge using the "once" start type will be started automatically when the
# broker starts but will not be restarted if the connection fails.
#start_type automatic

# Set the number of messages that need to be queued for a bridge with lazy
# start type to be restarted. Defaults to 10 messages.
# Must be less than max_queued_messages.
#threshold 10

# If try_private is set to true, the bridge will attempt to indicate to the
# remote broker that it is a bridge not an ordinary client. If successful, this
# means that loop detection will be more effective and that retained messages
# will be propagated correctly. Not all brokers support this feature so it may
# be necessary to set try_private to false if your bridge does not connect
# properly.
#try_private true

# Some MQTT brokers do not allow retained messages. MQTT v5 gives a mechanism
# for brokers to tell clients that they do not support retained messages, but
# this is not possible for MQTT v3.1.1 or v3.1. If you need to bridge to a
# v3.1.1 or v3.1 broker that does not support retained messages, set the
# bridge_outgoing_retain option to false. This will remove the retain bit on
# all outgoing messages to that bridge, regardless of any other setting.
#bridge_outgoing_retain true

# If you wish to restrict the size of messages sent to a remote bridge, use the
# bridge_max_packet_size option. This sets the maximum number of bytes for
# the total message, including headers and payload.
# Note that MQTT v5 brokers may provide their own maximum-packet-size property.
# In this case, the smaller of the two limits will be used.
# Set to 0 for "unlimited".
#bridge_max_packet_size 0


# -----------------------------------------------------------------
# Certificate based SSL/TLS support
# -----------------------------------------------------------------
# Either bridge_cafile or bridge_capath must be defined to enable TLS support
# for this bridge.
# bridge_cafile defines the path to a file containing the
# Certificate Authority certificates that have signed the remote broker
# certificate.
# bridge_capath defines a directory that will be searched for files containing
# the CA certificates. For bridge_capath to work correctly, the certificate
# files must have ".crt" as the file ending and you must run "openssl rehash
# <path to capath>" each time you add/remove a certificate.
#bridge_cafile
#bridge_capath


# If the remote broker has more than one protocol available on its port, e.g.
# MQTT and WebSockets, then use bridge_alpn to configure which protocol is
# requested. Note that WebSockets support for bridges is not yet available.
#bridge_alpn

# When using certificate based encryption, bridge_insecure disables
# verification of the server hostname in the server certificate. This can be
# useful when testing initial server configurations, but makes it possible for
# a malicious third party to impersonate your server through DNS spoofing, for
# example. Use this option in testing only. If you need to resort to using this
# option in a production environment, your setup is at fault and there is no
# point using encryption.
#bridge_insecure false

# Path to the PEM encoded client certificate, if required by the remote broker.
#bridge_certfile

# Path to the PEM encoded client private key, if required by the remote broker.
#bridge_keyfile

# -----------------------------------------------------------------
# PSK based SSL/TLS support
# -----------------------------------------------------------------
# Pre-shared-key encryption provides an alternative to certificate based
# encryption. A bridge can be configured to use PSK with the bridge_identity
# and bridge_psk options. These are the client PSK identity, and pre-shared-key
# in hexadecimal format with no "0x". Only one of certificate and PSK based
# encryption can be used on one
# bridge at once.
#bridge_identity
#bridge_psk


# =================================================================
# External config files
# =================================================================

# External configuration files may be included by using the
# include_dir option. This defines a directory that will be searched
# for config files. All files that end in '.conf' will be loaded as
# a configuration file. It is best to have this as the last option
# in the main file. This option will only be processed from the main
# configuration file. The directory specified must not contain the
# main configuration file.
# Files within include_dir will be loaded sorted in case-sensitive
# alphabetical order, with capital letters ordered first. If this option is
# given multiple times, all of the files from the first instance will be
# processed before the next instance. See the man page for examples.
#include_dir



================================================
FILE: integration/auto-mock/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*",
    "test/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/auto-mock/src/bar.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { FooService } from './foo.service';

@Injectable()
export class BarService {
  constructor(private readonly foo: FooService) {}

  bar() {
    this.foo.foo();
  }
}



================================================
FILE: integration/auto-mock/src/foo.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class FooService {
  foo() {
    console.log('foo called');
  }
}



================================================
FILE: integration/auto-mock/test/bar.service.spec.ts
================================================
import { Test } from '@nestjs/testing';
import * as chai from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import * as sinon from 'sinon';
import { BarService } from '../src/bar.service';
import { FooService } from '../src/foo.service';

chai.use(chaiAsPromised);
const { expect } = chai;

describe('Auto-Mocking Bar Deps', () => {
  let service: BarService;
  let fooService: FooService;
  const stub = sinon.stub();
  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [BarService],
    })
      .useMocker(() => ({ foo: stub }))
      .compile();
    service = moduleRef.get(BarService);
    fooService = moduleRef.get(FooService);
  });

  it('should be defined', () => {
    expect(service).not.to.be.undefined;
    expect(fooService).not.to.be.undefined;
  });
  it('should call bar.bar', () => {
    service.bar();
    expect(stub.called);
  });
});

describe('Auto-Mocking with token in factory', () => {
  it('can mock the dependencies', async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [BarService],
    })
      .useMocker(token => {
        if (token === FooService) {
          return { foo: sinon.stub };
        }
      })
      .compile();
    const service = moduleRef.get(BarService);
    const fooServ = moduleRef.get<{ foo: sinon.SinonStub }>(FooService as any);
    service.bar();
    expect(fooServ.foo.called);
  });
  it('cannot mock the dependencies', async () => {
    const moduleRef = Test.createTestingModule({
      providers: [BarService],
    }).useMocker(token => {
      if (token === FooService.name + 'something that fails the token') {
        return { foo: sinon.stub };
      }
    }).compile;
    expect(moduleRef()).to.eventually.throw();
  });
});



================================================
FILE: integration/cors/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/cors/e2e/express.spec.ts
================================================
import { NestExpressApplication } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Express Cors', () => {
  let app: NestExpressApplication;
  const configs = [
    {
      origin: 'example.com',
      methods: 'GET',
      credentials: true,
      exposedHeaders: ['foo', 'bar'],
      allowedHeaders: ['baz', 'woo'],
      maxAge: 123,
    },
    {
      origin: 'sample.com',
      methods: 'GET',
      credentials: true,
      exposedHeaders: ['zoo', 'bar'],
      allowedHeaders: ['baz', 'foo'],
      maxAge: 321,
    },
  ];
  describe('Dynamic config', () => {
    describe('enableCors', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestExpressApplication>();

        let requestId = 0;
        const configDelegation = function (req, cb) {
          const config = configs[requestId];
          requestId++;
          cb(null, config);
        };
        app.enableCors(configDelegation);

        await app.init();
      });

      it(`should add cors headers based on the first config`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });

      it(`should add cors headers based on the second config`, async () => {
        return request(app.getHttpServer())
          .options('/')
          .expect('access-control-allow-origin', 'sample.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'zoo,bar')
          .expect('access-control-allow-methods', 'GET')
          .expect('access-control-allow-headers', 'baz,foo')
          .expect('access-control-max-age', '321')
          .expect('content-length', '0');
      });

      after(async () => {
        await app.close();
      });
    });

    describe('Application Options', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        let requestId = 0;
        const configDelegation = function (req, cb) {
          const config = configs[requestId];
          requestId++;
          cb(null, config);
        };

        app = module.createNestApplication<NestExpressApplication>({
          cors: configDelegation,
        });

        await app.init();
      });

      it(`should add cors headers based on the first config`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });

      it(`should add cors headers based on the second config`, async () => {
        return request(app.getHttpServer())
          .options('/')
          .expect('access-control-allow-origin', 'sample.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'zoo,bar')
          .expect('access-control-allow-methods', 'GET')
          .expect('access-control-allow-headers', 'baz,foo')
          .expect('access-control-max-age', '321')
          .expect('content-length', '0');
      });

      after(async () => {
        await app.close();
      });
    });
  });
  describe('Static config', () => {
    describe('enableCors', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestExpressApplication>();
        app.enableCors(configs[0]);

        await app.init();
      });

      it(`CORS headers`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });
    });

    after(async () => {
      await app.close();
    });

    describe('Application Options', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestExpressApplication>({
          cors: configs[0],
        });
        await app.init();
      });

      it(`CORS headers`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });

      after(async () => {
        await app.close();
      });
    });
  });
});



================================================
FILE: integration/cors/e2e/fastify.spec.ts
================================================
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe.skip('Fastify Cors', () => {
  let app: NestFastifyApplication;
  const configs = [
    {
      origin: 'example.com',
      methods: 'GET',
      credentials: true,
      exposedHeaders: ['foo', 'bar'],
      allowedHeaders: ['baz', 'woo'],
      maxAge: 123,
    },
    {
      origin: 'sample.com',
      methods: 'GET',
      credentials: true,
      exposedHeaders: ['zoo', 'bar'],
      allowedHeaders: ['baz', 'foo'],
      maxAge: 321,
    },
  ];
  describe('Dynamic config', () => {
    describe('enableCors', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestFastifyApplication>(
          new FastifyAdapter(),
        );

        let requestId = 0;
        const configDelegation = {
          delegator: function (req, cb) {
            const config = configs[requestId];
            requestId++;
            cb(null, config);
          },
        };
        app.enableCors(configDelegation);

        await app.init();
      });

      it(`should add cors headers based on the first config`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });

      it(`should add cors headers based on the second config`, async () => {
        return request(app.getHttpServer())
          .options('/')
          .expect('access-control-allow-origin', 'sample.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'zoo,bar')
          .expect('access-control-allow-methods', 'GET')
          .expect('access-control-allow-headers', 'baz,foo')
          .expect('access-control-max-age', '321')
          .expect('content-length', '0');
      });

      after(async () => {
        await app.close();
      });
    });

    describe('Application Options', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        let requestId = 0;
        const configDelegation = function (req, cb) {
          const config = configs[requestId];
          requestId++;
          cb(null, config);
        };

        app = module.createNestApplication<NestFastifyApplication>(
          new FastifyAdapter(),
          {
            cors: configDelegation,
          },
        );

        await app.init();
      });

      it(`should add cors headers based on the first config`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });

      it(`should add cors headers based on the second config`, async () => {
        return request(app.getHttpServer())
          .options('/')
          .expect('access-control-allow-origin', 'sample.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'zoo,bar')
          .expect('access-control-allow-methods', 'GET')
          .expect('access-control-allow-headers', 'baz,foo')
          .expect('access-control-max-age', '321')
          .expect('content-length', '0');
      });

      after(async () => {
        await app.close();
      });
    });
  });

  describe('Static config', () => {
    describe('enableCors', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestFastifyApplication>(
          new FastifyAdapter(),
        );
        app.enableCors(configs[0]);

        await app.init();
      });

      it(`CORS headers`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });
    });

    after(async () => {
      await app.close();
    });

    describe('Application Options', () => {
      before(async () => {
        const module = await Test.createTestingModule({
          imports: [AppModule],
        }).compile();

        app = module.createNestApplication<NestFastifyApplication>(
          new FastifyAdapter(),
          {
            cors: configs[0],
          },
        );
        await app.init();
      });

      it(`CORS headers`, async () => {
        return request(app.getHttpServer())
          .get('/')
          .expect('access-control-allow-origin', 'example.com')
          .expect('vary', 'Origin')
          .expect('access-control-allow-credentials', 'true')
          .expect('access-control-expose-headers', 'foo,bar')
          .expect('content-length', '0');
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/cors/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  getGlobals() {
    return '';
  }
}



================================================
FILE: integration/cors/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: integration/discovery/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/discovery/e2e/discover-by-meta.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { DiscoveryService } from '@nestjs/core';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';
import { WebhooksExplorer } from '../src/webhooks.explorer';
import { NonAppliedDecorator } from '../src/decorators/non-applied.decorator';

describe('DiscoveryModule', () => {
  let moduleRef: TestingModule;

  beforeEach(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
  });

  it('should discover all providers & handlers with corresponding annotations', async () => {
    const webhooksExplorer = moduleRef.get(WebhooksExplorer);

    expect(webhooksExplorer.getWebhooks()).to.be.eql([
      {
        handlers: [
          {
            event: 'start',
            methodName: 'onStart',
          },
        ],
        name: 'cleanup',
      },
      {
        handlers: [
          {
            event: 'start',
            methodName: 'onStart',
          },
        ],
        name: 'flush',
      },
    ]);
  });

  it('should return an empty array if no providers were found for a given discoverable decorator', () => {
    const discoveryService = moduleRef.get(DiscoveryService);

    const providers = discoveryService.getProviders({
      metadataKey: NonAppliedDecorator.KEY,
    });
    expect(providers).to.be.eql([]);
  });

  it('should return an empty array if no controllers were found for a given discoverable decorator', () => {
    const discoveryService = moduleRef.get(DiscoveryService);

    const controllers = discoveryService.getControllers({
      metadataKey: NonAppliedDecorator.KEY,
    });
    expect(controllers).to.be.eql([]);
  });
});



================================================
FILE: integration/discovery/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { DiscoveryModule } from '@nestjs/core';
import { MyWebhookModule } from './my-webhook/my-webhook.module';
import { WebhooksExplorer } from './webhooks.explorer';

@Module({
  imports: [MyWebhookModule, DiscoveryModule],
  providers: [WebhooksExplorer],
})
export class AppModule {}



================================================
FILE: integration/discovery/src/webhooks.explorer.ts
================================================
import { Injectable } from '@nestjs/common';
import { DiscoveryService, MetadataScanner } from '@nestjs/core';
import { Webhook, WebhookHandler } from './decorators/webhook.decorators';

@Injectable()
export class WebhooksExplorer {
  constructor(
    private readonly discoveryService: DiscoveryService,
    private readonly metadataScanner: MetadataScanner,
  ) {}

  getWebhooks() {
    const webhooks = this.discoveryService.getProviders({
      metadataKey: Webhook.KEY,
    });
    return webhooks.map(wrapper => {
      const { name } = this.discoveryService.getMetadataByDecorator(
        Webhook,
        wrapper,
      )!;
      return {
        name,
        handlers: this.metadataScanner
          .getAllMethodNames(wrapper.metatype!.prototype)
          .map(methodName => {
            const { event } = this.discoveryService.getMetadataByDecorator(
              WebhookHandler,
              wrapper,
              methodName,
            )!;
            return {
              methodName,
              event,
            };
          }),
      };
    });
  }
}



================================================
FILE: integration/discovery/src/decorators/non-applied.decorator.ts
================================================
import { DiscoveryService } from '@nestjs/core';

/**
 * This decorator must not be used anywhere!
 *
 * This will be used to test the scenario where we are trying to retrieving
 * metadata for a discoverable decorator that was not applied to any class.
 */
export const NonAppliedDecorator = DiscoveryService.createDecorator();



================================================
FILE: integration/discovery/src/decorators/webhook.decorators.ts
================================================
import { DiscoveryService } from '@nestjs/core';

export const Webhook = DiscoveryService.createDecorator<{ name: string }>();
export const WebhookHandler = DiscoveryService.createDecorator<{
  event: string;
}>();



================================================
FILE: integration/discovery/src/my-webhook/cleanup.webhook.ts
================================================
import { Webhook, WebhookHandler } from '../decorators/webhook.decorators';

@Webhook({ name: 'cleanup' })
export class CleanupWebhook {
  @WebhookHandler({ event: 'start' })
  onStart() {
    console.log('cleanup started');
  }
}



================================================
FILE: integration/discovery/src/my-webhook/flush.webhook.ts
================================================
import { Webhook, WebhookHandler } from '../decorators/webhook.decorators';

@Webhook({ name: 'flush' })
export class FlushWebhook {
  @WebhookHandler({ event: 'start' })
  onStart() {
    console.log('flush started');
  }
}



================================================
FILE: integration/discovery/src/my-webhook/my-webhook.module.ts
================================================
import { Module } from '@nestjs/common';
import { CleanupWebhook } from './cleanup.webhook';
import { FlushWebhook } from './flush.webhook';

@Module({ providers: [CleanupWebhook, FlushWebhook] })
export class MyWebhookModule {}



================================================
FILE: integration/graphql-code-first/schema.gql
================================================
# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type Recipe {
  id: ID!
  title: String!
  description: String
  creationDate: Date!
  ingredients: [String!]!
}

"""Date custom scalar type"""
scalar Date

type Query {
  recipe(id: String!): Recipe!
  recipes(skip: Int! = 0, take: Int! = 25): [Recipe!]!
}

type Mutation {
  addRecipe(newRecipeData: NewRecipeInput!): Recipe!
  removeRecipe(id: String!): Boolean!
}

input NewRecipeInput {
  title: String!
  description: String
  ingredients: [String!]!
}

type Subscription {
  recipeAdded: Recipe!
}


================================================
FILE: integration/graphql-code-first/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/graphql-code-first/e2e/code-first.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('GraphQL - Code-first', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it(`should return query result`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  recipes {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: {
          recipes: [],
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-code-first/e2e/guards-filters.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('GraphQL - Guards', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it(`should throw an error`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  recipe(id: "3") {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: null,
        errors: [
          {
            message: 'Unauthorized error',
            locations: [
              {
                line: 2,
                column: 3,
              },
            ],
            path: ['recipe'],
            extensions: {
              code: 'INTERNAL_SERVER_ERROR',
            },
          },
        ],
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-code-first/e2e/pipes.spec.ts
================================================
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('GraphQL Pipes', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    app.useGlobalPipes(new ValidationPipe());
    await app.init();
  });

  it(`should throw an error`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query:
          'mutation {\n  addRecipe(newRecipeData: {title: "test", ingredients: []}) {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: null,
        errors: [
          {
            extensions: {
              code: 'BAD_REQUEST',
              originalError: {
                error: 'Bad Request',
                message: [
                  'description must be longer than or equal to 30 characters',
                ],
                statusCode: 400,
              },
            },
            locations: [
              {
                column: 3,
                line: 2,
              },
            ],
            message: 'Bad Request Exception',
            path: ['addRecipe'],
          },
        ],
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-code-first/src/app.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { join } from 'path';
import { RecipesModule } from './recipes/recipes.module';

@Module({
  imports: [
    RecipesModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      includeStacktraceInErrorResponses: false,
      installSubscriptionHandlers: true,
      autoSchemaFile: join(
        process.cwd(),
        'integration/graphql-code-first/schema.gql',
      ),
    }),
  ],
})
export class AppModule {}



================================================
FILE: integration/graphql-code-first/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
}
void bootstrap();



================================================
FILE: integration/graphql-code-first/src/common/filters/unauthorized.filter.ts
================================================
import { ArgumentsHost, Catch, UnauthorizedException } from '@nestjs/common';
import { GqlExceptionFilter } from '@nestjs/graphql';

@Catch(UnauthorizedException)
export class UnauthorizedFilter implements GqlExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    return new Error('Unauthorized error');
  }
}



================================================
FILE: integration/graphql-code-first/src/common/guards/auth.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

@Injectable()
export class AuthGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const gqlContext = GqlExecutionContext.create(context);
    if (gqlContext) {
      throw new UnauthorizedException();
    }
    return true;
  }
}



================================================
FILE: integration/graphql-code-first/src/common/interceptors/data.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class DataInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(tap(data => data));
  }
}



================================================
FILE: integration/graphql-code-first/src/common/scalars/date.scalar.ts
================================================
import { Scalar } from '@nestjs/graphql';
import { Kind, ValueNode } from 'graphql';

@Scalar('Date', type => Date)
export class DateScalar {
  description = 'Date custom scalar type';

  parseValue(value: any) {
    return new Date(value); // value from the client
  }

  serialize(value: any) {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode) {
    if (ast.kind === Kind.INT) {
      return parseInt(ast.value, 10); // ast value is always in string format
    }
    return null;
  }
}



================================================
FILE: integration/graphql-code-first/src/recipes/recipes.module.ts
================================================
import { Module } from '@nestjs/common';
import { APP_FILTER } from '@nestjs/core';
import { UnauthorizedFilter } from '../common/filters/unauthorized.filter';
import { DateScalar } from '../common/scalars/date.scalar';
import { RecipesResolver } from './recipes.resolver';
import { RecipesService } from './recipes.service';

@Module({
  providers: [
    RecipesResolver,
    RecipesService,
    DateScalar,
    {
      provide: APP_FILTER,
      useClass: UnauthorizedFilter,
    },
  ],
})
export class RecipesModule {}



================================================
FILE: integration/graphql-code-first/src/recipes/recipes.resolver.ts
================================================
import { NotFoundException, UseGuards, UseInterceptors } from '@nestjs/common';
import { Args, Mutation, Query, Resolver, Subscription } from '@nestjs/graphql';
import { PubSub } from 'graphql-subscriptions';
import { AuthGuard } from '../common/guards/auth.guard';
import { DataInterceptor } from '../common/interceptors/data.interceptor';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe';
import { RecipesService } from './recipes.service';

const pubSub = new PubSub();

@UseInterceptors(DataInterceptor)
@Resolver(of => Recipe)
export class RecipesResolver {
  constructor(private readonly recipesService: RecipesService) {}

  @UseGuards(AuthGuard)
  @Query(returns => Recipe)
  async recipe(@Args('id') id: string): Promise<Recipe> {
    const recipe = await this.recipesService.findOneById(id);
    if (!recipe) {
      throw new NotFoundException(id);
    }
    return recipe;
  }

  @Query(returns => [Recipe])
  recipes(@Args() recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return this.recipesService.findAll(recipesArgs);
  }

  @Mutation(returns => Recipe)
  async addRecipe(
    @Args('newRecipeData') newRecipeData: NewRecipeInput,
  ): Promise<Recipe> {
    const recipe = await this.recipesService.create(newRecipeData);
    void pubSub.publish('recipeAdded', { recipeAdded: recipe });
    return recipe;
  }

  @Mutation(returns => Boolean)
  async removeRecipe(@Args('id') id: string) {
    return this.recipesService.remove(id);
  }

  @Subscription(returns => Recipe)
  recipeAdded() {
    return pubSub.asyncIterableIterator('recipeAdded');
  }
}



================================================
FILE: integration/graphql-code-first/src/recipes/recipes.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe';

@Injectable()
export class RecipesService {
  /**
   * MOCK
   * Put some real business logic here
   * Left for demonstration purposes
   */

  async create(data: NewRecipeInput): Promise<Recipe> {
    return {
      id: 3,
    } as any;
  }

  async findOneById(id: string): Promise<Recipe> {
    return {} as any;
  }

  async findAll(recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return [] as Recipe[];
  }

  async remove(id: string): Promise<boolean> {
    return true;
  }
}



================================================
FILE: integration/graphql-code-first/src/recipes/dto/new-recipe.input.ts
================================================
import { Field, InputType } from '@nestjs/graphql';
import { Type } from 'class-transformer';
import { Length, MaxLength } from 'class-validator';

@InputType()
export class NewRecipeInput {
  @Field()
  @MaxLength(30)
  title: string;

  @Field({ nullable: true })
  @Length(30, 255)
  description?: string;

  @Type(() => String)
  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: integration/graphql-code-first/src/recipes/dto/recipes.args.ts
================================================
import { ArgsType, Field, Int } from '@nestjs/graphql';
import { Max, Min } from 'class-validator';

@ArgsType()
export class RecipesArgs {
  @Field(type => Int)
  @Min(0)
  skip = 0;

  @Field(type => Int)
  @Min(1)
  @Max(50)
  take = 25;
}



================================================
FILE: integration/graphql-code-first/src/recipes/models/recipe.ts
================================================
import { Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType()
export class Recipe {
  @Field(type => ID)
  id: string;

  @Field()
  title: string;

  @Field({ nullable: true })
  description?: string;

  @Field()
  creationDate: Date;

  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: integration/graphql-schema-first/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/graphql-schema-first/e2e/graphql-async-class.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import * as request from 'supertest';
import { AsyncClassApplicationModule } from '../src/async-options-class.module';

describe('GraphQL (async class)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = await NestFactory.create(AsyncClassApplicationModule, {
      logger: false,
    });
    await app.init();
  });

  it(`should return query result`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  getCats {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: {
          getCats: [
            {
              id: 1,
            },
          ],
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-schema-first/e2e/graphql-async-existing.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import * as request from 'supertest';
import { AsyncExistingApplicationModule } from '../src/async-options-existing.module';

describe('GraphQL (async existing)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = await NestFactory.create(AsyncExistingApplicationModule, {
      logger: false,
    });
    await app.init();
  });

  it(`should return query result`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  getCats {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: {
          getCats: [
            {
              id: 1,
            },
          ],
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-schema-first/e2e/graphql-async.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import * as request from 'supertest';
import { AsyncApplicationModule } from '../src/async-options.module';

describe('GraphQL (async configuration)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = await NestFactory.create(AsyncApplicationModule, { logger: false });
    await app.init();
  });

  it(`should return query result`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  getCats {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: {
          getCats: [
            {
              id: 1,
            },
          ],
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-schema-first/e2e/graphql-request-scoped.spec.ts
================================================
import { ApolloDriver } from '@nestjs/apollo';
import { INestApplication } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { join } from 'path';
import * as request from 'supertest';
import { CatsRequestScopedService } from '../src/cats/cats-request-scoped.service';
import { CatsModule } from '../src/cats/cats.module';

describe('GraphQL request scoped', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [
        CatsModule.enableRequestScope(),
        GraphQLModule.forRoot({
          driver: ApolloDriver,
          typePaths: [join(__dirname, '..', 'src', '**', '*.graphql')],
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    await app.init();

    const performHttpCall = end =>
      request(app.getHttpServer())
        .post('/graphql')
        .send({
          operationName: null,
          variables: {},
          query: '{\n  getCats {\n    id\n  }\n}\n',
        })
        .expect(200, {
          data: {
            getCats: [
              {
                id: 1,
              },
            ],
          },
        })
        .end(err => {
          if (err) return end(err);
          end();
        });

    await new Promise(resolve => performHttpCall(resolve));
    await new Promise(resolve => performHttpCall(resolve));
    await new Promise(resolve => performHttpCall(resolve));
  });

  it(`should create resolver for each incoming request`, () => {
    expect(CatsRequestScopedService.COUNTER).to.be.eql(3);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-schema-first/e2e/graphql.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('GraphQL', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it(`should return query result`, () => {
    return request(app.getHttpServer())
      .post('/graphql')
      .send({
        operationName: null,
        variables: {},
        query: '{\n  getCats {\n    id\n  }\n}\n',
      })
      .expect(200, {
        data: {
          getCats: [
            {
              id: 1,
            },
          ],
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/graphql-schema-first/src/app.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { join } from 'path';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [
    CatsModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      includeStacktraceInErrorResponses: true,
      typePaths: [join(__dirname, '**', '*.graphql')],
    }),
  ],
})
export class AppModule {}



================================================
FILE: integration/graphql-schema-first/src/async-options-class.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GqlOptionsFactory, GraphQLModule } from '@nestjs/graphql';
import { join } from 'path';
import { CatsModule } from './cats/cats.module';

class ConfigService implements GqlOptionsFactory {
  createGqlOptions(): ApolloDriverConfig {
    return {
      typePaths: [join(__dirname, '**', '*.graphql')],
    };
  }
}

@Module({
  imports: [
    CatsModule,
    GraphQLModule.forRootAsync<ApolloDriverConfig>({
      driver: ApolloDriver,
      useClass: ConfigService,
    }),
  ],
})
export class AsyncClassApplicationModule {}



================================================
FILE: integration/graphql-schema-first/src/async-options-existing.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { CatsModule } from './cats/cats.module';
import { ConfigModule } from './config.module';
import { ConfigService } from './config.service';

@Module({
  imports: [
    CatsModule,
    GraphQLModule.forRootAsync<ApolloDriverConfig>({
      driver: ApolloDriver,
      imports: [ConfigModule],
      useExisting: ConfigService,
    }),
  ],
})
export class AsyncExistingApplicationModule {}



================================================
FILE: integration/graphql-schema-first/src/async-options.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { join } from 'path';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [
    CatsModule,
    GraphQLModule.forRootAsync<ApolloDriverConfig>({
      driver: ApolloDriver,
      useFactory: async () => ({
        typePaths: [join(__dirname, '**', '*.graphql')],
      }),
    }),
  ],
})
export class AsyncApplicationModule {}



================================================
FILE: integration/graphql-schema-first/src/config.module.ts
================================================
import { Module } from '@nestjs/common';
import { ConfigService } from './config.service';

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
export class ConfigModule {}



================================================
FILE: integration/graphql-schema-first/src/config.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { GqlModuleOptions, GqlOptionsFactory } from '@nestjs/graphql';
import { join } from 'path';

@Injectable()
export class ConfigService implements GqlOptionsFactory {
  createGqlOptions(): GqlModuleOptions {
    return {
      typePaths: [join(__dirname, '**', '*.graphql')],
    };
  }
}



================================================
FILE: integration/graphql-schema-first/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
void bootstrap();



================================================
FILE: integration/graphql-schema-first/src/cats/cats-request-scoped.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable({ scope: Scope.REQUEST })
export class CatsRequestScopedService {
  static COUNTER = 0;
  private readonly cats: Cat[] = [{ id: 1, name: 'Cat', age: 5 }];

  constructor() {
    CatsRequestScopedService.COUNTER++;
  }

  create(cat: Cat): Cat {
    this.cats.push(cat);
    return cat;
  }

  findAll(): Cat[] {
    return this.cats;
  }

  findOneById(id: number): Cat {
    return this.cats.find(cat => cat.id === id)!;
  }
}



================================================
FILE: integration/graphql-schema-first/src/cats/cats.guard.ts
================================================
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

@Injectable()
export class CatsGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const ctx = GqlExecutionContext.create(context);
    return true;
  }
}



================================================
FILE: integration/graphql-schema-first/src/cats/cats.module.ts
================================================
import { DynamicModule, Module, Scope } from '@nestjs/common';
import { CatsRequestScopedService } from './cats-request-scoped.service';
import { CatsResolvers } from './cats.resolvers';
import { CatsService } from './cats.service';

@Module({
  providers: [CatsService, CatsResolvers],
})
export class CatsModule {
  static enableRequestScope(): DynamicModule {
    return {
      module: CatsModule,
      providers: [
        {
          provide: CatsService,
          useClass: CatsRequestScopedService,
          scope: Scope.REQUEST,
        },
      ],
    };
  }
}



================================================
FILE: integration/graphql-schema-first/src/cats/cats.resolvers.ts
================================================
import { ParseIntPipe, UseGuards } from '@nestjs/common';
import { Args, Mutation, Query, Resolver, Subscription } from '@nestjs/graphql';
import { PubSub } from 'graphql-subscriptions';
import { CatsGuard } from './cats.guard';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

const pubSub = new PubSub();

@Resolver('Cat')
export class CatsResolvers {
  constructor(private readonly catsService: CatsService) {}

  @Query()
  @UseGuards(CatsGuard)
  async getCats() {
    return this.catsService.findAll();
  }

  @Query('cat')
  async findOneById(
    @Args('id', ParseIntPipe)
    id: number,
  ): Promise<Cat> {
    return this.catsService.findOneById(id);
  }

  @Mutation('createCat')
  async create(@Args() args: Cat): Promise<Cat> {
    const createdCat = this.catsService.create(args);
    void pubSub.publish('catCreated', { catCreated: createdCat });
    return createdCat;
  }

  @Subscription('catCreated')
  catCreated() {
    return pubSub.asyncIterableIterator('catCreated');
  }
}



================================================
FILE: integration/graphql-schema-first/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  static COUNTER = 0;
  private readonly cats: Cat[] = [{ id: 1, name: 'Cat', age: 5 }];

  constructor() {
    CatsService.COUNTER++;
  }

  create(cat: Cat): Cat {
    this.cats.push(cat);
    return cat;
  }

  findAll(): Cat[] {
    return this.cats;
  }

  findOneById(id: number): Cat {
    return this.cats.find(cat => cat.id === id)!;
  }
}



================================================
FILE: integration/graphql-schema-first/src/cats/cats.types.graphql
================================================
type Query {
  getCats: [Cat]
  cat(id: ID!): Cat
}

type Mutation {
  createCat(name: String): Cat
}

type Subscription {
  catCreated: Cat
}

type Cat {
  id: Int
  name: String
  age: Int
}



================================================
FILE: integration/graphql-schema-first/src/cats/interfaces/cat.interface.ts
================================================
export interface Cat {
  readonly id: number;
  readonly name: string;
  readonly age: number;
}



================================================
FILE: integration/graphql-schema-first/src/common/scalars/date.scalar.ts
================================================
import { Scalar } from '@nestjs/graphql';
import { Kind } from 'graphql';

@Scalar('Date')
export class DateScalar {
  description = 'Date custom scalar type';

  parseValue(value) {
    return new Date(value); // value from the client
  }

  serialize(value) {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast) {
    if (ast.kind === Kind.INT) {
      return parseInt(ast.value, 10); // ast value is always in string format
    }
    return null;
  }
}



================================================
FILE: integration/hello-world/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/hello-world/e2e/exceptions.spec.ts
================================================
import { HttpStatus, INestApplication } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { RawServerDefault } from 'fastify';
import * as request from 'supertest';
import { ErrorsController } from '../src/errors/errors.controller';

describe('Error messages', () => {
  let server: RawServerDefault;

  describe('Express', () => {
    let app: INestApplication;
    beforeEach(async () => {
      const module = await Test.createTestingModule({
        controllers: [ErrorsController],
      }).compile();

      app = module.createNestApplication();
      server = app.getHttpServer();
      await app.init();
    });

    it(`/GET`, () => {
      return request(server)
        .get('/sync')
        .expect(HttpStatus.BAD_REQUEST)
        .expect({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Integration test',
        });
    });

    it(`/GET (Promise/async)`, () => {
      return request(server)
        .get('/async')
        .expect(HttpStatus.BAD_REQUEST)
        .expect({
          statusCode: 400,
          error: 'Bad Request',
          message: 'Integration test',
        });
    });

    it(`/GET (InternalServerError despite custom content-type)`, async () => {
      return request(server)
        .get('/unexpected-error')
        .expect(HttpStatus.INTERNAL_SERVER_ERROR)
        .expect({
          statusCode: 500,
          message: 'Internal server error',
        });
    });

    afterEach(async () => {
      await app.close();
    });
  });

  describe('Fastify', () => {
    let app: NestFastifyApplication;
    beforeEach(async () => {
      const module = await Test.createTestingModule({
        controllers: [ErrorsController],
      }).compile();

      app = module.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      server = app.getHttpServer();
      await app.init();
    });

    it(`/GET`, async () => {
      return app
        .inject({
          method: 'GET',
          url: '/sync',
        })
        .then(({ payload, statusCode }) => {
          expect(statusCode).to.equal(HttpStatus.BAD_REQUEST);
          expect(payload).to.equal(
            JSON.stringify({
              statusCode: 400,
              error: 'Bad Request',
              message: 'Integration test',
            }),
          );
        });
    });

    it(`/GET (Promise/async)`, async () => {
      return app
        .inject({
          method: 'GET',
          url: '/sync',
        })
        .then(({ payload, statusCode }) => {
          expect(statusCode).to.equal(HttpStatus.BAD_REQUEST);
          expect(payload).to.equal(
            JSON.stringify({
              statusCode: 400,
              error: 'Bad Request',
              message: 'Integration test',
            }),
          );
        });
    });

    it(`/GET (InternalServerError despite custom content-type)`, async () => {
      return app
        .inject({
          method: 'GET',
          url: '/unexpected-error',
        })
        .then(({ payload, statusCode }) => {
          expect(statusCode).to.equal(HttpStatus.INTERNAL_SERVER_ERROR);
          expect(payload).to.equal(
            JSON.stringify({
              statusCode: 500,
              message: 'Internal server error',
            }),
          );
        });
    });

    afterEach(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/hello-world/e2e/exclude-middleware-fastify.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  MiddlewareConsumer,
  Module,
  Post,
  RequestMethod,
} from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';
const MIDDLEWARE_VALUE = 'middleware';

@Controller()
class TestController {
  @Get('test')
  test() {
    return RETURN_VALUE;
  }

  @Get('test/test')
  testTest() {
    return RETURN_VALUE;
  }

  @Get('test2')
  test2() {
    return RETURN_VALUE;
  }

  @Get('middleware')
  middleware() {
    return RETURN_VALUE;
  }

  @Post('middleware')
  noMiddleware() {
    return RETURN_VALUE;
  }

  @Get('wildcard/overview')
  testOverview() {
    return RETURN_VALUE;
  }

  @Get('legacy-wildcard/overview')
  testLegacyWildcard() {
    return RETURN_VALUE;
  }

  @Get('splat-wildcard/overview')
  testSplatWildcard() {
    return RETURN_VALUE;
  }

  @Get('overview/:id')
  overviewById() {
    return RETURN_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.end(MIDDLEWARE_VALUE))
      .exclude(
        'test',
        'overview/:id',
        'wildcard/*',
        'legacy-wildcard/(.*)',
        'splat-wildcard/*splat',
        {
          path: 'middleware',
          method: RequestMethod.POST,
        },
      )
      .forRoutes('*');
  }
}

describe('Exclude middleware (fastify)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = (
      await Test.createTestingModule({
        imports: [TestModule],
      }).compile()
    ).createNestApplication<NestFastifyApplication>(new FastifyAdapter());

    await app.init();
    await app.getHttpAdapter().getInstance().ready();
  });

  it(`should exclude "/test" endpoint`, () => {
    return request(app.getHttpServer()).get('/test').expect(200, RETURN_VALUE);
  });

  it(`should not exclude "/test/test" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/test/test')
      .expect(200, MIDDLEWARE_VALUE);
  });

  it(`should not exclude "/test2" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/test2')
      .expect(200, MIDDLEWARE_VALUE);
  });

  it(`should run middleware for "/middleware" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/middleware')
      .expect(200, MIDDLEWARE_VALUE);
  });

  it(`should exclude POST "/middleware" endpoint`, () => {
    return request(app.getHttpServer())
      .post('/middleware')
      .expect(201, RETURN_VALUE);
  });

  it(`should exclude "/overview/:id" endpoint (by param)`, () => {
    return request(app.getHttpServer())
      .get('/overview/1')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/wildcard/overview" endpoint (by wildcard)`, () => {
    return request(app.getHttpServer())
      .get('/wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/legacy-wildcard/overview" endpoint (by wildcard, legacy syntax)`, () => {
    return request(app.getHttpServer())
      .get('/legacy-wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/splat-wildcard/overview" endpoint (by wildcard, new syntax)`, () => {
    return request(app.getHttpServer())
      .get('/splat-wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/exclude-middleware.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  MiddlewareConsumer,
  Module,
  Post,
  RequestMethod,
} from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';
const MIDDLEWARE_VALUE = 'middleware';

@Controller()
class TestController {
  @Get('test')
  test() {
    return RETURN_VALUE;
  }

  @Get('test2')
  test2() {
    return RETURN_VALUE;
  }

  @Get('middleware')
  middleware() {
    return RETURN_VALUE;
  }

  @Post('middleware')
  noMiddleware() {
    return RETURN_VALUE;
  }

  @Get('wildcard/overview')
  testOverview() {
    return RETURN_VALUE;
  }

  @Get('legacy-wildcard/overview')
  testLegacyWildcard() {
    return RETURN_VALUE;
  }

  @Get('splat-wildcard/overview')
  testSplatWildcard() {
    return RETURN_VALUE;
  }

  @Get('overview/:id')
  overviewById() {
    return RETURN_VALUE;
  }

  @Get('multiple/exclude')
  multipleExclude() {
    return RETURN_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(MIDDLEWARE_VALUE))
      .exclude(
        'test',
        'overview/:id',
        'wildcard/*',
        'legacy-wildcard/(.*)',
        'splat-wildcard/*splat',
        {
          path: 'middleware',
          method: RequestMethod.POST,
        },
      )
      .exclude('multiple/exclude')
      .forRoutes('*path');
  }
}

describe('Exclude middleware', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = (
      await Test.createTestingModule({
        imports: [TestModule],
      }).compile()
    ).createNestApplication();

    await app.init();
  });

  it(`should exclude "/test" endpoint`, () => {
    return request(app.getHttpServer()).get('/test').expect(200, RETURN_VALUE);
  });

  it(`should not exclude "/test2" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/test2')
      .expect(200, MIDDLEWARE_VALUE);
  });

  it(`should run middleware for "/middleware" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/middleware')
      .expect(200, MIDDLEWARE_VALUE);
  });

  it(`should exclude POST "/middleware" endpoint`, () => {
    return request(app.getHttpServer())
      .post('/middleware')
      .expect(201, RETURN_VALUE);
  });

  it(`should exclude "/overview/:id" endpoint (by param)`, () => {
    return request(app.getHttpServer())
      .get('/overview/1')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/wildcard/overview" endpoint (by wildcard)`, () => {
    return request(app.getHttpServer())
      .get('/wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/legacy-wildcard/overview" endpoint (by wildcard, legacy syntax)`, () => {
    return request(app.getHttpServer())
      .get('/legacy-wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/splat-wildcard/overview" endpoint (by wildcard, new syntax)`, () => {
    return request(app.getHttpServer())
      .get('/splat-wildcard/overview')
      .expect(200, RETURN_VALUE);
  });

  it(`should exclude "/multiple/exclude" endpoint`, () => {
    return request(app.getHttpServer())
      .get('/multiple/exclude')
      .expect(200, RETURN_VALUE);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/express-instance.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { ExpressAdapter } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import * as express from 'express';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { AppModule } from '../src/app.module';

describe('Hello world (express instance)', () => {
  let server: App;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication(new ExpressAdapter(express()));
    server = app.getHttpServer();
    await app.init();
  });

  it(`/GET`, () => {
    return request(server).get('/hello').expect(200).expect('Hello world!');
  });

  it(`/GET (Promise/async)`, () => {
    return request(server)
      .get('/hello/async')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET (Observable stream)`, () => {
    return request(server)
      .get('/hello/stream')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET { host: ":tenant.example.com" } not matched`, () => {
    return request(server).get('/host').expect(404).expect({
      statusCode: 404,
      error: 'Not Found',
      message: 'Cannot GET /host',
    });
  });

  it('/HEAD should respond to with a 200', () => {
    return request(server).head('/hello').expect(200);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/express-multiple.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { ExpressAdapter } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import * as express from 'express';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Hello world (express instance with multiple applications)', () => {
  let server;
  let apps: INestApplication[];

  beforeEach(async () => {
    const module1 = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    const module2 = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    const adapter = new ExpressAdapter(express());

    apps = [
      module1.createNestApplication(adapter),
      module2.createNestApplication(adapter).setGlobalPrefix('/app2'),
    ];
    await Promise.all(apps.map(app => app.init()));

    server = adapter.getInstance();
  });

  it(`/GET`, () => {
    return request(server).get('/hello').expect(200).expect('Hello world!');
  });

  it(`/GET (app2)`, () => {
    return request(server)
      .get('/app2/hello')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET (Promise/async)`, () => {
    return request(server)
      .get('/hello/async')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET (app2 Promise/async)`, () => {
    return request(server)
      .get('/app2/hello/async')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET (Observable stream)`, () => {
    return request(server)
      .get('/hello/stream')
      .expect(200)
      .expect('Hello world!');
  });

  it(`/GET (app2 Observable stream)`, () => {
    return request(server)
      .get('/app2/hello/stream')
      .expect(200)
      .expect('Hello world!');
  });

  afterEach(async () => {
    await Promise.all(apps.map(app => app.close()));
  });
});



================================================
FILE: integration/hello-world/e2e/fastify-adapter.spec.ts
================================================
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';

describe('Hello world (fastify adapter)', () => {
  let app: NestFastifyApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication<NestFastifyApplication>(
      new FastifyAdapter(),
    );
    await app.init();
  });

  it(`/GET`, () => {
    return app
      .inject({
        method: 'GET',
        url: '/hello',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (Promise/async)`, () => {
    return app
      .inject({
        method: 'GET',
        url: '/hello/async',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (Observable stream)`, () => {
    return app
      .inject({
        method: 'GET',
        url: '/hello/stream',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET { host: ":tenant.example.com" } not matched`, () => {
    return app
      .inject({
        method: 'GET',
        url: '/host',
      })
      .then(({ payload }) => {
        expect(JSON.parse(payload)).to.be.eql({
          error: 'Internal Server Error',
          message:
            'HTTP adapter does not support filtering on host: ":tenant.example.com"',
          statusCode: 500,
        });
      });
  });

  it(`/GET { host: [":tenant.example1.com", ":tenant.example2.com"] } not matched`, () => {
    return app
      .inject({
        method: 'GET',
        url: '/host-array',
      })
      .then(({ payload }) => {
        expect(JSON.parse(payload)).to.be.eql({
          error: 'Internal Server Error',
          message:
            'HTTP adapter does not support filtering on hosts: [":tenant.example1.com", ":tenant.example2.com"]',
          statusCode: 500,
        });
      });
  });

  it(`/GET inject with LightMyRequest chaining API`, () => {
    return app
      .inject()
      .get('/hello')
      .end()
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it('/HEAD should respond to with a 200', () => {
    return app
      .inject({
        method: 'HEAD',
        url: '/hello',
      })
      .then(({ statusCode }) => expect(statusCode).to.be.eq(200));
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/fastify-multiple.spec.ts
================================================
/* Temporarily disabled due to various regressions

import { FastifyAdapter, NestFastifyApplication } from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { ApplicationModule } from '../src/app.module';

describe('Hello world (fastify adapter with multiple applications)', () => {
  let adapter: FastifyAdapter;
  let apps: NestFastifyApplication[];

  beforeEach(async () => {
    const module1 = await Test.createTestingModule({
      imports: [ApplicationModule],
    }).compile();
    const module2 = await Test.createTestingModule({
      imports: [ApplicationModule],
    }).compile();

    adapter = new FastifyAdapter();

    apps = [
      module1.createNestApplication<NestFastifyApplication>(adapter),
      module2
        .createNestApplication<NestFastifyApplication>(adapter, {
          bodyParser: false,
        })
        .setGlobalPrefix('/app2'),
    ];
    await Promise.all(apps.map(app => app.init()));
  });

  it(`/GET`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/hello',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (app2)`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/app2/hello',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (Promise/async)`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/hello/async',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (app2 Promise/async)`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/app2/hello/async',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (Observable stream)`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/hello/stream',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  it(`/GET (app2 Observable stream)`, () => {
    return adapter
      .inject({
        method: 'GET',
        url: '/app2/hello/stream',
      })
      .then(({ payload }) => expect(payload).to.be.eql('Hello world!'));
  });

  afterEach(async () => {
    await Promise.all(apps.map(app => app.close()));
    await adapter.close();
  });
});*/



================================================
FILE: integration/hello-world/e2e/guards.spec.ts
================================================
import {
  INestApplication,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

@Injectable()
export class AuthGuard {
  canActivate() {
    const x = true;
    if (x) {
      throw new UnauthorizedException();
    }
  }
}

function createTestModule(guard) {
  return Test.createTestingModule({
    imports: [AppModule],
    providers: [
      {
        provide: APP_GUARD,
        useValue: guard,
      },
    ],
  }).compile();
}

describe('Guards', () => {
  let app: INestApplication;

  it(`should prevent access (unauthorized)`, async () => {
    app = (await createTestModule(new AuthGuard())).createNestApplication();

    await app.init();
    return request(app.getHttpServer()).get('/hello').expect(401);
  });
});



================================================
FILE: integration/hello-world/e2e/hello-world.spec.ts
================================================
import * as request from 'supertest';
import { Test } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import { AppModule } from '../src/app.module';

describe('Hello world (default adapter)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  [
    {
      host: 'example.com',
      path: '/hello',
      greeting: 'Hello world!',
    },
    {
      host: 'acme.example.com',
      path: '/host',
      greeting: 'Host Greeting! tenant=acme',
    },
    {
      host: 'acme.example1.com',
      path: '/host-array',
      greeting: 'Host Greeting! tenant=acme',
    },
    {
      host: 'acme.example2.com',
      path: '/host-array',
      greeting: 'Host Greeting! tenant=acme',
    },
  ].forEach(({ host, path, greeting }) => {
    describe(`host=${host}`, () => {
      describe('/GET', () => {
        it(`should return "${greeting}"`, () => {
          return request(server)
            .get(path)
            .set('Host', host)
            .expect(200)
            .expect(greeting);
        });

        it(`should attach response header`, () => {
          return request(server)
            .get(path)
            .set('Host', host)
            .expect(200)
            .expect('Authorization', 'Bearer');
        });
      });

      it(`/GET (Promise/async) returns "${greeting}"`, () => {
        return request(server)
          .get(`${path}/async`)
          .set('Host', host)
          .expect(200)
          .expect(greeting);
      });

      it(`/GET (Observable stream) "${greeting}"`, () => {
        return request(server)
          .get(`${path}/stream`)
          .set('Host', host)
          .expect(200)
          .expect(greeting);
      });
    });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/interceptors.spec.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  INestApplication,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { Test } from '@nestjs/testing';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';

@Injectable()
export class OverrideInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    return of(RETURN_VALUE);
  }
}

@Injectable()
export class TransformInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    return next.handle().pipe(map(data => ({ data })));
  }
}

@Injectable()
export class StatusInterceptor {
  constructor(private readonly statusCode: number) {}

  intercept(context: ExecutionContext, next: CallHandler) {
    const ctx = context.switchToHttp();
    const res = ctx.getResponse();
    res.status(this.statusCode);
    return next.handle().pipe(map(data => ({ data })));
  }
}

@Injectable()
export class HeaderInterceptor {
  constructor(private readonly headers: object) {}

  intercept(context: ExecutionContext, next: CallHandler) {
    const ctx = context.switchToHttp();
    const res = ctx.getResponse();
    for (const key in this.headers) {
      if (Object.prototype.hasOwnProperty.call(this.headers, key)) {
        res.header(key, this.headers[key]);
      }
    }
    return next.handle().pipe(map(data => ({ data })));
  }
}

function createTestModule(interceptor) {
  return Test.createTestingModule({
    imports: [AppModule],
    providers: [
      {
        provide: APP_INTERCEPTOR,
        useValue: interceptor,
      },
    ],
  }).compile();
}

describe('Interceptors', () => {
  let app: INestApplication;

  it(`should transform response (sync)`, async () => {
    app = (
      await createTestModule(new OverrideInterceptor())
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer()).get('/hello').expect(200, RETURN_VALUE);
  });

  it(`should map response`, async () => {
    app = (
      await createTestModule(new TransformInterceptor())
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer())
      .get('/hello')
      .expect(200, { data: 'Hello world!' });
  });

  it(`should map response (async)`, async () => {
    app = (
      await createTestModule(new TransformInterceptor())
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer())
      .get('/hello/stream')
      .expect(200, { data: 'Hello world!' });
  });

  it(`should map response (stream)`, async () => {
    app = (
      await createTestModule(new TransformInterceptor())
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer())
      .get('/hello/async')
      .expect(200, { data: 'Hello world!' });
  });

  it(`should modify response status`, async () => {
    app = (
      await createTestModule(new StatusInterceptor(400))
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer())
      .get('/hello')
      .expect(400, { data: 'Hello world!' });
  });

  it(`should modify Authorization header`, async () => {
    const customHeaders = {
      Authorization: 'jwt',
    };

    app = (
      await createTestModule(new HeaderInterceptor(customHeaders))
    ).createNestApplication();

    await app.init();
    return request(app.getHttpServer())
      .get('/hello')
      .expect(200)
      .expect('Authorization', 'jwt');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/local-pipes.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Hello world (default adapter)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`host=example.com should execute locally injected pipe by HelloController`, () => {
    return request(server).get('/hello/local-pipe/1').expect(200).expect({
      id: '1',
    });
  });

  it(`host=host.example.com should execute locally injected pipe by HostController`, () => {
    return request(server)
      .get('/host/local-pipe/1')
      .set('Host', 'acme.example.com')
      .expect(200)
      .expect({
        id: '1',
        host: true,
        tenant: 'acme',
      });
  });

  it(`should return 404 for mismatched host`, () => {
    return request(server).get('/host/local-pipe/1').expect(404).expect({
      error: 'Not Found',
      message: 'Cannot GET /host/local-pipe/1',
      statusCode: 404,
    });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/middleware-class.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  Injectable,
  MiddlewareConsumer,
  Module,
  RequestMethod,
} from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { Response } from 'express';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const INCLUDED_VALUE = 'test_included';
const RETURN_VALUE = 'test';
const WILDCARD_VALUE = 'test_wildcard';

@Injectable()
class Middleware {
  use(req, res, next) {
    res.send(WILDCARD_VALUE);
  }
}

@Controller()
class TestController {
  @Get('test')
  test() {
    return RETURN_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res: Response, next) => res.status(201).end(INCLUDED_VALUE))
      .forRoutes({ path: 'tests/included', method: RequestMethod.POST })
      .apply(Middleware)
      .forRoutes('*');
  }
}

describe('Middleware (class)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = (
      await Test.createTestingModule({
        imports: [TestModule],
      }).compile()
    ).createNestApplication();

    await app.init();
  });

  it(`forRoutes(*)`, () => {
    return request(app.getHttpServer())
      .get('/hello')
      .expect(200, WILDCARD_VALUE);
  });

  it(`/test forRoutes(*)`, () => {
    return request(app.getHttpServer())
      .get('/test')
      .expect(200, WILDCARD_VALUE);
  });

  it(`GET forRoutes(POST tests/included)`, () => {
    return request(app.getHttpServer())
      .get('/tests/included')
      .expect(200, WILDCARD_VALUE);
  });

  it(`POST forRoutes(POST tests/included)`, () => {
    return request(app.getHttpServer())
      .post('/tests/included')
      .expect(201, INCLUDED_VALUE);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/middleware-execute-order.spec.ts
================================================
import {
  Global,
  INestApplication,
  MiddlewareConsumer,
  Module,
} from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';

const RETURN_VALUE_A = 'test_A';
const RETURN_VALUE_B = 'test_B';
const RETURN_VALUE_X = 'test_X';
const RETURN_VALUE_GLOBAL = 'test_GLOBAL';

@Global()
@Module({})
class GlobalModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(RETURN_VALUE_GLOBAL))
      .forRoutes('ping');
  }
}

@Global()
@Module({})
class GlobalModule2 {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(RETURN_VALUE_GLOBAL + '2'))
      .forRoutes('ping');
  }
}

@Module({ imports: [GlobalModule, GlobalModule2] })
class ModuleX {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(RETURN_VALUE_X))
      .forRoutes('hello')
      .apply((req, res, next) => res.send(RETURN_VALUE_X))
      .forRoutes('ping');
  }
}

@Module({ imports: [ModuleX] })
class ModuleA {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(RETURN_VALUE_A))
      .forRoutes('hello')
      .apply((req, res, next) => res.send(RETURN_VALUE_A))
      .forRoutes('ping');
  }
}

@Module({
  imports: [ModuleA],
})
class ModuleB {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(RETURN_VALUE_B))
      .forRoutes('hello')
      .apply((req, res, next) => res.send(RETURN_VALUE_B))
      .forRoutes('ping');
  }
}

@Module({
  imports: [ModuleB],
})
class TestModule {}

describe('Middleware (execution order)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = (
      await Test.createTestingModule({
        imports: [TestModule],
      }).compile()
    ).createNestApplication();

    await app.init();
  });

  it(`should execute middleware in topological order`, () => {
    return request(app.getHttpServer())
      .get('/hello')
      .expect(200, RETURN_VALUE_B);
  });

  it('should execute global middleware first', () => {
    return request(app.getHttpServer())
      .get('/ping')
      .expect(200, RETURN_VALUE_GLOBAL);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/middleware-fastify.spec.ts
================================================
import {
  Controller,
  Get,
  MiddlewareConsumer,
  Module,
  NestMiddleware,
  NestModule,
  Param,
  Query,
  Req,
  RequestMethod,
} from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { FastifyRequest } from 'fastify';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Middleware (FastifyAdapter)', () => {
  let app: NestFastifyApplication;

  describe('should return expected values depending on the route', () => {
    const INCLUDED_VALUE = 'test_included';
    const QUERY_VALUE = 'test_query';
    const REQ_URL_VALUE = 'test_req_url';
    const RETURN_VALUE = 'test';
    const SCOPED_VALUE = 'test_scoped';
    const WILDCARD_VALUE = 'test_wildcard';

    @Controller()
    class TestController {
      @Get('express_style_wildcard/wildcard_nested')
      express_style_wildcard() {
        return RETURN_VALUE;
      }

      @Get('legacy_style_wildcard/wildcard_nested')
      legacy_style_wildcard() {
        return RETURN_VALUE;
      }

      @Get('test')
      test() {
        return RETURN_VALUE;
      }

      @Get('query')
      query() {
        return RETURN_VALUE;
      }

      @Get('tests/wildcard_nested')
      wildcard_nested() {
        return RETURN_VALUE;
      }

      @Get('tests/included')
      included() {
        return RETURN_VALUE;
      }
    }

    @Controller(QUERY_VALUE)
    class TestQueryController {
      @Get()
      [QUERY_VALUE](@Query('test') test: string) {
        return test;
      }
    }

    @Module({
      imports: [AppModule],
      controllers: [TestController, TestQueryController],
    })
    class TestModule {
      configure(consumer: MiddlewareConsumer) {
        consumer
          .apply((req, res, next) => res.end(INCLUDED_VALUE))
          .forRoutes({ path: 'tests/included', method: RequestMethod.POST })
          .apply((req, res, next) => res.end(REQ_URL_VALUE))
          .forRoutes('req/url/*')
          .apply((req, res, next) => res.end(WILDCARD_VALUE))
          .forRoutes(
            'express_style_wildcard/*',
            'tests/*path',
            'legacy_style_wildcard/(.*)',
          )
          .apply((req, res, next) => res.end(QUERY_VALUE))
          .forRoutes('query')
          .apply((req, res, next) => next())
          .forRoutes(TestQueryController)
          .apply((req, res, next) => res.end(SCOPED_VALUE))
          .forRoutes(TestController)
          .apply((req, res, next) => res.end(RETURN_VALUE))
          .exclude({ path: QUERY_VALUE, method: -1 as any })
          .forRoutes('*');
      }
    }

    beforeEach(async () => {
      app = (
        await Test.createTestingModule({
          imports: [TestModule],
        }).compile()
      ).createNestApplication<NestFastifyApplication>(new FastifyAdapter());

      await app.init();
    });

    it(`forRoutes(*)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/hello',
        })
        .then(({ payload }) => expect(payload).to.be.eql(RETURN_VALUE));
    });

    it(`forRoutes(TestController)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/test',
        })
        .then(({ payload }) => expect(payload).to.be.eql(SCOPED_VALUE));
    });

    it(`query?test=${QUERY_VALUE} forRoutes(query)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/query',
          query: {
            test: QUERY_VALUE,
          },
        })
        .then(({ payload }) => expect(payload).to.be.eql(QUERY_VALUE));
    });

    it(`${QUERY_VALUE}?test=${QUERY_VALUE} forRoutes(${QUERY_VALUE})`, () => {
      return app
        .inject({
          method: 'GET',
          url: QUERY_VALUE,
          query: {
            test: QUERY_VALUE,
          },
        })
        .then(({ payload }) => expect(payload).to.be.eql(QUERY_VALUE));
    });

    it(`forRoutes(tests/*path)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/tests/wildcard_nested',
        })
        .then(({ payload }) => expect(payload).to.be.eql(WILDCARD_VALUE));
    });

    it(`forRoutes(express_style_wildcard/*)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/express_style_wildcard/wildcard_nested',
        })
        .then(({ payload }) => expect(payload).to.be.eql(WILDCARD_VALUE));
    });

    it(`forRoutes(legacy_style_wildcard/*)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/legacy_style_wildcard/wildcard_nested',
        })
        .then(({ payload }) => expect(payload).to.be.eql(WILDCARD_VALUE));
    });

    it(`forRoutes(req/url/)`, () => {
      const reqUrl = '/test';
      return app
        .inject({
          method: 'GET',
          url: `/req/url${reqUrl}`,
        })
        .then(({ payload }) => expect(payload).to.be.eql(REQ_URL_VALUE));
    });

    it(`GET forRoutes(POST tests/included)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/tests/included',
        })
        .then(({ payload }) => expect(payload).to.be.eql(WILDCARD_VALUE));
    });

    it(`POST forRoutes(POST tests/included)`, () => {
      return app
        .inject({
          method: 'POST',
          url: '/tests/included',
        })
        .then(({ payload }) => expect(payload).to.be.eql(INCLUDED_VALUE));
    });

    afterEach(async () => {
      await app.close();
    });
  });

  describe('should execute middleware only once for given routes', () => {
    class Middleware implements NestMiddleware {
      use(request: any, reply: any, next: () => void) {
        if (request.middlewareExecutionCount === undefined) {
          request.middlewareExecutionCount = 1;
        } else {
          request.middlewareExecutionCount++;
        }
        next();
      }
    }

    @Controller()
    class AbcController {
      @Get('/a')
      async a(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      @Get('/a/b')
      async ab(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      @Get('/a/b/c')
      async abc(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      @Get('/similar')
      async withSimilar(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      @Get('/similar/test')
      async withSimilarTest(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      @Get('/similar/:id')
      async withSimilarId(@Req() request: any) {
        return this.validateExecutionCount({
          request,
          expected: 1,
        });
      }

      private validateExecutionCount({
        request,
        expected,
      }: {
        request: any;
        expected: number;
      }) {
        let actual: number | undefined;
        actual = request.raw.middlewareExecutionCount;
        actual ??= 0;

        return {
          success: actual === expected,
          actual,
          expected,
        };
      }
    }

    @Module({
      controllers: [AbcController],
    })
    class TestModule implements NestModule {
      configure(consumer: MiddlewareConsumer) {
        consumer.apply(Middleware).forRoutes(AbcController);
      }
    }

    beforeEach(async () => {
      app = (
        await Test.createTestingModule({
          imports: [TestModule],
        }).compile()
      ).createNestApplication<NestFastifyApplication>(new FastifyAdapter());

      await app.init();
    });

    it(`GET forRoutes(/a/b/c)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/a/b/c',
        })
        .then(({ payload }) => {
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          );
        });
    });

    it(`GET forRoutes(/a/b)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/a/b',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          ),
        );
    });

    it(`GET forRoutes(/a)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/a',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          ),
        );
    });

    it(`GET forRoutes(/similar)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/similar',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          ),
        );
    });

    it(`GET forRoutes(/similar/test)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/similar/test',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          ),
        );
    });

    it(`GET forRoutes(/similar/arbitrary)`, () => {
      return app
        .inject({
          method: 'GET',
          url: '/similar/arbitrary',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              actual: 1,
              expected: 1,
            }),
          ),
        );
    });

    afterEach(async () => {
      await app.close();
    });
  });

  describe('should have data attached in middleware', () => {
    @Controller()
    class DataController {
      @Get('data')
      async data(@Req() req: FastifyRequest['raw']) {
        return {
          success: true,
          extras: req?.['raw']?.extras,
          pong: req?.['raw']?.headers?.ping,
        };
      }
      @Get('pong')
      async pong(@Req() req: FastifyRequest['raw']) {
        return { success: true, pong: req?.['raw']?.headers?.ping };
      }

      @Get('')
      async rootPath(@Req() req: FastifyRequest['raw']) {
        return { success: true, root: true };
      }

      @Get('record/:id')
      async record(@Req() req: FastifyRequest['raw'], @Param('id') id: string) {
        return { success: true, record: id };
      }
    }

    @Module({
      controllers: [DataController],
    })
    class DataModule implements NestModule {
      configure(consumer: MiddlewareConsumer) {
        consumer
          .apply((req, res, next) => {
            req.extras = { data: 'Data attached in middleware' };
            req.headers['ping'] = 'pong';

            // When global prefix is set and the route is the root path
            if (req.originalUrl === '/api') {
              return res.end(JSON.stringify({ success: true, pong: 'pong' }));
            }
            next();
          })
          .forRoutes('{*path}');
      }
    }

    beforeEach(async () => {
      app = (
        await Test.createTestingModule({
          imports: [DataModule],
        }).compile()
      ).createNestApplication<NestFastifyApplication>(new FastifyAdapter());
    });

    it(`GET forRoutes('{*path}') with global prefix (route: /api/pong)`, async () => {
      app.setGlobalPrefix('/api');
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
      return app
        .inject({
          method: 'GET',
          url: '/api/pong',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              pong: 'pong',
            }),
          ),
        );
    });

    it(`GET forRoutes('{*path}') with global prefix (route: /api)`, async () => {
      app.setGlobalPrefix('/api');
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
      return app
        .inject({
          method: 'GET',
          url: '/api',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              pong: 'pong',
            }),
          ),
        );
    });

    it(`GET forRoutes('{*path}') without prefix config`, async () => {
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
      return app
        .inject({
          method: 'GET',
          url: '/pong',
        })
        .then(({ payload }) =>
          expect(payload).to.be.eql(
            JSON.stringify({
              success: true,
              pong: 'pong',
            }),
          ),
        );
    });

    it(`GET forRoutes('{*path}') with global prefix and exclude patterns`, async () => {
      app.setGlobalPrefix('/api', { exclude: ['/'] });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();

      await request(app.getHttpServer())
        .get('/')
        .expect(200, { success: true, root: true });
    });

    it(`GET forRoutes('{*path}') with global prefix and exclude pattern with wildcard`, async () => {
      app.setGlobalPrefix('/api', { exclude: ['/record/{*path}'] });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();

      await request(app.getHttpServer())
        .get('/api/pong')
        .expect(200, { success: true, pong: 'pong' });
      await request(app.getHttpServer())
        .get('/record/abc123')
        .expect(200, { success: true, record: 'abc123' });
    });

    it(`GET forRoutes('{*path}') with global prefix and exclude pattern with parameter`, async () => {
      app.setGlobalPrefix('/api', { exclude: ['/record/:id'] });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();

      await request(app.getHttpServer())
        .get('/record/abc123')
        .expect(200, { success: true, record: 'abc123' });
      await request(app.getHttpServer())
        .get('/api/pong')
        .expect(200, { success: true, pong: 'pong' });
    });

    it(`GET forRoutes('{*path}') with global prefix and global prefix options`, async () => {
      app.setGlobalPrefix('/api', { exclude: ['/'] });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();

      await request(app.getHttpServer())
        .get('/api/data')
        .expect(200, {
          success: true,
          extras: { data: 'Data attached in middleware' },
          pong: 'pong',
        });
      await request(app.getHttpServer())
        .get('/')
        .expect(200, { success: true, root: true });
    });

    it(`GET forRoutes('{*path}') with global prefix that not starts with /`, async () => {
      app.setGlobalPrefix('api');
      await app.init();
      await app.getHttpAdapter().getInstance().ready();

      await request(app.getHttpServer())
        .get('/api/data')
        .expect(200, {
          success: true,
          extras: { data: 'Data attached in middleware' },
          pong: 'pong',
        });
      await request(app.getHttpServer()).get('/').expect(404);
    });

    afterEach(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/hello-world/e2e/middleware-run-match-route.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  Injectable,
  MiddlewareConsumer,
  NestMiddleware,
  Module,
} from '@nestjs/common';
import { Test } from '../../../packages/testing';
import * as request from 'supertest';
import { expect } from 'chai';

/**
 * Number of times that the middleware was executed.
 */
let triggerCounter = 0;
@Injectable()
class Middleware implements NestMiddleware {
  use(req, res, next) {
    triggerCounter++;
    next();
  }
}

@Controller()
class TestController {
  @Get('/test')
  testA() {}

  @Get('/:id')
  testB() {}

  @Get('/static/route')
  testC() {}

  @Get('/:id/:nested')
  testD() {}
}

@Module({
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(Middleware).forRoutes(TestController);
  }
}

describe('Middleware (run on route match)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    triggerCounter = 0;
    app = (
      await Test.createTestingModule({
        imports: [TestModule],
      }).compile()
    ).createNestApplication();

    await app.init();
  });

  it(`forRoutes(TestController) should execute middleware once when request url is equal match`, () => {
    return request(app.getHttpServer())
      .get('/test')
      .expect(200)
      .then(() => {
        expect(triggerCounter).to.be.eq(1);
      });
  });

  it(`forRoutes(TestController) should execute middleware once when request url is not equal match`, () => {
    return request(app.getHttpServer())
      .get('/1')
      .expect(200)
      .then(() => {
        expect(triggerCounter).to.be.eq(1);
      });
  });

  it(`forRoutes(TestController) should execute middleware once when request url is not of nested params`, () => {
    return request(app.getHttpServer())
      .get('/static/route')
      .expect(200)
      .then(() => {
        expect(triggerCounter).to.be.eq(1);
      });
  });

  it(`forRoutes(TestController) should execute middleware once when request url is of nested params`, () => {
    return request(app.getHttpServer())
      .get('/1/abc')
      .expect(200)
      .then(() => {
        expect(triggerCounter).to.be.eq(1);
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/middleware-with-versioning.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  MiddlewareConsumer,
  Module,
  RequestMethod,
  Version,
  VersioningOptions,
  VersioningType,
  VERSION_NEUTRAL,
} from '@nestjs/common';
import { CustomVersioningOptions } from '@nestjs/common/interfaces';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';
const VERSIONED_VALUE = 'test_versioned';

@Controller()
class TestController {
  @Version('1')
  @Get('versioned')
  versionedTest() {
    return RETURN_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(VERSIONED_VALUE))
      .forRoutes({
        path: '/versioned',
        version: '1',
        method: RequestMethod.ALL,
      });
  }
}

describe('Middleware', () => {
  let app: INestApplication;

  describe('when using default URI versioning', () => {
    beforeEach(async () => {
      app = await createAppWithVersioning({
        type: VersioningType.URI,
        defaultVersion: VERSION_NEUTRAL,
      });
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/v1/versioned')
        .expect(200, VERSIONED_VALUE);
    });
  });

  describe('when default URI versioning with an alternative prefix', () => {
    beforeEach(async () => {
      app = await createAppWithVersioning({
        type: VersioningType.URI,
        defaultVersion: VERSION_NEUTRAL,
        prefix: 'version',
      });
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/version1/versioned')
        .expect(200, VERSIONED_VALUE);
    });
  });

  describe('when using default URI versioning with the global prefix', () => {
    beforeEach(async () => {
      app = await createAppWithVersioning(
        {
          type: VersioningType.URI,
          defaultVersion: VERSION_NEUTRAL,
        },
        async (app: INestApplication) => {
          app.setGlobalPrefix('api');
        },
      );
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/api/v1/versioned')
        .expect(200, VERSIONED_VALUE);
    });
  });

  describe('when using HEADER versioning', () => {
    beforeEach(async () => {
      app = await createAppWithVersioning({
        type: VersioningType.HEADER,
        header: 'version',
      });
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/versioned')
        .set('version', '1')
        .expect(200, VERSIONED_VALUE);
    });
  });

  describe('when using MEDIA TYPE versioning', () => {
    beforeEach(async () => {
      app = await createAppWithVersioning({
        type: VersioningType.MEDIA_TYPE,
        key: 'v',
        defaultVersion: VERSION_NEUTRAL,
      });
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/versioned')
        .expect(200, VERSIONED_VALUE);
    });
  });

  describe('when using CUSTOM TYPE versioning', () => {
    beforeEach(async () => {
      const extractor: CustomVersioningOptions['extractor'] = () => '1';

      app = await createAppWithVersioning({
        type: VersioningType.CUSTOM,
        extractor,
      });
    });

    it(`forRoutes({ path: '/versioned', version: '1', method: RequestMethod.ALL })`, () => {
      return request(app.getHttpServer())
        .get('/versioned')
        .expect(200, VERSIONED_VALUE);
    });
  });

  afterEach(async () => {
    await app.close();
  });
});

async function createAppWithVersioning(
  versioningOptions: VersioningOptions,
  beforeInit?: (app: INestApplication) => Promise<void>,
): Promise<INestApplication> {
  const app = (
    await Test.createTestingModule({
      imports: [TestModule],
    }).compile()
  ).createNestApplication();

  app.enableVersioning(versioningOptions);
  if (beforeInit) {
    await beforeInit(app);
  }
  await app.init();

  return app;
}



================================================
FILE: integration/hello-world/e2e/middleware.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  MiddlewareConsumer,
  Module,
} from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';
const SCOPED_VALUE = 'test_scoped';
const WILDCARD_VALUE = 'test_wildcard';
const EXCLUDE_VALUE = 'test_exclude';

@Controller()
class TestController {
  @Get('test')
  test() {
    return RETURN_VALUE;
  }

  @Get('tests/wildcard_nested')
  wildcard_nested() {
    return RETURN_VALUE;
  }

  @Get('legacy-wildcard/overview')
  legacyWildcard() {
    return RETURN_VALUE;
  }

  @Get('exclude')
  exclude() {
    return EXCLUDE_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(WILDCARD_VALUE))
      .forRoutes('tests/*path', 'legacy-wildcard/*')
      .apply((req, res, next) => res.send(SCOPED_VALUE))
      .exclude('exclude')
      .forRoutes(TestController)
      .apply((req, res, next) => res.send(RETURN_VALUE))
      .exclude('exclude')
      .forRoutes('*');
  }
}

describe('Middleware', () => {
  let app: INestApplication;

  it(`forRoutes(*)`, async () => {
    app = await createApp();
    await request(app.getHttpServer()).get('/hello').expect(200, RETURN_VALUE);
    await request(app.getHttpServer())
      .get('/exclude')
      .expect(200, EXCLUDE_VALUE);
  });

  it(`forRoutes(*) with global prefix`, async () => {
    app = await createApp(app => app.setGlobalPrefix('api'));
    await request(app.getHttpServer())
      .get('/api/hello')
      .expect(200, RETURN_VALUE);
    await request(app.getHttpServer())
      .get('/api/exclude')
      .expect(200, EXCLUDE_VALUE);
  });

  it(`forRoutes(TestController)`, async () => {
    app = await createApp();
    await request(app.getHttpServer()).get('/test').expect(200, SCOPED_VALUE);
    await request(app.getHttpServer())
      .get('/exclude')
      .expect(200, EXCLUDE_VALUE);
  });

  it(`forRoutes(tests/*)`, async () => {
    app = await createApp();
    return request(app.getHttpServer())
      .get('/tests/wildcard')
      .expect(200, WILDCARD_VALUE);
  });

  it(`forRoutes(legacy-wildcard/*)`, async () => {
    app = await createApp();
    return request(app.getHttpServer())
      .get('/legacy-wildcard/overview')
      .expect(200, WILDCARD_VALUE);
  });

  afterEach(async () => {
    await app.close();
  });
});

async function createApp(
  beforeInit?: (app: INestApplication) => void,
): Promise<INestApplication> {
  const app = (
    await Test.createTestingModule({
      imports: [TestModule],
    }).compile()
  ).createNestApplication();

  if (beforeInit) {
    beforeInit(app);
  }
  await app.init();

  return app;
}



================================================
FILE: integration/hello-world/e2e/router-module-middleware.spec.ts
================================================
import {
  Controller,
  Get,
  INestApplication,
  MiddlewareConsumer,
  Module,
} from '@nestjs/common';
import { RouterModule } from '@nestjs/core';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

const RETURN_VALUE = 'test';
const SCOPED_VALUE = 'test_scoped';

@Controller()
class TestController {
  @Get('test')
  test() {
    return RETURN_VALUE;
  }

  @Get('test2')
  test2() {
    return RETURN_VALUE;
  }
}

@Module({
  imports: [AppModule],
  controllers: [TestController],
})
class TestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.send(SCOPED_VALUE))
      .forRoutes(TestController);
  }
}

describe('RouterModule with Middleware functions', () => {
  let app: INestApplication;

  beforeEach(async () => {
    app = (
      await Test.createTestingModule({
        imports: [
          TestModule,
          RouterModule.register([
            {
              path: '/module-path/',
              module: TestModule,
            },
          ]),
        ],
      }).compile()
    ).createNestApplication();

    await app.init();
  });

  it(`forRoutes(TestController) - /test`, () => {
    return request(app.getHttpServer())
      .get('/module-path/test')
      .expect(200, SCOPED_VALUE);
  });

  it(`forRoutes(TestController) - /test2`, () => {
    return request(app.getHttpServer())
      .get('/module-path/test2')
      .expect(200, SCOPED_VALUE);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/e2e/router-module.spec.ts
================================================
import { Controller, Get, INestApplication, Module } from '@nestjs/common';
import { RouterModule, Routes } from '@nestjs/core';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';

describe('RouterModule', () => {
  let app: INestApplication;

  abstract class BaseController {
    @Get()
    getName() {
      return this.constructor.name;
    }
  }

  @Controller('/parent-controller')
  class ParentController extends BaseController {}
  @Controller('/child-controller')
  class ChildController extends BaseController {}
  @Controller('no-slash-controller')
  class NoSlashController extends BaseController {}

  class UnknownController {}
  @Module({ controllers: [ParentController] })
  class ParentModule {}

  @Module({ controllers: [ChildController] })
  class ChildModule {}

  @Module({})
  class AuthModule {}
  @Module({})
  class PaymentsModule {}

  @Module({ controllers: [NoSlashController] })
  class NoSlashModule {}

  const routes1: Routes = [
    {
      path: 'parent',
      module: ParentModule,
      children: [
        {
          path: 'child',
          module: ChildModule,
        },
      ],
    },
  ];
  const routes2: Routes = [
    { path: 'v1', children: [AuthModule, PaymentsModule, NoSlashModule] },
  ];

  @Module({
    imports: [ParentModule, ChildModule, RouterModule.register(routes1)],
  })
  class MainModule {}

  @Module({
    imports: [
      AuthModule,
      PaymentsModule,
      NoSlashModule,
      RouterModule.register(routes2),
    ],
  })
  class AppModule {}

  before(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [MainModule, AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it('should hit the "ParentController"', async () => {
    return request(app.getHttpServer())
      .get('/parent/parent-controller')
      .expect(200, 'ParentController');
  });

  it('should hit the "ChildController"', async () => {
    return request(app.getHttpServer())
      .get('/parent/child/child-controller')
      .expect(200, 'ChildController');
  });

  it('should hit the "NoSlashController"', async () => {
    return request(app.getHttpServer())
      .get('/v1/no-slash-controller')
      .expect(200, 'NoSlashController');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/hello-world/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelloModule } from './hello/hello.module';
import { HostArrayModule } from './host-array/host-array.module';
import { HostModule } from './host/host.module';

@Module({
  imports: [HelloModule, HostModule, HostArrayModule],
})
export class AppModule {}



================================================
FILE: integration/hello-world/src/errors/errors.controller.ts
================================================
import { BadRequestException, Controller, Get, Header } from '@nestjs/common';

@Controller()
export class ErrorsController {
  @Get('sync')
  synchronous() {
    this.throwError();
  }

  @Get('async')
  async asynchronous() {
    this.throwError();
  }

  @Get('unexpected-error')
  @Header('Content-Type', 'application/pdf')
  unexpectedError() {
    throw new Error();
  }

  throwError() {
    throw new BadRequestException({
      statusCode: 400,
      error: 'Bad Request',
      message: 'Integration test',
    });
  }
}



================================================
FILE: integration/hello-world/src/hello/hello.controller.ts
================================================
import { Controller, Get, Header, Param } from '@nestjs/common';
import { Observable, of } from 'rxjs';
import { HelloService } from './hello.service';
import { UserByIdPipe } from './users/user-by-id.pipe';

@Controller('hello')
export class HelloController {
  constructor(private readonly helloService: HelloService) {}

  @Get()
  @Header('Authorization', 'Bearer')
  greeting(): string {
    return this.helloService.greeting();
  }

  @Get('async')
  async asyncGreeting(): Promise<string> {
    return this.helloService.greeting();
  }

  @Get('stream')
  streamGreeting(): Observable<string> {
    return of(this.helloService.greeting());
  }

  @Get('local-pipe/:id')
  localPipe(
    @Param('id', UserByIdPipe)
    user: any,
  ): any {
    return user;
  }
}



================================================
FILE: integration/hello-world/src/hello/hello.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController],
  providers: [HelloService, UsersService],
})
export class HelloModule {}



================================================
FILE: integration/hello-world/src/hello/hello.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class HelloService {
  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/hello-world/src/hello/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/hello-world/src/hello/users/user-by-id.pipe.ts
================================================
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  constructor(private readonly usersService: UsersService) {}

  transform(value: string, metadata: ArgumentMetadata) {
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/hello-world/src/hello/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/hello-world/src/host/host.controller.ts
================================================
import { Controller, Get, Header, HostParam, Param } from '@nestjs/common';
import { Observable, of } from 'rxjs';
import { HostService } from './host.service';
import { UserByIdPipe } from './users/user-by-id.pipe';

@Controller({
  path: 'host',
  host: ':tenant.example.com',
})
export class HostController {
  constructor(private readonly hostService: HostService) {}

  @Get()
  @Header('Authorization', 'Bearer')
  greeting(@HostParam('tenant') tenant: string): string {
    return `${this.hostService.greeting()} tenant=${tenant}`;
  }

  @Get('async')
  async asyncGreeting(@HostParam('tenant') tenant: string): Promise<string> {
    return `${this.hostService.greeting()} tenant=${tenant}`;
  }

  @Get('stream')
  streamGreeting(@HostParam('tenant') tenant: string): Observable<string> {
    return of(`${this.hostService.greeting()} tenant=${tenant}`);
  }

  @Get('local-pipe/:id')
  localPipe(
    @Param('id', UserByIdPipe)
    user: any,
    @HostParam('tenant') tenant: string,
  ): any {
    return { ...user, tenant };
  }
}



================================================
FILE: integration/hello-world/src/host/host.module.ts
================================================
import { Module } from '@nestjs/common';
import { HostController } from './host.controller';
import { HostService } from './host.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HostController],
  providers: [HostService, UsersService],
})
export class HostModule {}



================================================
FILE: integration/hello-world/src/host/host.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class HostService {
  greeting(): string {
    return 'Host Greeting!';
  }
}



================================================
FILE: integration/hello-world/src/host/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/hello-world/src/host/users/user-by-id.pipe.ts
================================================
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  constructor(private readonly usersService: UsersService) {}

  transform(value: string, metadata: ArgumentMetadata) {
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/hello-world/src/host/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  findById(id: string) {
    return { id, host: true };
  }
}



================================================
FILE: integration/hello-world/src/host-array/host-array.controller.ts
================================================
import { Controller, Get, Header, HostParam, Param } from '@nestjs/common';
import { Observable, of } from 'rxjs';
import { HostArrayService } from './host-array.service';
import { UserByIdPipe } from './users/user-by-id.pipe';

@Controller({
  path: 'host-array',
  host: [':tenant.example1.com', ':tenant.example2.com'],
})
export class HostArrayController {
  constructor(private readonly hostService: HostArrayService) {}

  @Get()
  @Header('Authorization', 'Bearer')
  greeting(@HostParam('tenant') tenant: string): string {
    return `${this.hostService.greeting()} tenant=${tenant}`;
  }

  @Get('async')
  async asyncGreeting(@HostParam('tenant') tenant: string): Promise<string> {
    return `${this.hostService.greeting()} tenant=${tenant}`;
  }

  @Get('stream')
  streamGreeting(@HostParam('tenant') tenant: string): Observable<string> {
    return of(`${this.hostService.greeting()} tenant=${tenant}`);
  }

  @Get('local-pipe/:id')
  localPipe(
    @Param('id', UserByIdPipe)
    user: any,
    @HostParam('tenant') tenant: string,
  ): any {
    return { ...user, tenant };
  }
}



================================================
FILE: integration/hello-world/src/host-array/host-array.module.ts
================================================
import { Module } from '@nestjs/common';
import { HostArrayController } from './host-array.controller';
import { HostArrayService } from './host-array.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HostArrayController],
  providers: [HostArrayService, UsersService],
})
export class HostArrayModule {}



================================================
FILE: integration/hello-world/src/host-array/host-array.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class HostArrayService {
  greeting(): string {
    return 'Host Greeting!';
  }
}



================================================
FILE: integration/hello-world/src/host-array/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/hello-world/src/host-array/users/user-by-id.pipe.ts
================================================
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  constructor(private readonly usersService: UsersService) {}

  transform(value: string, metadata: ArgumentMetadata) {
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/hello-world/src/host-array/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  findById(id: string) {
    return { id, host: true };
  }
}



================================================
FILE: integration/hooks/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/hooks/e2e/before-app-shutdown.spec.ts
================================================
import { BeforeApplicationShutdown, Injectable, Module } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as Sinon from 'sinon';

@Injectable()
class TestInjectable implements BeforeApplicationShutdown {
  beforeApplicationShutdown = Sinon.spy();
}

describe('BeforeApplicationShutdown', () => {
  it('should call `beforeApplicationShutdown` when application closes', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.close();
    const instance = module.get(TestInjectable);
    expect(instance.beforeApplicationShutdown.called).to.be.true;
  });

  it('should sort modules by distance (topological sort) - DESC order', async () => {
    @Injectable()
    class BB implements BeforeApplicationShutdown {
      beforeApplicationShutdown = Sinon.spy();
    }

    @Module({
      providers: [BB],
      exports: [BB],
    })
    class B {}

    @Injectable()
    class AA implements BeforeApplicationShutdown {
      constructor(private bb: BB) {}
      beforeApplicationShutdown = Sinon.spy();
    }
    @Module({
      imports: [B],
      providers: [AA],
    })
    class A {}

    const module = await Test.createTestingModule({
      imports: [A],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    await app.close();

    const aa = module.get(AA);
    const bb = module.get(BB);
    Sinon.assert.callOrder(
      aa.beforeApplicationShutdown,
      bb.beforeApplicationShutdown,
    );
  });
});



================================================
FILE: integration/hooks/e2e/enable-shutdown-hook.spec.ts
================================================
import { expect } from 'chai';
import { spawnSync } from 'child_process';
import { join } from 'path';

describe('enableShutdownHooks', () => {
  it('should call the correct hooks if any shutdown signal gets invoked', done => {
    const result = spawnSync('ts-node', [
      join(__dirname, '../src/enable-shutdown-hooks-main.ts'),
      'SIGHUP',
    ]);
    const calls = result.stdout
      .toString()
      .split('\n')
      .map((call: string) => call.trim());
    expect(calls[0]).to.equal('beforeApplicationShutdown SIGHUP');
    expect(calls[1]).to.equal('onApplicationShutdown SIGHUP');
    done();
  }).timeout(10000);

  it('should call the correct hooks if a specific shutdown signal gets invoked', done => {
    const result = spawnSync('ts-node', [
      join(__dirname, '../src/enable-shutdown-hooks-main.ts'),
      'SIGINT',
      'SIGINT',
    ]);
    const calls = result.stdout
      .toString()
      .split('\n')
      .map((call: string) => call.trim());
    expect(calls[0]).to.equal('beforeApplicationShutdown SIGINT');
    expect(calls[1]).to.equal('onApplicationShutdown SIGINT');
    done();
  }).timeout(10000);

  it('should ignore system signals which are not specified', done => {
    const result = spawnSync('ts-node', [
      join(__dirname, '../src/enable-shutdown-hooks-main.ts'),
      'SIGINT',
      'SIGHUP',
    ]);
    expect(result.stdout.toString().trim()).to.be.eq('');
    done();
  }).timeout(10000);

  it('should ignore system signals if "enableShutdownHooks" was not called', done => {
    const result = spawnSync('ts-node', [
      join(__dirname, '../src/enable-shutdown-hooks-main.ts'),
      'SIGINT',
      'NONE',
    ]);
    expect(result.stdout.toString().trim()).to.be.eq('');
    done();
  }).timeout(10000);
});



================================================
FILE: integration/hooks/e2e/lifecycle-hook-order.spec.ts
================================================
import { Test } from '@nestjs/testing';
import * as Sinon from 'sinon';
import {
  Injectable,
  OnApplicationBootstrap,
  OnApplicationShutdown,
  OnModuleDestroy,
  OnModuleInit,
  BeforeApplicationShutdown,
} from '@nestjs/common';

@Injectable()
class TestInjectable
  implements
    OnApplicationBootstrap,
    OnModuleInit,
    OnModuleDestroy,
    OnApplicationShutdown,
    BeforeApplicationShutdown
{
  onApplicationBootstrap = Sinon.spy();
  beforeApplicationShutdown = Sinon.spy();
  onApplicationShutdown = Sinon.spy();
  onModuleDestroy = Sinon.spy();
  onModuleInit = Sinon.spy();
}

describe('Lifecycle Hook Order', () => {
  it('should call the lifecycle hooks in the correct order', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    await app.close();

    const instance = module.get(TestInjectable);
    Sinon.assert.callOrder(
      instance.onModuleInit,
      instance.onApplicationBootstrap,
      instance.onModuleDestroy,
      instance.beforeApplicationShutdown,
      instance.onApplicationShutdown,
    );
  });
});



================================================
FILE: integration/hooks/e2e/on-app-boostrap.spec.ts
================================================
import { Injectable, Module, OnApplicationBootstrap } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as Sinon from 'sinon';

@Injectable()
class TestInjectable implements OnApplicationBootstrap {
  onApplicationBootstrap = Sinon.spy();
}

describe('OnApplicationBootstrap', () => {
  it('should call onApplicationBootstrap when application starts', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    const instance = module.get(TestInjectable);
    expect(instance.onApplicationBootstrap.called).to.be.true;
  });

  it('should not throw an error when onApplicationBootstrap is null', async () => {
    const module = await Test.createTestingModule({
      providers: [
        { provide: 'TEST', useValue: { onApplicationBootstrap: null } },
      ],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should not throw an error when onApplicationBootstrap is undefined', async () => {
    const module = await Test.createTestingModule({
      providers: [
        { provide: 'TEST', useValue: { onApplicationBootstrap: undefined } },
      ],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should sort modules by distance (topological sort) - DESC order', async () => {
    @Injectable()
    class BB implements OnApplicationBootstrap {
      public field: string;
      async onApplicationBootstrap() {
        this.field = 'b-field';
      }
    }

    @Module({
      providers: [BB],
      exports: [BB],
    })
    class B {}

    @Injectable()
    class AA implements OnApplicationBootstrap {
      public field: string;
      constructor(private bb: BB) {}

      async onApplicationBootstrap() {
        this.field = this.bb.field + '_a-field';
      }
    }
    @Module({
      imports: [B],
      providers: [AA],
    })
    class A {}

    const module = await Test.createTestingModule({
      imports: [A],
    }).compile();

    const app = module.createNestApplication();
    await app.init();

    const instance = module.get(AA);
    expect(instance.field).to.equal('b-field_a-field');
  });
});



================================================
FILE: integration/hooks/e2e/on-app-shutdown.spec.ts
================================================
import { Injectable, Module, OnApplicationShutdown } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as Sinon from 'sinon';

@Injectable()
class TestInjectable implements OnApplicationShutdown {
  onApplicationShutdown = Sinon.spy();
}

describe('OnApplicationShutdown', () => {
  it('should call onApplicationShutdown when application closes', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.close();
    const instance = module.get(TestInjectable);
    expect(instance.onApplicationShutdown.called).to.be.true;
  });

  it('should sort modules by distance (topological sort) - DESC order', async () => {
    @Injectable()
    class BB implements OnApplicationShutdown {
      onApplicationShutdown = Sinon.spy();
    }

    @Module({
      providers: [BB],
      exports: [BB],
    })
    class B {}

    @Injectable()
    class AA implements OnApplicationShutdown {
      constructor(private bb: BB) {}
      onApplicationShutdown = Sinon.spy();
    }
    @Module({
      imports: [B],
      providers: [AA],
    })
    class A {}

    const module = await Test.createTestingModule({
      imports: [A],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    await app.close();

    const aa = module.get(AA);
    const bb = module.get(BB);
    Sinon.assert.callOrder(aa.onApplicationShutdown, bb.onApplicationShutdown);
  });
});



================================================
FILE: integration/hooks/e2e/on-module-destroy.spec.ts
================================================
import { Injectable, Module, OnModuleDestroy } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as Sinon from 'sinon';

@Injectable()
class TestInjectable implements OnModuleDestroy {
  onModuleDestroy = Sinon.spy();
}

describe('OnModuleDestroy', () => {
  it('should call onModuleDestroy when application closes', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.close();
    const instance = module.get(TestInjectable);
    expect(instance.onModuleDestroy.called).to.be.true;
  });

  it('should not throw an error when onModuleDestroy is null', async () => {
    const module = await Test.createTestingModule({
      providers: [{ provide: 'TEST', useValue: { onModuleDestroy: null } }],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should not throw an error when onModuleDestroy is undefined', async () => {
    const module = await Test.createTestingModule({
      providers: [
        { provide: 'TEST', useValue: { onModuleDestroy: undefined } },
      ],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should sort modules by distance (topological sort) - DESC order', async () => {
    @Injectable()
    class BB implements OnModuleDestroy {
      onModuleDestroy = Sinon.spy();
    }

    @Module({
      providers: [BB],
      exports: [BB],
    })
    class B {}

    @Injectable()
    class AA implements OnModuleDestroy {
      constructor(private bb: BB) {}
      onModuleDestroy = Sinon.spy();
    }

    @Module({
      imports: [B],
      providers: [AA],
    })
    class A {}

    const module = await Test.createTestingModule({
      imports: [A],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    await app.close();

    const aa = module.get(AA);
    const bb = module.get(BB);
    Sinon.assert.callOrder(aa.onModuleDestroy, bb.onModuleDestroy);
  });
});



================================================
FILE: integration/hooks/e2e/on-module-init.spec.ts
================================================
import { Injectable, Module, OnModuleInit } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as Sinon from 'sinon';

@Injectable()
class TestInjectable implements OnModuleInit {
  onModuleInit = Sinon.spy();
}

describe('OnModuleInit', () => {
  it('should call onModuleInit when application starts', async () => {
    const module = await Test.createTestingModule({
      providers: [TestInjectable],
    }).compile();

    const app = module.createNestApplication();
    await app.init();
    const instance = module.get(TestInjectable);
    expect(instance.onModuleInit.called).to.be.true;
  });

  it('should not throw an error when onModuleInit is null', async () => {
    const module = await Test.createTestingModule({
      providers: [{ provide: 'TEST', useValue: { onModuleInit: null } }],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should not throw an error when onModuleInit is undefined', async () => {
    const module = await Test.createTestingModule({
      providers: [{ provide: 'TEST', useValue: { onModuleInit: undefined } }],
    }).compile();

    const app = module.createNestApplication();
    await app.init().then(obj => expect(obj).to.not.be.undefined);
  });

  it('should sort modules by distance (topological sort) - DESC order', async () => {
    @Injectable()
    class CC implements OnModuleInit {
      public field: string;

      async onModuleInit() {
        this.field = 'c-field';
      }
    }

    @Module({})
    class C {
      static forRoot() {
        return {
          module: C,
          global: true,
          providers: [
            {
              provide: CC,
              useValue: new CC(),
            },
          ],
          exports: [CC],
        };
      }
    }

    @Injectable()
    class BB implements OnModuleInit {
      public field: string;
      constructor(private cc: CC) {}

      async onModuleInit() {
        this.field = this.cc.field + '_b-field';
      }
    }

    @Module({
      providers: [BB],
      exports: [BB],
    })
    class B {}

    @Injectable()
    class AA implements OnModuleInit {
      public field: string;
      constructor(private bb: BB) {}

      async onModuleInit() {
        this.field = this.bb.field + '_a-field';
      }
    }
    @Module({
      imports: [B],
      providers: [AA],
    })
    class A {}

    @Module({
      imports: [A, C.forRoot()],
    })
    class AppModule {}

    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    const app = module.createNestApplication();
    await app.init();

    const instance = module.get(AA);
    expect(instance.field).to.equal('c-field_b-field_a-field');
  });
});



================================================
FILE: integration/hooks/src/enable-shutdown-hooks-main.ts
================================================
import {
  BeforeApplicationShutdown,
  Injectable,
  Module,
  OnApplicationShutdown,
} from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
const SIGNAL = process.argv[2];
const SIGNAL_TO_LISTEN = process.argv[3];

@Injectable()
class TestInjectable
  implements OnApplicationShutdown, BeforeApplicationShutdown
{
  beforeApplicationShutdown(signal: string) {
    console.log('beforeApplicationShutdown ' + signal);
  }

  onApplicationShutdown(signal: string) {
    console.log('onApplicationShutdown ' + signal);
  }
}

@Module({
  providers: [TestInjectable],
})
class AppModule {}

async function bootstrap() {
  const app = await NestFactory.create(AppModule, { logger: false });

  if (SIGNAL_TO_LISTEN && SIGNAL_TO_LISTEN !== 'NONE') {
    app.enableShutdownHooks([SIGNAL_TO_LISTEN]);
  } else if (SIGNAL_TO_LISTEN !== 'NONE') {
    app.enableShutdownHooks();
  }

  await app.listen(1800);
  process.kill(process.pid, SIGNAL);
}

void bootstrap();



================================================
FILE: integration/injector/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/injector/e2e/circular-custom-providers.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';

import { Controller, Injectable, Module } from '@nestjs/common';

class B {}

@Injectable()
class A {
  constructor(b: B) {}
}

@Injectable()
class BImpl {
  constructor(a: A) {}
}

@Controller()
class AppController {
  constructor(a: A) {}
}

@Module({
  imports: [],
  controllers: [AppController],
  providers: [A, { provide: B, useClass: BImpl }],
})
export class AppModule {}

describe('Circular custom providers', () => {
  it('should throw an exception (useClass + regular provider)', async () => {
    try {
      const builder = Test.createTestingModule({
        imports: [AppModule],
      });
      await builder.compile();

      expect(true).to.be.eql(false);
    } catch (err) {
      expect(err.message).to.be.eql(
        'A circular dependency has been detected inside "A". Please, make sure that each side of a bidirectional relationships are decorated with "forwardRef()". Note that circular relationships between custom providers (e.g., factories) are not supported since functions cannot be called more than once.',
      );
    }
  });

  it('should throw an exception (2 factories)', async () => {
    try {
      const builder = Test.createTestingModule({
        providers: [
          { provide: 'ABC', useFactory: () => ({}), inject: ['DEF'] },
          { provide: 'DEF', useFactory: () => ({}), inject: ['ABC'] },
        ],
      });
      await builder.compile();

      expect(true).to.be.eql(false);
    } catch (err) {
      expect(err.message).to.be.eql(
        'A circular dependency has been detected inside "ABC". Please, make sure that each side of a bidirectional relationships are decorated with "forwardRef()". Note that circular relationships between custom providers (e.g., factories) are not supported since functions cannot be called more than once.',
      );
    }
  });
});



================================================
FILE: integration/injector/e2e/circular-modules.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { CircularModule } from '../src/circular-modules/circular.module';
import { CircularService } from '../src/circular-modules/circular.service';
import { InputModule } from '../src/circular-modules/input.module';
import { InputService } from '../src/circular-modules/input.service';

describe('Circular dependency (modules)', () => {
  it('should resolve circular dependency between providers', async () => {
    const builder = Test.createTestingModule({
      imports: [CircularModule, InputModule],
    });
    const testingModule = await builder.compile();
    const inputService = testingModule.get<InputService>(InputService);
    const circularService = testingModule.get<CircularService>(CircularService);

    expect(inputService.service).to.be.eql(circularService);
    expect(circularService.service).to.be.eql(inputService);
  });
});



================================================
FILE: integration/injector/e2e/circular-property-injection.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { CircularPropertiesModule } from '../src/circular-properties/circular-properties.module';
import { CircularService } from '../src/circular-properties/circular.service';
import { InputPropertiesModule } from '../src/circular-properties/input-properties.module';
import { InputService } from '../src/circular-properties/input.service';

describe('Circular properties dependency (modules)', () => {
  it('should resolve circular dependency between providers', async () => {
    const builder = Test.createTestingModule({
      imports: [CircularPropertiesModule, InputPropertiesModule],
    });
    const testingModule = await builder.compile();
    const inputService = testingModule.get<InputService>(InputService);
    const circularService = testingModule.get<CircularService>(CircularService);

    expect(inputService.service).to.be.eql(circularService);
    expect(circularService.service).to.be.eql(inputService);
  });
});



================================================
FILE: integration/injector/e2e/circular-structure-dynamic-modules.spec.ts
================================================
import { expect } from 'chai';
import { Test } from '@nestjs/testing';
import { CircularModule } from '../src/circular-structure-dynamic-module/circular.module';
import { InputService } from '../src/circular-structure-dynamic-module/input.service';

describe('Circular structure for dynamic modules', () => {
  it('should resolve circular structure with dynamic modules', async () => {
    const builder = Test.createTestingModule({
      imports: [CircularModule.forRoot()],
    });
    const testingModule = await builder.compile();
    const inputService = testingModule.get<InputService>(InputService);

    expect(inputService).to.be.instanceof(InputService);
  });
});



================================================
FILE: integration/injector/e2e/circular.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { CircularModule } from '../src/circular/circular.module';
import { CircularService } from '../src/circular/circular.service';
import { InputService } from '../src/circular/input.service';

describe('Circular dependency', () => {
  it('should resolve circular dependency between providers', async () => {
    const builder = Test.createTestingModule({
      imports: [CircularModule],
    });
    const testingModule = await builder.compile();
    const inputService = testingModule.get<InputService>(InputService);
    const circularService = testingModule.get<CircularService>(CircularService);

    expect(inputService.service).to.be.eql(circularService);
    expect(circularService.service).to.be.eql(inputService);
  });
});



================================================
FILE: integration/injector/e2e/core-injectables.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { CoreInjectablesModule } from '../src/core-injectables/core-injectables.module';
import { ApplicationConfig, ModuleRef } from '@nestjs/core';

describe('Core Injectables', () => {
  let testingModule: TestingModule;

  beforeEach(async () => {
    const builder = Test.createTestingModule({
      imports: [CoreInjectablesModule],
    });
    testingModule = await builder.compile();
  });

  it('should provide ApplicationConfig as core injectable', () => {
    const applicationConfig =
      testingModule.get<ApplicationConfig>(ApplicationConfig);

    applicationConfig.setGlobalPrefix('/api');

    expect(applicationConfig).to.not.be.undefined;
    expect(applicationConfig.getGlobalPrefix()).to.be.eq('/api');
  });

  it('should provide ModuleRef as core injectable', () => {
    const moduleRef = testingModule.get<ModuleRef>(ModuleRef);
    expect(moduleRef).to.not.be.undefined;
  });

  it('should provide the current Module as provider', () => {
    const module = testingModule.get<CoreInjectablesModule>(
      CoreInjectablesModule,
    );
    expect(module).to.not.be.undefined;
    expect(module.constructor.name).to.be.eq('CoreInjectablesModule');
  });
});



================================================
FILE: integration/injector/e2e/default-values.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { DefaultsModule } from '../src/defaults/defaults.module';
import { DefaultsService } from '../src/defaults/defaults.service';

describe('Injector', () => {
  describe('when optional', () => {
    it(`should make use of default assignments`, async () => {
      const builder = Test.createTestingModule({
        imports: [DefaultsModule],
      });
      const app = await builder.compile();
      expect(app.get(DefaultsService).coreService.default).to.be.true;
    });
  });
});



================================================
FILE: integration/injector/e2e/injector.spec.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';
import { UnknownDependenciesException } from '@nestjs/core/errors/exceptions/unknown-dependencies.exception';
import { UnknownExportException } from '@nestjs/core/errors/exceptions/unknown-export.exception';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as chai from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import {
  DYNAMIC_TOKEN,
  DYNAMIC_VALUE,
  NestDynamicModule,
} from '../src/dynamic/dynamic.module';
import { ExportsModule } from '../src/exports/exports.module';
import { InjectModule } from '../src/inject/inject.module';
import { InjectSameNameModule } from '../src/inject/inject-same-name.module';
import {
  SelfInjectionProviderModule,
  SelfInjectionProviderCustomTokenModule,
  SelfInjectionForwardProviderModule,
} from '../src/self-injection/self-injection-provider.module';
chai.use(chaiAsPromised);

describe('Injector', () => {
  describe('when "providers" and "exports" properties are inconsistent', () => {
    it(`should fail with "UnknownExportException"`, async () => {
      try {
        const builder = Test.createTestingModule({
          imports: [ExportsModule],
        });
        await builder.compile();
      } catch (err) {
        expect(err).to.be.instanceof(UnknownExportException);
      }
    });
  });

  describe("When class injects a provider with the same as class's name", () => {
    it('should compile with success', async () => {
      const builder = Test.createTestingModule({
        imports: [InjectSameNameModule],
      });

      await expect(builder.compile()).to.eventually.be.fulfilled;
    });
  });

  describe('when Nest cannot resolve dependencies', () => {
    it(`should fail with "RuntimeException"`, async () => {
      try {
        const builder = Test.createTestingModule({
          imports: [InjectModule],
        });
        await builder.compile();
      } catch (err) {
        expect(err).to.be.instanceof(RuntimeException);
      }
    });

    describe('due to self-injection providers', () => {
      it('should fail with "UnknownDependenciesException" due to self-injection via same class reference', async () => {
        const builder = Test.createTestingModule({
          imports: [SelfInjectionProviderModule],
        });

        await expect(
          builder.compile(),
        ).to.eventually.be.rejected.and.be.an.instanceOf(
          UnknownDependenciesException,
        );
      });
      it('should fail with "UnknownDependenciesException" due to self-injection via forwardRef to the same class reference', async () => {
        const builder = Test.createTestingModule({
          imports: [SelfInjectionForwardProviderModule],
        });

        await expect(
          builder.compile(),
        ).to.eventually.be.rejected.and.be.an.instanceOf(
          UnknownDependenciesException,
        );
      });
      it('should fail with "UnknownDependenciesException" due to self-injection via custom provider', async () => {
        const builder = Test.createTestingModule({
          imports: [SelfInjectionProviderCustomTokenModule],
        });

        await expect(
          builder.compile(),
        ).to.eventually.be.rejected.and.be.an.instanceOf(
          UnknownDependenciesException,
        );
      });
    });
  });

  describe('when dynamic module', () => {
    it(`should return provider via token (exported by object)`, async () => {
      const builder = Test.createTestingModule({
        imports: [NestDynamicModule.byObject()],
      });
      const app = await builder.compile();
      expect(app.get(DYNAMIC_TOKEN)).to.be.eql(DYNAMIC_VALUE);
    });

    it(`should return provider via token (exported by token)`, async () => {
      const builder = Test.createTestingModule({
        imports: [NestDynamicModule.byName()],
      });
      const app = await builder.compile();
      expect(app.get(DYNAMIC_TOKEN)).to.be.eql(DYNAMIC_VALUE);
    });
  });
});



================================================
FILE: integration/injector/e2e/introspection.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { ModuleRef } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { ScopedModule, STATIC_FACTORY } from '../src/scoped/scoped.module';
import { ScopedService } from '../src/scoped/scoped.service';
import { TransientService } from '../src/scoped/transient.service';

describe('Providers introspection', () => {
  let testingModule: TestingModule;
  let moduleRef: ModuleRef;

  beforeEach(async () => {
    testingModule = await Test.createTestingModule({
      imports: [ScopedModule],
    }).compile();
    moduleRef = testingModule.get(ModuleRef);
  });

  it('should properly introspect a transient provider', async () => {
    const introspectionResult = moduleRef.introspect(TransientService);
    expect(introspectionResult.scope).to.be.equal(Scope.TRANSIENT);
  });

  it('should properly introspect a singleton provider', async () => {
    const introspectionResult = moduleRef.introspect(STATIC_FACTORY);
    expect(introspectionResult.scope).to.be.equal(Scope.DEFAULT);
  });

  it('should properly introspect a request-scoped provider', async () => {
    const introspectionResult = moduleRef.introspect(ScopedService);
    expect(introspectionResult.scope).to.be.equal(Scope.REQUEST);
  });
});



================================================
FILE: integration/injector/e2e/multiple-providers.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { MultipleProvidersModule } from '../src/multiple-providers/multiple-providers.module';

describe('Multiple providers under the same token ("each" feature)', () => {
  describe('get()', () => {
    it('should return an array of providers', async () => {
      const builder = Test.createTestingModule({
        imports: [MultipleProvidersModule],
      });
      const testingModule = await builder.compile();

      const multiProviderInstances = testingModule.get<string>(
        'MULTI_PROVIDER',
        {
          each: true,
        },
      );

      // @ts-expect-error: make sure "multiProviderInstances" is string[] not string
      multiProviderInstances.charAt;

      expect(multiProviderInstances).to.be.eql(['A', 'B', 'C']);
    });
  });
  describe('resolve()', () => {
    it('should return an array of providers', async () => {
      const builder = Test.createTestingModule({
        imports: [MultipleProvidersModule],
      });
      const testingModule = await builder.compile();

      const multiProviderInstances = await testingModule.resolve<string>(
        'REQ_SCOPED_MULTI_PROVIDER',
        undefined,
        {
          each: true,
        },
      );

      // @ts-expect-error: make sure "multiProviderInstances" is string[] not string
      multiProviderInstances.charAt;

      expect(multiProviderInstances).to.be.eql(['A', 'B', 'C']);
    });
  });
});



================================================
FILE: integration/injector/e2e/optional-factory-provider-dep.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { UnknownDependenciesException } from '@nestjs/core/errors/exceptions/unknown-dependencies.exception';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';

describe('Optional factory provider deps', () => {
  describe('when dependency is optional', () => {
    describe('and it is available', () => {
      it('then it should be injected into the factory function', async () => {
        const defaultValue = 'DEFAULT_VALUE';
        const moduleRef = await Test.createTestingModule({
          providers: [
            {
              provide: 'FACTORY',
              useFactory: dep => dep ?? defaultValue,
              inject: [{ token: 'MISSING_DEP', optional: true }],
            },
            { provide: 'MISSING_DEP', useValue: 'OPTIONAL_DEP_VALUE' },
          ],
        }).compile();

        const factoryProvider = moduleRef.get('FACTORY');
        expect(factoryProvider).to.equal('OPTIONAL_DEP_VALUE');
      });
    });
    describe('otherwise', () => {
      it('"undefined" should be injected into the factory function', async () => {
        const defaultValue = 'DEFAULT_VALUE';
        const moduleRef = await Test.createTestingModule({
          providers: [
            {
              provide: 'FACTORY',
              useFactory: dep => dep ?? defaultValue,
              inject: [{ token: 'MISSING_DEP', optional: true }],
            },
          ],
        }).compile();

        const factoryProvider = moduleRef.get('FACTORY');
        expect(factoryProvider).to.equal(defaultValue);
      });
      it('"undefined" should be injected into the factory function (scoped provider)', async () => {
        const MY_PROVIDER = 'MY_PROVIDER';
        const FIRST_OPTIONAL_DEPENDENCY = 'FIRST_OPTIONAL_DEPENDENCY';
        const SECOND_OPTIONAL_DEPENDENCY = 'SECOND_OPTIONAL_DEPENDENCY';

        const module = await Test.createTestingModule({
          providers: [
            {
              provide: SECOND_OPTIONAL_DEPENDENCY,
              useValue: 'second',
            },
            {
              provide: MY_PROVIDER,
              scope: Scope.REQUEST,
              inject: [
                {
                  token: FIRST_OPTIONAL_DEPENDENCY,
                  optional: true,
                },
                {
                  token: SECOND_OPTIONAL_DEPENDENCY,
                  optional: true,
                },
              ],
              useFactory: (first?: string, second?: string) => {
                return { first, second };
              },
            },
          ],
        }).compile();

        expect(await module.resolve(MY_PROVIDER)).to.deep.equal({
          first: undefined,
          second: 'second',
        });
      });
    });
  });
  describe('otherwise', () => {
    describe('and dependency is not registered', () => {
      it('should error out', async () => {
        try {
          const builder = Test.createTestingModule({
            providers: [
              {
                provide: 'FACTORY',
                useFactory: () => 'RETURNED_VALUE',
                inject: ['MISSING_DEP'],
              },
            ],
          });
          await builder.compile();
        } catch (err) {
          expect(err).to.be.instanceOf(UnknownDependenciesException);
        }
      });
    });
  });
  describe('and dependency is registered but it cannot be instantiated', () => {
    it('should error out', async () => {
      try {
        const builder = Test.createTestingModule({
          providers: [
            {
              provide: 'POSSIBLY_MISSING_DEP',
              useFactory: () => null,
              inject: ['MISSING_DEP'],
            },
            {
              provide: 'FACTORY',
              useFactory: () => 'RETURNED_VALUE',
              inject: [{ token: 'POSSIBLY_MISSING_DEP', optional: false }],
            },
          ],
        });
        await builder.compile();
      } catch (err) {
        expect(err).to.be.instanceOf(UnknownDependenciesException);
        expect(err.message).to
          .equal(`Nest can't resolve dependencies of the POSSIBLY_MISSING_DEP (?). Please make sure that the argument "MISSING_DEP" at index [0] is available in the RootTestModule context.

Potential solutions:
- Is RootTestModule a valid NestJS module?
- If "MISSING_DEP" is a provider, is it part of the current RootTestModule?
- If "MISSING_DEP" is exported from a separate @Module, is that module imported within RootTestModule?
  @Module({
    imports: [ /* the Module containing "MISSING_DEP" */ ]
  })
`);
      }
    });
  });
});



================================================
FILE: integration/injector/e2e/property-injection.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { DependencyService } from '../src/properties/dependency.service';
import { PropertiesModule } from '../src/properties/properties.module';
import { PropertiesService } from '../src/properties/properties.service';
import { UnknownDependenciesException } from '@nestjs/core/errors/exceptions/unknown-dependencies.exception';

describe('Injector', () => {
  it('should resolve property-based dependencies', async () => {
    const builder = Test.createTestingModule({
      imports: [PropertiesModule],
    });
    const app = await builder.compile();
    const dependency = app.get(DependencyService);

    expect(app.get(PropertiesService).service).to.be.eql(dependency);
    expect(app.get(PropertiesService).token).to.be.true;
    expect(app.get(PropertiesService).symbolToken).to.be.true;
  });

  it('should throw UnknownDependenciesException when dependency is not met', async () => {
    let exception;

    try {
      const builder = Test.createTestingModule({
        providers: [
          DependencyService,
          PropertiesService,
          {
            provide: 'token',
            useValue: true,
          },
          // symbol token is missing here
        ],
      });
      const app = await builder.compile();
      app.get(DependencyService);
    } catch (e) {
      exception = e;
    }

    expect(exception).to.be.instanceOf(UnknownDependenciesException);
  });
});



================================================
FILE: integration/injector/e2e/scoped-instances.spec.ts
================================================
import { createContextId } from '@nestjs/core';
import { InvalidClassScopeException } from '@nestjs/core/errors/exceptions/invalid-class-scope.exception';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { ScopedController } from '../src/scoped/scoped.controller';
import {
  REQUEST_SCOPED_FACTORY,
  ScopedModule,
  STATIC_FACTORY,
  TRANSIENT_SCOPED_FACTORY,
} from '../src/scoped/scoped.module';
import { ScopedService } from '../src/scoped/scoped.service';
import { TransientService } from '../src/scoped/transient.service';
import { Transient3Service } from '../src/scoped/transient3.service';

describe('Scoped Instances', () => {
  let testingModule: TestingModule;

  beforeEach(async () => {
    testingModule = await Test.createTestingModule({
      imports: [ScopedModule],
    }).compile();
  });

  it('should dynamically resolve transient provider', async () => {
    const contextId = createContextId();
    const transient1 = await testingModule.resolve(TransientService, contextId);
    const transient2 = await testingModule.resolve(TransientService, contextId);
    const transientFactory = await testingModule.resolve(
      TRANSIENT_SCOPED_FACTORY,
    );

    expect(transient1).to.be.instanceOf(TransientService);
    expect(transient2).to.be.instanceOf(TransientService);
    expect(transient1).to.be.equal(transient2);
    expect(transientFactory).to.be.true;
  });

  it('should dynamically resolve nested transient provider', async () => {
    const contextId = createContextId();
    const transientTwoDepthLevel = await testingModule.resolve(
      TransientService,
      contextId,
    );
    const transientThreeDepthLevel = await testingModule.resolve(
      Transient3Service,
      contextId,
    );

    expect(transientTwoDepthLevel.svc.logger).to.not.be.undefined;
    expect(transientThreeDepthLevel.svc.svc.logger).to.not.be.undefined;
  });

  it('should dynamically resolve request-scoped provider', async () => {
    const request1 = await testingModule.resolve(ScopedService);
    const request2 = await testingModule.resolve(ScopedService);

    const ctxId = { id: 1 };
    const requestProvider = { host: 'localhost' };
    testingModule.registerRequestByContextId(requestProvider, ctxId);

    const request3 = await testingModule.resolve(ScopedService, ctxId);
    const requestFactory = await testingModule.resolve(REQUEST_SCOPED_FACTORY);

    expect(request1).to.be.instanceOf(ScopedService);
    expect(request2).to.be.instanceOf(ScopedService);
    expect(request3).to.not.be.equal(request2);
    expect(requestFactory).to.be.true;
    expect(request3.request).to.be.equal(requestProvider);
  });

  it('should dynamically resolve request-scoped controller', async () => {
    const request1 = await testingModule.resolve(ScopedController);
    const request2 = await testingModule.resolve(ScopedController);
    const request3 = await testingModule.resolve(ScopedController, { id: 1 });

    expect(request1).to.be.instanceOf(ScopedController);
    expect(request2).to.be.instanceOf(ScopedController);
    expect(request3).to.not.be.equal(request2);
  });

  it('should throw an exception when "get()" method is used for scoped providers', () => {
    try {
      testingModule.get(ScopedController);
    } catch (err) {
      expect(err).to.be.instanceOf(InvalidClassScopeException);
    }
  });

  it('should throw an exception when "resolve()" method is used for static providers', async () => {
    try {
      await testingModule.resolve(STATIC_FACTORY);
    } catch (err) {
      expect(err).to.be.instanceOf(InvalidClassScopeException);
    }
  });
});



================================================
FILE: integration/injector/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { ExportsModule } from './exports/exports.module';

@Module({
  imports: [ExportsModule],
})
export class ApplicationModule {}



================================================
FILE: integration/injector/src/circular/circular.module.ts
================================================
import { Module } from '@nestjs/common';
import { CircularService } from './circular.service';
import { InputService } from './input.service';

@Module({
  providers: [CircularService, InputService],
})
export class CircularModule {}



================================================
FILE: integration/injector/src/circular/circular.service.ts
================================================
import { Injectable, forwardRef, Inject } from '@nestjs/common';
import { InputService } from './input.service';

@Injectable()
export class CircularService {
  constructor(
    @Inject(forwardRef(() => InputService))
    public readonly service: InputService,
  ) {}
}



================================================
FILE: integration/injector/src/circular/input.service.ts
================================================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { CircularService } from './circular.service';

@Injectable()
export class InputService {
  constructor(
    @Inject(forwardRef(() => CircularService))
    public readonly service: CircularService,
  ) {}
}



================================================
FILE: integration/injector/src/circular-modules/circular.module.ts
================================================
import { Module, forwardRef } from '@nestjs/common';
import { CircularService } from './circular.service';
import { InputModule } from './input.module';

@Module({
  imports: [forwardRef(() => InputModule)],
  providers: [CircularService],
  exports: [CircularService],
})
export class CircularModule {}



================================================
FILE: integration/injector/src/circular-modules/circular.service.ts
================================================
import { Injectable, forwardRef, Inject } from '@nestjs/common';
import { InputService } from './input.service';

@Injectable()
export class CircularService {
  constructor(
    @Inject(forwardRef(() => InputService))
    public readonly service: InputService,
  ) {}
}



================================================
FILE: integration/injector/src/circular-modules/input.module.ts
================================================
import { Module, forwardRef } from '@nestjs/common';
import { CircularModule } from './circular.module';
import { InputService } from './input.service';

@Module({
  imports: [forwardRef(() => CircularModule)],
  providers: [InputService],
  exports: [InputService],
})
export class InputModule {}



================================================
FILE: integration/injector/src/circular-modules/input.service.ts
================================================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { CircularService } from './circular.service';

@Injectable()
export class InputService {
  constructor(
    @Inject(forwardRef(() => CircularService))
    public readonly service: CircularService,
  ) {}
}



================================================
FILE: integration/injector/src/circular-properties/circular-properties.module.ts
================================================
import { forwardRef, Module } from '@nestjs/common';
import { CircularService } from './circular.service';
import { InputPropertiesModule } from './input-properties.module';

@Module({
  imports: [forwardRef(() => InputPropertiesModule)],
  providers: [CircularService],
  exports: [CircularService],
})
export class CircularPropertiesModule {}



================================================
FILE: integration/injector/src/circular-properties/circular.service.ts
================================================
import { forwardRef, Inject, Injectable } from '@nestjs/common';
import { InputService } from './input.service';

@Injectable()
export class CircularService {
  @Inject(forwardRef(() => InputService))
  public readonly service: InputService;
}



================================================
FILE: integration/injector/src/circular-properties/input-properties.module.ts
================================================
import { forwardRef, Module } from '@nestjs/common';
import { CircularPropertiesModule } from './circular-properties.module';
import { InputService } from './input.service';

@Module({
  imports: [forwardRef(() => CircularPropertiesModule)],
  providers: [InputService],
  exports: [InputService],
})
export class InputPropertiesModule {}



================================================
FILE: integration/injector/src/circular-properties/input.service.ts
================================================
import { forwardRef, Inject, Injectable } from '@nestjs/common';
import { CircularService } from './circular.service';

@Injectable()
export class InputService {
  @Inject(forwardRef(() => CircularService))
  public readonly service: CircularService;
}



================================================
FILE: integration/injector/src/circular-structure-dynamic-module/circular.module.ts
================================================
import { DynamicModule } from '@nestjs/common';
import { InputService } from './input.service';

export class CircularModule {
  static forRoot(): DynamicModule {
    const a = {
      module: CircularModule,
      providers: [InputService],
      b: null as any,
    };
    a.b = a;
    return a;
  }
}



================================================
FILE: integration/injector/src/circular-structure-dynamic-module/input.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class InputService {}



================================================
FILE: integration/injector/src/core-injectables/core-injectables.module.ts
================================================
import { Module } from '@nestjs/common';

@Module({})
export class CoreInjectablesModule {}



================================================
FILE: integration/injector/src/defaults/core.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class CoreService {}



================================================
FILE: integration/injector/src/defaults/defaults.module.ts
================================================
import { Module } from '@nestjs/common';
import { DefaultsService } from './defaults.service';

@Module({
  providers: [DefaultsService],
})
export class DefaultsModule {}



================================================
FILE: integration/injector/src/defaults/defaults.service.ts
================================================
import { Inject, Injectable, Optional } from '@nestjs/common';
import { CoreService } from './core.service';

@Injectable()
export class DefaultsService {
  constructor(
    @Inject(CoreService)
    @Optional()
    public readonly coreService = { default: true },
  ) {}
}



================================================
FILE: integration/injector/src/dynamic/dynamic.module.ts
================================================
import { Module, DynamicModule } from '@nestjs/common';

export const DYNAMIC_TOKEN = 'DYNAMIC_TOKEN';
export const DYNAMIC_VALUE = {};

export const dynamicProvider = {
  provide: DYNAMIC_TOKEN,
  useValue: DYNAMIC_VALUE,
};

@Module({})
export class NestDynamicModule {
  static byObject(): DynamicModule {
    return {
      module: NestDynamicModule,
      providers: [dynamicProvider],
      exports: [dynamicProvider],
    };
  }

  static byName(): DynamicModule {
    return {
      module: NestDynamicModule,
      providers: [dynamicProvider],
      exports: [DYNAMIC_TOKEN],
    };
  }
}



================================================
FILE: integration/injector/src/exports/exports.module.ts
================================================
import { Module } from '@nestjs/common';
import { ExportsService } from './exports.service';

@Module({
  exports: [ExportsService],
})
export class ExportsModule {}



================================================
FILE: integration/injector/src/exports/exports.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class ExportsService {}



================================================
FILE: integration/injector/src/inject/core.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class CoreService {}



================================================
FILE: integration/injector/src/inject/inject-same-name.module.ts
================================================
import { Module, Injectable, Inject } from '@nestjs/common';

@Injectable()
class CoreService {
  constructor(@Inject(CoreService.name) private readonly coreService: any) {}
}

@Module({
  providers: [
    {
      provide: CoreService.name,
      useValue: 'anything',
    },
  ],
})
export class InjectSameNameModule {}



================================================
FILE: integration/injector/src/inject/inject.module.ts
================================================
import { Module } from '@nestjs/common';
import { InjectService } from './inject.service';

@Module({
  providers: [InjectService],
})
export class InjectModule {}



================================================
FILE: integration/injector/src/inject/inject.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CoreService } from './core.service';

@Injectable()
export class InjectService {
  constructor(private readonly coreService: CoreService) {}
}



================================================
FILE: integration/injector/src/multiple-providers/a.module.ts
================================================
import { Module, Scope } from '@nestjs/common';

@Module({
  providers: [
    {
      provide: 'MULTI_PROVIDER',
      useValue: 'A',
    },
    {
      provide: 'REQ_SCOPED_MULTI_PROVIDER',
      useFactory: () => 'A',
      scope: Scope.REQUEST,
    },
  ],
})
export class AModule {}



================================================
FILE: integration/injector/src/multiple-providers/b.module.ts
================================================
import { Module, Scope } from '@nestjs/common';

@Module({
  providers: [
    {
      provide: 'MULTI_PROVIDER',
      useValue: 'B',
    },
    {
      provide: 'REQ_SCOPED_MULTI_PROVIDER',
      useFactory: () => 'B',
      scope: Scope.REQUEST,
    },
  ],
})
export class BModule {}



================================================
FILE: integration/injector/src/multiple-providers/c.module.ts
================================================
import { Module, Scope } from '@nestjs/common';

@Module({
  providers: [
    {
      provide: 'MULTI_PROVIDER',
      useValue: 'C',
    },
    {
      provide: 'REQ_SCOPED_MULTI_PROVIDER',
      useFactory: () => 'C',
      scope: Scope.REQUEST,
    },
  ],
})
export class CModule {}



================================================
FILE: integration/injector/src/multiple-providers/multiple-providers.module.ts
================================================
import { Module } from '@nestjs/common';
import { AModule } from './a.module';
import { BModule } from './b.module';
import { CModule } from './c.module';

@Module({
  imports: [AModule, BModule, CModule],
})
export class MultipleProvidersModule {}



================================================
FILE: integration/injector/src/properties/dependency.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class DependencyService {}



================================================
FILE: integration/injector/src/properties/properties.module.ts
================================================
import { Module } from '@nestjs/common';
import { DependencyService } from './dependency.service';
import { PropertiesService, SYMBOL_TOKEN } from './properties.service';

@Module({
  providers: [
    DependencyService,
    PropertiesService,
    {
      provide: 'token',
      useValue: true,
    },
    {
      provide: SYMBOL_TOKEN,
      useValue: true,
    },
  ],
})
export class PropertiesModule {}



================================================
FILE: integration/injector/src/properties/properties.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { DependencyService } from './dependency.service';

export const SYMBOL_TOKEN = Symbol('token');

@Injectable()
export class PropertiesService {
  @Inject() service: DependencyService;
  @Inject('token') token: boolean;
  @Inject(SYMBOL_TOKEN) symbolToken: boolean;
}



================================================
FILE: integration/injector/src/scoped/scoped.controller.ts
================================================
import { Controller, Scope } from '@nestjs/common';

@Controller({
  path: 'test',
  scope: Scope.REQUEST,
})
export class ScopedController {}



================================================
FILE: integration/injector/src/scoped/scoped.module.ts
================================================
import { Module, Scope } from '@nestjs/common';
import { ScopedController } from './scoped.controller';
import { ScopedService } from './scoped.service';
import { TransientService } from './transient.service';
import { Transient2Service } from './transient2.service';
import { Transient3Service } from './transient3.service';

export const STATIC_FACTORY = 'STATIC_FACTORY';
export const REQUEST_SCOPED_FACTORY = 'REQUEST_SCOPED_FACTORY';
export const TRANSIENT_SCOPED_FACTORY = 'TRANSIENT_SCOPED_FACTORY';

@Module({
  controllers: [ScopedController],
  providers: [
    ScopedService,
    TransientService,
    Transient2Service,
    Transient3Service,
    {
      provide: STATIC_FACTORY,
      useFactory: () => true,
    },
    {
      provide: REQUEST_SCOPED_FACTORY,
      useFactory: () => true,
      scope: Scope.REQUEST,
    },
    {
      provide: TRANSIENT_SCOPED_FACTORY,
      useFactory: () => true,
      scope: Scope.TRANSIENT,
    },
  ],
})
export class ScopedModule {}



================================================
FILE: integration/injector/src/scoped/scoped.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';

@Injectable({ scope: Scope.REQUEST })
export class ScopedService {
  constructor(@Inject(REQUEST) public readonly request) {}
}



================================================
FILE: integration/injector/src/scoped/transient.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { Transient2Service } from './transient2.service';

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {
  constructor(public readonly svc: Transient2Service) {}
}



================================================
FILE: integration/injector/src/scoped/transient2.service.ts
================================================
import { Injectable, Logger, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class Transient2Service {
  logger = new Logger();
}



================================================
FILE: integration/injector/src/scoped/transient3.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { TransientService } from './transient.service';

@Injectable({ scope: Scope.TRANSIENT })
export class Transient3Service {
  constructor(public readonly svc: TransientService) {}
}



================================================
FILE: integration/injector/src/self-injection/self-injection-provider.module.ts
================================================
import { Module, Injectable, Inject, forwardRef } from '@nestjs/common';

@Injectable()
class ServiceInjectingItself {
  constructor(private readonly coreService: ServiceInjectingItself) {}
}

@Injectable()
class ServiceInjectingItselfForward {
  constructor(
    @Inject(forwardRef(() => ServiceInjectingItself))
    private readonly coreService: ServiceInjectingItself,
  ) {}
}

@Injectable()
class ServiceInjectingItselfViaCustomToken {
  constructor(@Inject('AnotherToken') private readonly coreService: any) {}
}

@Module({
  providers: [ServiceInjectingItself],
})
export class SelfInjectionProviderModule {}

@Module({
  providers: [ServiceInjectingItselfForward],
})
export class SelfInjectionForwardProviderModule {}

@Module({
  providers: [
    ServiceInjectingItselfViaCustomToken,
    {
      provide: 'AnotherToken',
      useClass: ServiceInjectingItselfViaCustomToken,
    },
  ],
})
export class SelfInjectionProviderCustomTokenModule {}



================================================
FILE: integration/inspector/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/inspector/e2e/graph-inspector.spec.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { Injector } from '@nestjs/core/injector/injector';
import { SerializedGraph } from '@nestjs/core/inspector/serialized-graph';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { readFileSync } from 'fs';
import { join } from 'path';
import * as sinon from 'sinon';
import { AppModule } from '../src/app.module';
import { HttpExceptionFilter } from '../src/common/filters/http-exception.filter';
import { TimeoutInterceptor } from '../src/common/interceptors/timeout.interceptor';

describe('Graph inspector', () => {
  let testingModule: TestingModule;

  before(async () => {
    sinon.stub(Injector.prototype as any, 'getNowTimestamp').callsFake(() => 0);

    testingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile({ snapshot: true });
  });

  it('should generate a pre-initialization graph and match snapshot', () => {
    const graph = testingModule.get(SerializedGraph);

    // Update snapshot:
    // writeFileSync(
    //   join(__dirname, 'fixtures', 'pre-init-graph.json'),
    //   graph.toString(),
    // );

    const snapshot = readFileSync(
      join(__dirname, 'fixtures', 'pre-init-graph.json'),
      'utf-8',
    );

    expect(JSON.parse(graph.toString())).to.deep.equal(JSON.parse(snapshot));
  });

  it('should generate a post-initialization graph and match snapshot', async () => {
    const app = testingModule.createNestApplication({ preview: true });
    app.useGlobalPipes(new ValidationPipe());
    app.useGlobalFilters(new HttpExceptionFilter());
    app.useGlobalInterceptors(new TimeoutInterceptor());
    app.enableVersioning();
    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.TCP,
      options: {},
    });
    await app.init();

    const graph = testingModule.get(SerializedGraph);

    // Update snapshot:
    // writeFileSync(
    //   join(__dirname, 'fixtures', 'post-init-graph.json'),
    //   graph.toString(),
    // );

    const snapshot = readFileSync(
      join(__dirname, 'fixtures', 'post-init-graph.json'),
      'utf-8',
    );

    expect(graph.toString()).to.equal(snapshot);
  });
});



================================================
FILE: integration/inspector/e2e/fixtures/post-init-graph.json
================================================
{
  "nodes": {
    "18347652": {
      "id": "18347652",
      "label": "LoggingInterceptor",
      "parent": "2133316171",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "LoggingInterceptor",
        "subtype": "interceptor",
        "initTime": 0
      }
    },
    "55510001": {
      "id": "55510001",
      "label": "UsersService",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "UsersService",
        "initTime": 0
      }
    },
    "91819333": {
      "id": "91819333",
      "label": "ModuleRef",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "203550704": {
      "id": "203550704",
      "label": "ExternalContextCreator",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "ExternalContextCreator",
        "initTime": 0
      }
    },
    "208171089": {
      "id": "208171089",
      "label": "RolesGuard",
      "parent": "1434441974",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "RolesGuard",
        "subtype": "guard",
        "initTime": 0
      }
    },
    "225063248": {
      "id": "225063248",
      "label": "InternalCoreModule",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "InternalCoreModule",
        "initTime": 0
      }
    },
    "256260345": {
      "id": "256260345",
      "label": "ApplicationConfig",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "345516396": {
      "id": "345516396",
      "label": "ApplicationConfig",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "345719894": {
      "id": "345719894",
      "label": "CoreModule",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CoreModule",
        "initTime": 0
      }
    },
    "437945905": {
      "id": "437945905",
      "label": "ApplicationConfig",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "519735830": {
      "id": "519735830",
      "label": "ApplicationConfig",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "521671888": {
      "id": "521671888",
      "label": "DogsModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "555176277": {
      "id": "555176277",
      "label": "InternalCoreModule",
      "metadata": {
        "type": "module",
        "global": true,
        "dynamic": true,
        "internal": true
      }
    },
    "594986539": {
      "id": "594986539",
      "label": "InputService",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "InputService",
        "initTime": 0
      }
    },
    "603011239": {
      "id": "603011239",
      "label": "UsersService",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "UsersService",
        "initTime": 0
      }
    },
    "671882984": {
      "id": "671882984",
      "label": "Reflector",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "Reflector",
        "initTime": 0
      }
    },
    "791004148": {
      "id": "791004148",
      "label": "ExternalSvcModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "867482265": {
      "id": "867482265",
      "label": "Interceptor",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "Interceptor",
        "subtype": "interceptor",
        "initTime": 0
      }
    },
    "927096496": {
      "id": "927096496",
      "label": "ApplicationConfig",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "928565345": {
      "id": "928565345",
      "label": "HelperService",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": true,
        "token": "HelperService",
        "initTime": 0
      }
    },
    "941957564": {
      "id": "941957564",
      "label": "RequestChainModule",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "RequestChainModule",
        "initTime": 0
      }
    },
    "980514911": {
      "id": "980514911",
      "label": "Symbol(token)",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "Symbol(token)"
      }
    },
    "1004276345": {
      "id": "1004276345",
      "label": "Meta",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "META",
        "initTime": 0
      }
    },
    "1010833816": {
      "id": "1010833816",
      "label": "token",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "token"
      }
    },
    "1047229654": {
      "id": "1047229654",
      "label": "CircularModule",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CircularModule",
        "initTime": 0
      }
    },
    "1074192353": {
      "id": "1074192353",
      "label": "ChatService",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ChatService",
        "initTime": 0
      }
    },
    "1120316353": {
      "id": "1120316353",
      "label": "ModuleRef",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1131051184": {
      "id": "1131051184",
      "label": "ChatGateway",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ChatGateway",
        "initTime": 0
      }
    },
    "1142369607": {
      "id": "1142369607",
      "label": "HelperModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1189153544": {
      "id": "1189153544",
      "label": "ChatModule",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ChatModule",
        "initTime": 0
      }
    },
    "1253818496": {
      "id": "1253818496",
      "label": "RootTestModule",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "RootTestModule",
        "initTime": 0
      }
    },
    "1433815174": {
      "id": "1433815174",
      "label": "DogsModule",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DogsModule",
        "initTime": 0
      }
    },
    "1434441974": {
      "id": "1434441974",
      "label": "CatsModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1434456218": {
      "id": "1434456218",
      "label": "Reflector",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": true,
        "token": "Reflector",
        "initTime": 0
      }
    },
    "1472486160": {
      "id": "1472486160",
      "label": "HelloController",
      "parent": "1743739569",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "HelloController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "-2010060263",
            "methodKey": "greeting",
            "subtype": "guard"
          },
          {
            "id": "867482265",
            "methodKey": "greeting",
            "subtype": "interceptor"
          },
          {
            "id": "1893794611",
            "methodKey": "greeting",
            "subtype": "pipe"
          }
        ]
      }
    },
    "1528017428": {
      "id": "1528017428",
      "label": "DatabaseModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1535366709": {
      "id": "1535366709",
      "label": "ApplicationConfig",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "1551182002": {
      "id": "1551182002",
      "label": "ModuleRef",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1616075090": {
      "id": "1616075090",
      "label": "CatsModule",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CatsModule",
        "initTime": 0
      }
    },
    "1634859874": {
      "id": "1634859874",
      "label": "LoggerMiddleware",
      "parent": "-1125887048",
      "metadata": {
        "type": "middleware",
        "internal": false,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "LoggerMiddleware",
        "initTime": 0
      }
    },
    "1743739569": {
      "id": "1743739569",
      "label": "HelloModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": true,
        "internal": false
      }
    },
    "1771940178": {
      "id": "1771940178",
      "label": "ApplicationConfig",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "1809676814": {
      "id": "1809676814",
      "label": "ModuleRef",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1893794611": {
      "id": "1893794611",
      "label": "UserByIdPipe",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "UserByIdPipe",
        "subtype": "pipe",
        "initTime": 0
      }
    },
    "1919157847": {
      "id": "1919157847",
      "label": "REQUEST",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": true,
        "token": "REQUEST",
        "initTime": 0
      }
    },
    "2018972420": {
      "id": "2018972420",
      "label": "TransformInterceptor",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "APP_INTERCEPTOR (UUID: -1146749753)",
        "subtype": "interceptor",
        "initTime": 0,
        "global": true
      }
    },
    "2133316171": {
      "id": "2133316171",
      "label": "RequestChainModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-1486320561": {
      "id": "-1486320561",
      "label": "ModuleRef",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-651043398": {
      "id": "-651043398",
      "label": "ApplicationConfig",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-255469305": {
      "id": "-255469305",
      "label": "INQUIRER",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 1,
        "transient": true,
        "exported": true,
        "token": "INQUIRER",
        "initTime": 0
      }
    },
    "-26938366": {
      "id": "-26938366",
      "label": "ModulesContainer",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "ModulesContainer",
        "initTime": 0
      }
    },
    "-326832201": {
      "id": "-326832201",
      "label": "HttpAdapterHost",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "HttpAdapterHost",
        "initTime": 0
      }
    },
    "-702581189": {
      "id": "-702581189",
      "label": "LazyModuleLoader",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "LazyModuleLoader",
        "initTime": 0
      }
    },
    "-1904419534": {
      "id": "-1904419534",
      "label": "SerializedGraph",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "SerializedGraph",
        "initTime": 0
      }
    },
    "-1251270035": {
      "id": "-1251270035",
      "label": "RootTestModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-969610649": {
      "id": "-969610649",
      "label": "ModuleRef",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-19112576": {
      "id": "-19112576",
      "label": "AppModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2139588960": {
      "id": "-2139588960",
      "label": "AppModule",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "AppModule",
        "initTime": 0
      }
    },
    "-71302842": {
      "id": "-71302842",
      "label": "ModuleRef",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-2064622725": {
      "id": "-2064622725",
      "label": "ApplicationConfig",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-365265483": {
      "id": "-365265483",
      "label": "AppV1Controller",
      "parent": "-19112576",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "AppV1Controller",
        "initTime": 0
      }
    },
    "-774089708": {
      "id": "-774089708",
      "label": "AppV2Controller",
      "parent": "-19112576",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "AppV2Controller",
        "initTime": 0
      }
    },
    "-1125887048": {
      "id": "-1125887048",
      "label": "CoreModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-112192227": {
      "id": "-112192227",
      "label": "ApplicationConfig",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-2007711503": {
      "id": "-2007711503",
      "label": "LoggingInterceptor",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "APP_INTERCEPTOR (UUID: 1780085433)",
        "subtype": "interceptor",
        "initTime": 0,
        "global": true
      }
    },
    "-183456272": {
      "id": "-183456272",
      "label": "ModuleRef",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1846830501": {
      "id": "-1846830501",
      "label": "ApplicationConfig",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-593595711": {
      "id": "-593595711",
      "label": "CatsService",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "CatsService",
        "initTime": 0
      }
    },
    "-1550892030": {
      "id": "-1550892030",
      "label": "CatsController",
      "parent": "1434441974",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "CatsController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "208171089",
            "subtype": "guard"
          },
          {
            "name": "ParseIntPipe",
            "methodKey": "findOne",
            "subtype": "pipe"
          }
        ]
      }
    },
    "-1378706112": {
      "id": "-1378706112",
      "label": "HelloModule",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "HelloModule",
        "initTime": 0
      }
    },
    "-1166465801": {
      "id": "-1166465801",
      "label": "ModuleRef",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1191459348": {
      "id": "-1191459348",
      "label": "ApplicationConfig",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1758187461": {
      "id": "-1758187461",
      "label": "HelloService",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "HelloService",
        "initTime": 0
      }
    },
    "-2010060263": {
      "id": "-2010060263",
      "label": "Guard",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "Guard",
        "subtype": "guard",
        "initTime": 0
      }
    },
    "-1124392646": {
      "id": "-1124392646",
      "label": "DurableModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-522935456": {
      "id": "-522935456",
      "label": "DurableModule",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DurableModule",
        "initTime": 0
      }
    },
    "-1808043520": {
      "id": "-1808043520",
      "label": "ModuleRef",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-57038411": {
      "id": "-57038411",
      "label": "ApplicationConfig",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1673986099": {
      "id": "-1673986099",
      "label": "DurableService",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DurableModule",
        "durable": true,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "DurableService",
        "initTime": 0
      }
    },
    "-848516688": {
      "id": "-848516688",
      "label": "DurableController",
      "parent": "-1124392646",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DurableModule",
        "durable": true,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "DurableController",
        "initTime": 0
      }
    },
    "-1096226358": {
      "id": "-1096226358",
      "label": "ModuleRef",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-335387007": {
      "id": "-335387007",
      "label": "DogsService",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DogsService",
        "initTime": 0
      }
    },
    "-1558907338": {
      "id": "-1558907338",
      "label": "DogsController",
      "parent": "521671888",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DogsController",
        "initTime": 0
      }
    },
    "-2003726489": {
      "id": "-2003726489",
      "label": "UsersModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-495603840": {
      "id": "-495603840",
      "label": "UsersModule",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "UsersModule",
        "initTime": 0
      }
    },
    "-618964563": {
      "id": "-618964563",
      "label": "ModuleRef",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-643958110": {
      "id": "-643958110",
      "label": "ApplicationConfig",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1102473136": {
      "id": "-1102473136",
      "label": "UsersController",
      "parent": "-2003726489",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "UsersController",
        "initTime": 0
      }
    },
    "-1098322034": {
      "id": "-1098322034",
      "label": "DatabaseModule",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DatabaseModule",
        "initTime": 0
      }
    },
    "-616397055": {
      "id": "-616397055",
      "label": "DatabaseService",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DatabaseService",
        "initTime": 0
      }
    },
    "-377928898": {
      "id": "-377928898",
      "label": "DatabaseController",
      "parent": "1528017428",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DatabaseController",
        "initTime": 0
      }
    },
    "-511735264": {
      "id": "-511735264",
      "label": "ExternalSvcModule",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcModule",
        "initTime": 0
      }
    },
    "-660323910": {
      "id": "-660323910",
      "label": "ModuleRef",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-217737489": {
      "id": "-217737489",
      "label": "ApplicationConfig",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1902429503": {
      "id": "-1902429503",
      "label": "ExternalSvcService",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcService",
        "initTime": 0
      }
    },
    "-349899408": {
      "id": "-349899408",
      "label": "ExternalSvcController",
      "parent": "791004148",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcController",
        "initTime": 0
      }
    },
    "-493958991": {
      "id": "-493958991",
      "label": "ChatModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2111857237": {
      "id": "-2111857237",
      "label": "ModuleRef",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-234035039": {
      "id": "-234035039",
      "label": "RequestChainService",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "RequestChainService",
        "initTime": 0
      }
    },
    "-1927427604": {
      "id": "-1927427604",
      "label": "RequestChainController",
      "parent": "2133316171",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "RequestChainController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "18347652",
            "methodKey": "greeting",
            "subtype": "interceptor"
          }
        ]
      }
    },
    "-162987852": {
      "id": "-162987852",
      "label": "HelperModule",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "HelperModule",
        "initTime": 0
      }
    },
    "-1469176692": {
      "id": "-1469176692",
      "label": "PropertiesModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-1501313730": {
      "id": "-1501313730",
      "label": "PropertiesModule",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "PropertiesModule",
        "initTime": 0
      }
    },
    "-1377446394": {
      "id": "-1377446394",
      "label": "ModuleRef",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1494077847": {
      "id": "-1494077847",
      "label": "DependencyService",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DependencyService",
        "initTime": 0
      }
    },
    "-1803759743": {
      "id": "-1803759743",
      "label": "PropertiesService",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "PropertiesService",
        "initTime": 0
      }
    },
    "-1813741655": {
      "id": "-1813741655",
      "label": "InputModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2113121728": {
      "id": "-2113121728",
      "label": "InputModule",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "InputModule",
        "initTime": 0
      }
    },
    "-428979729": {
      "id": "-428979729",
      "label": "ModuleRef",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-453973276": {
      "id": "-453973276",
      "label": "ApplicationConfig",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-369869768": {
      "id": "-369869768",
      "label": "CircularModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-88210382": {
      "id": "-88210382",
      "label": "ModuleRef",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1641626851": {
      "id": "-1641626851",
      "label": "ApplicationConfig",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1721730431": {
      "id": "-1721730431",
      "label": "CircularService",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "CircularService",
        "initTime": 0
      }
    }
  },
  "edges": {
    "22193019": {
      "source": "-19112576",
      "target": "521671888",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DogsModule"
      },
      "id": "22193019"
    },
    "33333764": {
      "source": "791004148",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "ExternalSvcModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "33333764"
    },
    "40501732": {
      "source": "521671888",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DogsModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "40501732"
    },
    "73947303": {
      "source": "-1813741655",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "InputModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "73947303"
    },
    "182501115": {
      "source": "1434441974",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CatsModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "182501115"
    },
    "189694679": {
      "source": "1434456218",
      "target": "671882984",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "InternalCoreModule",
        "sourceClassName": "Reflector",
        "targetClassName": "Reflector",
        "sourceClassToken": "Reflector",
        "targetClassToken": "Reflector",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "189694679"
    },
    "231469845": {
      "source": "-1803759743",
      "target": "-1494077847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "DependencyService",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "DependencyService",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "service",
        "injectionType": "property"
      },
      "id": "231469845"
    },
    "250652665": {
      "source": "2133316171",
      "target": "1142369607",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RequestChainModule",
        "targetModuleName": "HelperModule"
      },
      "id": "250652665"
    },
    "393939926": {
      "source": "-1813741655",
      "target": "-369869768",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "InputModule",
        "targetModuleName": "CircularModule"
      },
      "id": "393939926"
    },
    "417363164": {
      "source": "-1251270035",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RootTestModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "417363164"
    },
    "469401997": {
      "source": "-493958991",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "ChatModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "469401997"
    },
    "654001290": {
      "source": "1472486160",
      "target": "867482265",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "Interceptor",
        "sourceClassToken": "HelloController",
        "targetClassToken": "Interceptor",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "654001290"
    },
    "676175891": {
      "source": "-1251270035",
      "target": "-19112576",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RootTestModule",
        "targetModuleName": "AppModule"
      },
      "id": "676175891"
    },
    "800268760": {
      "source": "-1102473136",
      "target": "603011239",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "UsersModule",
        "sourceClassName": "UsersController",
        "targetClassName": "UsersService",
        "sourceClassToken": "UsersController",
        "targetClassToken": "UsersService",
        "targetModuleName": "UsersModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "800268760"
    },
    "804987620": {
      "source": "-19112576",
      "target": "-1125887048",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "CoreModule"
      },
      "id": "804987620"
    },
    "807697929": {
      "source": "-19112576",
      "target": "1528017428",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DatabaseModule"
      },
      "id": "807697929"
    },
    "966350248": {
      "source": "1131051184",
      "target": "1074192353",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "ChatModule",
        "sourceClassName": "ChatGateway",
        "targetClassName": "ChatService",
        "sourceClassToken": "ChatGateway",
        "targetClassToken": "ChatService",
        "targetModuleName": "ChatModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "966350248"
    },
    "987755577": {
      "source": "-2003726489",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "UsersModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "987755577"
    },
    "1056428433": {
      "source": "-19112576",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1056428433"
    },
    "1059069749": {
      "source": "-1558907338",
      "target": "-335387007",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DogsModule",
        "sourceClassName": "DogsController",
        "targetClassName": "DogsService",
        "sourceClassToken": "DogsController",
        "targetClassToken": "DogsService",
        "targetModuleName": "DogsModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1059069749"
    },
    "1142343545": {
      "source": "-1758187461",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloService",
        "targetClassName": "Meta",
        "sourceClassToken": "HelloService",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1142343545"
    },
    "1178436405": {
      "source": "1893794611",
      "target": "55510001",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "UserByIdPipe",
        "targetClassName": "UsersService",
        "sourceClassToken": "UserByIdPipe",
        "targetClassToken": "UsersService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1178436405"
    },
    "1195474320": {
      "source": "-369869768",
      "target": "-1813741655",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CircularModule",
        "targetModuleName": "InputModule"
      },
      "id": "1195474320"
    },
    "1247743823": {
      "source": "2133316171",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RequestChainModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1247743823"
    },
    "1325313063": {
      "source": "-1927427604",
      "target": "18347652",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainController",
        "targetClassName": "LoggingInterceptor",
        "sourceClassToken": "RequestChainController",
        "targetClassToken": "LoggingInterceptor",
        "targetModuleName": "RequestChainModule",
        "injectionType": "decorator"
      },
      "id": "1325313063"
    },
    "1497653915": {
      "source": "55510001",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "UsersService",
        "targetClassName": "Meta",
        "sourceClassToken": "UsersService",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1497653915"
    },
    "1615322974": {
      "source": "-1469176692",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "PropertiesModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1615322974"
    },
    "1856016815": {
      "source": "-1721730431",
      "target": "594986539",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CircularModule",
        "sourceClassName": "CircularService",
        "targetClassName": "InputService",
        "sourceClassToken": "CircularService",
        "targetClassToken": "InputService",
        "targetModuleName": "InputModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1856016815"
    },
    "1900414743": {
      "source": "1472486160",
      "target": "1893794611",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "UserByIdPipe",
        "sourceClassToken": "HelloController",
        "targetClassToken": "UserByIdPipe",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "1900414743"
    },
    "1904579661": {
      "source": "18347652",
      "target": "928565345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "LoggingInterceptor",
        "targetClassName": "HelperService",
        "sourceClassToken": "LoggingInterceptor",
        "targetClassToken": "HelperService",
        "targetModuleName": "HelperModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1904579661"
    },
    "1960203007": {
      "source": "-1803759743",
      "target": "980514911",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "Symbol(token)",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "Symbol(token)",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "symbolToken",
        "injectionType": "property"
      },
      "id": "1960203007"
    },
    "1976848738": {
      "source": "1528017428",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DatabaseModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1976848738"
    },
    "-2105726668": {
      "source": "-1803759743",
      "target": "1010833816",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "token",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "token",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "token",
        "injectionType": "property"
      },
      "id": "-2105726668"
    },
    "-21463590": {
      "source": "-1378706112",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloModule",
        "targetClassName": "Meta",
        "sourceClassToken": "HelloModule",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-21463590"
    },
    "-1657371464": {
      "source": "-1673986099",
      "target": "1919157847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DurableModule",
        "sourceClassName": "DurableService",
        "targetClassName": "REQUEST",
        "sourceClassToken": "DurableService",
        "targetClassToken": "REQUEST",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-1657371464"
    },
    "-1303681274": {
      "source": "928565345",
      "target": "1919157847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelperModule",
        "sourceClassName": "HelperService",
        "targetClassName": "REQUEST",
        "sourceClassToken": "HelperService",
        "targetClassToken": "REQUEST",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-1303681274"
    },
    "-886102564": {
      "source": "208171089",
      "target": "671882984",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "RolesGuard",
        "targetClassName": "Reflector",
        "sourceClassToken": "RolesGuard",
        "targetClassToken": "Reflector",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-886102564"
    },
    "-2003045613": {
      "source": "-377928898",
      "target": "-616397055",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DatabaseModule",
        "sourceClassName": "DatabaseController",
        "targetClassName": "DatabaseService",
        "sourceClassToken": "DatabaseController",
        "targetClassToken": "DatabaseService",
        "targetModuleName": "DatabaseModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-2003045613"
    },
    "-881420795": {
      "source": "-349899408",
      "target": "-1902429503",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "ExternalSvcModule",
        "sourceClassName": "ExternalSvcController",
        "targetClassName": "ExternalSvcService",
        "sourceClassToken": "ExternalSvcController",
        "targetClassToken": "ExternalSvcService",
        "targetModuleName": "ExternalSvcModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-881420795"
    },
    "-831049991": {
      "source": "594986539",
      "target": "-1721730431",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "InputModule",
        "sourceClassName": "InputService",
        "targetClassName": "CircularService",
        "sourceClassToken": "InputService",
        "targetClassToken": "CircularService",
        "targetModuleName": "CircularModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-831049991"
    },
    "-2146943494": {
      "source": "-234035039",
      "target": "928565345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainService",
        "targetClassName": "HelperService",
        "sourceClassToken": "RequestChainService",
        "targetClassToken": "HelperService",
        "targetModuleName": "HelperModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-2146943494"
    },
    "-1816180282": {
      "source": "-848516688",
      "target": "-1673986099",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DurableModule",
        "sourceClassName": "DurableController",
        "targetClassName": "DurableService",
        "sourceClassToken": "DurableController",
        "targetClassToken": "DurableService",
        "targetModuleName": "DurableModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-1816180282"
    },
    "-180350082": {
      "source": "-1550892030",
      "target": "-593595711",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "CatsController",
        "targetClassName": "CatsService",
        "sourceClassToken": "CatsController",
        "targetClassToken": "CatsService",
        "targetModuleName": "CatsModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-180350082"
    },
    "-1043628608": {
      "source": "1472486160",
      "target": "-1758187461",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "HelloService",
        "sourceClassToken": "HelloController",
        "targetClassToken": "HelloService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-1043628608"
    },
    "-1335121169": {
      "source": "1472486160",
      "target": "55510001",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "UsersService",
        "sourceClassToken": "HelloController",
        "targetClassToken": "UsersService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 1,
        "injectionType": "constructor"
      },
      "id": "-1335121169"
    },
    "-296280311": {
      "source": "-1927427604",
      "target": "-234035039",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainController",
        "targetClassName": "RequestChainService",
        "sourceClassToken": "RequestChainController",
        "targetClassToken": "RequestChainService",
        "targetModuleName": "RequestChainModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-296280311"
    },
    "-393224862": {
      "source": "-19112576",
      "target": "1434441974",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "CatsModule"
      },
      "id": "-393224862"
    },
    "-1675983900": {
      "source": "-19112576",
      "target": "1743739569",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "HelloModule"
      },
      "id": "-1675983900"
    },
    "-678699872": {
      "source": "-19112576",
      "target": "-1124392646",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DurableModule"
      },
      "id": "-678699872"
    },
    "-158970266": {
      "source": "-19112576",
      "target": "-2003726489",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "UsersModule"
      },
      "id": "-158970266"
    },
    "-2086236431": {
      "source": "-19112576",
      "target": "791004148",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "ExternalSvcModule"
      },
      "id": "-2086236431"
    },
    "-192150092": {
      "source": "-19112576",
      "target": "-493958991",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "ChatModule"
      },
      "id": "-192150092"
    },
    "-1609022090": {
      "source": "-19112576",
      "target": "2133316171",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "RequestChainModule"
      },
      "id": "-1609022090"
    },
    "-773455435": {
      "source": "-19112576",
      "target": "-1469176692",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "PropertiesModule"
      },
      "id": "-773455435"
    },
    "-967144236": {
      "source": "-19112576",
      "target": "-1813741655",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "InputModule"
      },
      "id": "-967144236"
    },
    "-528424051": {
      "source": "-1125887048",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CoreModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-528424051"
    },
    "-698929209": {
      "source": "1743739569",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "HelloModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-698929209"
    },
    "-1671708813": {
      "source": "-1124392646",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DurableModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-1671708813"
    },
    "-665042842": {
      "source": "1142369607",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "HelperModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-665042842"
    },
    "-1891610441": {
      "source": "-369869768",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CircularModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-1891610441"
    },
    "-878379437": {
      "source": "-1550892030",
      "target": "208171089",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "CatsController",
        "targetClassName": "RolesGuard",
        "sourceClassToken": "CatsController",
        "targetClassToken": "RolesGuard",
        "targetModuleName": "CatsModule",
        "injectionType": "decorator"
      },
      "id": "-878379437"
    },
    "-822816169": {
      "source": "1472486160",
      "target": "-2010060263",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "Guard",
        "sourceClassToken": "HelloController",
        "targetClassToken": "Guard",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "-822816169"
    }
  },
  "entrypoints": {
    "1131051184": [
      {
        "type": "websocket",
        "methodName": "create",
        "className": "ChatGateway",
        "classNodeId": "1131051184",
        "metadata": {
          "port": 0,
          "key": "createChat",
          "message": "createChat"
        },
        "id": "1131051184_create"
      },
      {
        "type": "websocket",
        "methodName": "findAll",
        "className": "ChatGateway",
        "classNodeId": "1131051184",
        "metadata": {
          "port": 0,
          "key": "findAllChat",
          "message": "findAllChat"
        },
        "id": "1131051184_findAll"
      },
      {
        "type": "websocket",
        "methodName": "findOne",
        "className": "ChatGateway",
        "classNodeId": "1131051184",
        "metadata": {
          "port": 0,
          "key": "findOneChat",
          "message": "findOneChat"
        },
        "id": "1131051184_findOne"
      },
      {
        "type": "websocket",
        "methodName": "update",
        "className": "ChatGateway",
        "classNodeId": "1131051184",
        "metadata": {
          "port": 0,
          "key": "updateChat",
          "message": "updateChat"
        },
        "id": "1131051184_update"
      },
      {
        "type": "websocket",
        "methodName": "remove",
        "className": "ChatGateway",
        "classNodeId": "1131051184",
        "metadata": {
          "port": 0,
          "key": "removeChat",
          "message": "removeChat"
        },
        "id": "1131051184_remove"
      }
    ],
    "1472486160": [
      {
        "type": "http-endpoint",
        "methodName": "greeting",
        "className": "HelloController",
        "classNodeId": "1472486160",
        "metadata": {
          "key": "/hello",
          "path": "/hello",
          "requestMethod": "GET"
        },
        "id": "1472486160_greeting"
      }
    ],
    "1634859874": [
      {
        "type": "middleware",
        "methodName": "use",
        "className": "LoggerMiddleware",
        "classNodeId": "1634859874",
        "metadata": {
          "key": "/cats/",
          "path": "/cats/",
          "requestMethod": "POST"
        },
        "id": "1634859874_use"
      },
      {
        "type": "middleware",
        "methodName": "use",
        "className": "LoggerMiddleware",
        "classNodeId": "1634859874",
        "metadata": {
          "key": "/cats/",
          "path": "/cats/",
          "requestMethod": "GET"
        },
        "id": "1634859874_use"
      },
      {
        "type": "middleware",
        "methodName": "use",
        "className": "LoggerMiddleware",
        "classNodeId": "1634859874",
        "metadata": {
          "key": "/cats/:id",
          "path": "/cats/:id",
          "requestMethod": "GET"
        },
        "id": "1634859874_use"
      }
    ],
    "-349899408": [
      {
        "type": "microservice",
        "methodName": "create",
        "className": "ExternalSvcController",
        "classNodeId": "-349899408",
        "metadata": {
          "key": "createExternalSvc",
          "transportId": "TCP",
          "patterns": [
            "createExternalSvc"
          ],
          "isEventHandler": false,
          "extras": {}
        },
        "id": "-349899408_create"
      },
      {
        "type": "microservice",
        "methodName": "findAll",
        "className": "ExternalSvcController",
        "classNodeId": "-349899408",
        "metadata": {
          "key": "findAllExternalSvc",
          "transportId": "TCP",
          "patterns": [
            "findAllExternalSvc"
          ],
          "isEventHandler": false,
          "extras": {}
        },
        "id": "-349899408_findAll"
      },
      {
        "type": "microservice",
        "methodName": "findOne",
        "className": "ExternalSvcController",
        "classNodeId": "-349899408",
        "metadata": {
          "key": "findOneExternalSvc",
          "transportId": "TCP",
          "patterns": [
            "findOneExternalSvc"
          ],
          "isEventHandler": false,
          "extras": {}
        },
        "id": "-349899408_findOne"
      },
      {
        "type": "microservice",
        "methodName": "update",
        "className": "ExternalSvcController",
        "classNodeId": "-349899408",
        "metadata": {
          "key": "updateExternalSvc",
          "transportId": "TCP",
          "patterns": [
            "updateExternalSvc"
          ],
          "isEventHandler": false,
          "extras": {}
        },
        "id": "-349899408_update"
      },
      {
        "type": "microservice",
        "methodName": "remove",
        "className": "ExternalSvcController",
        "classNodeId": "-349899408",
        "metadata": {
          "key": "removeExternalSvc",
          "transportId": "TCP",
          "patterns": [
            "removeExternalSvc"
          ],
          "isEventHandler": false,
          "extras": {}
        },
        "id": "-349899408_remove"
      }
    ],
    "-365265483": [
      {
        "type": "http-endpoint",
        "methodName": "helloWorldV1",
        "className": "AppV1Controller",
        "classNodeId": "-365265483",
        "metadata": {
          "key": "/v1",
          "path": "/v1",
          "requestMethod": "GET",
          "controllerVersion": "1"
        },
        "id": "-365265483_helloWorldV1"
      },
      {
        "type": "http-endpoint",
        "methodName": "paramV1",
        "className": "AppV1Controller",
        "classNodeId": "-365265483",
        "metadata": {
          "key": "/v1/:param/hello",
          "path": "/v1/:param/hello",
          "requestMethod": "GET",
          "controllerVersion": "1"
        },
        "id": "-365265483_paramV1"
      }
    ],
    "-774089708": [
      {
        "type": "http-endpoint",
        "methodName": "helloWorldV2",
        "className": "AppV2Controller",
        "classNodeId": "-774089708",
        "metadata": {
          "key": "/v2",
          "path": "/v2",
          "requestMethod": "GET",
          "controllerVersion": "2"
        },
        "id": "-774089708_helloWorldV2"
      },
      {
        "type": "http-endpoint",
        "methodName": "paramV1",
        "className": "AppV2Controller",
        "classNodeId": "-774089708",
        "metadata": {
          "key": "/v3/:param/hello",
          "path": "/v3/:param/hello",
          "requestMethod": "GET",
          "methodVersion": "3",
          "controllerVersion": "2"
        },
        "id": "-774089708_paramV1"
      }
    ],
    "-1550892030": [
      {
        "type": "http-endpoint",
        "methodName": "create",
        "className": "CatsController",
        "classNodeId": "-1550892030",
        "metadata": {
          "key": "/cats",
          "path": "/cats",
          "requestMethod": "POST"
        },
        "id": "-1550892030_create"
      },
      {
        "type": "http-endpoint",
        "methodName": "findAll",
        "className": "CatsController",
        "classNodeId": "-1550892030",
        "metadata": {
          "key": "/cats",
          "path": "/cats",
          "requestMethod": "GET"
        },
        "id": "-1550892030_findAll"
      },
      {
        "type": "http-endpoint",
        "methodName": "findOne",
        "className": "CatsController",
        "classNodeId": "-1550892030",
        "metadata": {
          "key": "/cats/:id",
          "path": "/cats/:id",
          "requestMethod": "GET"
        },
        "id": "-1550892030_findOne"
      }
    ],
    "-848516688": [
      {
        "type": "http-endpoint",
        "methodName": "greeting",
        "className": "DurableController",
        "classNodeId": "-848516688",
        "metadata": {
          "key": "/durable",
          "path": "/durable",
          "requestMethod": "GET"
        },
        "id": "-848516688_greeting"
      },
      {
        "type": "http-endpoint",
        "methodName": "echo",
        "className": "DurableController",
        "classNodeId": "-848516688",
        "metadata": {
          "key": "/durable/echo",
          "path": "/durable/echo",
          "requestMethod": "GET"
        },
        "id": "-848516688_echo"
      }
    ],
    "-1558907338": [
      {
        "type": "http-endpoint",
        "methodName": "create",
        "className": "DogsController",
        "classNodeId": "-1558907338",
        "metadata": {
          "key": "/dogs",
          "path": "/dogs",
          "requestMethod": "POST"
        },
        "id": "-1558907338_create"
      },
      {
        "type": "http-endpoint",
        "methodName": "findAll",
        "className": "DogsController",
        "classNodeId": "-1558907338",
        "metadata": {
          "key": "/dogs",
          "path": "/dogs",
          "requestMethod": "GET"
        },
        "id": "-1558907338_findAll"
      },
      {
        "type": "http-endpoint",
        "methodName": "findOne",
        "className": "DogsController",
        "classNodeId": "-1558907338",
        "metadata": {
          "key": "/dogs/:id",
          "path": "/dogs/:id",
          "requestMethod": "GET"
        },
        "id": "-1558907338_findOne"
      },
      {
        "type": "http-endpoint",
        "methodName": "update",
        "className": "DogsController",
        "classNodeId": "-1558907338",
        "metadata": {
          "key": "/dogs/:id",
          "path": "/dogs/:id",
          "requestMethod": "PATCH"
        },
        "id": "-1558907338_update"
      },
      {
        "type": "http-endpoint",
        "methodName": "remove",
        "className": "DogsController",
        "classNodeId": "-1558907338",
        "metadata": {
          "key": "/dogs/:id",
          "path": "/dogs/:id",
          "requestMethod": "DELETE"
        },
        "id": "-1558907338_remove"
      }
    ],
    "-1102473136": [
      {
        "type": "http-endpoint",
        "methodName": "create",
        "className": "UsersController",
        "classNodeId": "-1102473136",
        "metadata": {
          "key": "/users",
          "path": "/users",
          "requestMethod": "POST"
        },
        "id": "-1102473136_create"
      },
      {
        "type": "http-endpoint",
        "methodName": "findAll",
        "className": "UsersController",
        "classNodeId": "-1102473136",
        "metadata": {
          "key": "/users",
          "path": "/users",
          "requestMethod": "GET"
        },
        "id": "-1102473136_findAll"
      },
      {
        "type": "http-endpoint",
        "methodName": "findOne",
        "className": "UsersController",
        "classNodeId": "-1102473136",
        "metadata": {
          "key": "/users/:id",
          "path": "/users/:id",
          "requestMethod": "GET"
        },
        "id": "-1102473136_findOne"
      },
      {
        "type": "http-endpoint",
        "methodName": "update",
        "className": "UsersController",
        "classNodeId": "-1102473136",
        "metadata": {
          "key": "/users/:id",
          "path": "/users/:id",
          "requestMethod": "PATCH"
        },
        "id": "-1102473136_update"
      },
      {
        "type": "http-endpoint",
        "methodName": "remove",
        "className": "UsersController",
        "classNodeId": "-1102473136",
        "metadata": {
          "key": "/users/:id",
          "path": "/users/:id",
          "requestMethod": "DELETE"
        },
        "id": "-1102473136_remove"
      }
    ],
    "-377928898": [
      {
        "type": "http-endpoint",
        "methodName": "create",
        "className": "DatabaseController",
        "classNodeId": "-377928898",
        "metadata": {
          "key": "/database",
          "path": "/database",
          "requestMethod": "POST"
        },
        "id": "-377928898_create"
      },
      {
        "type": "http-endpoint",
        "methodName": "findAll",
        "className": "DatabaseController",
        "classNodeId": "-377928898",
        "metadata": {
          "key": "/database",
          "path": "/database",
          "requestMethod": "GET"
        },
        "id": "-377928898_findAll"
      },
      {
        "type": "http-endpoint",
        "methodName": "findOne",
        "className": "DatabaseController",
        "classNodeId": "-377928898",
        "metadata": {
          "key": "/database/:id",
          "path": "/database/:id",
          "requestMethod": "GET"
        },
        "id": "-377928898_findOne"
      },
      {
        "type": "http-endpoint",
        "methodName": "update",
        "className": "DatabaseController",
        "classNodeId": "-377928898",
        "metadata": {
          "key": "/database/:id",
          "path": "/database/:id",
          "requestMethod": "PATCH"
        },
        "id": "-377928898_update"
      },
      {
        "type": "http-endpoint",
        "methodName": "remove",
        "className": "DatabaseController",
        "classNodeId": "-377928898",
        "metadata": {
          "key": "/database/:id",
          "path": "/database/:id",
          "requestMethod": "DELETE"
        },
        "id": "-377928898_remove"
      }
    ],
    "-1927427604": [
      {
        "type": "http-endpoint",
        "methodName": "greeting",
        "className": "RequestChainController",
        "classNodeId": "-1927427604",
        "metadata": {
          "key": "/hello",
          "path": "/hello",
          "requestMethod": "GET"
        },
        "id": "-1927427604_greeting"
      }
    ]
  },
  "extras": {
    "orphanedEnhancers": [
      {
        "subtype": "pipe",
        "ref": "ValidationPipe"
      },
      {
        "subtype": "filter",
        "ref": "HttpExceptionFilter"
      },
      {
        "subtype": "interceptor",
        "ref": "TimeoutInterceptor"
      }
    ],
    "attachedEnhancers": [
      {
        "nodeId": "2018972420"
      },
      {
        "nodeId": "-2007711503"
      }
    ]
  },
  "status": "complete"
}


================================================
FILE: integration/inspector/e2e/fixtures/pre-init-graph.json
================================================
{
  "nodes": {
    "18347652": {
      "id": "18347652",
      "label": "LoggingInterceptor",
      "parent": "2133316171",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "LoggingInterceptor",
        "subtype": "interceptor",
        "initTime": 0
      }
    },
    "55510001": {
      "id": "55510001",
      "label": "UsersService",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "UsersService",
        "initTime": 0
      }
    },
    "91819333": {
      "id": "91819333",
      "label": "ModuleRef",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "203550704": {
      "id": "203550704",
      "label": "ExternalContextCreator",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "ExternalContextCreator",
        "initTime": 0
      }
    },
    "208171089": {
      "id": "208171089",
      "label": "RolesGuard",
      "parent": "1434441974",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "RolesGuard",
        "subtype": "guard",
        "initTime": 0
      }
    },
    "225063248": {
      "id": "225063248",
      "label": "InternalCoreModule",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "InternalCoreModule",
        "initTime": 0
      }
    },
    "256260345": {
      "id": "256260345",
      "label": "ApplicationConfig",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "345516396": {
      "id": "345516396",
      "label": "ApplicationConfig",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "345719894": {
      "id": "345719894",
      "label": "CoreModule",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CoreModule",
        "initTime": 0
      }
    },
    "437945905": {
      "id": "437945905",
      "label": "ApplicationConfig",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "519735830": {
      "id": "519735830",
      "label": "ApplicationConfig",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "521671888": {
      "id": "521671888",
      "label": "DogsModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "555176277": {
      "id": "555176277",
      "label": "InternalCoreModule",
      "metadata": {
        "type": "module",
        "global": true,
        "dynamic": true,
        "internal": true
      }
    },
    "594986539": {
      "id": "594986539",
      "label": "InputService",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "InputService",
        "initTime": 0
      }
    },
    "603011239": {
      "id": "603011239",
      "label": "UsersService",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "UsersService",
        "initTime": 0
      }
    },
    "671882984": {
      "id": "671882984",
      "label": "Reflector",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "Reflector",
        "initTime": 0
      }
    },
    "791004148": {
      "id": "791004148",
      "label": "ExternalSvcModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "867482265": {
      "id": "867482265",
      "label": "Interceptor",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "Interceptor",
        "subtype": "interceptor",
        "initTime": 0
      }
    },
    "927096496": {
      "id": "927096496",
      "label": "ApplicationConfig",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "928565345": {
      "id": "928565345",
      "label": "HelperService",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": true,
        "token": "HelperService",
        "initTime": 0
      }
    },
    "941957564": {
      "id": "941957564",
      "label": "RequestChainModule",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "RequestChainModule",
        "initTime": 0
      }
    },
    "980514911": {
      "id": "980514911",
      "label": "Symbol(token)",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "Symbol(token)"
      }
    },
    "1004276345": {
      "id": "1004276345",
      "label": "Meta",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "META",
        "initTime": 0
      }
    },
    "1010833816": {
      "id": "1010833816",
      "label": "token",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "token"
      }
    },
    "1047229654": {
      "id": "1047229654",
      "label": "CircularModule",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CircularModule",
        "initTime": 0
      }
    },
    "1074192353": {
      "id": "1074192353",
      "label": "ChatService",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ChatService",
        "initTime": 0
      }
    },
    "1120316353": {
      "id": "1120316353",
      "label": "ModuleRef",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1131051184": {
      "id": "1131051184",
      "label": "ChatGateway",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ChatGateway",
        "initTime": 0
      }
    },
    "1142369607": {
      "id": "1142369607",
      "label": "HelperModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1189153544": {
      "id": "1189153544",
      "label": "ChatModule",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ChatModule",
        "initTime": 0
      }
    },
    "1253818496": {
      "id": "1253818496",
      "label": "RootTestModule",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "RootTestModule",
        "initTime": 0
      }
    },
    "1433815174": {
      "id": "1433815174",
      "label": "DogsModule",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DogsModule",
        "initTime": 0
      }
    },
    "1434441974": {
      "id": "1434441974",
      "label": "CatsModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1434456218": {
      "id": "1434456218",
      "label": "Reflector",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": true,
        "token": "Reflector",
        "initTime": 0
      }
    },
    "1472486160": {
      "id": "1472486160",
      "label": "HelloController",
      "parent": "1743739569",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "HelloController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "-2010060263",
            "methodKey": "greeting",
            "subtype": "guard"
          },
          {
            "id": "867482265",
            "methodKey": "greeting",
            "subtype": "interceptor"
          },
          {
            "id": "1893794611",
            "methodKey": "greeting",
            "subtype": "pipe"
          }
        ]
      }
    },
    "1528017428": {
      "id": "1528017428",
      "label": "DatabaseModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "1535366709": {
      "id": "1535366709",
      "label": "ApplicationConfig",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "1551182002": {
      "id": "1551182002",
      "label": "ModuleRef",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1616075090": {
      "id": "1616075090",
      "label": "CatsModule",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "CatsModule",
        "initTime": 0
      }
    },
    "1743739569": {
      "id": "1743739569",
      "label": "HelloModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": true,
        "internal": false
      }
    },
    "1771940178": {
      "id": "1771940178",
      "label": "ApplicationConfig",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "1809676814": {
      "id": "1809676814",
      "label": "ModuleRef",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "1893794611": {
      "id": "1893794611",
      "label": "UserByIdPipe",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "UserByIdPipe",
        "subtype": "pipe",
        "initTime": 0
      }
    },
    "1919157847": {
      "id": "1919157847",
      "label": "REQUEST",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": true,
        "token": "REQUEST",
        "initTime": 0
      }
    },
    "2018972420": {
      "id": "2018972420",
      "label": "TransformInterceptor",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "APP_INTERCEPTOR (UUID: -1146749753)",
        "subtype": "interceptor",
        "initTime": 0,
        "global": true
      }
    },
    "2133316171": {
      "id": "2133316171",
      "label": "RequestChainModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-1486320561": {
      "id": "-1486320561",
      "label": "ModuleRef",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-651043398": {
      "id": "-651043398",
      "label": "ApplicationConfig",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-255469305": {
      "id": "-255469305",
      "label": "INQUIRER",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "scope": 1,
        "transient": true,
        "exported": true,
        "token": "INQUIRER",
        "initTime": 0
      }
    },
    "-26938366": {
      "id": "-26938366",
      "label": "ModulesContainer",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "ModulesContainer",
        "initTime": 0
      }
    },
    "-326832201": {
      "id": "-326832201",
      "label": "HttpAdapterHost",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "HttpAdapterHost",
        "initTime": 0
      }
    },
    "-702581189": {
      "id": "-702581189",
      "label": "LazyModuleLoader",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "LazyModuleLoader",
        "initTime": 0
      }
    },
    "-1904419534": {
      "id": "-1904419534",
      "label": "SerializedGraph",
      "parent": "555176277",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InternalCoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "SerializedGraph",
        "initTime": 0
      }
    },
    "-1251270035": {
      "id": "-1251270035",
      "label": "RootTestModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-969610649": {
      "id": "-969610649",
      "label": "ModuleRef",
      "parent": "-1251270035",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "RootTestModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-19112576": {
      "id": "-19112576",
      "label": "AppModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2139588960": {
      "id": "-2139588960",
      "label": "AppModule",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "AppModule",
        "initTime": 0
      }
    },
    "-71302842": {
      "id": "-71302842",
      "label": "ModuleRef",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-2064622725": {
      "id": "-2064622725",
      "label": "ApplicationConfig",
      "parent": "-19112576",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-365265483": {
      "id": "-365265483",
      "label": "AppV1Controller",
      "parent": "-19112576",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "AppV1Controller",
        "initTime": 0
      }
    },
    "-774089708": {
      "id": "-774089708",
      "label": "AppV2Controller",
      "parent": "-19112576",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "AppModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "AppV2Controller",
        "initTime": 0
      }
    },
    "-1125887048": {
      "id": "-1125887048",
      "label": "CoreModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-112192227": {
      "id": "-112192227",
      "label": "ApplicationConfig",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-2007711503": {
      "id": "-2007711503",
      "label": "LoggingInterceptor",
      "parent": "-1125887048",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CoreModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "APP_INTERCEPTOR (UUID: 1780085433)",
        "subtype": "interceptor",
        "initTime": 0,
        "global": true
      }
    },
    "-183456272": {
      "id": "-183456272",
      "label": "ModuleRef",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1846830501": {
      "id": "-1846830501",
      "label": "ApplicationConfig",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-593595711": {
      "id": "-593595711",
      "label": "CatsService",
      "parent": "1434441974",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "CatsService",
        "initTime": 0
      }
    },
    "-1550892030": {
      "id": "-1550892030",
      "label": "CatsController",
      "parent": "1434441974",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "CatsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "CatsController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "208171089",
            "subtype": "guard"
          },
          {
            "name": "ParseIntPipe",
            "methodKey": "findOne",
            "subtype": "pipe"
          }
        ]
      }
    },
    "-1378706112": {
      "id": "-1378706112",
      "label": "HelloModule",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "HelloModule",
        "initTime": 0
      }
    },
    "-1166465801": {
      "id": "-1166465801",
      "label": "ModuleRef",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1191459348": {
      "id": "-1191459348",
      "label": "ApplicationConfig",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1758187461": {
      "id": "-1758187461",
      "label": "HelloService",
      "parent": "1743739569",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "HelloService",
        "initTime": 0
      }
    },
    "-2010060263": {
      "id": "-2010060263",
      "label": "Guard",
      "parent": "1743739569",
      "metadata": {
        "type": "injectable",
        "internal": false,
        "sourceModuleName": "HelloModule",
        "durable": false,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "Guard",
        "subtype": "guard",
        "initTime": 0
      }
    },
    "-1124392646": {
      "id": "-1124392646",
      "label": "DurableModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-522935456": {
      "id": "-522935456",
      "label": "DurableModule",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DurableModule",
        "initTime": 0
      }
    },
    "-1808043520": {
      "id": "-1808043520",
      "label": "ModuleRef",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-57038411": {
      "id": "-57038411",
      "label": "ApplicationConfig",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DurableModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1673986099": {
      "id": "-1673986099",
      "label": "DurableService",
      "parent": "-1124392646",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DurableModule",
        "durable": true,
        "static": false,
        "scope": 2,
        "transient": false,
        "exported": false,
        "token": "DurableService",
        "initTime": 0
      }
    },
    "-848516688": {
      "id": "-848516688",
      "label": "DurableController",
      "parent": "-1124392646",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DurableModule",
        "durable": true,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "DurableController",
        "initTime": 0
      }
    },
    "-1096226358": {
      "id": "-1096226358",
      "label": "ModuleRef",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-335387007": {
      "id": "-335387007",
      "label": "DogsService",
      "parent": "521671888",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DogsService",
        "initTime": 0
      }
    },
    "-1558907338": {
      "id": "-1558907338",
      "label": "DogsController",
      "parent": "521671888",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DogsModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DogsController",
        "initTime": 0
      }
    },
    "-2003726489": {
      "id": "-2003726489",
      "label": "UsersModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-495603840": {
      "id": "-495603840",
      "label": "UsersModule",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "UsersModule",
        "initTime": 0
      }
    },
    "-618964563": {
      "id": "-618964563",
      "label": "ModuleRef",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-643958110": {
      "id": "-643958110",
      "label": "ApplicationConfig",
      "parent": "-2003726489",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1102473136": {
      "id": "-1102473136",
      "label": "UsersController",
      "parent": "-2003726489",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "UsersModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "UsersController",
        "initTime": 0
      }
    },
    "-1098322034": {
      "id": "-1098322034",
      "label": "DatabaseModule",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "DatabaseModule",
        "initTime": 0
      }
    },
    "-616397055": {
      "id": "-616397055",
      "label": "DatabaseService",
      "parent": "1528017428",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DatabaseService",
        "initTime": 0
      }
    },
    "-377928898": {
      "id": "-377928898",
      "label": "DatabaseController",
      "parent": "1528017428",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "DatabaseModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DatabaseController",
        "initTime": 0
      }
    },
    "-511735264": {
      "id": "-511735264",
      "label": "ExternalSvcModule",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcModule",
        "initTime": 0
      }
    },
    "-660323910": {
      "id": "-660323910",
      "label": "ModuleRef",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-217737489": {
      "id": "-217737489",
      "label": "ApplicationConfig",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1902429503": {
      "id": "-1902429503",
      "label": "ExternalSvcService",
      "parent": "791004148",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcService",
        "initTime": 0
      }
    },
    "-349899408": {
      "id": "-349899408",
      "label": "ExternalSvcController",
      "parent": "791004148",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "ExternalSvcModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "ExternalSvcController",
        "initTime": 0
      }
    },
    "-493958991": {
      "id": "-493958991",
      "label": "ChatModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2111857237": {
      "id": "-2111857237",
      "label": "ModuleRef",
      "parent": "-493958991",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "ChatModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-234035039": {
      "id": "-234035039",
      "label": "RequestChainService",
      "parent": "2133316171",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "RequestChainService",
        "initTime": 0
      }
    },
    "-1927427604": {
      "id": "-1927427604",
      "label": "RequestChainController",
      "parent": "2133316171",
      "metadata": {
        "type": "controller",
        "internal": false,
        "sourceModuleName": "RequestChainModule",
        "durable": false,
        "static": false,
        "transient": false,
        "exported": false,
        "token": "RequestChainController",
        "initTime": 0,
        "enhancers": [
          {
            "id": "18347652",
            "methodKey": "greeting",
            "subtype": "interceptor"
          }
        ]
      }
    },
    "-162987852": {
      "id": "-162987852",
      "label": "HelperModule",
      "parent": "1142369607",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "HelperModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "HelperModule",
        "initTime": 0
      }
    },
    "-1469176692": {
      "id": "-1469176692",
      "label": "PropertiesModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-1501313730": {
      "id": "-1501313730",
      "label": "PropertiesModule",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "PropertiesModule",
        "initTime": 0
      }
    },
    "-1377446394": {
      "id": "-1377446394",
      "label": "ModuleRef",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1494077847": {
      "id": "-1494077847",
      "label": "DependencyService",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "DependencyService",
        "initTime": 0
      }
    },
    "-1803759743": {
      "id": "-1803759743",
      "label": "PropertiesService",
      "parent": "-1469176692",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "PropertiesModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": false,
        "token": "PropertiesService",
        "initTime": 0
      }
    },
    "-1813741655": {
      "id": "-1813741655",
      "label": "InputModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-2113121728": {
      "id": "-2113121728",
      "label": "InputModule",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "InputModule",
        "initTime": 0
      }
    },
    "-428979729": {
      "id": "-428979729",
      "label": "ModuleRef",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-453973276": {
      "id": "-453973276",
      "label": "ApplicationConfig",
      "parent": "-1813741655",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "InputModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-369869768": {
      "id": "-369869768",
      "label": "CircularModule",
      "metadata": {
        "type": "module",
        "global": false,
        "dynamic": false,
        "internal": false
      }
    },
    "-88210382": {
      "id": "-88210382",
      "label": "ModuleRef",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ModuleRef"
      }
    },
    "-1641626851": {
      "id": "-1641626851",
      "label": "ApplicationConfig",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": true,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "scope": 0,
        "transient": false,
        "exported": false,
        "token": "ApplicationConfig"
      }
    },
    "-1721730431": {
      "id": "-1721730431",
      "label": "CircularService",
      "parent": "-369869768",
      "metadata": {
        "type": "provider",
        "internal": false,
        "sourceModuleName": "CircularModule",
        "durable": false,
        "static": true,
        "transient": false,
        "exported": true,
        "token": "CircularService",
        "initTime": 0
      }
    }
  },
  "edges": {
    "22193019": {
      "source": "-19112576",
      "target": "521671888",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DogsModule"
      },
      "id": "22193019"
    },
    "33333764": {
      "source": "791004148",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "ExternalSvcModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "33333764"
    },
    "40501732": {
      "source": "521671888",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DogsModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "40501732"
    },
    "73947303": {
      "source": "-1813741655",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "InputModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "73947303"
    },
    "182501115": {
      "source": "1434441974",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CatsModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "182501115"
    },
    "189694679": {
      "source": "1434456218",
      "target": "671882984",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "InternalCoreModule",
        "sourceClassName": "Reflector",
        "targetClassName": "Reflector",
        "sourceClassToken": "Reflector",
        "targetClassToken": "Reflector",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "189694679"
    },
    "231469845": {
      "source": "-1803759743",
      "target": "-1494077847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "DependencyService",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "DependencyService",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "service",
        "injectionType": "property"
      },
      "id": "231469845"
    },
    "250652665": {
      "source": "2133316171",
      "target": "1142369607",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RequestChainModule",
        "targetModuleName": "HelperModule"
      },
      "id": "250652665"
    },
    "393939926": {
      "source": "-1813741655",
      "target": "-369869768",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "InputModule",
        "targetModuleName": "CircularModule"
      },
      "id": "393939926"
    },
    "417363164": {
      "source": "-1251270035",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RootTestModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "417363164"
    },
    "469401997": {
      "source": "-493958991",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "ChatModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "469401997"
    },
    "654001290": {
      "source": "1472486160",
      "target": "867482265",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "Interceptor",
        "sourceClassToken": "HelloController",
        "targetClassToken": "Interceptor",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "654001290"
    },
    "676175891": {
      "source": "-1251270035",
      "target": "-19112576",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RootTestModule",
        "targetModuleName": "AppModule"
      },
      "id": "676175891"
    },
    "800268760": {
      "source": "-1102473136",
      "target": "603011239",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "UsersModule",
        "sourceClassName": "UsersController",
        "targetClassName": "UsersService",
        "sourceClassToken": "UsersController",
        "targetClassToken": "UsersService",
        "targetModuleName": "UsersModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "800268760"
    },
    "804987620": {
      "source": "-19112576",
      "target": "-1125887048",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "CoreModule"
      },
      "id": "804987620"
    },
    "807697929": {
      "source": "-19112576",
      "target": "1528017428",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DatabaseModule"
      },
      "id": "807697929"
    },
    "966350248": {
      "source": "1131051184",
      "target": "1074192353",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "ChatModule",
        "sourceClassName": "ChatGateway",
        "targetClassName": "ChatService",
        "sourceClassToken": "ChatGateway",
        "targetClassToken": "ChatService",
        "targetModuleName": "ChatModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "966350248"
    },
    "987755577": {
      "source": "-2003726489",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "UsersModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "987755577"
    },
    "1056428433": {
      "source": "-19112576",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1056428433"
    },
    "1059069749": {
      "source": "-1558907338",
      "target": "-335387007",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DogsModule",
        "sourceClassName": "DogsController",
        "targetClassName": "DogsService",
        "sourceClassToken": "DogsController",
        "targetClassToken": "DogsService",
        "targetModuleName": "DogsModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1059069749"
    },
    "1142343545": {
      "source": "-1758187461",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloService",
        "targetClassName": "Meta",
        "sourceClassToken": "HelloService",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1142343545"
    },
    "1178436405": {
      "source": "1893794611",
      "target": "55510001",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "UserByIdPipe",
        "targetClassName": "UsersService",
        "sourceClassToken": "UserByIdPipe",
        "targetClassToken": "UsersService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1178436405"
    },
    "1195474320": {
      "source": "-369869768",
      "target": "-1813741655",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CircularModule",
        "targetModuleName": "InputModule"
      },
      "id": "1195474320"
    },
    "1247743823": {
      "source": "2133316171",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "RequestChainModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1247743823"
    },
    "1325313063": {
      "source": "-1927427604",
      "target": "18347652",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainController",
        "targetClassName": "LoggingInterceptor",
        "sourceClassToken": "RequestChainController",
        "targetClassToken": "LoggingInterceptor",
        "targetModuleName": "RequestChainModule",
        "injectionType": "decorator"
      },
      "id": "1325313063"
    },
    "1497653915": {
      "source": "55510001",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "UsersService",
        "targetClassName": "Meta",
        "sourceClassToken": "UsersService",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1497653915"
    },
    "1615322974": {
      "source": "-1469176692",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "PropertiesModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1615322974"
    },
    "1856016815": {
      "source": "-1721730431",
      "target": "594986539",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CircularModule",
        "sourceClassName": "CircularService",
        "targetClassName": "InputService",
        "sourceClassToken": "CircularService",
        "targetClassToken": "InputService",
        "targetModuleName": "InputModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1856016815"
    },
    "1900414743": {
      "source": "1472486160",
      "target": "1893794611",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "UserByIdPipe",
        "sourceClassToken": "HelloController",
        "targetClassToken": "UserByIdPipe",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "1900414743"
    },
    "1904579661": {
      "source": "18347652",
      "target": "928565345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "LoggingInterceptor",
        "targetClassName": "HelperService",
        "sourceClassToken": "LoggingInterceptor",
        "targetClassToken": "HelperService",
        "targetModuleName": "HelperModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "1904579661"
    },
    "1960203007": {
      "source": "-1803759743",
      "target": "980514911",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "Symbol(token)",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "Symbol(token)",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "symbolToken",
        "injectionType": "property"
      },
      "id": "1960203007"
    },
    "1976848738": {
      "source": "1528017428",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DatabaseModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "1976848738"
    },
    "-2105726668": {
      "source": "-1803759743",
      "target": "1010833816",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "PropertiesModule",
        "sourceClassName": "PropertiesService",
        "targetClassName": "token",
        "sourceClassToken": "PropertiesService",
        "targetClassToken": "token",
        "targetModuleName": "PropertiesModule",
        "keyOrIndex": "token",
        "injectionType": "property"
      },
      "id": "-2105726668"
    },
    "-21463590": {
      "source": "-1378706112",
      "target": "1004276345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloModule",
        "targetClassName": "Meta",
        "sourceClassToken": "HelloModule",
        "targetClassToken": "META",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-21463590"
    },
    "-1657371464": {
      "source": "-1673986099",
      "target": "1919157847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DurableModule",
        "sourceClassName": "DurableService",
        "targetClassName": "REQUEST",
        "sourceClassToken": "DurableService",
        "targetClassToken": "REQUEST",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-1657371464"
    },
    "-1303681274": {
      "source": "928565345",
      "target": "1919157847",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelperModule",
        "sourceClassName": "HelperService",
        "targetClassName": "REQUEST",
        "sourceClassToken": "HelperService",
        "targetClassToken": "REQUEST",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-1303681274"
    },
    "-886102564": {
      "source": "208171089",
      "target": "671882984",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "RolesGuard",
        "targetClassName": "Reflector",
        "sourceClassToken": "RolesGuard",
        "targetClassToken": "Reflector",
        "targetModuleName": "InternalCoreModule",
        "keyOrIndex": 0,
        "injectionType": "constructor",
        "internal": true
      },
      "id": "-886102564"
    },
    "-2003045613": {
      "source": "-377928898",
      "target": "-616397055",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DatabaseModule",
        "sourceClassName": "DatabaseController",
        "targetClassName": "DatabaseService",
        "sourceClassToken": "DatabaseController",
        "targetClassToken": "DatabaseService",
        "targetModuleName": "DatabaseModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-2003045613"
    },
    "-881420795": {
      "source": "-349899408",
      "target": "-1902429503",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "ExternalSvcModule",
        "sourceClassName": "ExternalSvcController",
        "targetClassName": "ExternalSvcService",
        "sourceClassToken": "ExternalSvcController",
        "targetClassToken": "ExternalSvcService",
        "targetModuleName": "ExternalSvcModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-881420795"
    },
    "-831049991": {
      "source": "594986539",
      "target": "-1721730431",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "InputModule",
        "sourceClassName": "InputService",
        "targetClassName": "CircularService",
        "sourceClassToken": "InputService",
        "targetClassToken": "CircularService",
        "targetModuleName": "CircularModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-831049991"
    },
    "-2146943494": {
      "source": "-234035039",
      "target": "928565345",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainService",
        "targetClassName": "HelperService",
        "sourceClassToken": "RequestChainService",
        "targetClassToken": "HelperService",
        "targetModuleName": "HelperModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-2146943494"
    },
    "-1816180282": {
      "source": "-848516688",
      "target": "-1673986099",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "DurableModule",
        "sourceClassName": "DurableController",
        "targetClassName": "DurableService",
        "sourceClassToken": "DurableController",
        "targetClassToken": "DurableService",
        "targetModuleName": "DurableModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-1816180282"
    },
    "-180350082": {
      "source": "-1550892030",
      "target": "-593595711",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "CatsController",
        "targetClassName": "CatsService",
        "sourceClassToken": "CatsController",
        "targetClassToken": "CatsService",
        "targetModuleName": "CatsModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-180350082"
    },
    "-1043628608": {
      "source": "1472486160",
      "target": "-1758187461",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "HelloService",
        "sourceClassToken": "HelloController",
        "targetClassToken": "HelloService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-1043628608"
    },
    "-1335121169": {
      "source": "1472486160",
      "target": "55510001",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "UsersService",
        "sourceClassToken": "HelloController",
        "targetClassToken": "UsersService",
        "targetModuleName": "HelloModule",
        "keyOrIndex": 1,
        "injectionType": "constructor"
      },
      "id": "-1335121169"
    },
    "-296280311": {
      "source": "-1927427604",
      "target": "-234035039",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "RequestChainModule",
        "sourceClassName": "RequestChainController",
        "targetClassName": "RequestChainService",
        "sourceClassToken": "RequestChainController",
        "targetClassToken": "RequestChainService",
        "targetModuleName": "RequestChainModule",
        "keyOrIndex": 0,
        "injectionType": "constructor"
      },
      "id": "-296280311"
    },
    "-393224862": {
      "source": "-19112576",
      "target": "1434441974",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "CatsModule"
      },
      "id": "-393224862"
    },
    "-1675983900": {
      "source": "-19112576",
      "target": "1743739569",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "HelloModule"
      },
      "id": "-1675983900"
    },
    "-678699872": {
      "source": "-19112576",
      "target": "-1124392646",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "DurableModule"
      },
      "id": "-678699872"
    },
    "-158970266": {
      "source": "-19112576",
      "target": "-2003726489",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "UsersModule"
      },
      "id": "-158970266"
    },
    "-2086236431": {
      "source": "-19112576",
      "target": "791004148",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "ExternalSvcModule"
      },
      "id": "-2086236431"
    },
    "-192150092": {
      "source": "-19112576",
      "target": "-493958991",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "ChatModule"
      },
      "id": "-192150092"
    },
    "-1609022090": {
      "source": "-19112576",
      "target": "2133316171",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "RequestChainModule"
      },
      "id": "-1609022090"
    },
    "-773455435": {
      "source": "-19112576",
      "target": "-1469176692",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "PropertiesModule"
      },
      "id": "-773455435"
    },
    "-967144236": {
      "source": "-19112576",
      "target": "-1813741655",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "AppModule",
        "targetModuleName": "InputModule"
      },
      "id": "-967144236"
    },
    "-528424051": {
      "source": "-1125887048",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CoreModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-528424051"
    },
    "-698929209": {
      "source": "1743739569",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "HelloModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-698929209"
    },
    "-1671708813": {
      "source": "-1124392646",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "DurableModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-1671708813"
    },
    "-665042842": {
      "source": "1142369607",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "HelperModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-665042842"
    },
    "-1891610441": {
      "source": "-369869768",
      "target": "555176277",
      "metadata": {
        "type": "module-to-module",
        "sourceModuleName": "CircularModule",
        "targetModuleName": "InternalCoreModule"
      },
      "id": "-1891610441"
    },
    "-878379437": {
      "source": "-1550892030",
      "target": "208171089",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "CatsModule",
        "sourceClassName": "CatsController",
        "targetClassName": "RolesGuard",
        "sourceClassToken": "CatsController",
        "targetClassToken": "RolesGuard",
        "targetModuleName": "CatsModule",
        "injectionType": "decorator"
      },
      "id": "-878379437"
    },
    "-822816169": {
      "source": "1472486160",
      "target": "-2010060263",
      "metadata": {
        "type": "class-to-class",
        "sourceModuleName": "HelloModule",
        "sourceClassName": "HelloController",
        "targetClassName": "Guard",
        "sourceClassToken": "HelloController",
        "targetClassToken": "Guard",
        "targetModuleName": "HelloModule",
        "injectionType": "decorator"
      },
      "id": "-822816169"
    }
  },
  "entrypoints": {},
  "extras": {
    "orphanedEnhancers": [],
    "attachedEnhancers": [
      {
        "nodeId": "2018972420"
      },
      {
        "nodeId": "-2007711503"
      }
    ]
  },
  "status": "complete"
}


================================================
FILE: integration/inspector/src/app-v1.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller({
  version: '1',
})
export class AppV1Controller {
  @Get('/')
  helloWorldV1() {
    return 'Hello World V1!';
  }

  @Get('/:param/hello')
  paramV1() {
    return 'Parameter V1!';
  }
}



================================================
FILE: integration/inspector/src/app-v2.controller.ts
================================================
import { Controller, Get, Version } from '@nestjs/common';

@Controller({
  version: '2',
})
export class AppV2Controller {
  @Get('/')
  helloWorldV2() {
    return 'Hello World V2!';
  }

  @Version('3')
  @Get('/:param/hello')
  paramV1() {
    return 'Parameter V2!';
  }
}



================================================
FILE: integration/inspector/src/app.module.ts
================================================
import { Module, Scope } from '@nestjs/common';
import { AppV1Controller } from './app-v1.controller';
import { AppV2Controller } from './app-v2.controller';
import { CatsModule } from './cats/cats.module';
import { ChatModule } from './chat/chat.module';
import { HelloModule as CircularHelloModule } from './circular-hello/hello.module';
import { HelloService } from './circular-hello/hello.service';
import { InputModule } from './circular-modules/input.module';
import { CoreModule } from './core/core.module';
import { DatabaseModule } from './database/database.module';
import { DogsModule } from './dogs/dogs.module';
import { DurableModule } from './durable/durable.module';
import { ExternalSvcModule } from './external-svc/external-svc.module';
import { PropertiesModule } from './properties/properties.module';
import { RequestChainModule } from './request-chain/request-chain.module';
import { UsersModule } from './users/users.module';

class Meta {
  static COUNTER = 0;
  constructor(private readonly helloService: HelloService) {
    Meta.COUNTER++;
  }
}

@Module({
  imports: [
    CoreModule,
    CatsModule,
    CircularHelloModule.forRoot({
      provide: 'META',
      useClass: Meta,
      scope: Scope.REQUEST,
    }),
    DurableModule,
    DogsModule,
    UsersModule,
    DatabaseModule,
    ExternalSvcModule,
    ChatModule,
    RequestChainModule,
    PropertiesModule,
    InputModule,
  ],
  controllers: [AppV1Controller, AppV2Controller],
})
export class AppModule {}



================================================
FILE: integration/inspector/src/cats/cats.controller.ts
================================================
import { Body, Controller, Get, Param, Post, UseGuards } from '@nestjs/common';
import { RolesGuard } from '../common/guards/roles.guard';
import { ParseIntPipe } from '../common/pipes/parse-int.pipe';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@UseGuards(RolesGuard)
@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }

  @Get(':id')
  findOne(
    @Param('id', new ParseIntPipe())
    id: number,
  ) {
    // get by ID logic
  }
}



================================================
FILE: integration/inspector/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: integration/inspector/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}



================================================
FILE: integration/inspector/src/cats/dto/create-cat.dto.ts
================================================
import { IsInt, IsString } from 'class-validator';

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}



================================================
FILE: integration/inspector/src/cats/interfaces/cat.interface.ts
================================================
export interface Cat {
  name: string;
  age: number;
  breed: string;
}



================================================
FILE: integration/inspector/src/chat/chat.gateway.ts
================================================
import {
  WebSocketGateway,
  SubscribeMessage,
  MessageBody,
} from '@nestjs/websockets';
import { ChatService } from './chat.service';
import { CreateChatDto } from './dto/create-chat.dto';
import { UpdateChatDto } from './dto/update-chat.dto';

@WebSocketGateway()
export class ChatGateway {
  constructor(private readonly chatService: ChatService) {}

  @SubscribeMessage('createChat')
  create(@MessageBody() createChatDto: CreateChatDto) {
    return this.chatService.create(createChatDto);
  }

  @SubscribeMessage('findAllChat')
  findAll() {
    return this.chatService.findAll();
  }

  @SubscribeMessage('findOneChat')
  findOne(@MessageBody() id: number) {
    return this.chatService.findOne(id);
  }

  @SubscribeMessage('updateChat')
  update(@MessageBody() updateChatDto: UpdateChatDto) {
    return this.chatService.update(updateChatDto.id, updateChatDto);
  }

  @SubscribeMessage('removeChat')
  remove(@MessageBody() id: number) {
    return this.chatService.remove(id);
  }
}



================================================
FILE: integration/inspector/src/chat/chat.module.ts
================================================
import { Module } from '@nestjs/common';
import { ChatService } from './chat.service';
import { ChatGateway } from './chat.gateway';

@Module({
  providers: [ChatGateway, ChatService],
})
export class ChatModule {}



================================================
FILE: integration/inspector/src/chat/chat.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateChatDto } from './dto/create-chat.dto';
import { UpdateChatDto } from './dto/update-chat.dto';

@Injectable()
export class ChatService {
  create(createChatDto: CreateChatDto) {
    return 'This action adds a new chat';
  }

  findAll() {
    return `This action returns all chat`;
  }

  findOne(id: number) {
    return `This action returns a #${id} chat`;
  }

  update(id: number, updateChatDto: UpdateChatDto) {
    return `This action updates a #${id} chat`;
  }

  remove(id: number) {
    return `This action removes a #${id} chat`;
  }
}



================================================
FILE: integration/inspector/src/chat/dto/create-chat.dto.ts
================================================
export class CreateChatDto {}



================================================
FILE: integration/inspector/src/chat/dto/update-chat.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateChatDto } from './create-chat.dto';

export class UpdateChatDto extends PartialType(CreateChatDto) {
  id: number;
}



================================================
FILE: integration/inspector/src/chat/entities/chat.entity.ts
================================================
export class Chat {}



================================================
FILE: integration/inspector/src/circular-hello/hello.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';
import { UsersService } from './users/users.service';

@Controller('hello')
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/inspector/src/circular-hello/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController],
  providers: [HelloService, UsersService],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/inspector/src/circular-hello/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    HelloService.COUNTER++;
  }

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/inspector/src/circular-hello/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/inspector/src/circular-hello/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Guard implements CanActivate {
  static COUNTER = 0;
  constructor() {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}



================================================
FILE: integration/inspector/src/circular-hello/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  constructor() {
    Interceptor.COUNTER++;
  }
  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    return call.handle();
  }
}



================================================
FILE: integration/inspector/src/circular-hello/users/user-by-id.pipe.ts
================================================
import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  static COUNTER = 0;
  constructor(private readonly usersService: UsersService) {
    UserByIdPipe.COUNTER++;
  }

  transform(value: string, metadata: ArgumentMetadata) {
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/inspector/src/circular-hello/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/inspector/src/circular-modules/circular.module.ts
================================================
import { Module, forwardRef } from '@nestjs/common';
import { CircularService } from './circular.service';
import { InputModule } from './input.module';

@Module({
  imports: [forwardRef(() => InputModule)],
  providers: [CircularService],
  exports: [CircularService],
})
export class CircularModule {}



================================================
FILE: integration/inspector/src/circular-modules/circular.service.ts
================================================
import { Injectable, forwardRef, Inject } from '@nestjs/common';
import { InputService } from './input.service';

@Injectable()
export class CircularService {
  constructor(
    @Inject(forwardRef(() => InputService))
    public readonly service: InputService,
  ) {}
}



================================================
FILE: integration/inspector/src/circular-modules/input.module.ts
================================================
import { Module, forwardRef } from '@nestjs/common';
import { CircularModule } from './circular.module';
import { InputService } from './input.service';

@Module({
  imports: [forwardRef(() => CircularModule)],
  providers: [InputService],
  exports: [InputService],
})
export class InputModule {}



================================================
FILE: integration/inspector/src/circular-modules/input.service.ts
================================================
import { Injectable, Inject, forwardRef } from '@nestjs/common';
import { CircularService } from './circular.service';

@Injectable()
export class InputService {
  constructor(
    @Inject(forwardRef(() => CircularService))
    public readonly service: CircularService,
  ) {}
}



================================================
FILE: integration/inspector/src/common/filters/http-exception.filter.ts
================================================
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
} from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter<HttpException> {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const statusCode = exception.getStatus();

    response.status(statusCode).json({
      statusCode,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}



================================================
FILE: integration/inspector/src/common/guards/roles.guard.ts
================================================
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get<string[]>('roles', context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const hasRole = () =>
      user.roles.some(role => !!roles.find(item => item === role));

    return user && user.roles && hasRole();
  }
}



================================================
FILE: integration/inspector/src/common/interceptors/timeout.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { timeout } from 'rxjs/operators';

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(timeout(5000));
  }
}



================================================
FILE: integration/inspector/src/common/middleware/logger.middleware.ts
================================================
import { Injectable, NestMiddleware } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: any, res: any, next: () => void) {
    console.log(`Request...`);
    next();
  }
}



================================================
FILE: integration/inspector/src/common/pipes/parse-int.pipe.ts
================================================
import {
  BadRequestException,
  PipeTransform,
  Injectable,
  ArgumentMetadata,
} from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string> {
  async transform(value: string, metadata: ArgumentMetadata) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}



================================================
FILE: integration/inspector/src/core/core.module.ts
================================================
import { MiddlewareConsumer, Module, NestModule } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { CatsController } from '../cats/cats.controller';
import { LoggerMiddleware } from '../common/middleware/logger.middleware';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { TransformInterceptor } from './interceptors/transform.interceptor';

@Module({
  providers: [
    { provide: APP_INTERCEPTOR, useClass: TransformInterceptor },
    { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor },
  ],
})
export class CoreModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(LoggerMiddleware).forRoutes(CatsController);
  }
}



================================================
FILE: integration/inspector/src/core/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
  }
}



================================================
FILE: integration/inspector/src/core/interceptors/transform.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler<T>,
  ): Observable<Response<T>> {
    return next.handle().pipe(map(data => ({ data })));
  }
}



================================================
FILE: integration/inspector/src/database/database.controller.ts
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { DatabaseService } from './database.service';
import { CreateDatabaseDto } from './dto/create-database.dto';
import { UpdateDatabaseDto } from './dto/update-database.dto';

@Controller('database')
export class DatabaseController {
  constructor(private readonly databaseService: DatabaseService) {}

  @Post()
  create(@Body() createDatabaseDto: CreateDatabaseDto) {
    return this.databaseService.create(createDatabaseDto);
  }

  @Get()
  findAll() {
    return this.databaseService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.databaseService.findOne(+id);
  }

  @Patch(':id')
  update(
    @Param('id') id: string,
    @Body() updateDatabaseDto: UpdateDatabaseDto,
  ) {
    return this.databaseService.update(+id, updateDatabaseDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.databaseService.remove(+id);
  }
}



================================================
FILE: integration/inspector/src/database/database.module.ts
================================================
import { Module } from '@nestjs/common';
import { DatabaseService } from './database.service';
import { DatabaseController } from './database.controller';

@Module({
  controllers: [DatabaseController],
  providers: [DatabaseService],
})
export class DatabaseModule {}



================================================
FILE: integration/inspector/src/database/database.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateDatabaseDto } from './dto/create-database.dto';
import { UpdateDatabaseDto } from './dto/update-database.dto';

@Injectable()
export class DatabaseService {
  create(createDatabaseDto: CreateDatabaseDto) {
    return 'This action adds a new database';
  }

  findAll() {
    return `This action returns all database`;
  }

  findOne(id: number) {
    return `This action returns a #${id} database`;
  }

  update(id: number, updateDatabaseDto: UpdateDatabaseDto) {
    return `This action updates a #${id} database`;
  }

  remove(id: number) {
    return `This action removes a #${id} database`;
  }
}



================================================
FILE: integration/inspector/src/database/dto/create-database.dto.ts
================================================
export class CreateDatabaseDto {}



================================================
FILE: integration/inspector/src/database/dto/update-database.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateDatabaseDto } from './create-database.dto';

export class UpdateDatabaseDto extends PartialType(CreateDatabaseDto) {}



================================================
FILE: integration/inspector/src/database/entities/database.entity.ts
================================================
export class Database {}



================================================
FILE: integration/inspector/src/defaults/core.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class CoreService {}



================================================
FILE: integration/inspector/src/defaults/defaults.module.ts
================================================
import { Module } from '@nestjs/common';
import { DefaultsService } from './defaults.service';

@Module({
  providers: [DefaultsService],
})
export class DefaultsModule {}



================================================
FILE: integration/inspector/src/defaults/defaults.service.ts
================================================
import { Inject, Injectable, Optional } from '@nestjs/common';
import { CoreService } from './core.service';

@Injectable()
export class DefaultsService {
  constructor(
    @Inject(CoreService)
    @Optional()
    public readonly coreService = { default: true },
  ) {}
}



================================================
FILE: integration/inspector/src/dogs/dogs.controller.ts
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { DogsService } from './dogs.service';
import { CreateDogDto } from './dto/create-dog.dto';
import { UpdateDogDto } from './dto/update-dog.dto';

@Controller('dogs')
export class DogsController {
  constructor(private readonly dogsService: DogsService) {}

  @Post()
  create(@Body() createDogDto: CreateDogDto) {
    return this.dogsService.create(createDogDto);
  }

  @Get()
  findAll() {
    return this.dogsService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.dogsService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateDogDto: UpdateDogDto) {
    return this.dogsService.update(+id, updateDogDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.dogsService.remove(+id);
  }
}



================================================
FILE: integration/inspector/src/dogs/dogs.module.ts
================================================
import { Module } from '@nestjs/common';
import { DogsService } from './dogs.service';
import { DogsController } from './dogs.controller';

@Module({
  controllers: [DogsController],
  providers: [DogsService],
})
export class DogsModule {}



================================================
FILE: integration/inspector/src/dogs/dogs.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateDogDto } from './dto/create-dog.dto';
import { UpdateDogDto } from './dto/update-dog.dto';

@Injectable()
export class DogsService {
  create(createDogDto: CreateDogDto) {
    return 'This action adds a new dog';
  }

  findAll() {
    return `This action returns all dogs`;
  }

  findOne(id: number) {
    return `This action returns a #${id} dog`;
  }

  update(id: number, updateDogDto: UpdateDogDto) {
    return `This action updates a #${id} dog`;
  }

  remove(id: number) {
    return `This action removes a #${id} dog`;
  }
}



================================================
FILE: integration/inspector/src/dogs/dto/create-dog.dto.ts
================================================
export class CreateDogDto {}



================================================
FILE: integration/inspector/src/dogs/dto/update-dog.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateDogDto } from './create-dog.dto';

export class UpdateDogDto extends PartialType(CreateDogDto) {}



================================================
FILE: integration/inspector/src/dogs/entities/dog.entity.ts
================================================
export class Dog {}



================================================
FILE: integration/inspector/src/durable/durable-context-id.strategy.ts
================================================
import { ContextId, ContextIdStrategy, HostComponentInfo } from '@nestjs/core';
import { Request } from 'express';

const tenants = new Map<string, ContextId>();

export class DurableContextIdStrategy implements ContextIdStrategy {
  attach(contextId: ContextId, request: Request) {
    const tenantId = request.headers['x-tenant-id'] as string;
    let tenantSubTreeId: ContextId;

    if (tenants.has(tenantId)) {
      tenantSubTreeId = tenants.get(tenantId);
    } else {
      tenantSubTreeId = { id: +tenantId } as ContextId;
      tenants.set(tenantId, tenantSubTreeId);
    }
    return {
      resolve: (info: HostComponentInfo) =>
        info.isTreeDurable ? tenantSubTreeId : contextId,
      payload: { tenantId },
    };
  }
}



================================================
FILE: integration/inspector/src/durable/durable.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { DurableService } from './durable.service';

@Controller('durable')
export class DurableController {
  constructor(private readonly durableService: DurableService) {}

  @Get()
  greeting(): string {
    return this.durableService.greeting();
  }

  @Get('echo')
  echo() {
    return this.durableService.requestPayload;
  }
}



================================================
FILE: integration/inspector/src/durable/durable.module.ts
================================================
import { Module } from '@nestjs/common';
import { DurableController } from './durable.controller';
import { DurableService } from './durable.service';

@Module({
  controllers: [DurableController],
  providers: [DurableService],
})
export class DurableModule {}



================================================
FILE: integration/inspector/src/durable/durable.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';

@Injectable({ scope: Scope.REQUEST, durable: true })
export class DurableService {
  public instanceCounter = 0;

  constructor(@Inject(REQUEST) public readonly requestPayload: unknown) {}

  greeting() {
    ++this.instanceCounter;
    return `Hello world! Counter: ${this.instanceCounter}`;
  }
}



================================================
FILE: integration/inspector/src/external-svc/external-svc.controller.ts
================================================
import { Controller } from '@nestjs/common';
import { MessagePattern, Payload } from '@nestjs/microservices';
import { CreateExternalSvcDto } from './dto/create-external-svc.dto';
import { UpdateExternalSvcDto } from './dto/update-external-svc.dto';
import { ExternalSvcService } from './external-svc.service';

@Controller()
export class ExternalSvcController {
  constructor(private readonly externalSvcService: ExternalSvcService) {}

  @MessagePattern('createExternalSvc')
  create(@Payload() createExternalSvcDto: CreateExternalSvcDto) {
    return this.externalSvcService.create(createExternalSvcDto);
  }

  @MessagePattern('findAllExternalSvc')
  findAll() {
    return this.externalSvcService.findAll();
  }

  @MessagePattern('findOneExternalSvc')
  findOne(@Payload() id: number) {
    return this.externalSvcService.findOne(id);
  }

  @MessagePattern('updateExternalSvc')
  update(@Payload() updateExternalSvcDto: UpdateExternalSvcDto) {
    return this.externalSvcService.update(
      updateExternalSvcDto.id,
      updateExternalSvcDto,
    );
  }

  @MessagePattern('removeExternalSvc')
  remove(@Payload() id: number) {
    return this.externalSvcService.remove(id);
  }
}



================================================
FILE: integration/inspector/src/external-svc/external-svc.module.ts
================================================
import { Module } from '@nestjs/common';
import { ExternalSvcService } from './external-svc.service';
import { ExternalSvcController } from './external-svc.controller';

@Module({
  controllers: [ExternalSvcController],
  providers: [ExternalSvcService],
})
export class ExternalSvcModule {}



================================================
FILE: integration/inspector/src/external-svc/external-svc.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateExternalSvcDto } from './dto/create-external-svc.dto';
import { UpdateExternalSvcDto } from './dto/update-external-svc.dto';

@Injectable()
export class ExternalSvcService {
  create(createExternalSvcDto: CreateExternalSvcDto) {
    return 'This action adds a new externalSvc';
  }

  findAll() {
    return `This action returns all externalSvc`;
  }

  findOne(id: number) {
    return `This action returns a #${id} externalSvc`;
  }

  update(id: number, updateExternalSvcDto: UpdateExternalSvcDto) {
    return `This action updates a #${id} externalSvc`;
  }

  remove(id: number) {
    return `This action removes a #${id} externalSvc`;
  }
}



================================================
FILE: integration/inspector/src/external-svc/dto/create-external-svc.dto.ts
================================================
export class CreateExternalSvcDto {}



================================================
FILE: integration/inspector/src/external-svc/dto/update-external-svc.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateExternalSvcDto } from './create-external-svc.dto';

export class UpdateExternalSvcDto extends PartialType(CreateExternalSvcDto) {
  id: number;
}



================================================
FILE: integration/inspector/src/external-svc/entities/external-svc.entity.ts
================================================
export class ExternalSvc {}



================================================
FILE: integration/inspector/src/properties/dependency.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class DependencyService {}



================================================
FILE: integration/inspector/src/properties/properties.module.ts
================================================
import { Module } from '@nestjs/common';
import { DependencyService } from './dependency.service';
import { PropertiesService, SYMBOL_TOKEN } from './properties.service';

@Module({
  providers: [
    DependencyService,
    PropertiesService,
    {
      provide: 'token',
      useValue: true,
    },
    {
      provide: SYMBOL_TOKEN,
      useValue: true,
    },
  ],
})
export class PropertiesModule {}



================================================
FILE: integration/inspector/src/properties/properties.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { DependencyService } from './dependency.service';

export const SYMBOL_TOKEN = Symbol('token');

@Injectable()
export class PropertiesService {
  @Inject() service: DependencyService;
  @Inject('token') token: boolean;
  @Inject(SYMBOL_TOKEN) symbolToken: boolean;
}



================================================
FILE: integration/inspector/src/request-chain/request-chain.controller.ts
================================================
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { RequestChainService } from './request-chain.service';

@Controller('hello')
export class RequestChainController {
  constructor(private readonly chainService: RequestChainService) {}

  @UseInterceptors(LoggingInterceptor)
  @Get()
  greeting(): void {
    this.chainService.call();
  }
}



================================================
FILE: integration/inspector/src/request-chain/request-chain.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelperModule } from './helper/helper.module';
import { RequestChainController } from './request-chain.controller';
import { RequestChainService } from './request-chain.service';

@Module({
  imports: [HelperModule],
  providers: [RequestChainService],
  controllers: [RequestChainController],
})
export class RequestChainModule {}



================================================
FILE: integration/inspector/src/request-chain/request-chain.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { HelperService } from './helper/helper.service';

@Injectable()
export class RequestChainService {
  static COUNTER = 0;
  constructor(private readonly helperService: HelperService) {
    helperService.noop();
    RequestChainService.COUNTER += 1;
  }

  call() {
    this.helperService.noop();
  }
}



================================================
FILE: integration/inspector/src/request-chain/helper/helper.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelperService } from './helper.service';

@Module({
  providers: [HelperService],
  exports: [HelperService],
})
export class HelperModule {}



================================================
FILE: integration/inspector/src/request-chain/helper/helper.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';

@Injectable({ scope: Scope.REQUEST })
export class HelperService {
  constructor(@Inject(REQUEST) public readonly request) {}

  public noop() {}
}



================================================
FILE: integration/inspector/src/request-chain/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { HelperService } from '../helper/helper.service';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private readonly helperSvc: HelperService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    this.helperSvc.noop();
    if (!this.helperSvc.request) {
      throw new Error('error');
    }
    return next.handle();
  }
}



================================================
FILE: integration/inspector/src/users/users.controller.ts
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}



================================================
FILE: integration/inspector/src/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';
import { UsersController } from './users.controller';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}



================================================
FILE: integration/inspector/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Injectable()
export class UsersService {
  create(createUserDto: CreateUserDto) {
    return 'This action adds a new user';
  }

  findAll() {
    return `This action returns all users`;
  }

  findOne(id: number) {
    return `This action returns a #${id} user`;
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}



================================================
FILE: integration/inspector/src/users/dto/create-user.dto.ts
================================================
export class CreateUserDto {}



================================================
FILE: integration/inspector/src/users/dto/update-user.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}



================================================
FILE: integration/inspector/src/users/entities/user.entity.ts
================================================
export class User {}



================================================
FILE: integration/lazy-modules/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/lazy-modules/e2e/lazy-import-global-modules.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as chai from 'chai';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';
import chaiAsPromised = require('chai-as-promised');
chai.use(chaiAsPromised);

describe('Lazy imports', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
  });

  it(`should allow imports of global modules`, async () => {
    await expect(app.init()).to.eventually.be.fulfilled;
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/lazy-modules/e2e/lazy-import-request-providers.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { LazyController } from '../src/lazy.controller';

describe('Lazy Requested Scoped providers', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [LazyController],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it('should not recreate dependencies for default scope', async () => {
    const resultOne = await request(app.getHttpServer()).get('/lazy/request');

    expect(resultOne.text).to.be.equal('Hi! Counter is 1');
    expect(resultOne.statusCode).to.be.equal(200);

    const resultTwo = await request(app.getHttpServer()).get('/lazy/request');

    expect(resultTwo.text).to.be.equal('Hi! Counter is 2');
    expect(resultTwo.statusCode).to.be.equal(200);
  });
});



================================================
FILE: integration/lazy-modules/e2e/lazy-import-transient-providers.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { TransientLazyModule } from '../src/transient.module';
import { LazyController } from '../src/lazy.controller';
import * as chai from 'chai';
import { expect } from 'chai';
import * as request from 'supertest';

describe('Lazy Transient providers', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [LazyController],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it('should not recreate dependencies for default scope', async () => {
    const resultOne = await request(app.getHttpServer()).get('/lazy/transient');

    const resultTwo = await request(app.getHttpServer()).get('/lazy/transient');

    expect(resultOne.text).to.be.equal('Hi! Counter is 1');
    expect(resultOne.statusCode).to.be.equal(200);

    expect(resultTwo.text).to.be.equal('Hi! Counter is 2');
    expect(resultTwo.statusCode).to.be.equal(200);
  });
});



================================================
FILE: integration/lazy-modules/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { LazyModuleLoader } from '@nestjs/core';
import { EagerModule } from './eager.module';
import { GlobalModule } from './global.module';
import { LazyModule } from './lazy.module';

@Module({
  imports: [GlobalModule, EagerModule],
})
export class AppModule {
  constructor(public loader: LazyModuleLoader) {}

  async onApplicationBootstrap() {
    await this.loader.load(() => LazyModule);
  }
}



================================================
FILE: integration/lazy-modules/src/eager.module.ts
================================================
import { Module, Injectable } from '@nestjs/common';
import { GlobalService } from './global.module';

@Injectable()
export class EagerService {
  private counter = 0;
  constructor(public globalService: GlobalService) {}

  sayHello() {
    this.counter++;
    return 'Hi! Counter is ' + this.counter;
  }
}

@Module({
  providers: [EagerService],
})
export class EagerModule {}



================================================
FILE: integration/lazy-modules/src/global.module.ts
================================================
import { Module, Injectable, Global } from '@nestjs/common';

@Injectable()
export class GlobalService {
  constructor() {}
}

@Global()
@Module({
  providers: [GlobalService],
  exports: [GlobalService],
})
export class GlobalModule {}



================================================
FILE: integration/lazy-modules/src/lazy.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { LazyModuleLoader } from '@nestjs/core';

@Controller('lazy')
export class LazyController {
  constructor(private lazyLoadModule: LazyModuleLoader) {}

  @Get('transient')
  async exec() {
    const { TransientLazyModule } = await import('./transient.module');
    const moduleRef = await this.lazyLoadModule.load(() => TransientLazyModule);

    const { TransientService } = await import('./transient.service');
    const _service = await moduleRef.resolve(TransientService);

    return _service.eager();
  }
  @Get('request')
  async execRequestScope() {
    const { RequestLazyModule } = await import('./request.module');
    const moduleRef = await this.lazyLoadModule.load(() => RequestLazyModule);

    const { RequestService } = await import('./request.service');
    const _service = await moduleRef.resolve(RequestService);

    return _service.eager();
  }
}



================================================
FILE: integration/lazy-modules/src/lazy.module.ts
================================================
import { Module, Injectable } from '@nestjs/common';
import { GlobalService } from './global.module';

@Injectable()
export class LazyService {
  constructor(public globalService: GlobalService) {}
}

@Module({
  providers: [LazyService],
})
export class LazyModule {}



================================================
FILE: integration/lazy-modules/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
void bootstrap();



================================================
FILE: integration/lazy-modules/src/request.module.ts
================================================
import { Module } from '@nestjs/common';
import { EagerService } from './eager.module';
import { GlobalService } from './global.module';
import { RequestService } from './request.service';

@Module({
  imports: [],
  providers: [RequestService, GlobalService, EagerService],
  exports: [RequestService],
})
export class RequestLazyModule {}



================================================
FILE: integration/lazy-modules/src/request.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { EagerService } from './eager.module';

@Injectable({ scope: Scope.REQUEST })
export class RequestService {
  constructor(private eagerService: EagerService) {}

  eager() {
    return this.eagerService.sayHello();
  }
}



================================================
FILE: integration/lazy-modules/src/transient.module.ts
================================================
import { Module } from '@nestjs/common';
import { GlobalService } from './global.module';
import { EagerService } from './eager.module';
import { TransientService } from './transient.service';

@Module({
  imports: [],
  providers: [TransientService, GlobalService, EagerService],
  exports: [TransientService],
})
export class TransientLazyModule {}



================================================
FILE: integration/lazy-modules/src/transient.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { EagerService } from './eager.module';

@Injectable({ scope: Scope.TRANSIENT })
export class TransientService {
  constructor(private eagerService: EagerService) {}

  eager() {
    return this.eagerService.sayHello();
  }
}



================================================
FILE: integration/microservices/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/microservices/e2e/broadcast-mqtt.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { MqttBroadcastController } from '../src/mqtt/mqtt-broadcast.controller';

describe('MQTT transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [MqttBroadcastController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.MQTT,
      options: {
        host: '0.0.0.0',
      },
    });
    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.MQTT,
      options: {
        host: '0.0.0.0',
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`Broadcast (2 subscribers)`, () => {
    return request(server).get('/broadcast').expect(200, '2');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/broadcast-nats.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { NatsBroadcastController } from '../src/nats/nats-broadcast.controller';

describe('NATS transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [NatsBroadcastController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.NATS,
      options: {
        servers: 'nats://0.0.0.0:4222',
      },
    });
    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.NATS,
      options: {
        servers: 'servers://0.0.0.0:4222',
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`Broadcast (2 subscribers)`, () => {
    return request(server).get('/broadcast').expect(200, '2');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/broadcast-redis.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { RedisBroadcastController } from '../src/redis/redis-broadcast.controller';

describe('REDIS transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [RedisBroadcastController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.REDIS,
      options: {
        host: '0.0.0.0',
        port: 6379,
      },
    });
    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.REDIS,
      options: {
        host: '0.0.0.0',
        port: 6379,
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`Broadcast (2 subscribers)`, () => {
    return request(server).get('/broadcast').expect(200, '2');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/concurrent-kafka.spec.ts
================================================
import { INestApplication, Logger } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { Admin, ITopicMetadata, Kafka } from 'kafkajs';
import * as request from 'supertest';
import * as util from 'util';
import { KafkaConcurrentController } from '../src/kafka-concurrent/kafka-concurrent.controller';
import { KafkaConcurrentMessagesController } from '../src/kafka-concurrent/kafka-concurrent.messages.controller';

describe.skip('Kafka concurrent', function () {
  const numbersOfServers = 3;

  const requestTopic = 'math.sum.sync.number.wait';
  const responseTopic = 'math.sum.sync.number.wait.reply';

  let admin: Admin;
  const servers: any[] = [];
  const apps: INestApplication[] = [];

  const logger = new Logger('concurrent-kafka.spec.ts');

  // set timeout to be longer (especially for the after hook)
  this.timeout(30000);

  const startServer = async () => {
    const module = await Test.createTestingModule({
      controllers: [
        KafkaConcurrentController,
        KafkaConcurrentMessagesController,
      ],
    }).compile();

    // use our own logger for a little
    // Logger.overrideLogger(new Logger());

    const app = module.createNestApplication();

    const server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.KAFKA,
      options: {
        client: {
          brokers: ['localhost:9092'],
        },
        run: {
          partitionsConsumedConcurrently: numbersOfServers,
        },
      },
    });

    // enable these for clean shutdown
    app.enableShutdownHooks();

    // push to the collection
    servers.push(server);
    apps.push(app);

    // await the start
    await app.startAllMicroservices();
    await app.init();
  };

  it(`Create kafka topics/partitions`, async () => {
    const kafka = new Kafka({
      clientId: 'concurrent-test-admin',
      brokers: ['localhost:9092'],
    });

    admin = kafka.admin();
    await admin.connect();

    let topicMetadata: {
      topics: ITopicMetadata[];
    };

    try {
      topicMetadata = await admin.fetchTopicMetadata({
        topics: [requestTopic, responseTopic],
      });
    } catch (e) {
      // create with number of servers
      try {
        await admin.createTopics({
          topics: [
            {
              topic: requestTopic,
              numPartitions: numbersOfServers,
              replicationFactor: 1,
            },
            {
              topic: responseTopic,
              numPartitions: numbersOfServers,
              replicationFactor: 1,
            },
          ],
        });
      } catch (e) {
        logger.error(util.format('Create topics error: %o', e));
      }
    }

    if (topicMetadata! && topicMetadata.topics.length > 0) {
      // we have topics, how many partitions do they have?
      for (const topic of topicMetadata.topics) {
        if (topic.partitions.length < numbersOfServers) {
          try {
            await admin.createPartitions({
              topicPartitions: [
                {
                  topic: topic.name,
                  count: numbersOfServers,
                },
              ],
            });
          } catch (e) {
            logger.error(util.format('Create partitions error: %o', e));
          }
        }
      }
    }

    // create with number of servers
    try {
      await admin.createTopics({
        topics: [
          {
            topic: requestTopic,
            numPartitions: numbersOfServers,
            replicationFactor: 1,
          },
          {
            topic: responseTopic,
            numPartitions: numbersOfServers,
            replicationFactor: 1,
          },
        ],
      });
    } catch (e) {
      logger.error(util.format('Create topics error: %o', e));
    }

    // disconnect
    await admin.disconnect();
  });

  it(`Start Kafka apps`, async () => {
    // start all at once
    await Promise.all(
      Array(numbersOfServers)
        .fill(1)
        .map(async (v, i) => {
          // return startServer();

          // wait in intervals so the consumers start in order
          return new Promise<void>(resolve => {
            setTimeout(async () => {
              await startServer();

              return resolve();
            }, 1000 * i);
          });
        }),
    );
  }).timeout(30000);

  it(`Concurrent messages without forcing a rebalance.`, async () => {
    // wait a second before notifying the servers to respond
    setTimeout(async () => {
      // notify the other servers that it is time to respond
      await Promise.all(
        servers.map(async server => {
          // send to all servers since indexes don't necessarily align with server consumers
          return request(server).post('/go').send();
        }),
      );
    }, 1000);

    await Promise.all(
      servers.map(async (server, index) => {
        // send requests
        const payload = {
          key: index,
          numbers: [1, index],
        };
        const result = (1 + index).toString();

        return request(server)
          .post('/mathSumSyncNumberWait')
          .send(payload)
          .expect(200)
          .expect(200, result);
      }),
    );
  });

  it(`Close kafka client consumer while waiting for message pattern response.`, async () => {
    await Promise.all(
      servers.map(async (server, index) => {
        // shut off and delete the leader
        if (index === 0) {
          return new Promise<void>(resolve => {
            // wait a second before closing so the producers can send the message to the server consumers
            setTimeout(async () => {
              // get the controller
              const controller = apps[index].get(KafkaConcurrentController);

              // close the controller clients
              await controller.client.close();

              // notify the other servers that we have stopped
              await Promise.all(
                servers.map(async server => {
                  // send to all servers since indexes don't necessarily align with server consumers
                  return request(server).post('/go').send();
                }),
              );

              return resolve();
            }, 1000);
          });
        }

        // send requests
        const payload = {
          key: index,
          numbers: [1, index],
        };
        const result = (1 + index).toString();

        return request(server)
          .post('/mathSumSyncNumberWait')
          .send(payload)
          .expect(200)
          .expect(200, result);
      }),
    );
  });

  it(`Start kafka client consumer while waiting for message pattern response.`, async () => {
    await Promise.all(
      servers.map(async (server, index) => {
        // shut off and delete the leader
        if (index === 0) {
          return new Promise<void>(resolve => {
            // wait a second before closing so the producers can send the message to the server consumers
            setTimeout(async () => {
              // get the controller
              const controller = apps[index].get(KafkaConcurrentController);

              // connect the controller client
              await controller.client.connect();

              // notify the servers that we have started
              await Promise.all(
                servers.map(async server => {
                  // send to all servers since indexes don't necessarily align with server consumers
                  return request(server).post('/go').send();
                }),
              );

              return resolve();
            }, 1000);
          });
        }

        // send requests
        const payload = {
          key: index,
          numbers: [1, index],
        };
        const result = (1 + index).toString();

        return request(server)
          .post('/mathSumSyncNumberWait')
          .send(payload)
          .expect(200)
          .expect(200, result);
      }),
    );
  });

  after(`Stopping Kafka app`, async () => {
    // close all concurrently
    return Promise.all(
      apps.map(async app => {
        return app.close();
      }),
    );
  });
});



================================================
FILE: integration/microservices/e2e/disconnected-client.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { App } from 'supertest/types';
import { DisconnectedClientController } from '../src/disconnected.controller';

describe('Disconnected client', () => {
  let server: App;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [DisconnectedClientController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    await app.init();
  });

  it(`TCP`, () => {
    return request(server)
      .post('/')
      .send({
        transport: Transport.TCP,
      })
      .expect(408);
  });

  it(`REDIS`, () => {
    return request(server)
      .post('/')
      .send({
        transport: Transport.REDIS,
        options: {
          port: '3333',
        },
      })
      .expect(408);
  });

  it(`NATS`, () => {
    return request(server)
      .post('/')
      .send({
        transport: Transport.NATS,
        options: {
          servers: 'nats://localhost:4224',
        },
      })
      .expect(408);
  });

  it(`MQTT`, () => {
    return request(server)
      .post('/')
      .send({
        transport: Transport.MQTT,
        options: {
          host: 'mqtt://broker.hivemq.com',
          port: 183,
        },
      })
      .expect(408);
  });

  it(`RMQ`, () => {
    return request(server)
      .post('/')
      .send({
        transport: Transport.RMQ,
        options: {
          urls: [`amqp://0.0.0.0:3333`],
          queue: 'test',
        },
      })
      .expect(408);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/math-grpc.spec.ts
================================================
import * as GRPC from '@grpc/grpc-js';
import * as ProtoLoader from '@grpc/proto-loader';
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { fail } from 'assert';
import { expect, use } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { join } from 'path';
import * as sinon from 'sinon';
import * as request from 'supertest';
import { GrpcController } from '../src/grpc/grpc.controller';

use(chaiAsPromised);

describe('GRPC transport', () => {
  let server;
  let app: INestApplication;
  let client: any;

  before(async () => {
    const module = await Test.createTestingModule({
      controllers: [GrpcController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.GRPC,
      options: {
        package: ['math', 'math2'],
        protoPath: [
          join(__dirname, '../src/grpc/math.proto'),
          join(__dirname, '../src/grpc/math2.proto'),
        ],
      },
    });

    // Start gRPC microservice
    await app.startAllMicroservices();
    await app.init();
    // Load proto-buffers for test gRPC dispatch
    const proto = ProtoLoader.loadSync(
      join(__dirname, '../src/grpc/math.proto'),
    ) as any;
    // Create Raw gRPC client object
    const protoGRPC = GRPC.loadPackageDefinition(proto) as any;
    // Create client connected to started services at standard 5000 port
    client = new protoGRPC.math.Math(
      'localhost:5000',
      GRPC.credentials.createInsecure(),
    );
  });

  it(`GRPC Sending and Receiving HTTP POST`, async () => {
    await request(server)
      .post('/sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, { result: 15 });

    await request(server)
      .post('/upperMethod/sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, { result: 15 });
  });

  it(`GRPC Receiving serialized Error`, async () => {
    await request(server)
      .post('/error?client=standard')
      .expect(200)
      .expect('false');

    await request(server)
      .post('/error?client=custom')
      .expect(200)
      .expect('true');
  });

  it(`GRPC Sending and Receiving HTTP POST (multiple proto)`, async () => {
    await request(server)
      .post('/multi/sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, { result: 15 });

    await request(server)
      .post('/multi/sum2')
      .send([1, 2, 3, 4, 5])
      .expect(200, { result: 15 });
  });

  it('GRPC Sending and receiving Stream from RX handler', async () => {
    const callHandler = client.SumStream();

    callHandler.on('data', (msg: number) => {
      expect(msg).to.eql({ result: 15 });
      callHandler.cancel();
    });

    callHandler.on('error', (err: any) => {
      // We want to fail only on real errors while Cancellation error
      // is expected
      if (!String(err).toLowerCase().includes('cancelled')) {
        fail('gRPC Stream error happened, error: ' + err);
      }
    });

    return new Promise((resolve, reject) => {
      callHandler.write({ data: [1, 2, 3, 4, 5] });
      setTimeout(() => resolve(), 1000);
    });
  });

  it('GRPC Sending and receiving Stream from Call Passthrough handler', async () => {
    const callHandler = client.SumStreamPass();

    callHandler.on('data', (msg: number) => {
      expect(msg).to.eql({ result: 15 });
      callHandler.cancel();
    });

    callHandler.on('error', (err: any) => {
      // We want to fail only on real errors while Cancellation error
      // is expected
      if (!String(err).toLowerCase().includes('cancelled')) {
        fail('gRPC Stream error happened, error: ' + err);
      }
    });

    return new Promise((resolve, reject) => {
      callHandler.write({ data: [1, 2, 3, 4, 5] });
      setTimeout(() => resolve(), 1000);
    });
  });

  it(`GRPC with backpressure control`, async function () {
    // This test hit the gRPC server with 1000 messages, but the server
    // has to process large (> 1MB) messages, so it will definitely hit
    // issues where writing to the stream needs to be paused until a drain
    // event. Prior to this test, a bug existed where the server would
    // send the incorrect number of messages due to improper backpressure
    // handling that wrote messages more than once.
    this.timeout(10000);

    const largeMessages = client.streamLargeMessages();
    // [0, 1, 2, ..., 999]
    const expectedIds = Array.from({ length: 1000 }, (_, n) => n);
    const receivedIds: number[] = [];

    await largeMessages.forEach(msg => {
      receivedIds.push(msg.id);
    });

    expect(receivedIds).to.deep.equal(expectedIds);
  });

  describe('streaming calls that error', () => {
    // We want to assert that the application does not crash when an error is encountered with an unhandledRejection
    // the best way to do that is to listen for the unhandledRejection event and fail the test if it is called
    let processSpy: sinon.SinonSpy;

    beforeEach(() => {
      processSpy = sinon.spy();
      process.on('unhandledRejection', processSpy);
    });

    afterEach(() => {
      process.off('unhandledRejection', processSpy);
    });

    it('should not crash when replying with an error', async () => {
      const call = new Promise<void>((resolve, reject) => {
        const stream = client.streamDivide({
          data: [{ dividend: 1, divisor: 0 }],
        });

        stream.on('data', () => {
          fail('Stream should not have emitted any data');
        });

        stream.on('error', err => {
          if (err.code !== GRPC.status.CANCELLED) {
            reject(err as Error);
          }
        });

        stream.on('end', () => {
          resolve();
        });
      });

      await expect(call).to.eventually.be.rejectedWith(
        '3 INVALID_ARGUMENT: dividing by 0 is not possible',
      );

      // if this fails the application has crashed
      expect(processSpy.called).to.be.false;
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/mqtt-record-builder.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { MqttController } from '../src/mqtt/mqtt.controller';

describe('MQTT transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [MqttController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.MQTT,
      options: {
        url: 'mqtt://0.0.0.0:1883',
        subscribeOptions: {
          qos: 1,
        },
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST (setting packet options with "RecordBuilder")`, () => {
    const payload = { items: [1, 2, 3] };
    return request(server)
      .post('/record-builder-duplex')
      .send(payload)
      .expect(200, {
        data: payload,
        qos: 1,
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/orders-grpc.spec.ts
================================================
import * as GRPC from '@grpc/grpc-js';
import * as ProtoLoader from '@grpc/proto-loader';
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { ExpressAdapter } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { fail } from 'assert';
import { expect } from 'chai';
import * as express from 'express';
import { join } from 'path';
import * as request from 'supertest';
import { AdvancedGrpcController } from '../src/grpc-advanced/advanced.grpc.controller';

describe('Advanced GRPC transport', () => {
  let server;
  let app: INestApplication;
  let client: any;

  before(async () => {
    const module = await Test.createTestingModule({
      controllers: [AdvancedGrpcController],
    }).compile();
    // Create gRPC + HTTP server
    server = express();
    app = module.createNestApplication(new ExpressAdapter(server));
    /*
     *  Create microservice configuration
     */
    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.GRPC,
      options: {
        url: 'localhost:5001',
        package: 'proto_example',
        protoPath: 'root.proto',
        loader: {
          includeDirs: [join(__dirname, '../src/grpc-advanced/proto')],
          keepCase: true,
        },
      },
    });
    // Start gRPC microservice
    await app.startAllMicroservices();
    await app.init();
    // Load proto-buffers for test gRPC dispatch
    const proto = ProtoLoader.loadSync('root.proto', {
      includeDirs: [join(__dirname, '../src/grpc-advanced/proto')],
    }) as any;
    // Create Raw gRPC client object
    const protoGRPC = GRPC.loadPackageDefinition(proto) as any;
    // Create client connected to started services at standard 5000 port
    client = new protoGRPC.proto_example.orders.OrderService(
      'localhost:5001',
      GRPC.credentials.createInsecure(),
    );
  });

  it(`GRPC Sending and Receiving HTTP POST`, () => {
    return request(server)
      .post('/')
      .send('1')
      .expect(200, {
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
  });

  it(`GRPC Streaming and Receiving HTTP POST`, () => {
    return request(server)
      .post('/client-streaming')
      .send('1')
      .expect(200, {
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
  });

  it('GRPC Sending and receiving message', async () => {
    // Execute find in Promise
    return new Promise(resolve => {
      client.find(
        {
          id: 1,
        },
        (err, result) => {
          // Compare results
          expect(err).to.be.null;
          expect(result).to.eql({
            id: 1,
            itemTypes: [1],
            shipmentType: {
              from: 'test',
              to: 'test1',
              carrier: 'test-carrier',
            },
          });
          // Resolve after checkups
          resolve();
        },
      );
    });
  });

  it('GRPC Sending and receiving Stream from RX handler', async () => {
    const callHandler = client.sync();

    // Get Set-Cookie from Metadata
    callHandler.on('metadata', (metadata: GRPC.Metadata) => {
      expect(metadata.get('Set-Cookie')[0]).to.eq('test_cookie=abcd');
    });

    callHandler.on('data', (msg: number) => {
      // Do deep comparison (to.eql)
      expect(msg).to.eql({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });

    callHandler.on('error', (err: any) => {
      // We want to fail only on real errors while Cancellation error
      // is expected
      if (!String(err).toLowerCase().includes('cancelled')) {
        fail('gRPC Stream error happened, error: ' + err);
      }
    });

    return new Promise((resolve, reject) => {
      callHandler.write({
        id: 1,
      });
      setTimeout(() => resolve(), 1000);
    });
  });

  it('GRPC Sending and receiving Stream from Call handler', async () => {
    const callHandler = client.syncCall();

    callHandler.on('data', (msg: number) => {
      // Do deep comparison (to.eql)
      expect(msg).to.eql({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });

    callHandler.on('error', (err: any) => {
      // We want to fail only on real errors while Cancellation error
      // is expected
      if (!String(err).toLowerCase().includes('cancelled')) {
        fail('gRPC Stream error happened, error: ' + err);
      }
    });

    return new Promise((resolve, reject) => {
      callHandler.write({
        id: 1,
      });
      setTimeout(() => resolve(), 1000);
    });
  });

  it('GRPC Sending Stream and receiving a single message from RX handler', async () => {
    const callHandler = client.streamReq((err, res) => {
      if (err) {
        throw err;
      }
      expect(res).to.eql({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });

    return new Promise((resolve, reject) => {
      callHandler.write({
        id: 1,
      });
      setTimeout(() => resolve(), 1000);
    });
  });

  it('GRPC Sending Stream and receiving a single message from Call handler', async () => {
    const callHandler = client.streamReqCall((err, res) => {
      if (err) {
        throw err;
      }
      expect(res).to.eql({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });

    return new Promise((resolve, reject) => {
      callHandler.write({
        id: 1,
      });
      setTimeout(() => resolve(), 1000);
    });
  });
});



================================================
FILE: integration/microservices/e2e/sum-kafka.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { BusinessDto } from '../src/kafka/dtos/business.dto';
import { UserDto } from '../src/kafka/dtos/user.dto';
import { UserEntity } from '../src/kafka/entities/user.entity';
import { KafkaController } from '../src/kafka/kafka.controller';
import { KafkaMessagesController } from '../src/kafka/kafka.messages.controller';

/**
 * Skip this flaky test in CI/CD pipeline as it frequently
 * fails to connect to Kafka container in the cloud.
 */
describe.skip('Kafka transport', function () {
  let server: any;
  let app: INestApplication;

  // set timeout to be longer (especially for the after hook)
  this.timeout(50000);
  this.retries(10);

  before(`Start Kafka app`, async function () {
    const module = await Test.createTestingModule({
      controllers: [KafkaController, KafkaMessagesController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.KAFKA,
      options: {
        client: {
          brokers: ['localhost:9092'],
        },
      },
    });
    app.enableShutdownHooks();
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST (sync sum kafka message)`, function () {
    return request(server)
      .post('/mathSumSyncKafkaMessage')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (sync sum kafka(ish) message without key and only the value)`, () => {
    return request(server)
      .post('/mathSumSyncWithoutKey')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (sync sum plain object)`, () => {
    return request(server)
      .post('/mathSumSyncPlainObject')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (sync sum array)`, () => {
    return request(server)
      .post('/mathSumSyncArray')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (sync sum string)`, () => {
    return request(server)
      .post('/mathSumSyncString')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (sync sum number)`, () => {
    return request(server)
      .post('/mathSumSyncNumber')
      .send([12345])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (async event notification)`, done => {
    void request(server)
      .post('/notify')
      .send()
      .end(() => {
        setTimeout(() => {
          expect(KafkaController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  const userDto: UserDto = {
    email: 'enriquebenavidesm@gmail.com',
    name: 'Ben',
    phone: '1112223331',
    years: 33,
  };
  const newUser: UserEntity = new UserEntity(userDto);
  const businessDto: BusinessDto = {
    name: 'Example',
    phone: '2233441122',
    user: newUser,
  };
  it(`/POST (sync command create user)`, () => {
    return request(server).post('/user').send(userDto).expect(200);
  });

  it(`/POST (sync command create business`, () => {
    return request(server).post('/business').send(businessDto).expect(200);
  });

  it(`/POST (sync command create user) Concurrency Test`, async () => {
    const promises = [] as Array<Promise<any>>;
    for (let concurrencyKey = 0; concurrencyKey < 100; concurrencyKey++) {
      const innerUserDto = JSON.parse(JSON.stringify(userDto));
      innerUserDto.name += `+${concurrencyKey}`;
      promises.push(request(server).post('/user').send(userDto).expect(200));
    }
    await Promise.all(promises);
  });

  after(`Stopping Kafka app`, async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-mqtt.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { MqttController } from '../src/mqtt/mqtt.controller';

describe('MQTT transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [MqttController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.MQTT,
      options: {
        url: 'mqtt://0.0.0.0:1883',
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST`, () => {
    return request(server)
      .post('/?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=asyncSum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=streamSum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  }).timeout(5000);

  it(`/POST (concurrent)`, function () {
    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  }).timeout(5000);

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  }).timeout(5000);

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(MqttController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (wildcard EVENT #)`, done => {
    void request(server)
      .post('/wildcard-event')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(MqttController.IS_WILDCARD_EVENT_RECEIVED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (wildcard MESSAGE #)`, () => {
    return request(server)
      .post('/wildcard-message')
      .send([1, 2, 3, 4, 5])
      .expect(201, '15');
  });

  it(`/POST (wildcard EVENT +)`, done => {
    void request(server)
      .post('/wildcard-event2')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(MqttController.IS_WILDCARD2_EVENT_RECEIVED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (wildcard MESSAGE +)`, () => {
    return request(server)
      .post('/wildcard-message2')
      .send([1, 2, 3, 4, 5])
      .expect(201, '15');
  });

  it(`/POST (shared wildcard EVENT #)`, done => {
    void request(server)
      .post('/shared-wildcard-event')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(MqttController.IS_SHARED_WILDCARD_EVENT_RECEIVED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (shared wildcard MESSAGE #)`, () => {
    return request(server)
      .post('/shared-wildcard-message')
      .send([1, 2, 3, 4, 5])
      .expect(201, '15');
  });

  it(`/POST (shared wildcard EVENT +)`, done => {
    void request(server)
      .post('/shared-wildcard-event2')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(MqttController.IS_SHARED_WILDCARD2_EVENT_RECEIVED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (shared wildcard MESSAGE +)`, () => {
    return request(server)
      .post('/shared-wildcard-message2')
      .send([1, 2, 3, 4, 5])
      .expect(201, '15');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-nats.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { NatsController } from '../src/nats/nats.controller';
import { NatsService } from '../src/nats/nats.service';

describe('NATS transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [NatsController],
      providers: [NatsService],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.NATS,
      options: {
        servers: 'nats://0.0.0.0:4222',
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST`, () => {
    return request(server)
      .post('/?command=math.sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=async.sum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=stream.sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (concurrent)`, () => {
    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  });

  it(`/GET (exception)`, () => {
    return request(server).get('/exception').expect(200, {
      message: 'test',
      status: 'error',
    });
  });

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(NatsController.IS_NOTIFIED).to.be.true;
          expect(NatsController.IS_NOTIFIED2).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (sending headers with "RecordBuilder")`, () => {
    const payload = { items: [1, 2, 3] };
    return request(server)
      .post('/record-builder-duplex')
      .send(payload)
      .expect(200, {
        data: payload,
        headers: {
          ['x-version']: '1.0.0',
        },
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-redis.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { RedisController } from '../src/redis/redis.controller';

describe('REDIS transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [RedisController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.REDIS,
      options: {
        host: '0.0.0.0',
        port: 6379,
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST`, () => {
    return request(server)
      .post('/?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=asyncSum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=streamSum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (concurrent)`, function () {
    this.retries(10);

    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  }).timeout(5000);

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(RedisController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-rmq.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { RMQController } from '../src/rmq/rmq.controller';

describe('RabbitMQ transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      controllers: [RMQController],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.RMQ,
      options: {
        urls: [`amqp://0.0.0.0:5672`],
        queue: 'test',
        queueOptions: { durable: false },
        socketOptions: { noDelay: true },
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST`, () => {
    return request(server)
      .post('/?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=asyncSum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=streamSum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (concurrent)`, () => {
    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  });

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (multiple-urls)`, () => {
    return request(server)
      .post('/multiple-urls')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  }).timeout(10000);

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(RMQController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  it(`/POST (sending options with "RecordBuilder")`, () => {
    const payload = { items: [1, 2, 3] };
    return request(server)
      .post('/record-builder-duplex')
      .send(payload)
      .expect(200, {
        data: payload,
        headers: {
          ['x-version']: '1.0.0',
        },
        priority: 3,
      });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-rpc-async.spec.ts
================================================
import {
  Controller,
  INestMicroservice,
  Injectable,
  Module,
} from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import {
  AsyncOptions,
  ClientTCP,
  ClientsModule,
  MessagePattern,
  MicroserviceOptions,
  Payload,
  TcpOptions,
  Transport,
} from '@nestjs/microservices';
import { expect } from 'chai';

let port: number;

do {
  port = Math.round(Math.random() * 10000);
} while (port < 1000);

@Injectable()
class RpcOptionsProvider {
  getOptions(): TcpOptions {
    return {
      transport: Transport.TCP,
      options: {
        port,
        host: '0.0.0.0',
      },
    };
  }
}

@Controller()
class RpcController {
  @MessagePattern({ cmd: 'sum' })
  sumPayload(@Payload() payload: number[]) {
    return payload.reduce((a, b) => a + b, 0);
  }
}

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'RPC_CLIENT',
        transport: Transport.TCP,
        options: {
          port,
          host: '0.0.0.0',
        },
      },
    ]),
  ],
  controllers: [RpcController],
  providers: [RpcOptionsProvider],
})
class RpcModule {}

describe('RPC Async transport', () => {
  let app: INestMicroservice;
  let client: ClientTCP;

  beforeEach(async () => {
    app = await NestFactory.createMicroservice<
      AsyncOptions<MicroserviceOptions>
    >(RpcModule, {
      logger: false,
      inject: [RpcOptionsProvider],
      useFactory: (optionsProvider: RpcOptionsProvider) =>
        optionsProvider.getOptions(),
    });

    await app.listen();
    client = app.get('RPC_CLIENT', { strict: false });
  });

  it(`/POST`, done => {
    let retData = 0;
    client.send({ cmd: 'sum' }, [1, 2, 3, 4, 5]).subscribe({
      next: val => (retData += val),
      error: done,
      complete: () => {
        expect(retData).to.eq(15);
        done();
      },
    });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-rpc-tls.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as fs from 'fs';
import * as path from 'path';
import * as request from 'supertest';
import { AppController } from '../src/tcp-tls/app.controller';
import { ApplicationModule } from '../src/tcp-tls/app.module';

describe('RPC TLS transport', () => {
  let server;
  let app: INestApplication;
  let key: string;
  let cert: string;

  before(() => {
    // Generate a self-signed key pair
    key = fs
      .readFileSync(path.join(__dirname, '../src/tcp-tls/privkey.pem'), 'utf8')
      .toString();
    cert = fs
      .readFileSync(path.join(__dirname, '../src/tcp-tls/ca.cert.pem'), 'utf8')
      .toString();
  });

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [ApplicationModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice({
      transport: Transport.TCP,
      options: {
        host: '0.0.0.0',
        tlsOptions: { key: key, cert: cert },
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST TLS`, () => {
    return request(server)
      .post('/?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=asyncSum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=streamSum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (useFactory client)`, () => {
    return request(server)
      .post('/useFactory?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (useClass client)`, () => {
    return request(server)
      .post('/useClass?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (concurrent)`, () => {
    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  });

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (pattern not found)`, () => {
    return request(server).post('/?command=test').expect(500);
  });

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(AppController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  it('/POST (custom client)', () => {
    return request(server)
      .post('/error?client=custom')
      .send({})
      .expect(200)
      .expect('true');
  });

  it('/POST (standard client)', () => {
    return request(server)
      .post('/error?client=standard')
      .send({})
      .expect(200)
      .expect('false');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/e2e/sum-rpc.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { AppController } from '../src/app.controller';
import { AppModule } from '../src/app.module';

describe('RPC transport', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpAdapter().getInstance();

    app.connectMicroservice<MicroserviceOptions>({
      transport: Transport.TCP,
      options: {
        host: '0.0.0.0',
      },
    });
    await app.startAllMicroservices();
    await app.init();
  });

  it(`/POST`, () => {
    return request(server)
      .post('/?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (Promise/async)`, () => {
    return request(server)
      .post('/?command=asyncSum')
      .send([1, 2, 3, 4, 5])
      .expect(200)
      .expect(200, '15');
  });

  it(`/POST (Observable stream)`, () => {
    return request(server)
      .post('/?command=streamSum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (useFactory client)`, () => {
    return request(server)
      .post('/useFactory?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (useClass client)`, () => {
    return request(server)
      .post('/useClass?command=sum')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (concurrent)`, () => {
    return request(server)
      .post('/concurrent')
      .send([
        Array.from({ length: 10 }, (v, k) => k + 1),
        Array.from({ length: 10 }, (v, k) => k + 11),
        Array.from({ length: 10 }, (v, k) => k + 21),
        Array.from({ length: 10 }, (v, k) => k + 31),
        Array.from({ length: 10 }, (v, k) => k + 41),
        Array.from({ length: 10 }, (v, k) => k + 51),
        Array.from({ length: 10 }, (v, k) => k + 61),
        Array.from({ length: 10 }, (v, k) => k + 71),
        Array.from({ length: 10 }, (v, k) => k + 81),
        Array.from({ length: 10 }, (v, k) => k + 91),
      ])
      .expect(200, 'true');
  });

  it(`/POST (streaming)`, () => {
    return request(server)
      .post('/stream')
      .send([1, 2, 3, 4, 5])
      .expect(200, '15');
  });

  it(`/POST (pattern not found)`, () => {
    return request(server).post('/?command=test').expect(500);
  });

  it(`/POST (event notification)`, done => {
    void request(server)
      .post('/notify')
      .send([1, 2, 3, 4, 5])
      .end(() => {
        setTimeout(() => {
          expect(AppController.IS_NOTIFIED).to.be.true;
          done();
        }, 1000);
      });
  });

  it('/POST (custom client)', () => {
    return request(server)
      .post('/error?client=custom')
      .send({})
      .expect(200)
      .expect('true');
  });

  it('/POST (standard client)', () => {
    return request(server)
      .post('/error?client=standard')
      .send({})
      .expect(200)
      .expect('false');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/microservices/src/app.controller.ts
================================================
import {
  Body,
  Controller,
  HttpCode,
  Inject,
  Post,
  Query,
} from '@nestjs/common';
import {
  Client,
  ClientProxy,
  EventPattern,
  MessagePattern,
  RpcException,
  Transport,
} from '@nestjs/microservices';
import { from, lastValueFrom, Observable, of, throwError } from 'rxjs';
import { catchError, scan } from 'rxjs/operators';

@Controller()
export class AppController {
  constructor(
    @Inject('USE_CLASS_CLIENT') private useClassClient: ClientProxy,
    @Inject('USE_FACTORY_CLIENT') private useFactoryClient: ClientProxy,
    @Inject('CUSTOM_PROXY_CLIENT') private customClient: ClientProxy,
  ) {}
  static IS_NOTIFIED = false;

  @Client({ transport: Transport.TCP })
  client: ClientProxy;

  @Post()
  @HttpCode(200)
  call(@Query('command') cmd, @Body() data: number[]): Observable<number> {
    return this.client.send<number>({ cmd }, data);
  }

  @Post('useFactory')
  @HttpCode(200)
  callWithClientUseFactory(
    @Query('command') cmd,
    @Body() data: number[],
  ): Observable<number> {
    return this.useFactoryClient.send<number>({ cmd }, data);
  }

  @Post('useClass')
  @HttpCode(200)
  callWithClientUseClass(
    @Query('command') cmd,
    @Body() data: number[],
  ): Observable<number> {
    return this.useClassClient.send<number>({ cmd }, data);
  }

  @Post('stream')
  @HttpCode(200)
  stream(@Body() data: number[]): Observable<number> {
    return this.client
      .send<number>({ cmd: 'streaming' }, data)
      .pipe(scan((a, b) => a + b));
  }

  @Post('concurrent')
  @HttpCode(200)
  concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>({ cmd: 'sum' }, tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @Post('error')
  @HttpCode(200)
  serializeError(
    @Query('client') query: 'custom' | 'standard' = 'standard',
    @Body() body: Record<string, any>,
  ): Observable<boolean> {
    const client = query === 'custom' ? this.customClient : this.client;
    return client.send({ cmd: 'err' }, {}).pipe(
      catchError(err => {
        return of(err instanceof RpcException);
      }),
    );
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'asyncSum' })
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'streamSum' })
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'streaming' })
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @MessagePattern({ cmd: 'err' })
  throwAnError() {
    return throwError(() => new Error('err'));
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @EventPattern('notification')
  eventHandler(data: boolean) {
    AppController.IS_NOTIFIED = data;
  }
}



================================================
FILE: integration/microservices/src/app.module.ts
================================================
import { Module, Injectable } from '@nestjs/common';
import { AppController } from './app.controller';
import {
  ClientsModule,
  Transport,
  ClientsModuleOptionsFactory,
  ClientOptions,
  ClientTCP,
  RpcException,
} from '@nestjs/microservices';

class ErrorHandlingProxy extends ClientTCP {
  serializeError(err) {
    return new RpcException(err);
  }
}

@Injectable()
class ConfigService {
  private readonly config = {
    transport: Transport.TCP,
  };
  get(key: string) {
    return this.config[key];
  }
}

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
class ConfigModule {}

@Injectable()
class ClientOptionService implements ClientsModuleOptionsFactory {
  constructor(private readonly configService: ConfigService) {}
  createClientOptions(): Promise<ClientOptions> | ClientOptions {
    return {
      transport: this.configService.get('transport'),
      options: {},
    };
  }
}

@Module({
  imports: [
    ClientsModule.registerAsync([
      {
        imports: [ConfigModule],
        name: 'USE_FACTORY_CLIENT',
        useFactory: (configService: ConfigService) => ({
          transport: configService.get('transport'),
          options: {},
        }),
        inject: [ConfigService],
      },
      {
        imports: [ConfigModule],
        name: 'USE_CLASS_CLIENT',
        useClass: ClientOptionService,
        inject: [ConfigService],
      },
      {
        imports: [ConfigModule],
        inject: [ConfigService],
        name: 'CUSTOM_PROXY_CLIENT',
        useFactory: (config: ConfigService) => ({
          customClass: ErrorHandlingProxy,
        }),
      },
    ]),
  ],
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: integration/microservices/src/disconnected.controller.ts
================================================
import {
  Body,
  Controller,
  InternalServerErrorException,
  Post,
  RequestTimeoutException,
} from '@nestjs/common';
import { ClientProxyFactory } from '@nestjs/microservices';
import { Observable, throwError } from 'rxjs';
import { catchError, tap } from 'rxjs/operators';

@Controller()
export class DisconnectedClientController {
  @Post()
  call(@Body() options): Observable<number> {
    const client = ClientProxyFactory.create(options);
    return client.send<number, number[]>({ cmd: 'none' }, [1, 2, 3]).pipe(
      // tap(
      //   console.log.bind(console, 'data'),
      //   console.error.bind(console, 'error'),
      // ),
      catchError(error => {
        const { code } = error?.err ?? error ?? { code: 'CONN_ERR' };
        return throwError(() =>
          code === 'ECONNREFUSED' ||
          code === 'CONN_ERR' ||
          code === 'ENOTFOUND' ||
          code === 'CONNECTION_REFUSED' ||
          error.message.includes('Connection is closed.')
            ? new RequestTimeoutException('ECONNREFUSED')
            : new InternalServerErrorException(),
        );
      }),
      tap({
        error: () => client.close(),
      }),
    );
  }
}



================================================
FILE: integration/microservices/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { ApplicationModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  await app.listen(3000);
}
void bootstrap();



================================================
FILE: integration/microservices/src/grpc/grpc.controller.ts
================================================
import { Body, Controller, HttpCode, Post, Query } from '@nestjs/common';
import {
  Client,
  ClientGrpc,
  ClientGrpcProxy,
  GrpcMethod,
  GrpcStreamCall,
  GrpcStreamMethod,
  RpcException,
  Transport,
} from '@nestjs/microservices';
import { join } from 'path';
import { catchError, from, mergeMap, Observable, of } from 'rxjs';

class ErrorHandlingProxy extends ClientGrpcProxy {
  serializeError(err) {
    return new RpcException(err);
  }
}

@Controller()
export class GrpcController {
  private readonly customClient: ClientGrpc;
  constructor() {
    this.customClient = new ErrorHandlingProxy({
      package: 'math',
      protoPath: join(__dirname, 'math.proto'),
    });
  }

  @Client({
    transport: Transport.GRPC,
    options: {
      package: 'math',
      protoPath: join(__dirname, 'math.proto'),
    },
  })
  client: ClientGrpc;

  @Client({
    transport: Transport.GRPC,
    options: {
      package: ['math', 'math2'],
      protoPath: [
        join(__dirname, 'math.proto'),
        join(__dirname, 'math2.proto'),
      ],
    },
  })
  clientMulti: ClientGrpc;

  @Post('sum')
  @HttpCode(200)
  call(@Body() data: number[]): Observable<number> {
    const svc = this.client.getService<any>('Math');
    return svc.sum({ data });
  }

  // Test that getService generate both lower and uppercase method
  @Post('upperMethod/sum')
  @HttpCode(200)
  callWithOptions(@Body() data: number[]): Observable<number> {
    const svc = this.client.getService<any>('Math');
    return svc.Sum({ data });
  }

  @GrpcMethod('Math')
  async sum({ data }: { data: number[] }): Promise<any> {
    return of({
      result: data.reduce((a, b) => a + b),
    });
  }

  @GrpcStreamMethod('Math')
  async sumStream(messages: Observable<any>): Promise<any> {
    return new Promise<any>((resolve, reject) => {
      messages.subscribe({
        next: msg => {
          resolve({
            result: msg.data.reduce((a, b) => a + b),
          });
        },
        error: err => {
          reject(err as Error);
        },
      });
    });
  }

  @GrpcStreamCall('Math')
  async sumStreamPass(stream: any) {
    stream.on('data', (msg: any) => {
      stream.write({ result: msg.data.reduce((a, b) => a + b) });
    });
  }

  @GrpcMethod('Math')
  async divide(request: { dividend: number; divisor: number }): Promise<any> {
    if (request.divisor === 0) {
      throw new RpcException({
        code: 3,
        message: 'dividing by 0 is not possible',
      });
    }
    return {
      result: request.dividend / request.divisor,
    };
  }

  // contrived example meant to show when an error is encountered, like dividing by zero, the
  // application does not crash and the error is returned appropriately to the client
  @GrpcMethod('Math', 'StreamDivide')
  streamDivide({
    data,
  }: {
    data: { dividend: number; divisor: number }[];
  }): Observable<any> {
    return from(data).pipe(mergeMap(request => this.divide(request)));
  }

  @GrpcMethod('Math2')
  async sum2({ data }: { data: number[] }): Promise<any> {
    return of({
      result: data.reduce((a, b) => a + b),
    });
  }

  @Post('multi/sum')
  @HttpCode(200)
  callMultiSum(@Body() data: number[]): Observable<number> {
    const svc = this.clientMulti.getService<any>('Math');
    return svc.sum({ data });
  }

  @Post('multi/sum2')
  @HttpCode(200)
  callMultiSum2(@Body() data: number[]): Observable<number> {
    const svc = this.clientMulti.getService<any>('Math2');
    return svc.sum2({ data });
  }

  @GrpcMethod('Math')
  streamLargeMessages(_req: unknown, _meta: unknown) {
    // Send 1000 messages of >1MB each relatively fast
    // This should be enough to trigger backpressure issues
    // while writing to the socket.
    return new Observable(subscriber => {
      let n = 0;
      const interval = setInterval(() => {
        // We'll be checking the ids. The `data` is just to make the
        // message large enough to trigger backpressure issues.
        subscriber.next({ id: n++, data: 'a'.repeat(1024 * 1024) });
        if (n === 1000) {
          subscriber.complete();
        }
      }, 0);
      return () => {
        clearInterval(interval);
      };
    });
  }

  @Post('error')
  @HttpCode(200)
  serializeError(
    @Query('client') query: 'custom' | 'standard' = 'standard',
    @Body() body: Record<string, any>,
  ): Observable<boolean> {
    const client = query === 'custom' ? this.customClient : this.client;
    const svc = client.getService<any>('Math');

    const errorDivideRequest = {
      dividend: 1,
      divisor: 0,
    };
    return svc.divide(errorDivideRequest).pipe(
      catchError(err => {
        return of(err instanceof RpcException);
      }),
    );
  }
}



================================================
FILE: integration/microservices/src/grpc/math.proto
================================================
syntax = "proto3";

package math;

service Math {
  rpc Sum (RequestSum) returns (SumResult);
  rpc SumStream(stream RequestSum) returns(stream SumResult);
  rpc SumStreamPass(stream RequestSum) returns(stream SumResult);
  rpc Divide (RequestDivide) returns (DivideResult);
  rpc StreamLargeMessages(Empty) returns (stream BackpressureData);
  /* Given a series of dividend and divisor, stream back the division results for each */
  rpc StreamDivide (StreamDivideRequest) returns (stream StreamDivideResponse);
}

message BackpressureData {
    int32 id = 1;
    string data = 2;
}

message Empty {}

message SumResult {
  int32 result = 1;
}

message RequestSum {
  repeated int32 data = 1;
}

message RequestDivide {
  int32 dividend = 1;
  int32 divisor = 2 ;
}

message DivideResult {
  int32 result = 1;
}

message StreamDivideRequest {
  repeated RequestDivide data = 1;
}

message StreamDivideResponse {
  DivideResult data = 1;
}



================================================
FILE: integration/microservices/src/grpc/math2.proto
================================================
syntax = "proto3";

package math2;

service Math2 {
  rpc Sum2 (RequestSum) returns (SumResult) {}
}

message SumResult {
  int32 result = 1;
}

message RequestSum {
  repeated int32 data = 1;
}



================================================
FILE: integration/microservices/src/grpc-advanced/advanced.grpc.controller.ts
================================================
import { Metadata } from '@grpc/grpc-js';
import { Body, Controller, HttpCode, Post } from '@nestjs/common';
import {
  Client,
  ClientGrpc,
  GrpcMethod,
  GrpcStreamCall,
  GrpcStreamMethod,
  Transport,
} from '@nestjs/microservices';
import { join } from 'path';
import { Observable, of, ReplaySubject, Subject } from 'rxjs';

@Controller()
export class AdvancedGrpcController {
  /*
   *  HTTP Proxy Client defines loading pattern
   */
  @Client({
    transport: Transport.GRPC,
    options: {
      url: 'localhost:5001',
      package: 'proto_example.orders',
      protoPath: 'root.proto',
      loader: {
        includeDirs: [join(__dirname, './proto')],
        keepCase: true,
      },
    },
  })
  client: ClientGrpc;

  /**
   * HTTP Proxy entry for support non-stream find method
   * @param id
   */
  @Post()
  @HttpCode(200)
  call(@Body() id: number): Observable<number> {
    const svc = this.client.getService<any>('OrderService');
    return svc.find({ id });
  }

  /**
   * HTTP Proxy entry for support client-side stream find method
   * @param id
   */
  @Post('client-streaming')
  @HttpCode(200)
  stream(): Observable<number> {
    const svc = this.client.getService<any>('OrderService');
    const upstream = new ReplaySubject();
    upstream.next({
      id: 1,
      itemTypes: [1],
      shipmentType: {
        from: 'test',
        to: 'test1',
        carrier: 'test-carrier',
      },
    });
    upstream.complete();
    return svc.streamReq(upstream);
  }

  /**
   * GRPC stub for Find method
   * @param id
   */
  @GrpcMethod('orders.OrderService')
  async find({ id }: { id: number }): Promise<any> {
    return of({
      id: 1,
      itemTypes: [1],
      shipmentType: {
        from: 'test',
        to: 'test1',
        carrier: 'test-carrier',
      },
    });
  }

  /**
   * GRPC stub implementation for sync stream method
   * @param messages
   */
  @GrpcStreamMethod('orders.OrderService')
  async sync(
    messages: Observable<any>,
    metadata: Metadata,
    call: any,
  ): Promise<any> {
    // Set Set-Cookie from Metadata
    const srvMetadata = new Metadata();
    srvMetadata.add('Set-Cookie', 'test_cookie=abcd');
    call.sendMetadata(srvMetadata);

    const s = new Subject();
    const o = s.asObservable();
    messages.subscribe(msg => {
      s.next({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });
    return o;
  }

  /**
   * GRPC stub implementation for syncCall stream method (implemented through call)
   * @param stream
   */
  @GrpcStreamCall('orders.OrderService')
  async syncCall(stream: any) {
    stream.on('data', (msg: any) => {
      stream.write({
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });
  }

  @GrpcStreamMethod('orders.OrderService')
  async streamReq(messages: Observable<any>): Promise<any> {
    const s = new Subject();
    const o = s.asObservable();
    messages.subscribe({
      next: () => {
        s.next({
          id: 1,
          itemTypes: [1],
          shipmentType: {
            from: 'test',
            to: 'test1',
            carrier: 'test-carrier',
          },
        });
      },
      complete: () => s.complete(),
    });
    return o;
  }

  @GrpcStreamCall('orders.OrderService')
  async streamReqCall(stream: any, callback: Function) {
    stream.on('data', (msg: any) => {
      // process msg
    });
    stream.on('end', () => {
      callback(null, {
        id: 1,
        itemTypes: [1],
        shipmentType: {
          from: 'test',
          to: 'test1',
          carrier: 'test-carrier',
        },
      });
    });
  }
}



================================================
FILE: integration/microservices/src/grpc-advanced/proto/root.proto
================================================
syntax = "proto3";
package proto_example;
import public "orders/service.proto";



================================================
FILE: integration/microservices/src/grpc-advanced/proto/common/item_types.proto
================================================
syntax = "proto3";
package proto_example.common.items;

enum ItemType {
    DEFAULT = 0;
    SUPERIOR = 1;
    FLAWLESS = 2;
}


================================================
FILE: integration/microservices/src/grpc-advanced/proto/common/shipment_types.proto
================================================
syntax = "proto3";
package proto_example.common.shipments;

message ShipmentType {
    string from = 1;
    string to = 2;
    string carrier = 3;
}


================================================
FILE: integration/microservices/src/grpc-advanced/proto/orders/message.proto
================================================
syntax = "proto3";
package proto_example.orders;

import public "common/item_types.proto";
import public "common/shipment_types.proto";

message Order {
    int32 id = 1;
    repeated common.items.ItemType itemTypes = 2;
    common.shipments.ShipmentType shipmentType = 3;
}


================================================
FILE: integration/microservices/src/grpc-advanced/proto/orders/service.proto
================================================
syntax = "proto3";
import "orders/message.proto";
package proto_example.orders;

service OrderService {
    rpc Find(Order) returns (Order);
    rpc Sync(stream Order) returns (stream Order);
    rpc SyncCall(stream Order) returns (stream Order);
    rpc StreamReq(stream Order) returns (Order);
    rpc StreamReqCall(stream Order) returns (Order);
}


================================================
FILE: integration/microservices/src/kafka/kafka.controller.ts
================================================
import {
  Body,
  Controller,
  HttpCode,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  Post,
} from '@nestjs/common';
import { Client, ClientKafka, Transport } from '@nestjs/microservices';
import { lastValueFrom, Observable } from 'rxjs';
import { BusinessDto } from './dtos/business.dto';
import { UserDto } from './dtos/user.dto';

@Controller()
export class KafkaController implements OnModuleInit, OnModuleDestroy {
  protected readonly logger = new Logger(KafkaController.name);
  static IS_NOTIFIED = false;
  static MATH_SUM = 0;

  @Client({
    transport: Transport.KAFKA,
    options: {
      client: {
        brokers: ['localhost:9092'],
      },
    },
  })
  private readonly client: ClientKafka;

  async onModuleInit() {
    const requestPatterns = [
      'math.sum.sync.kafka.message',
      'math.sum.sync.without.key',
      'math.sum.sync.plain.object',
      'math.sum.sync.array',
      'math.sum.sync.string',
      'math.sum.sync.number',
      'user.create',
      'business.create',
    ];

    requestPatterns.forEach(pattern => {
      this.client.subscribeToResponseOf(pattern);
    });

    await this.client.connect();
  }

  async onModuleDestroy() {
    await this.client.close();
  }

  // sync send kafka message
  @Post('mathSumSyncKafkaMessage')
  @HttpCode(200)
  async mathSumSyncKafkaMessage(
    @Body() data: number[],
  ): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.kafka.message', {
        key: '1',
        value: {
          numbers: data,
        },
      }),
    );
    return result;
  }

  // sync send kafka(ish) message without key and only the value
  @Post('mathSumSyncWithoutKey')
  @HttpCode(200)
  async mathSumSyncWithoutKey(
    @Body() data: number[],
  ): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.without.key', {
        value: {
          numbers: data,
        },
      }),
    );
    return result;
  }

  // sync send message without key or value
  @Post('mathSumSyncPlainObject')
  @HttpCode(200)
  async mathSumSyncPlainObject(
    @Body() data: number[],
  ): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.plain.object', {
        numbers: data,
      }),
    );
    return result;
  }

  // sync send message without key or value
  @Post('mathSumSyncArray')
  @HttpCode(200)
  async mathSumSyncArray(@Body() data: number[]): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.array', data),
    );
    return result;
  }

  @Post('mathSumSyncString')
  @HttpCode(200)
  async mathSumSyncString(@Body() data: number[]): Promise<Observable<any>> {
    // this.logger.error(util.format('mathSumSyncString() data: %o', data));
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.string', data.toString()),
    );
    return result;
  }

  @Post('mathSumSyncNumber')
  @HttpCode(200)
  async mathSumSyncNumber(@Body() data: number[]): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('math.sum.sync.number', data[0]),
    );
    return result;
  }

  // async notify
  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit('notify', { notify: true });
  }

  // Complex data to send.
  @Post('/user')
  @HttpCode(200)
  async createUser(@Body() user: UserDto): Promise<Observable<any>> {
    const result = await lastValueFrom(
      this.client.send('user.create', {
        key: '1',
        value: {
          user,
        },
      }),
    );
    return result;
  }

  // Complex data to send.
  @Post('/business')
  @HttpCode(200)
  async createBusiness(@Body() business: BusinessDto) {
    const result = await lastValueFrom(
      this.client.send('business.create', {
        key: '1',
        value: {
          business,
        },
      }),
    );
    return result;
  }
}



================================================
FILE: integration/microservices/src/kafka/kafka.messages.controller.ts
================================================
import { Controller, Logger } from '@nestjs/common';
import { EventPattern, MessagePattern } from '@nestjs/microservices';
import { BusinessDto } from './dtos/business.dto';
import { UserDto } from './dtos/user.dto';
import { BusinessEntity } from './entities/business.entity';
import { UserEntity } from './entities/user.entity';
import { KafkaController } from './kafka.controller';

@Controller()
export class KafkaMessagesController {
  protected readonly logger = new Logger(KafkaMessagesController.name);
  static IS_NOTIFIED = false;

  @MessagePattern('math.sum.sync.kafka.message')
  mathSumSyncKafkaMessage(data: any) {
    return (data.value.numbers || []).reduce((a, b) => a + b);
  }

  @MessagePattern('math.sum.sync.without.key')
  mathSumSyncWithoutKey(data: any) {
    return (data.value.numbers || []).reduce((a, b) => a + b);
  }

  @MessagePattern('math.sum.sync.plain.object')
  mathSumSyncPlainObject(data: any) {
    return (data.value.numbers || []).reduce((a, b) => a + b);
  }

  @MessagePattern('math.sum.sync.array')
  mathSumSyncArray(data: any) {
    return (data.value || []).reduce((a, b) => a + b);
  }

  @MessagePattern('math.sum.sync.string')
  mathSumSyncString(data: any) {
    // this.logger.error(util.format('mathSumSyncString() data: %o', data));
    return (data.value.split(',') || [])
      .map(i => {
        return parseFloat(i);
      })
      .reduce((a, b) => a + b);
  }

  @MessagePattern('math.sum.sync.number')
  mathSumSyncNumber(data: any) {
    // this.logger.error(util.format('mathSumSyncNumber() data: %o', data));
    return (data.value.toString().split('') || [])
      .map(i => {
        return parseFloat(i);
      })
      .reduce((a, b) => a + b);
  }

  @EventPattern('notify')
  eventHandler(data: any) {
    KafkaController.IS_NOTIFIED = data.value.notify;
  }

  // Complex data to send.
  @MessagePattern('user.create')
  async createUser(params: { value: { user: UserDto } }) {
    return new UserEntity(params.value.user);
  }

  @MessagePattern('business.create')
  async createBusiness(params: { value: { business: BusinessDto } }) {
    return new BusinessEntity(params.value.business);
  }
}



================================================
FILE: integration/microservices/src/kafka/dtos/business.dto.ts
================================================
import { UserEntity } from '../entities/user.entity';

export class BusinessDto {
  name: string;
  phone: string;
  user: UserEntity;
}



================================================
FILE: integration/microservices/src/kafka/dtos/user.dto.ts
================================================
export class UserDto {
  name: string;
  email: string;
  phone: string;
  years: number;
}



================================================
FILE: integration/microservices/src/kafka/entities/business.entity.ts
================================================
import { UserEntity } from './user.entity';
import { BusinessDto } from '../dtos/business.dto';

export class BusinessEntity {
  constructor(business: BusinessDto) {
    this.id = Math.random() * 99999999;
    this.name = business.name;
    this.phone = business.phone;
    this.createdBy = {
      id: business.user.id,
    };
    this.created = new Date();
  }
  id: number;
  name: string;
  phone: string;
  createdBy: Partial<UserEntity>;
  created: Date;
}



================================================
FILE: integration/microservices/src/kafka/entities/user.entity.ts
================================================
import { UserDto } from '../dtos/user.dto';

export class UserEntity {
  constructor(user: UserDto) {
    this.id = Math.random() * 99999999;
    this.name = user.name;
    this.email = user.email;
    this.phone = user.phone;
    this.years = user.years;
    this.created = new Date();
  }
  id: number;
  name: string;
  email: string;
  phone: string;
  years: number;
  created: Date;
}



================================================
FILE: integration/microservices/src/kafka-concurrent/kafka-concurrent.controller.ts
================================================
import {
  Body,
  Controller,
  HttpCode,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  Post,
} from '@nestjs/common';
import { Client, ClientKafka, Transport } from '@nestjs/microservices';
import { PartitionerArgs } from 'kafkajs';
import { Observable } from 'rxjs';
import { SumDto } from './dto/sum.dto';

/**
 * The following function explicitly sends messages to the key representing the partition.
 */
const explicitPartitioner = () => {
  return ({ message }: PartitionerArgs) => {
    return parseFloat(message.headers!.toPartition!.toString());
  };
};

@Controller()
export class KafkaConcurrentController
  implements OnModuleInit, OnModuleDestroy
{
  protected readonly logger = new Logger(KafkaConcurrentController.name);

  @Client({
    transport: Transport.KAFKA,
    options: {
      client: {
        brokers: ['localhost:9092'],
      },
      run: {
        partitionsConsumedConcurrently: 3,
      },
      producer: {
        createPartitioner: explicitPartitioner,
      },
    },
  })
  public readonly client: ClientKafka;

  async onModuleInit() {
    const requestPatterns = ['math.sum.sync.number.wait'];

    requestPatterns.forEach(pattern => {
      this.client.subscribeToResponseOf(pattern);
    });

    await this.client.connect();
  }

  async onModuleDestroy() {
    await this.client.close();
  }

  @Post('mathSumSyncNumberWait')
  @HttpCode(200)
  public mathSumSyncNumberWait(@Body() data: SumDto): Observable<string> {
    return this.client.send('math.sum.sync.number.wait', {
      headers: {
        toPartition: data.key.toString(),
      },
      key: data.key.toString(),
      value: data.numbers,
    });
  }
}



================================================
FILE: integration/microservices/src/kafka-concurrent/kafka-concurrent.messages.controller.ts
================================================
import { Controller, HttpCode, Post } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';
import { BehaviorSubject, Observable } from 'rxjs';
import { first, map, skipWhile } from 'rxjs/operators';

@Controller()
export class KafkaConcurrentMessagesController {
  public waiting = new BehaviorSubject<boolean>(false);

  @Post('go')
  @HttpCode(200)
  async go() {
    // no longer waiting
    this.waiting.next(false);

    return;
  }

  @MessagePattern('math.sum.sync.number.wait')
  public mathSumSyncNumberWait(data: any): Observable<number> {
    // start waiting
    this.waiting.next(true);

    // find sum
    const sum = data.value[0] + data.value[1];

    return this.waiting.asObservable().pipe(
      skipWhile(isWaiting => {
        return isWaiting;
      }),
      map(() => {
        return sum;
      }),
      first(),
    );
  }
}



================================================
FILE: integration/microservices/src/kafka-concurrent/dto/sum.dto.ts
================================================
export class SumDto {
  key: string;
  numbers: number[];
}



================================================
FILE: integration/microservices/src/mqtt/mqtt-broadcast.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import {
  Client,
  ClientProxy,
  MessagePattern,
  Transport,
} from '@nestjs/microservices';
import { Observable } from 'rxjs';
import { scan, take } from 'rxjs/operators';

@Controller()
export class MqttBroadcastController {
  @Client({ transport: Transport.MQTT })
  client: ClientProxy;

  @Get('broadcast')
  multicats() {
    return this.client.send<number>({ cmd: 'broadcast' }, {}).pipe(
      scan((a, b) => a + b),
      take(2),
    );
  }

  @MessagePattern({ cmd: 'broadcast' })
  replyBroadcast(): Observable<number> {
    return new Observable(observer => observer.next(1));
  }
}



================================================
FILE: integration/microservices/src/mqtt/mqtt.controller.ts
================================================
import { Body, Controller, HttpCode, Post, Query } from '@nestjs/common';
import {
  Client,
  ClientProxy,
  Ctx,
  EventPattern,
  MessagePattern,
  MqttContext,
  MqttRecordBuilder,
  Payload,
  Transport,
} from '@nestjs/microservices';
import { from, lastValueFrom, Observable, of } from 'rxjs';
import { scan } from 'rxjs/operators';

@Controller()
export class MqttController {
  static IS_NOTIFIED = false;
  static IS_WILDCARD_EVENT_RECEIVED = false;
  static IS_WILDCARD2_EVENT_RECEIVED = false;
  static IS_SHARED_WILDCARD_EVENT_RECEIVED = false;
  static IS_SHARED_WILDCARD2_EVENT_RECEIVED = false;

  @Client({ transport: Transport.MQTT })
  client: ClientProxy;

  @Post()
  @HttpCode(200)
  async call(
    @Query('command') cmd,
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>({ cmd }, data);
  }

  @Post('stream')
  @HttpCode(200)
  async stream(@Body() data: number[]) {
    const result = lastValueFrom(
      this.client
        .send<number>({ cmd: 'streaming' }, data)
        .pipe(scan((a, b) => a + b, 0)),
    );
    return result;
  }

  @Post('concurrent')
  @HttpCode(200)
  async concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>({ cmd: 'sum' }, tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @Post('wildcard-event')
  async sendWildcardEvent(): Promise<any> {
    return this.client.emit<number>('wildcard-event/test', true);
  }

  @Post('wildcard-message')
  async sendWildcardMessage(
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>('wildcard-message/test', data);
  }

  @Post('wildcard-event2')
  async sendWildcardEvent2(): Promise<any> {
    return this.client.emit<number>('wildcard-event2/test/test', true);
  }

  @Post('wildcard-message2')
  async sendWildcardMessage2(
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>('wildcard-message2/test/test', data);
  }

  @Post('record-builder-duplex')
  @HttpCode(200)
  useRecordBuilderDuplex(@Body() data: Record<string, any>) {
    const record = new MqttRecordBuilder(data).setQoS(1).build();
    return this.client.send('record-builder-duplex', record);
  }

  @MessagePattern('record-builder-duplex')
  handleRecordBuilderDuplex(
    @Payload() data: Record<string, any>,
    @Ctx() context: MqttContext,
  ) {
    const { qos } = context.getPacket();
    return {
      data,
      qos,
    };
  }

  @Post('shared-wildcard-event')
  async sendSharedWildcardEvent(): Promise<any> {
    return this.client.emit<number>('shared-wildcard-event/test', true);
  }

  @Post('shared-wildcard-message')
  async sendSharedWildcardMessage(
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>('shared-wildcard-message/test', data);
  }

  @Post('shared-wildcard-event2')
  async sendSharedWildcardEvent2(): Promise<any> {
    return this.client.emit<number>('shared-wildcard-event2/test/test', true);
  }

  @Post('shared-wildcard-message2')
  async sendSharedWildcardMessage2(
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>('shared-wildcard-message2/test/test', data);
  }

  @MessagePattern('wildcard-message/#')
  wildcardMessageHandler(data: number[]): number | undefined {
    if ((data as any).response) {
      return;
    }
    return (data || []).reduce((a, b) => a + b);
  }

  @EventPattern('wildcard-event/#')
  wildcardEventHandler(data: boolean) {
    MqttController.IS_WILDCARD_EVENT_RECEIVED = data;
  }

  @MessagePattern('wildcard-message2/+/test')
  wildcardMessageHandler2(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @EventPattern('wildcard-event2/+/test')
  wildcardEventHandler2(data: boolean) {
    MqttController.IS_WILDCARD2_EVENT_RECEIVED = data;
  }

  @EventPattern('notification')
  eventHandler(data: boolean) {
    MqttController.IS_NOTIFIED = data;
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'asyncSum' })
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'streamSum' })
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'streaming' })
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @MessagePattern('$share/test-group/shared-wildcard-message/#')
  sharedWildcardMessageHandler(data: number[]): number | undefined {
    if ((data as any).response) {
      return;
    }
    return (data || []).reduce((a, b) => a + b);
  }

  @EventPattern('$share/test-group/shared-wildcard-event/#')
  sharedWildcardEventHandler(data: boolean) {
    MqttController.IS_SHARED_WILDCARD_EVENT_RECEIVED = data;
  }

  @MessagePattern('$share/test-group/shared-wildcard-message2/+/test')
  sharedWildcardMessageHandler2(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @EventPattern('$share/test-group/shared-wildcard-event2/+/test')
  sharedWildcardEventHandler2(data: boolean) {
    MqttController.IS_SHARED_WILDCARD2_EVENT_RECEIVED = data;
  }
}



================================================
FILE: integration/microservices/src/nats/nats-broadcast.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import {
  Client,
  ClientProxy,
  MessagePattern,
  Transport,
} from '@nestjs/microservices';
import { Observable } from 'rxjs';
import { scan, take } from 'rxjs/operators';

@Controller()
export class NatsBroadcastController {
  @Client({
    transport: Transport.NATS,
    options: {
      servers: 'nats://localhost:4222',
    },
  })
  client: ClientProxy;

  @Get('broadcast')
  multicats() {
    return this.client.send<number>('broadcast.test', {}).pipe(
      scan((a, b) => a + b),
      take(2),
    );
  }

  @MessagePattern('broadcast.*')
  replyBroadcast(): Observable<number> {
    return new Observable(observer => observer.next(1));
  }
}



================================================
FILE: integration/microservices/src/nats/nats.controller.ts
================================================
import { Body, Controller, Get, HttpCode, Post, Query } from '@nestjs/common';
import {
  ClientProxy,
  ClientProxyFactory,
  Ctx,
  EventPattern,
  MessagePattern,
  NatsContext,
  NatsRecordBuilder,
  Payload,
  RpcException,
  Transport,
} from '@nestjs/microservices';
import * as nats from 'nats';
import { from, lastValueFrom, Observable, of, throwError } from 'rxjs';
import { catchError, scan } from 'rxjs/operators';
import { NatsService } from './nats.service';

@Controller()
export class NatsController {
  static IS_NOTIFIED = false;
  static IS_NOTIFIED2 = false;

  constructor(private readonly natsService: NatsService) {}

  client: ClientProxy = ClientProxyFactory.create({
    transport: Transport.NATS,
    options: {
      servers: 'nats://localhost:4222',
    },
  });

  @Post()
  @HttpCode(200)
  async call(
    @Query('command') cmd,
    @Body() data: number[],
  ): Promise<Observable<number>> {
    await this.client.connect();
    return this.client.send<number>(cmd, data);
  }

  @Post('stream')
  @HttpCode(200)
  stream(@Body() data: number[]): Observable<number> {
    return this.client
      .send<number>('streaming.sum', data)
      .pipe(scan((a, b) => a + b));
  }

  @Post('concurrent')
  @HttpCode(200)
  concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>('math.sum', tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @Post('record-builder-duplex')
  @HttpCode(200)
  useRecordBuilderDuplex(@Body() data: Record<string, any>) {
    const headers = nats.headers();
    headers.set('x-version', '1.0.0');
    const record = new NatsRecordBuilder(data).setHeaders(headers).build();
    return this.client.send('record-builder-duplex', record);
  }

  @MessagePattern('record-builder-duplex')
  handleRecordBuilderDuplex(
    @Payload() data: Record<string, any>,
    @Ctx() context: NatsContext,
  ) {
    return {
      data,
      headers: {
        ['x-version']: context.getHeaders().get('x-version'),
      },
    };
  }

  @MessagePattern('math.*')
  sum(@Payload() data: number[], @Ctx() context: NatsContext): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern('async.*')
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern('stream.*')
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern('streaming.*')
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @Get('exception')
  async getError() {
    return this.client
      .send<number>('exception', {})
      .pipe(catchError(err => of(err)));
  }

  @MessagePattern('exception')
  throwError(): Observable<number> {
    return throwError(() => new RpcException('test'));
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @EventPattern('notification')
  eventHandler(@Payload() data: boolean) {
    NatsController.IS_NOTIFIED = data;
  }

  @EventPattern('notification')
  eventHandler2(@Payload() data: boolean) {
    NatsController.IS_NOTIFIED2 = data;
  }
}



================================================
FILE: integration/microservices/src/nats/nats.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { CONTEXT } from '@nestjs/microservices';

@Injectable()
export class NatsService {
  constructor(@Inject(CONTEXT) public ctx) {}
}



================================================
FILE: integration/microservices/src/redis/redis-broadcast.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import {
  Client,
  MessagePattern,
  ClientProxy,
  Transport,
} from '@nestjs/microservices';
import { Observable } from 'rxjs';
import { scan, take } from 'rxjs/operators';

@Controller()
export class RedisBroadcastController {
  @Client({ transport: Transport.REDIS })
  client: ClientProxy;

  @Get('broadcast')
  multicats() {
    return this.client.send<number>({ cmd: 'broadcast' }, {}).pipe(
      scan((a, b) => a + b),
      take(2),
    );
  }

  @MessagePattern({ cmd: 'broadcast' })
  replyBroadcast(): Observable<number> {
    return new Observable(observer => observer.next(1));
  }
}



================================================
FILE: integration/microservices/src/redis/redis.controller.ts
================================================
import { Body, Controller, HttpCode, Post, Query } from '@nestjs/common';
import {
  Client,
  ClientProxy,
  EventPattern,
  MessagePattern,
  Transport,
} from '@nestjs/microservices';
import { from, lastValueFrom, Observable, of } from 'rxjs';
import { scan } from 'rxjs/operators';

@Controller()
export class RedisController {
  static IS_NOTIFIED = false;

  @Client({ transport: Transport.REDIS })
  client: ClientProxy;

  @Post()
  @HttpCode(200)
  call(@Query('command') cmd, @Body() data: number[]): Observable<number> {
    return this.client.send<number>({ cmd }, data);
  }

  @Post('stream')
  @HttpCode(200)
  stream(@Body() data: number[]): Observable<number> {
    return this.client
      .send<number>({ cmd: 'streaming' }, data)
      .pipe(scan((a, b) => a + b));
  }

  @Post('concurrent')
  @HttpCode(200)
  concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>({ cmd: 'sum' }, tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'asyncSum' })
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'streamSum' })
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'streaming' })
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @EventPattern('notification')
  eventHandler(data: boolean) {
    RedisController.IS_NOTIFIED = data;
  }
}



================================================
FILE: integration/microservices/src/rmq/rmq-broadcast.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import {
  ClientProxy,
  ClientProxyFactory,
  MessagePattern,
  Transport,
} from '@nestjs/microservices';
import { Observable } from 'rxjs';
import { scan, take } from 'rxjs/operators';

@Controller()
export class RMQBroadcastController {
  client: ClientProxy;

  constructor() {
    this.client = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: [`amqp://localhost:5672`],
        queue: 'test_broadcast',
        queueOptions: { durable: false },
        socketOptions: { noDelay: true },
      },
    });
  }

  @Get('broadcast')
  multicats() {
    return this.client.send<number>({ cmd: 'broadcast' }, {}).pipe(
      scan((a, b) => a + b),
      take(2),
    );
  }

  @MessagePattern({ cmd: 'broadcast' })
  replyBroadcast(): Observable<number> {
    return new Observable(observer => observer.next(1));
  }
}



================================================
FILE: integration/microservices/src/rmq/rmq.controller.ts
================================================
import { Body, Controller, HttpCode, Post, Query } from '@nestjs/common';
import {
  ClientProxy,
  ClientProxyFactory,
  Ctx,
  EventPattern,
  MessagePattern,
  Payload,
  RmqContext,
  RmqRecordBuilder,
  Transport,
} from '@nestjs/microservices';
import { from, lastValueFrom, Observable, of } from 'rxjs';
import { scan } from 'rxjs/operators';

@Controller()
export class RMQController {
  static IS_NOTIFIED = false;

  client: ClientProxy;

  constructor() {
    this.client = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: [`amqp://localhost:5672`],
        queue: 'test',
        queueOptions: { durable: false },
        socketOptions: { noDelay: true },
      },
    });
  }

  @Post()
  @HttpCode(200)
  call(@Query('command') cmd, @Body() data: number[]) {
    return this.client.send<number>({ cmd }, data);
  }

  @Post('stream')
  @HttpCode(200)
  stream(@Body() data: number[]): Observable<number> {
    return this.client
      .send<number>({ cmd: 'streaming' }, data)
      .pipe(scan((a, b) => a + b));
  }

  @Post('concurrent')
  @HttpCode(200)
  concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>({ cmd: 'sum' }, tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @Post('multiple-urls')
  @HttpCode(200)
  multipleUrls(@Body() data: number[]) {
    const clientWithMultipleUrls = ClientProxyFactory.create({
      transport: Transport.RMQ,
      options: {
        urls: [`amqp://localhost:5671`, `amqp://localhost:5672`],
        queue: 'test',
        queueOptions: { durable: false },
        socketOptions: { noDelay: true },
      },
    });
    return clientWithMultipleUrls.send<number>({ cmd: 'multiple-urls' }, data);
  }

  @Post('record-builder-duplex')
  @HttpCode(200)
  useRecordBuilderDuplex(@Body() data: Record<string, any>) {
    const record = new RmqRecordBuilder(data)
      .setOptions({
        headers: {
          ['x-version']: '1.0.0',
        },
        priority: 3,
      })
      .build();

    return this.client.send('record-builder-duplex', record);
  }

  @MessagePattern('record-builder-duplex')
  handleRecordBuilderDuplex(
    @Payload() data: Record<string, any>,
    @Ctx() context: RmqContext,
  ) {
    const originalMessage = context.getMessage();
    return {
      data,
      headers: originalMessage.properties.headers,
      priority: originalMessage.properties.priority,
    };
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'asyncSum' })
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'streamSum' })
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'streaming' })
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @MessagePattern({ cmd: 'multiple-urls' })
  handleMultipleUrls(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @EventPattern('notification')
  eventHandler(data: boolean) {
    RMQController.IS_NOTIFIED = data;
  }
}



================================================
FILE: integration/microservices/src/tcp-tls/app.controller.ts
================================================
import {
  Body,
  Controller,
  HttpCode,
  Inject,
  Post,
  Query,
} from '@nestjs/common';
import {
  Client,
  ClientProxy,
  EventPattern,
  MessagePattern,
  RpcException,
  Transport,
} from '@nestjs/microservices';
import { from, lastValueFrom, Observable, of, throwError } from 'rxjs';
import { catchError, scan } from 'rxjs/operators';
import * as fs from 'fs';
import * as path from 'path';

@Controller()
export class AppController {
  constructor(
    @Inject('USE_CLASS_CLIENT') private useClassClient: ClientProxy,
    @Inject('USE_FACTORY_CLIENT') private useFactoryClient: ClientProxy,
    @Inject('CUSTOM_PROXY_CLIENT') private customClient: ClientProxy,
  ) {}
  static IS_NOTIFIED = false;

  @Client({
    transport: Transport.TCP,
    options: {
      tlsOptions: {
        ca: [
          fs
            .readFileSync(path.join(__dirname, 'ca.cert.pem'), 'utf-8')
            .toString(),
        ],
      },
    },
  })
  client: ClientProxy;

  @Post()
  @HttpCode(200)
  call(@Query('command') cmd, @Body() data: number[]): Observable<number> {
    return this.client.send<number>({ cmd }, data);
  }

  @Post('useFactory')
  @HttpCode(200)
  callWithClientUseFactory(
    @Query('command') cmd,
    @Body() data: number[],
  ): Observable<number> {
    return this.useFactoryClient.send<number>({ cmd }, data);
  }

  @Post('useClass')
  @HttpCode(200)
  callWithClientUseClass(
    @Query('command') cmd,
    @Body() data: number[],
  ): Observable<number> {
    return this.useClassClient.send<number>({ cmd }, data);
  }

  @Post('stream')
  @HttpCode(200)
  stream(@Body() data: number[]): Observable<number> {
    return this.client
      .send<number>({ cmd: 'streaming' }, data)
      .pipe(scan((a, b) => a + b));
  }

  @Post('concurrent')
  @HttpCode(200)
  concurrent(@Body() data: number[][]): Promise<boolean> {
    const send = async (tab: number[]) => {
      const expected = tab.reduce((a, b) => a + b);
      const result = await lastValueFrom(
        this.client.send<number>({ cmd: 'sum' }, tab),
      );

      return result === expected;
    };
    return data
      .map(async tab => send(tab))
      .reduce(async (a, b) => (await a) && b);
  }

  @Post('error')
  @HttpCode(200)
  serializeError(
    @Query('client') query: 'custom' | 'standard' = 'standard',
    @Body() body: Record<string, any>,
  ): Observable<boolean> {
    const client = query === 'custom' ? this.customClient : this.client;
    return client.send({ cmd: 'err' }, {}).pipe(
      catchError(err => {
        return of(err instanceof RpcException);
      }),
    );
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'asyncSum' })
  async asyncSum(data: number[]): Promise<number> {
    return (data || []).reduce((a, b) => a + b);
  }

  @MessagePattern({ cmd: 'streamSum' })
  streamSum(data: number[]): Observable<number> {
    return of((data || []).reduce((a, b) => a + b));
  }

  @MessagePattern({ cmd: 'streaming' })
  streaming(data: number[]): Observable<number> {
    return from(data);
  }

  @MessagePattern({ cmd: 'err' })
  throwAnError() {
    return throwError(() => new Error('err'));
  }

  @Post('notify')
  async sendNotification(): Promise<any> {
    return this.client.emit<number>('notification', true);
  }

  @EventPattern('notification')
  eventHandler(data: boolean) {
    AppController.IS_NOTIFIED = data;
  }
}



================================================
FILE: integration/microservices/src/tcp-tls/app.module.ts
================================================
import { Injectable, Module } from '@nestjs/common';
import {
  ClientOptions,
  ClientsModule,
  ClientsModuleOptionsFactory,
  ClientTCP,
  RpcException,
  Transport,
} from '@nestjs/microservices';
import { AppController } from './app.controller';

import * as fs from 'fs';
import * as path from 'path';

const caCert = fs.readFileSync(path.join(__dirname, 'ca.cert.pem')).toString();

class ErrorHandlingProxy extends ClientTCP {
  constructor() {
    super({
      tlsOptions: { ca: caCert },
    });
  }

  serializeError(err) {
    return new RpcException(err);
  }
}

@Injectable()
class ConfigService {
  private readonly config = {
    transport: Transport.TCP,
  };
  get(key: string, defaultValue?: any) {
    return this.config[key] || defaultValue;
  }
}

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
class ConfigModule {}

@Injectable()
class ClientOptionService implements ClientsModuleOptionsFactory {
  constructor(private readonly configService: ConfigService) {}
  createClientOptions(): Promise<ClientOptions> | ClientOptions {
    return {
      transport: this.configService.get('transport'),
      options: {
        tlsOptions: { ca: caCert },
      },
    };
  }
}

@Module({
  imports: [
    ClientsModule.registerAsync([
      {
        imports: [ConfigModule],
        name: 'USE_FACTORY_CLIENT',
        useFactory: (configService: ConfigService) => ({
          transport: configService.get('transport'),
          options: {
            tlsOptions: { ca: caCert },
          },
        }),
        inject: [ConfigService],
      },
      {
        imports: [ConfigModule],
        name: 'USE_CLASS_CLIENT',
        useClass: ClientOptionService,
        inject: [ConfigService],
      },
      {
        imports: [ConfigModule],
        inject: [ConfigService],
        name: 'CUSTOM_PROXY_CLIENT',
        useFactory: (config: ConfigService) => ({
          customClass: ErrorHandlingProxy,
        }),
      },
    ]),
  ],
  controllers: [AppController],
})
export class ApplicationModule {}



================================================
FILE: integration/microservices/src/tcp-tls/ca.cert.pem
================================================
-----BEGIN CERTIFICATE-----
MIICpDCCAYwCCQCyP27z3r0PFjANBgkqhkiG9w0BAQsFADAUMRIwEAYDVQQDDAls
b2NhbGhvc3QwHhcNMjIxMjAyMDQ0NTQ1WhcNMzIxMTI5MDQ0NTQ1WjAUMRIwEAYD
VQQDDAlsb2NhbGhvc3QwggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDZ
1IdZZXqrwXql4AIOJnlfpoGKOKoIalnK7KaKHTsq1QOF8z2abFuNBVIIrO0etQ/0
PPAaFGkXl6HHBuA5PrFpsw3V1wSnNs1Cns9NhvypHI2V71lkwBJrEaSicNWL2AOE
QkQ9cZ4YsTGd0BrM8D5VvgXdrC7gOXfj7Hx3E4K+wFO/Gi4AUXl5CXxleSFcW4U+
jFulfq/DE8rBZXs29IsGeVkkgUoICjQ4Ey4zE6EY7f3SPKgU8gfgzYyGSd/ZZ/E7
6M2yakEUX448Nl4BeuNWroBHVm1pSiMo+Cm1g34pJScPrx1yw6qquziCc/2n1M6O
B4WGIZAmJDWnAOEjjrxFAgMBAAEwDQYJKoZIhvcNAQELBQADggEBAABGByZZUjaq
ZygICSH2qUGHPPIyrfaCe0qM7de6kYfxxPYQQZb0HDynzv780Lq1002XeT02fNR+
5sBCVFuKvS8BNvTq6kHzO1FiWIk/E5fQcYNToYSeEcXgWFLhJMty7+R6sIc9y8PH
2YNehf78Jjm9ukM52sLc4+JWl7AEeqPrOHZdh/ve8M2gTfimFKTrW5cEAVPIOPhp
2t5BdDKt8ZxgrGC7iRxga+v80VUOHRGfrd3hf3NlDQZO8upVGY8DdJhPRDB72+R0
kzJ7eyQwlGXM20atiFxPk43h0f273MneIJG8NgGiVU0ND4XnZkAB3KSAu7pB+nEw
QRYMYDgo/8Q=
-----END CERTIFICATE-----



================================================
FILE: integration/microservices/src/tcp-tls/privkey.pem
================================================
-----BEGIN PRIVATE KEY-----
MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQDZ1IdZZXqrwXql
4AIOJnlfpoGKOKoIalnK7KaKHTsq1QOF8z2abFuNBVIIrO0etQ/0PPAaFGkXl6HH
BuA5PrFpsw3V1wSnNs1Cns9NhvypHI2V71lkwBJrEaSicNWL2AOEQkQ9cZ4YsTGd
0BrM8D5VvgXdrC7gOXfj7Hx3E4K+wFO/Gi4AUXl5CXxleSFcW4U+jFulfq/DE8rB
ZXs29IsGeVkkgUoICjQ4Ey4zE6EY7f3SPKgU8gfgzYyGSd/ZZ/E76M2yakEUX448
Nl4BeuNWroBHVm1pSiMo+Cm1g34pJScPrx1yw6qquziCc/2n1M6OB4WGIZAmJDWn
AOEjjrxFAgMBAAECggEANUKZtWnyjHxKGLSkzADsPE7h7YHdUSFvwwYJ0ktDZD2h
FudacJ994wUiAa0GbTOoKvebXUUQTQxuKdOsj1Kc3lNBVr+0C46CsX9TAIm4zUCF
/dr/6HpuBm/R6UXdcMvoUDZDqSJWnYL1trhjVSiIlT5ZANJQw9JJVhlEdXj3xtuc
I9aC+33f9hKO1wzei/mTjIRGyRIeKselZPpA7qJnE4s3hmZxnO/rSqyPIvh1XLfZ
3Eoyyg+xNpTZ8JqlHB5d7hDSnj8cjboa7IYpHJDXN3r8Aui+R9e/sQkezHbF7fR0
xHpBVYQvGMuqSnTBkdJfq4qPAR1K49UrpEXB2GHaIQKBgQDs3t/ZUA138AiPIeLd
aTsEPhf5dWEZynfNvXZ0VcoSr8ckaiaq9OEllprAriYWj+XphTDsBUAh/R7KlOR4
eb+m6OwH7LseGiLIEr54GGP0LzVXAkfH2/uR1cak8qAmHB00jNEg7sj0eVAsHO3f
WQm67f+RNP/IgAa+V8JKIkgTwwKBgQDrbAH8eAQsq9rjpxcic1EUI7uFHzr+cKf/
4Y8ThLUNAzNfAbQWRBYjS1R8GM79Wiuh+WT1ooHKLryuLF7LVukvKHJ5GiNFBmaO
llf72Zf1y4tBE2RCXQbf6h8+ohSDC/hwYy+w20/i2KzSBKkS0+gQuAX/HzfTpRd3
q3/uEniXVwKBgDNnElDIbIPQlSrqgZ7mzSXYi79Y15+PLnx5VxFb5KQ1fRPL7WRA
C/PqQN77a8yNoakRfFJbuVUm5t2zffkfApYoCcCWgOzBYzbjym2pbVd6PysIlacr
d+Zn69mzxUk/5J6YyHFLIFTdVqacCIrleZUVPNa4F6HdFpmL1d/cnKOdAoGAMDuB
sKsaF9jh0LBkEf/URa8IdT6vxH9qPAeHW7VdrpvQQ4/CyKkMbBC772zZw5hcxiOl
Zpnzw2uN5pVamohk3++GfH85aKPmESKGRigPdSFNl3iUmvAaP3flDN0CHNMwBD6d
/7r/A/fmeGTSCvR1YC+DswA/XNI/G5p8bFdGc6MCgYBd9oQiZlkYMiDGPUAjx+DO
kqtAmc8DLJEanSbWdIxL2bGL04cgBRPssM4m0UScx4PucvqWEPdN/5Ug0z5TrD77
2K5nZSBUdy4DunBImz1NHRQEiytkrYX0LesGr02QlzIH4wmwb1TFu7rLkr6KfNuV
xqWi+JVY8N4vuHAxCeEALw==
-----END PRIVATE KEY-----


================================================
FILE: integration/module-utils/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*",
    "test/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/module-utils/src/integration.module-definition.ts
================================================
import { ConfigurableModuleBuilder } from '@nestjs/common';
import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } =
  new ConfigurableModuleBuilder<IntegrationModuleOptions>()
    .setClassMethodName('forRoot')
    .setFactoryMethodName('construct')
    .setExtras(
      {
        isGlobal: true,
      },
      (definition, extras) => ({
        ...definition,
        global: extras.isGlobal,
      }),
    )
    .build();



================================================
FILE: integration/module-utils/src/integration.module.ts
================================================
import { Inject, Module } from '@nestjs/common';
import {
  ConfigurableModuleClass,
  MODULE_OPTIONS_TOKEN,
} from './integration.module-definition';
import { IntegrationModuleOptions } from './interfaces/integration-module-options.interface';

@Module({})
export class IntegrationModule extends ConfigurableModuleClass {
  constructor(
    @Inject(MODULE_OPTIONS_TOKEN)
    public readonly options: IntegrationModuleOptions,
  ) {
    super();
  }
}



================================================
FILE: integration/module-utils/src/interfaces/integration-module-options.interface.ts
================================================
export interface IntegrationModuleOptions {
  url: string;
  secure?: boolean;
}



================================================
FILE: integration/module-utils/test/integration-module.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { IntegrationModule } from '../src/integration.module';

describe('Module utils (ConfigurableModuleBuilder)', () => {
  it('should auto-generate "forRoot" method', async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        IntegrationModule.forRoot({
          isGlobal: true,
          url: 'test_url',
          secure: false,
        }),
      ],
    }).compile();

    const integrationModule = moduleRef.get(IntegrationModule);

    expect(integrationModule.options).to.deep.equal({
      url: 'test_url',
      secure: false,
    });
  });

  it('should auto-generate "forRootAsync" method', async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        IntegrationModule.forRootAsync({
          isGlobal: true,
          useFactory: () => {
            return {
              url: 'test_url',
              secure: false,
            };
          },
        }),
      ],
    }).compile();

    const integrationModule = moduleRef.get(IntegrationModule);

    expect(integrationModule.options).to.deep.equal({
      url: 'test_url',
      secure: false,
    });
  });
});



================================================
FILE: integration/mongoose/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/mongoose/e2e/async-class-options.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsClassModule } from '../src/async-class-options.module';

describe('Mongoose', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsClassModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    const cat = {
      name: 'Nest',
      age: 20,
      breed: 'Awesome',
    };
    return request(server)
      .post('/cats')
      .send(cat)
      .expect(201)
      .expect(({ body }) => body.name === cat.name);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/mongoose/e2e/async-existing-options.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsExistingModule } from '../src/async-existing-options.module';

describe('Mongoose', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsExistingModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    const cat = {
      name: 'Nest',
      age: 20,
      breed: 'Awesome',
    };
    return request(server)
      .post('/cats')
      .send(cat)
      .expect(201)
      .expect(({ body }) => body.name === cat.name);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/mongoose/e2e/async-options.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsFactoryModule } from '../src/async-options.module';

describe('Mongoose', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsFactoryModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    const cat = {
      name: 'Nest',
      age: 20,
      breed: 'Awesome',
    };
    return request(server)
      .post('/cats')
      .send(cat)
      .expect(201)
      .expect(({ body }) => body.name === cat.name);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/mongoose/e2e/mongoose.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { ApplicationModule } from '../src/app.module';

describe('Mongoose', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [ApplicationModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    const cat = {
      name: 'Nest',
      age: 20,
      breed: 'Awesome',
    };
    return request(server)
      .post('/cats')
      .send(cat)
      .expect(201)
      .expect(({ body }) => body.name === cat.name);
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/mongoose/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [
    MongooseModule.forRoot('mongodb://localhost:27017/test'),
    CatsModule,
  ],
})
export class ApplicationModule {}



================================================
FILE: integration/mongoose/src/async-class-options.module.ts
================================================
import { Module } from '@nestjs/common';
import {
  MongooseModule,
  MongooseModuleOptions,
  MongooseOptionsFactory,
} from '@nestjs/mongoose';
import { CatsModule } from './cats/cats.module';

class ConfigService implements MongooseOptionsFactory {
  createMongooseOptions(): MongooseModuleOptions {
    return {
      uri: 'mongodb://localhost:27017/test',
    };
  }
}

@Module({
  imports: [
    MongooseModule.forRootAsync({
      useClass: ConfigService,
    }),
    CatsModule,
  ],
})
export class AsyncOptionsClassModule {}



================================================
FILE: integration/mongoose/src/async-existing-options.module.ts
================================================
import { Module } from '@nestjs/common';
import {
  MongooseModule,
  MongooseModuleOptions,
  MongooseOptionsFactory,
} from '@nestjs/mongoose';
import { CatsModule } from './cats/cats.module';

class ConfigService implements MongooseOptionsFactory {
  createMongooseOptions(): MongooseModuleOptions {
    return {
      uri: 'mongodb://localhost:27017/test',
    };
  }
}

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
class ConfigModule {}

@Module({
  imports: [
    MongooseModule.forRootAsync({
      imports: [ConfigModule],
      useExisting: ConfigService,
    }),
    CatsModule,
  ],
})
export class AsyncOptionsExistingModule {}



================================================
FILE: integration/mongoose/src/async-options.module.ts
================================================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [
    MongooseModule.forRootAsync({
      useFactory: () => ({
        uri: 'mongodb://localhost:27017/test',
      }),
    }),
    CatsModule,
  ],
})
export class AsyncOptionsFactoryModule {}



================================================
FILE: integration/mongoose/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { ApplicationModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  await app.listen(3001);
}
void bootstrap();



================================================
FILE: integration/mongoose/src/cats/cats.controller.ts
================================================
import { Body, Controller, Get, Post } from '@nestjs/common';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    return this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}



================================================
FILE: integration/mongoose/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { CatSchema } from './schemas/cat.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: 'Cat', schema: CatSchema }])],
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: integration/mongoose/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  constructor(@InjectModel('Cat') private readonly catModel: Model<Cat>) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const cat = new this.catModel(createCatDto);
    return cat.save();
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }
}



================================================
FILE: integration/mongoose/src/cats/dto/create-cat.dto.ts
================================================
export class CreateCatDto {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: integration/mongoose/src/cats/interfaces/cat.interface.ts
================================================
import { Document } from 'mongoose';

export interface Cat extends Document {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: integration/mongoose/src/cats/schemas/cat.schema.ts
================================================
import * as mongoose from 'mongoose';

export const CatSchema = new mongoose.Schema({
  name: String,
  age: Number,
  breed: String,
});



================================================
FILE: integration/nest-application/app-locals/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist",
    "strictNullChecks": true,
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/app-locals/e2e/express.spec.ts
================================================
import { NestExpressApplication } from '@nestjs/platform-express';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('App-level globals (Express Application)', () => {
  let moduleFixture: TestingModule;
  let app: NestExpressApplication;

  beforeEach(async () => {
    moduleFixture = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
  });

  beforeEach(() => {
    app = moduleFixture.createNestApplication<NestExpressApplication>();
  });

  it('should get "title" from "app.locals"', async () => {
    app.setLocal('title', 'My Website');
    await app.init();
    const response = await request(app.getHttpServer()).get('/').expect(200);
    expect(response.body.title).to.equal('My Website');
  });

  it('should get "email" from "app.locals"', async () => {
    app.setLocal('email', 'admin@example.com');
    await app.listen(4444);
    const response = await request(app.getHttpServer()).get('/').expect(200);
    expect(response.body.email).to.equal('admin@example.com');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/nest-application/app-locals/src/app.controller.ts
================================================
import { Controller, Get, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller()
export class AppController {
  @Get()
  getGlobals(@Req() req: Request) {
    return req.app.locals;
  }
}



================================================
FILE: integration/nest-application/app-locals/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: integration/nest-application/get-url/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist",
    "strictNullChecks": true,
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/get-url/e2e/express.spec.ts
================================================
import { ExpressAdapter } from '@nestjs/platform-express';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import * as express from 'express';
import { AppModule } from '../src/app.module';
import { randomPort } from './utils';

describe('Get URL (Express Application)', () => {
  let testModule: TestingModule;
  let port: number;

  beforeEach(async () => {
    testModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
  });

  beforeEach(async () => {
    port = await randomPort();
  });

  it('should be able to get the IPv6 address', async () => {
    const app = testModule.createNestApplication(new ExpressAdapter(express()));
    await app.listen(port);
    expect(await app.getUrl()).to.be.eql(`http://[::1]:${port}`);
    await app.close();
  });
  it('should be able to get the IPv4 address', async () => {
    const app = testModule.createNestApplication(new ExpressAdapter(express()));
    await app.listen(port, '127.0.0.5');
    expect(await app.getUrl()).to.be.eql(`http://127.0.0.5:${port}`);
    await app.close();
  });
  it('should return 127.0.0.1 for 0.0.0.0', async () => {
    const app = testModule.createNestApplication(new ExpressAdapter(express()));
    await app.listen(port, '0.0.0.0');
    expect(await app.getUrl()).to.be.eql(`http://127.0.0.1:${port}`);
    await app.close();
  });
  it('should return 127.0.0.1 even in a callback', () => {
    const app = testModule.createNestApplication(new ExpressAdapter(express()));
    return app.listen(port, async () => {
      expect(await app.getUrl()).to.be.eql(`http://127.0.0.1:${port}`);
      await app.close();
    });
  });
  it('should throw an error for calling getUrl before listen', async () => {
    const app = testModule.createNestApplication(new ExpressAdapter(express()));
    try {
      await app.getUrl();
    } catch (err) {
      expect(err).to.be.eql(
        'app.listen() needs to be called before calling app.getUrl()',
      );
    }
  });
});



================================================
FILE: integration/nest-application/get-url/e2e/fastify.spec.ts
================================================
import { FastifyAdapter } from '@nestjs/platform-fastify';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';
import { randomPort } from './utils';

describe('Get URL (Fastify Application)', () => {
  let testModule: TestingModule;
  let port: number;

  beforeEach(async () => {
    testModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
  });

  beforeEach(async () => {
    port = await randomPort();
  });

  it('should be able to get the IPv4 address', async () => {
    const app = testModule.createNestApplication(new FastifyAdapter());
    await app.listen(port, '127.0.0.5');
    expect(await app.getUrl()).to.be.eql(`http://127.0.0.5:${port}`);
    await app.close();
  });
  it('should return 127.0.0.1 for 0.0.0.0', async () => {
    const app = testModule.createNestApplication(new FastifyAdapter());
    await app.listen(port, '0.0.0.0');
    expect(await app.getUrl()).to.be.eql(`http://127.0.0.1:${port}`);
    await app.close();
  });
  it('should return 127.0.0.1 even in a callback', () => {
    const app = testModule.createNestApplication(new FastifyAdapter());
    return app.listen(port, async () => {
      expect(await app.getUrl()).to.be.eql(`http://127.0.0.1:${port}`);
      await app.close();
    });
  });
  it('should throw an error for calling getUrl before listen', async () => {
    const app = testModule.createNestApplication(new FastifyAdapter());
    try {
      await app.getUrl();
    } catch (err) {
      expect(err).to.be.eql(
        'app.listen() needs to be called before calling app.getUrl()',
      );
    }
  });
});



================================================
FILE: integration/nest-application/get-url/e2e/utils.ts
================================================
import * as net from 'net';

export let port: number;

export async function randomPort(): Promise<number> {
  const server = net.createServer();
  return new Promise((resolve, reject) => {
    if (port) {
      resolve(port);
    }
    server.listen(0, () => {
      port = (server.address() as net.AddressInfo).port;
      server.close();
      resolve(port);
    });
  });
}



================================================
FILE: integration/nest-application/get-url/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.sayHello();
  }
}



================================================
FILE: integration/nest-application/get-url/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: integration/nest-application/get-url/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  sayHello(): string {
    return 'Hello World!';
  }
}



================================================
FILE: integration/nest-application/global-prefix/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist",
    "strictNullChecks": true,
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/global-prefix/e2e/global-prefix.spec.ts
================================================
import { INestApplication, RequestMethod } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import {
  AppModule,
  MIDDLEWARE_PARAM_VALUE,
  MIDDLEWARE_VALUE,
} from '../src/app.module';

describe('Global prefix', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
  });

  it(`should use the global prefix`, async () => {
    app.setGlobalPrefix('/api/v1');

    server = app.getHttpServer();
    await app.init();

    await request(server).get('/health').expect(404);

    await request(server).get('/api/v1/health').expect(200);
  });

  it(`should exclude the path as string`, async () => {
    app.setGlobalPrefix('/api/v1', { exclude: ['/test', '/middleware'] });

    server = app.getHttpServer();
    await app.init();
    await request(server).get('/test').expect(200);
    await request(server).post('/test').expect(201);

    await request(server).get('/api/v1/test').expect(404);
    await request(server).post('/api/v1/test').expect(404);

    await request(server).get('/middleware').expect(200, MIDDLEWARE_VALUE);
    await request(server).post('/middleware').expect(201, MIDDLEWARE_VALUE);

    await request(server).get('/api/v1/middleware').expect(404);
    await request(server).post('/api/v1/middleware').expect(404);
  });

  it(`should exclude the path as RouteInfo`, async () => {
    app.setGlobalPrefix('/api/v1', {
      exclude: [
        { path: '/health', method: RequestMethod.GET },
        { path: '/middleware', method: RequestMethod.POST },
      ],
    });

    server = app.getHttpServer();
    await app.init();

    await request(server).get('/health').expect(200);

    await request(server).get('/middleware').expect(404);
    await request(server).post('/middleware').expect(201, MIDDLEWARE_VALUE);

    await request(server).get('/api/v1/health').expect(404);

    await request(server)
      .get('/api/v1/middleware')
      .expect(200, MIDDLEWARE_VALUE);
    await request(server).post('/api/v1/middleware').expect(404);
  });

  it(`should only exclude the GET RequestMethod`, async () => {
    app.setGlobalPrefix('/api/v1', {
      exclude: [{ path: '/test', method: RequestMethod.GET }],
    });

    server = app.getHttpServer();
    await app.init();

    await request(server).get('/test').expect(200);

    await request(server).post('/test').expect(404);

    await request(server).post('/api/v1/test').expect(201);
  });

  it(`should exclude the path as a mix of string and RouteInfo`, async () => {
    app.setGlobalPrefix('/api/v1', {
      exclude: ['test', { path: '/health', method: RequestMethod.GET }],
    });

    server = app.getHttpServer();
    await app.init();

    await request(server).get('/health').expect(200);

    await request(server).get('/test').expect(200);
  });

  it(`should exclude the path with route param`, async () => {
    app.setGlobalPrefix('/api/v1', {
      exclude: ['/hello/:name', '/middleware/:name'],
    });

    server = app.getHttpServer();
    await app.init();

    await request(server)
      .get('/hello/foo')
      .expect(200, 'Hello: Data attached in middleware');

    await request(server)
      .get('/middleware/foo')
      .expect(200, MIDDLEWARE_PARAM_VALUE);

    await request(server).get('/api/v1/middleware/foo').expect(404);
  });

  it(`should get the params in the global prefix`, async () => {
    app.setGlobalPrefix('/api/:tenantId');

    server = app.getHttpServer();
    await app.init();

    await request(server)
      .get('/api/test/params')
      .expect(200, { tenantId: 'test', path: ['params'] });
  });

  it(`should execute middleware only once`, async () => {
    app.setGlobalPrefix('/api', { exclude: ['/'] });

    server = app.getHttpServer();
    await app.init();

    await request(server)
      .get('/')
      .expect(200, 'Extras: Data attached in middleware, Count: 1');
    await request(server).get('/api/count').expect(200, '2');
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/nest-application/global-prefix/src/app.controller.ts
================================================
import { Controller, Get, Post, Req } from '@nestjs/common';

@Controller()
export class AppController {
  @Get('hello/:name')
  getHello(@Req() req): string {
    return 'Hello: ' + req.extras?.data;
  }

  @Get('params')
  getParams(@Req() req): any {
    return req.middlewareParams;
  }

  @Get('health')
  getHealth(): string {
    return 'up';
  }

  @Get('test')
  getTest(): string {
    return 'test';
  }

  @Post('test')
  postTest(): string {
    return 'test';
  }

  @Get()
  getHome(@Req() req) {
    return 'Extras: ' + req.extras?.data + ', Count: ' + req.count;
  }

  @Get('count')
  getCount(@Req() req) {
    return req.count;
  }
}



================================================
FILE: integration/nest-application/global-prefix/src/app.module.ts
================================================
import { MiddlewareConsumer, Module, RequestMethod } from '@nestjs/common';
import { AppController } from './app.controller';

export const MIDDLEWARE_VALUE = 'middleware';
export const MIDDLEWARE_PARAM_VALUE = 'middleware_param';

@Module({
  controllers: [AppController],
})
export class AppModule {
  private count = 0;
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res, next) => res.end(MIDDLEWARE_VALUE))
      .forRoutes({ path: MIDDLEWARE_VALUE, method: RequestMethod.GET })
      .apply((req, res, next) => res.status(201).end(MIDDLEWARE_VALUE))
      .forRoutes({ path: MIDDLEWARE_VALUE, method: RequestMethod.POST })
      .apply((req, res, next) => res.end(MIDDLEWARE_PARAM_VALUE))
      .forRoutes({
        path: MIDDLEWARE_VALUE + '/*path',
        method: RequestMethod.GET,
      })
      .apply((req, res, next) => res.status(201).end(MIDDLEWARE_PARAM_VALUE))
      .forRoutes({
        path: MIDDLEWARE_VALUE + '/*path',
        method: RequestMethod.POST,
      })
      .apply((req, res, next) => {
        req.extras = { data: 'Data attached in middleware' };
        next();
      })
      .forRoutes({ path: '*path', method: RequestMethod.GET })
      .apply((req, res, next) => {
        req.middlewareParams = req.params;
        next();
      })
      .forRoutes({ path: '*path', method: RequestMethod.GET })
      .apply((req, res, next) => {
        this.count += 1;
        req.count = this.count;
        next();
      })
      .forRoutes('*path');
  }
}



================================================
FILE: integration/nest-application/listen/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist",
    "strictNullChecks": true,
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/listen/e2e/express.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { ExpressAdapter } from '@nestjs/platform-express';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import * as express from 'express';
import { AppModule } from '../src/app.module';

describe('Listen (Express Application)', () => {
  let testModule: TestingModule;
  let app: INestApplication;

  beforeEach(async () => {
    testModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = testModule.createNestApplication(new ExpressAdapter(express()));
  });

  afterEach(async () => {
    await app.close();
  });

  it('should resolve with httpServer on success', async () => {
    const response = await app.listen(3000);
    expect(response).to.eql(app.getHttpServer());
  });

  it('should reject if the port is not available', async () => {
    await app.listen(3000);
    const secondApp = testModule.createNestApplication(
      new ExpressAdapter(express()),
    );
    try {
      await secondApp.listen(3000);
    } catch (error) {
      expect(error.code).to.equal('EADDRINUSE');
    }
  });

  it('should reject if there is an invalid host', async () => {
    try {
      await app.listen(3000, '1');
    } catch (error) {
      expect(error.code).to.equal('EADDRNOTAVAIL');
    }
  });
});



================================================
FILE: integration/nest-application/listen/e2e/fastify.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { FastifyAdapter } from '@nestjs/platform-fastify';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';

describe('Listen (Fastify Application)', () => {
  let testModule: TestingModule;
  let app: INestApplication;

  beforeEach(async () => {
    testModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = testModule.createNestApplication(new FastifyAdapter());
  });

  afterEach(async () => {
    await app.close();
  });

  it('should resolve with httpServer on success', async () => {
    const response = await app.listen(3000);
    expect(response).to.eql(app.getHttpServer());
  });

  it('should reject if the port is not available', async () => {
    await app.listen(3000);
    const secondApp = testModule.createNestApplication(new FastifyAdapter());
    try {
      await secondApp.listen(3000);
    } catch (error) {
      expect(error.code).to.equal('EADDRINUSE');
    }

    await secondApp.close();
  });

  it('should reject if there is an invalid host', async () => {
    try {
      await app.listen(3000, '1');
    } catch (error) {
      expect(error.code).to.equal('EADDRNOTAVAIL');
    }
  });
});



================================================
FILE: integration/nest-application/listen/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.sayHello();
  }
}



================================================
FILE: integration/nest-application/listen/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: integration/nest-application/listen/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  sayHello(): string {
    return 'Hello World!';
  }
}



================================================
FILE: integration/nest-application/raw-body/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist",
    "strictNullChecks": true,
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/raw-body/e2e/express.spec.ts
================================================
import { NestExpressApplication } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { ExpressModule } from '../src/express.module';

describe('Raw body (Express Application)', () => {
  let app: NestExpressApplication;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [ExpressModule],
    }).compile();

    app = moduleFixture.createNestApplication<NestExpressApplication>({
      rawBody: true,
    });

    await app.init();
  });

  afterEach(async () => {
    await app.close();
  });

  describe('application/json', () => {
    const body = '{ "amount":0.0 }';

    it('should return exact post body', async () => {
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .send(body)
        .expect(201);

      expect(response.body).to.eql({
        parsed: {
          amount: 0,
        },
        raw: body,
      });
    });

    it('should work if post body is empty', async () => {
      await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .expect(201);
    });
  });

  describe('application/x-www-form-urlencoded', () => {
    const body = 'content=this is a post\'s content by "Nest"';

    it('should return exact post body', async () => {
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/x-www-form-urlencoded')
        .send(body)
        .expect(201);

      expect(response.body).to.eql({
        parsed: {
          content: 'this is a post\'s content by "Nest"',
        },
        raw: body,
      });
    });

    it('should work if post body is empty', async () => {
      await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/x-www-form-urlencoded')
        .expect(201);
    });
  });
});



================================================
FILE: integration/nest-application/raw-body/e2e/fastify.spec.ts
================================================
import {
  NestFastifyApplication,
  FastifyAdapter,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { FastifyModule } from '../src/fastify.module';

describe('Raw body (Fastify Application)', () => {
  let app: NestFastifyApplication;

  beforeEach(async () => {
    const moduleFixture = await Test.createTestingModule({
      imports: [FastifyModule],
    }).compile();

    app = moduleFixture.createNestApplication<NestFastifyApplication>(
      new FastifyAdapter(),
      {
        rawBody: true,
      },
    );

    await app.init();
  });

  afterEach(async () => {
    await app.close();
  });

  describe('application/json', () => {
    const body = '{ "amount":0.0 }';

    it('should return exact post body', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/json' },
        payload: body,
      });

      expect(JSON.parse(response.body)).to.eql({
        parsed: {
          amount: 0,
        },
        raw: body,
      });
    });

    it('should fail if post body is empty', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: {
          'content-type': 'application/json',
          accept: 'application/json',
        },
      });

      // Unlike Express, when you send a POST request without a body
      // with Fastify, Fastify will throw an error because it isn't valid
      // JSON. See fastify/fastify#297.
      expect(response.statusCode).to.equal(400);
    });
  });

  describe('application/x-www-form-urlencoded', () => {
    const body = 'content=this is a post\'s content by "Nest"';

    it('should return exact post body', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/x-www-form-urlencoded' },
        payload: body,
      });

      expect(JSON.parse(response.body)).to.eql({
        parsed: {
          content: 'this is a post\'s content by "Nest"',
        },
        raw: body,
      });
    });

    it('should work if post body is empty', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: {
          'content-type': 'application/x-www-form-urlencoded',
        },
      });

      expect(response.statusCode).to.equal(201);
    });
  });
});



================================================
FILE: integration/nest-application/raw-body/src/express.controller.ts
================================================
import { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';
import { Request } from 'express';

@Controller()
export class ExpressController {
  @Post()
  getRawBody(@Req() req: RawBodyRequest<Request>) {
    return {
      parsed: req.body,
      raw: req.rawBody!.toString(),
    };
  }
}



================================================
FILE: integration/nest-application/raw-body/src/express.module.ts
================================================
import { Module } from '@nestjs/common';
import { ExpressController } from './express.controller';

@Module({
  controllers: [ExpressController],
})
export class ExpressModule {}



================================================
FILE: integration/nest-application/raw-body/src/fastify.controller.ts
================================================
import { Controller, Post, RawBodyRequest, Req } from '@nestjs/common';
import type { FastifyRequest } from 'fastify';

@Controller()
export class FastifyController {
  @Post()
  getRawBody(@Req() req: RawBodyRequest<FastifyRequest>) {
    return {
      parsed: req.body,
      raw: req.rawBody!.toString(),
    };
  }
}



================================================
FILE: integration/nest-application/raw-body/src/fastify.module.ts
================================================
import { Module } from '@nestjs/common';
import { FastifyController } from './fastify.controller';

@Module({
  controllers: [FastifyController],
})
export class FastifyModule {}



================================================
FILE: integration/nest-application/sse/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "lib": ["dom"],
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../../packages/common"],
      "@nestjs/common/*": ["../../../packages/common/*"],
      "@nestjs/core": ["../../../packages/core"],
      "@nestjs/core/*": ["../../../packages/core/*"],
      "@nestjs/microservices": ["../../../packages/microservices"],
      "@nestjs/microservices/*": ["../../../packages/microservices/*"],
      "@nestjs/websockets": ["../../../packages/websockets"],
      "@nestjs/websockets/*": ["../../../packages/websockets/*"],
      "@nestjs/testing": ["../../../packages/testing"],
      "@nestjs/testing/*": ["../../../packages/testing/*"],
      "@nestjs/platform-express": ["../../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/nest-application/sse/e2e/express.spec.ts
================================================
import { NestExpressApplication } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { EventSource } from 'eventsource';
import { AppModule } from '../src/app.module';

describe('Sse (Express Application)', () => {
  let app: NestExpressApplication;
  let eventSource: EventSource;

  describe('without forceCloseConnections', () => {
    beforeEach(async () => {
      const moduleFixture = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleFixture.createNestApplication<NestExpressApplication>();

      await app.listen(3000);
      const url = await app.getUrl();

      eventSource = new EventSource(url + '/sse', {
        fetch: (input, init) =>
          fetch(input, {
            ...init,
            headers: {
              ...init?.headers,
              connection: 'keep-alive',
            },
          }),
      });
    });

    // The order of actions is very important here. When not using `forceCloseConnections`,
    // the SSe eventsource should close the connections in order to signal the server that
    // the keep-alive connection can be ended.
    afterEach(async () => {
      eventSource.close();

      await app.close();
    });

    it('receives events from server', done => {
      eventSource.addEventListener('message', event => {
        expect(JSON.parse(event.data)).to.eql({
          hello: 'world',
        });
        done();
      });
    });
  });

  describe('with forceCloseConnections', () => {
    beforeEach(async () => {
      const moduleFixture = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleFixture.createNestApplication<NestExpressApplication>({
        forceCloseConnections: true,
      });

      await app.listen(3000);
      const url = await app.getUrl();

      eventSource = new EventSource(url + '/sse', {
        fetch: (input, init) =>
          fetch(input, {
            ...init,
            headers: {
              ...init?.headers,
              connection: 'keep-alive',
            },
          }),
      });
    });

    afterEach(async () => {
      await app.close();

      eventSource.close();
    });

    it('receives events from server', done => {
      eventSource.addEventListener('message', event => {
        expect(JSON.parse(event.data)).to.eql({
          hello: 'world',
        });
        done();
      });
    });
  });
});



================================================
FILE: integration/nest-application/sse/e2e/fastify.spec.ts
================================================
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { EventSource } from 'eventsource';
import { AppModule } from '../src/app.module';

describe('Sse (Fastify Application)', () => {
  let app: NestFastifyApplication;
  let eventSource: EventSource;

  describe('without forceCloseConnections', () => {
    beforeEach(async () => {
      const moduleFixture = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleFixture.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );

      await app.listen(3000);
      const url = await app.getUrl();

      eventSource = new EventSource(url + '/sse', {
        fetch: (input, init) =>
          fetch(input, {
            ...init,
            headers: {
              ...init?.headers,
              connection: 'keep-alive',
            },
          }),
      });
    });

    // The order of actions is very important here. When not using `forceCloseConnections`,
    // the SSe eventsource should close the connections in order to signal the server that
    // the keep-alive connection can be ended.
    afterEach(async () => {
      eventSource.close();

      await app.close();
    });

    it('receives events from server', done => {
      eventSource.addEventListener('message', event => {
        expect(JSON.parse(event.data)).to.eql({
          hello: 'world',
        });
        done();
      });
    });
  });

  describe('with forceCloseConnections', () => {
    beforeEach(async () => {
      const moduleFixture = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleFixture.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter({
          forceCloseConnections: true,
        }),
      );

      await app.listen(3000);
      const url = await app.getUrl();

      eventSource = new EventSource(url + '/sse', {
        fetch: (input, init) =>
          fetch(input, {
            ...init,
            headers: {
              ...init?.headers,
              connection: 'keep-alive',
            },
          }),
      });
    });

    afterEach(async () => {
      await app.close();

      eventSource.close();
    });

    it('receives events from server', done => {
      eventSource.addEventListener('message', event => {
        expect(JSON.parse(event.data)).to.eql({
          hello: 'world',
        });
        done();
      });
    });
  });
});



================================================
FILE: integration/nest-application/sse/src/app.controller.ts
================================================
import { Controller, MessageEvent, Sse } from '@nestjs/common';
import { interval, map, Observable } from 'rxjs';

@Controller()
export class AppController {
  @Sse('sse')
  sse(): Observable<MessageEvent> {
    return interval(1000).pipe(
      map(() => ({ data: { hello: 'world' } }) as MessageEvent),
    );
  }
}



================================================
FILE: integration/nest-application/sse/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: integration/nest-application/use-body-parser/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "lib": ["dom"],
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "outDir": "./dist"
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules"
  ]
}



================================================
FILE: integration/nest-application/use-body-parser/e2e/express.spec.ts
================================================
import { NestExpressApplication } from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { OptionsUrlencoded } from 'body-parser';
import { expect } from 'chai';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Body Parser (Express Application)', () => {
  const moduleFixture = Test.createTestingModule({
    imports: [AppModule],
  });
  let app: NestExpressApplication;

  afterEach(async () => {
    await app.close();
  });

  describe('application/json', () => {
    const stringLimit = '{ "msg": "Hello, World" }';
    const stringOverLimit = '{ "msg": "Hello, World!" }';

    beforeEach(async () => {
      const testFixture = await moduleFixture.compile();

      app = testFixture
        .createNestApplication<NestExpressApplication>({
          rawBody: true,
          logger: false,
        })
        .useBodyParser('json', { limit: Buffer.from(stringLimit).byteLength });

      await app.init();
    });

    it('should allow request with matching body limit', async () => {
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .send(stringLimit)
        .expect(201);

      expect(response.body).to.eql({
        raw: stringLimit,
      });
    });

    it('should fail if post body is larger than limit', async () => {
      await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/json')
        .send(stringOverLimit)
        .expect(413);
    });
  });

  describe('application/x-www-form-urlencoded', () => {
    const stringLimit = 'msg=Hello, World';
    const stringOverLimit = 'msg=Hello, World!';

    beforeEach(async () => {
      const testFixture = await moduleFixture.compile();

      app = testFixture
        .createNestApplication<NestExpressApplication>({
          rawBody: true,
          logger: false,
        })
        .useBodyParser<OptionsUrlencoded>('urlencoded', {
          limit: Buffer.from(stringLimit).byteLength,
          extended: true,
        });

      await app.init();
    });
    it('should allow request with matching body limit', async () => {
      const response = await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/x-www-form-urlencoded')
        .send(stringLimit)
        .expect(201);

      expect(response.body).to.eql({
        raw: stringLimit,
      });
    });

    it('should fail if post body is larger than limit', async () => {
      await request(app.getHttpServer())
        .post('/')
        .set('Content-Type', 'application/x-www-form-urlencoded')
        .send(stringOverLimit)
        .expect(413);
    });
  });
});



================================================
FILE: integration/nest-application/use-body-parser/e2e/fastify.spec.ts
================================================
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { AppModule } from '../src/app.module';

describe('Body Parser (Fastify Application)', () => {
  const moduleFixture = Test.createTestingModule({
    imports: [AppModule],
  });
  let app: NestFastifyApplication;

  afterEach(async () => {
    await app.close();
  });

  describe('application/json', () => {
    const stringLimit = '{ "msg": "Hello, World" }';
    const stringOverLimit = '{ "msg": "Hello, World!" }';

    beforeEach(async () => {
      const testFixture = await moduleFixture.compile();

      app = testFixture
        .createNestApplication<NestFastifyApplication>(new FastifyAdapter(), {
          rawBody: true,
          logger: false,
        })
        .useBodyParser('application/json', {
          bodyLimit: Buffer.from(stringLimit).byteLength,
        });

      await app.init();
    });

    it('should allow request with matching body limit', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/json' },
        payload: stringLimit,
      });

      expect(JSON.parse(response.body)).to.eql({
        raw: stringLimit,
      });
    });

    it('should fail if post body is larger than limit', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/json' },
        payload: stringOverLimit,
      });

      expect(response.statusCode).to.equal(413);
    });
  });

  describe('application/x-www-form-urlencoded', () => {
    const stringLimit = 'msg=Hello, World';
    const stringOverLimit = 'msg=Hello, World!';

    beforeEach(async () => {
      const testFixture = await moduleFixture.compile();

      app = testFixture
        .createNestApplication<NestFastifyApplication>(new FastifyAdapter(), {
          rawBody: true,
          logger: false,
        })
        .useBodyParser('application/x-www-form-urlencoded', {
          bodyLimit: Buffer.from(stringLimit).byteLength,
        });

      await app.init();
    });

    it('should allow request with matching body limit', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/x-www-form-urlencoded' },
        payload: stringLimit,
      });

      expect(JSON.parse(response.body)).to.eql({
        raw: stringLimit,
      });
    });

    it('should fail if post body is larger than limit', async () => {
      const response = await app.inject({
        method: 'POST',
        url: '/',
        headers: { 'content-type': 'application/x-www-form-urlencoded' },
        payload: stringOverLimit,
      });

      expect(response.statusCode).to.equal(413);
    });
  });
});



================================================
FILE: integration/nest-application/use-body-parser/src/app.controller.ts
================================================
import { Controller, Post, Req, RawBodyRequest } from '@nestjs/common';
import { IncomingMessage } from 'http';

@Controller()
export class AppController {
  @Post()
  index(@Req() req: RawBodyRequest<IncomingMessage>) {
    return {
      raw: req.rawBody?.toString(),
    };
  }
}



================================================
FILE: integration/nest-application/use-body-parser/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: integration/repl/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/repl/e2e/repl.spec.ts
================================================
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { repl } from '@nestjs/core';
import {
  DebugReplFn,
  GetReplFn,
  HelpReplFn,
  MethodsReplFn,
  ResolveReplFn,
  SelectReplFn,
} from '@nestjs/core/repl/native-functions';
import { ReplContext } from '@nestjs/core/repl/repl-context';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { AppModule } from '../src/app.module';

const PROMPT = '\u001b[1G\u001b[0J> \u001b[3G';

describe('REPL', () => {
  beforeEach(() => {
    // To avoid coloring the output:
    sinon.stub(clc, 'bold').callsFake(text => text);
    sinon.stub(clc, 'green').callsFake(text => text);
    sinon.stub(clc, 'yellow').callsFake(text => text);
    sinon.stub(clc, 'red').callsFake(text => text);
    sinon.stub(clc, 'magentaBright').callsFake(text => text);
    sinon.stub(clc, 'cyanBright').callsFake(text => text);
  });
  afterEach(() => {
    sinon.restore();
  });

  it('get()', async () => {
    const server = await repl(AppModule);
    server.context;
    let outputText = '';
    sinon.stub(process.stdout, 'write').callsFake(text => {
      outputText += text as string;
      return true;
    });
    server.emit('line', 'get(UsersService)');

    expect(outputText).to.equal(
      `UsersService { usersRepository: UsersRepository {} }
${PROMPT}`,
    );

    outputText = '';
    server.emit('line', 'get(UsersService).findAll()');

    expect(outputText).to
      .equal(`\u001b[32m'This action returns all users'\u001b[39m
${PROMPT}`);

    outputText = '';
    server.emit('line', 'get("UsersRepository")');

    expect(outputText).to.equal(`UsersRepository {}
${PROMPT}`);
  });

  it('$()', async () => {
    const server = await repl(AppModule);
    server.context;
    let outputText = '';
    sinon.stub(process.stdout, 'write').callsFake(text => {
      outputText += text as string;
      return true;
    });
    server.emit('line', '$(UsersService)');

    expect(outputText).to.equal(
      `UsersService { usersRepository: UsersRepository {} }
${PROMPT}`,
    );

    outputText = '';
    server.emit('line', '$(UsersService).findAll()');

    expect(outputText).to
      .equal(`\u001b[32m'This action returns all users'\u001b[39m
${PROMPT}`);

    outputText = '';
    server.emit('line', '$("UsersRepository")');

    expect(outputText).to.equal(`UsersRepository {}
${PROMPT}`);
  });

  it('debug()', async () => {
    const server = await repl(AppModule);

    let outputText = '';
    sinon.stub(process.stdout, 'write').callsFake(text => {
      outputText += text as string;
      return true;
    });
    server.emit('line', 'debug(UsersModule)');

    expect(outputText).to.equal(
      `
UsersModule:
 - controllers:
  ◻ UsersController
 - providers:
  ◻ UsersService
  ◻ "UsersRepository"

${PROMPT}`,
    );
  });

  it('methods()', async () => {
    const server = await repl(AppModule);

    let outputText = '';
    sinon.stub(process.stdout, 'write').callsFake(text => {
      outputText += text as string;
      return true;
    });
    server.emit('line', 'methods("UsersRepository")');

    expect(outputText).to.equal(
      `
Methods:
 ◻ find

${PROMPT}`,
    );

    outputText = '';
    server.emit('line', 'methods(UsersService)');

    expect(outputText).to.equal(
      `
Methods:
 ◻ create
 ◻ findAll
 ◻ findOne
 ◻ update
 ◻ remove

${PROMPT}`,
    );
  });

  describe('<native_function>.help', () => {
    it(`Typing "help.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new HelpReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'help.help');

      expect(outputText).to.equal(`${description}
Interface: help${signature}
${PROMPT}`);
    });

    it(`Typing "get.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new GetReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'get.help');

      expect(outputText).to.equal(`${description}
Interface: get${signature}
${PROMPT}`);
    });

    it(`Typing "resolve.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new ResolveReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'resolve.help');

      expect(outputText).to.equal(`${description}
Interface: resolve${signature}
${PROMPT}`);
    });

    it(`Typing "select.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new SelectReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'select.help');

      expect(outputText).to.equal(`${description}
Interface: select${signature}
${PROMPT}`);
    });

    it(`Typing "debug.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new DebugReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'debug.help');

      expect(outputText).to.equal(`${description}
Interface: debug${signature}
${PROMPT}`);
    });

    it(`Typing "methods.help" should print function's description and interface`, async () => {
      const replServer = await repl(AppModule);

      const { description, signature } = new MethodsReplFn(
        sinon.stub() as unknown as ReplContext,
      ).fnDefinition;
      let outputText = '';
      sinon.stub(process.stdout, 'write').callsFake(text => {
        outputText += text as string;
        return true;
      });

      replServer.emit('line', 'methods.help');

      expect(outputText).to.equal(`${description}
Interface: methods${signature}
${PROMPT}`);
    });
  });
});



================================================
FILE: integration/repl/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
})
export class AppModule {}



================================================
FILE: integration/repl/src/users/users.controller.ts
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
} from '@nestjs/common';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }

  @Patch(':id')
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(+id, updateUserDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.usersService.remove(+id);
  }
}



================================================
FILE: integration/repl/src/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersController } from './users.controller';
import { UsersRepository } from './users.repository';
import { UsersService } from './users.service';

@Module({
  controllers: [UsersController],
  providers: [
    UsersService,
    {
      provide: UsersRepository.name,
      useValue: new UsersRepository(),
    },
  ],
})
export class UsersModule {}



================================================
FILE: integration/repl/src/users/users.repository.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersRepository {
  async find() {
    return [{ id: 1, email: 'test@nestjs.com' }];
  }
}



================================================
FILE: integration/repl/src/users/users.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';
import { UsersRepository } from './users.repository';

@Injectable()
export class UsersService {
  constructor(
    @Inject('UsersRepository')
    private readonly usersRepository: UsersRepository,
  ) {}

  create(createUserDto: CreateUserDto) {
    return 'This action adds a new user';
  }

  findAll() {
    return `This action returns all users`;
  }

  findOne(id: number) {
    return `This action returns a #${id} user`;
  }

  update(id: number, updateUserDto: UpdateUserDto) {
    return `This action updates a #${id} user`;
  }

  remove(id: number) {
    return `This action removes a #${id} user`;
  }
}



================================================
FILE: integration/repl/src/users/dto/create-user.dto.ts
================================================
export class CreateUserDto {}



================================================
FILE: integration/repl/src/users/dto/update-user.dto.ts
================================================
import { PartialType } from '@nestjs/mapped-types';
import { CreateUserDto } from './create-user.dto';

export class UpdateUserDto extends PartialType(CreateUserDto) {}



================================================
FILE: integration/repl/src/users/entities/user.entity.ts
================================================
export class User {}



================================================
FILE: integration/scopes/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/scopes/e2e/circular-request-scope.spec.ts
================================================
import { INestApplication, Scope } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { HelloController } from '../src/circular-hello/hello.controller';
import { HelloModule } from '../src/circular-hello/hello.module';
import { HelloService } from '../src/circular-hello/hello.service';
import { UsersService } from '../src/circular-hello/users/users.service';

class Meta {
  static COUNTER = 0;
  constructor(private readonly helloService: HelloService) {
    Meta.COUNTER++;
  }
}

describe('Circular request scope', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [
        HelloModule.forRoot({
          provide: 'META',
          useClass: Meta,
          scope: Scope.REQUEST,
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  describe('when one service is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end((err, res) => {
            if (err) return end(err);
            end();
          });
      await new Promise(resolve => performHttpCall(resolve));
      await new Promise(resolve => performHttpCall(resolve));
      await new Promise(resolve => performHttpCall(resolve));
    });

    it(`should create controller for each request`, () => {
      expect(HelloController.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, () => {
      expect(UsersService.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, () => {
      expect(HelloService.COUNTER).to.be.eql(3);
    });

    it(`should create provider for each inquirer`, () => {
      expect(Meta.COUNTER).to.be.eql(3);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/circular-transient-scope.spec.ts
================================================
import { INestApplication, Scope } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { HelloController } from '../src/circular-transient/hello.controller';
import { HelloModule } from '../src/circular-transient/hello.module';
import { HelloService } from '../src/circular-transient/hello.service';
import { UsersService } from '../src/circular-transient/users/users.service';

class Meta {
  static COUNTER = 0;
  constructor(private readonly helloService: HelloService) {
    Meta.COUNTER++;
  }
}

describe('Circular transient scope', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [
        HelloModule.forRoot({
          provide: 'META',
          useClass: Meta,
          scope: Scope.TRANSIENT,
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  describe('when one service is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end(err => {
            if (err) return end(err);
            end();
          });
      await new Promise(resolve => performHttpCall(resolve));
      await new Promise(resolve => performHttpCall(resolve));
      await new Promise(resolve => performHttpCall(resolve));
    });

    it(`should create controller for each request`, async () => {
      expect(HelloController.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, async () => {
      expect(UsersService.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, async () => {
      expect(HelloService.COUNTER).to.be.eql(3);
    });

    it(`should create provider for each inquirer`, async () => {
      expect(Meta.COUNTER).to.be.eql(7);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/durable-providers.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { ContextIdFactory } from '@nestjs/core';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { DurableContextIdStrategy } from '../src/durable/durable-context-id.strategy';
import { DurableModule } from '../src/durable/durable.module';

describe('Durable providers', () => {
  let server: any;
  let app: INestApplication;

  before(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [DurableModule],
    }).compile();

    app = moduleRef.createNestApplication();
    server = app.getHttpServer();
    await app.init();

    ContextIdFactory.apply(new DurableContextIdStrategy());
  });

  describe('when service is durable', () => {
    const performHttpCall = (
      tenantId: number,
      end: (err?: any) => void,
      endpoint = '/durable',
      opts: {
        forceError: boolean;
      } = { forceError: false },
    ) =>
      request(server)
        .get(endpoint)
        .set({ ['x-tenant-id']: String(tenantId) })
        .set({ ['x-force-error']: opts.forceError ? 'true' : 'false' })
        .end((err, res) => {
          if (err) return end(err);
          end(res);
        });

    it(`should share durable providers per tenant`, async () => {
      let result: request.Response;
      result = await new Promise<request.Response>(resolve =>
        performHttpCall(1, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 1');

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(1, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 2');

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(1, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 3');
    });

    it(`should create per-tenant DI sub-tree`, async () => {
      let result: request.Response;
      result = await new Promise<request.Response>(resolve =>
        performHttpCall(4, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 1');

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(5, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 1');

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(6, resolve),
      );
      expect(result.text).equal('Hello world! Counter: 1');
    });

    it(`should register a custom per-tenant request payload`, async () => {
      let result: request.Response;
      result = await new Promise<request.Response>(resolve =>
        performHttpCall(1, resolve, '/durable/echo'),
      );
      expect(result.body).deep.equal({ tenantId: '1' });

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(3, resolve, '/durable/echo'),
      );
      expect(result.body).deep.equal({ tenantId: '3' });
    });

    it(`should return the same tenantId both from durable request scoped service and non-durable request scoped service`, async () => {
      let result: request.Response;
      result = await new Promise<request.Response>(resolve =>
        performHttpCall(1, resolve, '/durable/request-context'),
      );
      expect(result.body).deep.equal({
        durableService: '1',
        nonDurableService: '1',
      });

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(2, resolve, '/durable/request-context'),
      );
      expect(result.body).deep.equal({
        durableService: '2',
        nonDurableService: '2',
      });
    });

    it(`should not cache durable providers that throw errors`, async () => {
      let result: request.Response;

      result = await new Promise<request.Response>(resolve =>
        performHttpCall(10, resolve, '/durable/echo', { forceError: true }),
      );

      expect(result.statusCode).equal(412);

      // The second request should be successful
      result = await new Promise<request.Response>(resolve =>
        performHttpCall(10, resolve, '/durable/echo'),
      );

      expect(result.body).deep.equal({ tenantId: '10' });
    });
  });

  after(async () => {
    ContextIdFactory['strategy'] = undefined;
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/inject-inquirer.spec.ts
================================================
import { INestApplication, Logger } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as sinon from 'sinon';
import * as request from 'supertest';
import { HelloModule } from '../src/inject-inquirer/hello.module';

describe('Inject Inquirer', () => {
  let logger: Record<string, any>;
  let server: any;
  let app: INestApplication;

  beforeEach(async () => {
    logger = { log: sinon.spy() };

    const module = await Test.createTestingModule({
      imports: [HelloModule],
    })
      .overrideProvider(Logger)
      .useValue(logger)
      .compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should allow the injection of inquirer in a Transient Scope`, async () => {
    await request(server).get('/hello/transient');

    expect(
      logger.log.calledWith({
        message: 'Hello transient!',
        feature: 'transient',
      }),
    ).to.be.true;
  });

  it(`should allow the injection of the inquirer in a Request Scope`, async () => {
    await request(server).get('/hello/request');

    expect(
      logger.log.calledWith({
        message: 'Hello request!',
        requestId: sinon.match.string,
        feature: 'request',
      }),
    ).to.be.true;

    const requestId = logger.log.getCall(0).args[0].requestId;

    expect(
      logger.log.calledWith({
        message: 'Goodbye request!',
        requestId,
        feature: 'request',
      }),
    );
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/msvc-request-scope.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { Guard } from '../src/msvc/guards/request-scoped.guard';
import { HelloController } from '../src/msvc/hello.controller';
import { HelloModule } from '../src/msvc/hello.module';
import { Interceptor } from '../src/msvc/interceptors/logging.interceptor';
import { UsersService } from '../src/msvc/users/users.service';

class Meta {
  static COUNTER = 0;
  constructor() {
    Meta.COUNTER++;
  }
}

describe('Request scope (microservices)', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [
        HelloModule.forRoot({
          provide: 'META',
          useClass: Meta,
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    app.connectMicroservice<MicroserviceOptions>({ transport: Transport.TCP });

    server = app.getHttpServer();
    await app.init();
    await app.startAllMicroservices();
  });

  describe('when one service is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end((err, res) => {
            if (err) return end(err);
            end();
          });
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
    });

    it(`should create controller for each request`, () => {
      expect(HelloController.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, () => {
      expect(UsersService.COUNTER).to.be.eql(3);
    });

    it(`should share static provider across requests`, () => {
      expect(Meta.COUNTER).to.be.eql(1);
    });

    it(`should create request scoped interceptor for each request`, () => {
      expect(Interceptor.COUNTER).to.be.eql(3);
      expect(Interceptor.REQUEST_SCOPED_DATA).to.deep.equal([1, 1, 1]);
    });

    it(`should create request scoped guard for each request`, () => {
      expect(Guard.COUNTER).to.be.eql(3);
      expect(Guard.REQUEST_SCOPED_DATA).to.deep.equal([1, 1, 1]);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/request-modules-scope.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { RequestChainModule } from '../src/request-chain/request-chain.module';
import { RequestChainService } from '../src/request-chain/request-chain.service';

describe('Request scope (modules propagation)', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [RequestChainModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  describe('when service from parent module is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end(err => {
            if (err) return end(err);
            end();
          });
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
    });

    it(`should not fail`, () => {
      expect(RequestChainService.COUNTER).to.be.eql(3);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/request-scope.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { Guard } from '../src/hello/guards/request-scoped.guard';
import { HelloController } from '../src/hello/hello.controller';
import { HelloModule } from '../src/hello/hello.module';
import { Interceptor } from '../src/hello/interceptors/logging.interceptor';
import { UserByIdPipe } from '../src/hello/users/user-by-id.pipe';
import { UsersService } from '../src/hello/users/users.service';

class Meta {
  static COUNTER = 0;
  constructor() {
    Meta.COUNTER++;
  }
}

describe('Request scope', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [
        HelloModule.forRoot({
          provide: 'META',
          useClass: Meta,
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  describe('when one service is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end(err => {
            if (err) return end(err);
            end();
          });
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
    });

    it(`should create controller for each request`, () => {
      expect(HelloController.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, () => {
      expect(UsersService.COUNTER).to.be.eql(3);
    });

    it(`should share static provider across requests`, () => {
      expect(Meta.COUNTER).to.be.eql(1);
    });

    it(`should create request scoped pipe for each request`, () => {
      expect(UserByIdPipe.COUNTER).to.be.eql(3);
      expect(UserByIdPipe.REQUEST_SCOPED_DATA).to.deep.equal([1, 1, 1]);
    });

    it(`should create request scoped interceptor for each request`, () => {
      expect(Interceptor.COUNTER).to.be.eql(3);
      expect(Interceptor.REQUEST_SCOPED_DATA).to.deep.equal([1, 1, 1]);
    });

    it(`should create request scoped guard for each request`, () => {
      expect(Guard.COUNTER).to.be.eql(3);
      expect(Guard.REQUEST_SCOPED_DATA).to.deep.equal([1, 1, 1]);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/resolve-scoped.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { loggerProvider } from '../src/resolve-scoped/logger.provider';
import { LoggerService } from '../src/resolve-scoped/logger.service';
import { RequestLoggerService } from '../src/resolve-scoped/request-logger.service';

describe('Resolve method', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [LoggerService, loggerProvider, RequestLoggerService],
    }).compile();

    app = module.createNestApplication();
    await app.init();
  });

  it('should resolve transient logger', async () => {
    const transientLogger = await app.resolve(LoggerService);
    expect(transientLogger.logger).to.be.eql({
      logger: true,
    });
  });

  it('should resolve request-scoped logger', async () => {
    const requestScoped = await app.resolve(RequestLoggerService);

    expect(requestScoped.loggerService).to.be.instanceOf(LoggerService);
    expect(requestScoped.loggerService.logger).to.be.eql({
      logger: true,
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/e2e/transient-scope.spec.ts
================================================
import { INestApplication, Scope } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as request from 'supertest';
import { Guard } from '../src/transient/guards/request-scoped.guard';
import { HelloController } from '../src/transient/hello.controller';
import { HelloModule } from '../src/transient/hello.module';
import { Interceptor } from '../src/transient/interceptors/logging.interceptor';
import { UserByIdPipe } from '../src/transient/users/user-by-id.pipe';
import { UsersService } from '../src/transient/users/users.service';

class Meta {
  static COUNTER = 0;
  constructor() {
    Meta.COUNTER++;
  }
}

describe('Transient scope', () => {
  let server;
  let app: INestApplication;

  before(async () => {
    const module = await Test.createTestingModule({
      imports: [
        HelloModule.forRoot({
          provide: 'META',
          useClass: Meta,
          scope: Scope.TRANSIENT,
        }),
      ],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  describe('when one service is request scoped', () => {
    before(async () => {
      const performHttpCall = end =>
        request(server)
          .get('/hello')
          .end(err => {
            if (err) return end(err);
            end();
          });
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
      await new Promise<any>(resolve => performHttpCall(resolve));
    });

    it(`should create controller for each request`, () => {
      expect(HelloController.COUNTER).to.be.eql(3);
    });

    it(`should create service for each request`, () => {
      expect(UsersService.COUNTER).to.be.eql(3);
    });

    it(`should create provider for each inquirer`, () => {
      expect(Meta.COUNTER).to.be.eql(7);
    });

    it(`should create transient pipe for each controller (3 requests, 1 static)`, () => {
      expect(UserByIdPipe.COUNTER).to.be.eql(4);
    });

    it(`should create transient interceptor for each controller (3 requests, 1 static)`, () => {
      expect(Interceptor.COUNTER).to.be.eql(4);
    });

    it(`should create transient guard for each controller (3 requests, 1 static)`, () => {
      expect(Guard.COUNTER).to.be.eql(4);
    });
  });

  after(async () => {
    await app.close();
  });
});



================================================
FILE: integration/scopes/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelloModule } from './hello/hello.module';

@Module({
  imports: [HelloModule.forRoot({ provide: 'META', useValue: true })],
})
export class ApplicationModule {}



================================================
FILE: integration/scopes/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { ApplicationModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(ApplicationModule);
  await app.listen(3000);
}
void bootstrap();



================================================
FILE: integration/scopes/src/circular-hello/hello.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';
import { UsersService } from './users/users.service';

@Controller('hello')
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/scopes/src/circular-hello/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController],
  providers: [HelloService, UsersService],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/scopes/src/circular-hello/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    HelloService.COUNTER++;
  }

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/scopes/src/circular-hello/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/scopes/src/circular-hello/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Guard implements CanActivate {
  static COUNTER = 0;
  constructor() {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}



================================================
FILE: integration/scopes/src/circular-hello/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  constructor() {
    Interceptor.COUNTER++;
  }
  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    return call.handle();
  }
}



================================================
FILE: integration/scopes/src/circular-hello/users/user-by-id.pipe.ts
================================================
import { ArgumentMetadata, Injectable, PipeTransform } from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  static COUNTER = 0;
  constructor(private readonly usersService: UsersService) {
    UserByIdPipe.COUNTER++;
  }

  transform(value: string, metadata: ArgumentMetadata) {
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/scopes/src/circular-hello/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/scopes/src/circular-transient/hello.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';
import { UsersService } from './users/users.service';

@Controller('hello')
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/scopes/src/circular-transient/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { TestController } from './test.controller';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController, TestController],
  providers: [HelloService, UsersService],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/scopes/src/circular-transient/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    HelloService.COUNTER++;
  }

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/scopes/src/circular-transient/test.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';

@Controller('test')
export class TestController {
  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return 'hey';
  }
}



================================================
FILE: integration/scopes/src/circular-transient/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/scopes/src/circular-transient/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.TRANSIENT })
export class Guard implements CanActivate {
  static COUNTER = 0;
  constructor() {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}



================================================
FILE: integration/scopes/src/circular-transient/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.TRANSIENT })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  constructor() {
    Interceptor.COUNTER++;
  }
  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    return call.handle();
  }
}



================================================
FILE: integration/scopes/src/circular-transient/users/user-by-id.pipe.ts
================================================
import {
  ArgumentMetadata,
  Injectable,
  PipeTransform,
  Scope,
} from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class UserByIdPipe implements PipeTransform<string> {
  static COUNTER = 0;
  constructor() {
    UserByIdPipe.COUNTER++;
  }

  transform(value: string, metadata: ArgumentMetadata) {
    return value;
  }
}



================================================
FILE: integration/scopes/src/circular-transient/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/scopes/src/durable/durable-context-id.strategy.ts
================================================
import { ContextId, ContextIdStrategy, HostComponentInfo } from '@nestjs/core';
import { Request } from 'express';

export type TenantContext = {
  tenantId: string;
  forceError?: boolean;
};

const tenants = new Map<string, ContextId>();

export class DurableContextIdStrategy implements ContextIdStrategy {
  attach(contextId: ContextId, request: Request) {
    const tenantId = request.headers['x-tenant-id'] as string;
    const forceError = request.headers['x-force-error'] === 'true';

    let tenantSubTreeId: ContextId;

    if (tenants.has(tenantId)) {
      tenantSubTreeId = tenants.get(tenantId)!;
    } else {
      tenantSubTreeId = { id: +tenantId } as ContextId;
      tenants.set(tenantId, tenantSubTreeId);
    }

    const payload: TenantContext = { tenantId };
    if (forceError) {
      payload.forceError = true;
    }
    return {
      resolve: (info: HostComponentInfo) =>
        info.isTreeDurable ? tenantSubTreeId : contextId,
      payload,
    };
  }
}



================================================
FILE: integration/scopes/src/durable/durable.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { DurableService } from './durable.service';
import { NonDurableService } from './non-durable.service';

@Controller('durable')
export class DurableController {
  constructor(
    private readonly durableService: DurableService,
    private readonly nonDurableService: NonDurableService,
  ) {}

  @Get()
  greeting(): string {
    return this.durableService.greeting();
  }

  @Get('echo')
  echo() {
    return {
      tenantId: this.durableService.getTenantId(),
    };
  }

  @Get('request-context')
  getRequestContext() {
    return {
      durableService: this.durableService.getTenantId(),
      nonDurableService: this.nonDurableService.getTenantId(),
    };
  }
}



================================================
FILE: integration/scopes/src/durable/durable.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Scope,
} from '@nestjs/common';
import { DurableService } from './durable.service';

@Injectable({ scope: Scope.REQUEST, durable: true })
export class DurableGuard implements CanActivate {
  public instanceCounter = 0;
  constructor(private readonly durableService: DurableService) {}

  public async canActivate(context: ExecutionContext): Promise<boolean> {
    if (typeof this.durableService === 'undefined') {
      throw new Error('Durable service is undefined');
    }
    this.instanceCounter++;
    return true;
  }
}



================================================
FILE: integration/scopes/src/durable/durable.module.ts
================================================
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { DurableController } from './durable.controller';
import { DurableGuard } from './durable.guard';
import { DurableService } from './durable.service';
import { NonDurableService } from './non-durable.service';

@Module({
  controllers: [DurableController],
  providers: [
    DurableService,
    NonDurableService,
    {
      provide: APP_GUARD,
      useClass: DurableGuard,
    },
  ],
})
export class DurableModule {}



================================================
FILE: integration/scopes/src/durable/durable.service.ts
================================================
import {
  Inject,
  Injectable,
  PreconditionFailedException,
  Scope,
} from '@nestjs/common';
import { REQUEST } from '@nestjs/core';
import { TenantContext } from './durable-context-id.strategy';

@Injectable({ scope: Scope.REQUEST, durable: true })
export class DurableService {
  public instanceCounter = 0;

  constructor(@Inject(REQUEST) private readonly requestPayload: TenantContext) {
    if (requestPayload.forceError) {
      throw new PreconditionFailedException('Forced error');
    }
  }

  greeting() {
    ++this.instanceCounter;
    return `Hello world! Counter: ${this.instanceCounter}`;
  }

  getTenantId() {
    return this.requestPayload.tenantId;
  }
}



================================================
FILE: integration/scopes/src/durable/non-durable.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';
import { TenantContext } from './durable-context-id.strategy';

@Injectable()
export class NonDurableService {
  constructor(
    @Inject(REQUEST) private readonly requestPayload: TenantContext,
  ) {}

  getTenantId() {
    return this.requestPayload.tenantId;
  }
}



================================================
FILE: integration/scopes/src/hello/hello.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';
import { UsersService } from './users/users.service';

@Controller('hello')
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/scopes/src/hello/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider, Scope } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController],
  providers: [
    HelloService,
    UsersService,
    {
      provide: 'REQUEST_ID',
      useFactory: () => 1,
      scope: Scope.REQUEST,
    },
  ],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/scopes/src/hello/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  constructor(@Inject('META') private readonly meta) {}

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/scopes/src/hello/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/scopes/src/hello/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Guard implements CanActivate {
  static COUNTER = 0;
  static REQUEST_SCOPED_DATA = [] as number[];

  constructor(@Inject('REQUEST_ID') private readonly requestId: number) {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    Guard.REQUEST_SCOPED_DATA.push(this.requestId);
    return true;
  }
}



================================================
FILE: integration/scopes/src/hello/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  static REQUEST_SCOPED_DATA = [] as number[];

  constructor(@Inject('REQUEST_ID') private readonly requestId: number) {
    Interceptor.COUNTER++;
  }

  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    Interceptor.REQUEST_SCOPED_DATA.push(this.requestId);
    return call.handle();
  }
}



================================================
FILE: integration/scopes/src/hello/users/user-by-id.pipe.ts
================================================
import {
  ArgumentMetadata,
  Inject,
  Injectable,
  PipeTransform,
} from '@nestjs/common';
import { UsersService } from './users.service';

@Injectable()
export class UserByIdPipe implements PipeTransform<string> {
  static COUNTER = 0;
  static REQUEST_SCOPED_DATA = [] as number[];

  constructor(
    @Inject('REQUEST_ID') private readonly requestId: number,
    private readonly usersService: UsersService,
  ) {
    UserByIdPipe.COUNTER++;
  }

  transform(value: string, metadata: ArgumentMetadata) {
    UserByIdPipe.REQUEST_SCOPED_DATA.push(this.requestId);
    return this.usersService.findById(value);
  }
}



================================================
FILE: integration/scopes/src/hello/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/scopes/src/inject-inquirer/hello.controller.ts
================================================
import { Controller, Get, Scope } from '@nestjs/common';
import { HelloRequestService } from './hello-request/hello-request.service';
import { HelloTransientService } from './hello-transient/hello-transient.service';

@Controller({
  path: 'hello',
  scope: Scope.REQUEST,
})
export class HelloController {
  constructor(
    private readonly helloTransientService: HelloTransientService,
    private readonly helloRequestService: HelloRequestService,
  ) {}

  @Get('transient')
  greetingTransient() {
    this.helloTransientService.greeting();
  }

  @Get('request')
  greetingRequest() {
    this.helloRequestService.greeting();
    this.helloRequestService.farewell();
  }
}



================================================
FILE: integration/scopes/src/inject-inquirer/hello.module.ts
================================================
import { Module, Logger } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloRequestService } from './hello-request/hello-request.service';
import { HelloTransientService } from './hello-transient/hello-transient.service';
import { RequestLogger } from './hello-request/request-logger.service';
import { TransientLogger } from './hello-transient/transient-logger.service';

@Module({
  controllers: [HelloController],
  providers: [
    HelloRequestService,
    HelloTransientService,
    RequestLogger,
    TransientLogger,
    Logger,
  ],
})
export class HelloModule {}



================================================
FILE: integration/scopes/src/inject-inquirer/hello-request/hello-request.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { INQUIRER } from '@nestjs/core';
import { RequestLogger } from './request-logger.service';

@Injectable({ scope: Scope.REQUEST })
export class HelloRequestService {
  static logger = { feature: 'request' };

  constructor(
    private readonly logger: RequestLogger,
    @Inject(INQUIRER) private readonly inquirer,
  ) {}

  greeting() {
    this.logger.log('Hello request!');
  }

  farewell() {
    this.logger.log('Goodbye request!');
  }
}



================================================
FILE: integration/scopes/src/inject-inquirer/hello-request/request-logger.service.ts
================================================
import { Inject, Injectable, Logger, Scope } from '@nestjs/common';
import { INQUIRER, REQUEST } from '@nestjs/core';

@Injectable({ scope: Scope.TRANSIENT })
export class RequestLogger {
  config: object;

  constructor(
    @Inject(INQUIRER) { constructor },
    @Inject(REQUEST) private readonly request,
    private readonly logger: Logger,
  ) {
    this.config = (constructor && constructor.logger) || {};
  }

  get requestId() {
    if (!this.request.id) {
      this.request.id = `${Date.now()}.${Math.floor(Math.random() * 1000000)}`;
    }
    return this.request.id;
  }

  log(message: string) {
    this.logger.log({ message, requestId: this.requestId, ...this.config });
  }
}



================================================
FILE: integration/scopes/src/inject-inquirer/hello-transient/hello-transient.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { TransientLogger } from './transient-logger.service';

@Injectable()
export class HelloTransientService {
  static logger = { feature: 'transient' };

  constructor(private readonly logger: TransientLogger) {}

  greeting() {
    this.logger.log('Hello transient!');
  }
}



================================================
FILE: integration/scopes/src/inject-inquirer/hello-transient/transient-logger.service.ts
================================================
import { Inject, Injectable, Logger, Scope } from '@nestjs/common';
import { INQUIRER } from '@nestjs/core';

@Injectable({ scope: Scope.TRANSIENT })
export class TransientLogger {
  @Inject(INQUIRER) inquirer: any = null;
  config: object;

  constructor(
    @Inject(INQUIRER) private readonly inquirerInCtor,
    private readonly logger: Logger,
  ) {
    this.config =
      (inquirerInCtor.constructor && inquirerInCtor.constructor.logger) || {};
  }

  log(message: string) {
    this.logger.log({ message, ...this.config });
  }
}



================================================
FILE: integration/scopes/src/msvc/hello.controller.ts
================================================
import { Controller, UseGuards, UseInterceptors } from '@nestjs/common';
import { MessagePattern } from '@nestjs/microservices';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UsersService } from './users/users.service';

@Controller()
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @MessagePattern('test')
  greeting(): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/scopes/src/msvc/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider, Scope } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { HttpController } from './http.controller';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController, HttpController],
  providers: [
    HelloService,
    UsersService,
    {
      provide: 'REQUEST_ID',
      useFactory: () => 1,
      scope: Scope.REQUEST,
    },
  ],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/scopes/src/msvc/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  constructor(@Inject('META') private readonly meta) {}

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/scopes/src/msvc/http.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { ClientProxyFactory, Transport } from '@nestjs/microservices';

@Controller()
export class HttpController {
  @Get('hello')
  testMsvc() {
    const client = ClientProxyFactory.create({
      transport: Transport.TCP,
    });
    return client.send('test', { test: true });
  }
}



================================================
FILE: integration/scopes/src/msvc/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/scopes/src/msvc/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Inject,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Guard implements CanActivate {
  static COUNTER = 0;
  static REQUEST_SCOPED_DATA = [] as number[];

  constructor(@Inject('REQUEST_ID') private readonly requestId: number) {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    Guard.REQUEST_SCOPED_DATA.push(this.requestId);
    return true;
  }
}



================================================
FILE: integration/scopes/src/msvc/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.REQUEST })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  static REQUEST_SCOPED_DATA = [] as number[];

  constructor(@Inject('REQUEST_ID') private readonly requestId: number) {
    Interceptor.COUNTER++;
  }

  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    Interceptor.REQUEST_SCOPED_DATA.push(this.requestId);
    return call.handle();
  }
}



================================================
FILE: integration/scopes/src/msvc/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/scopes/src/request-chain/request-chain.controller.ts
================================================
import { Controller, Get, UseInterceptors } from '@nestjs/common';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { RequestChainService } from './request-chain.service';

@Controller('hello')
export class RequestChainController {
  constructor(private readonly chainService: RequestChainService) {}

  @UseInterceptors(LoggingInterceptor)
  @Get()
  greeting(): void {
    this.chainService.call();
  }
}



================================================
FILE: integration/scopes/src/request-chain/request-chain.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelperModule } from './helper/helper.module';
import { RequestChainController } from './request-chain.controller';
import { RequestChainService } from './request-chain.service';

@Module({
  imports: [HelperModule],
  providers: [RequestChainService],
  controllers: [RequestChainController],
})
export class RequestChainModule {}



================================================
FILE: integration/scopes/src/request-chain/request-chain.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { HelperService } from './helper/helper.service';

@Injectable()
export class RequestChainService {
  static COUNTER = 0;
  constructor(private readonly helperService: HelperService) {
    helperService.noop();
    RequestChainService.COUNTER += 1;
  }

  call() {
    this.helperService.noop();
  }
}



================================================
FILE: integration/scopes/src/request-chain/helper/helper.module.ts
================================================
import { Module } from '@nestjs/common';
import { HelperService } from './helper.service';

@Module({
  providers: [HelperService],
  exports: [HelperService],
})
export class HelperModule {}



================================================
FILE: integration/scopes/src/request-chain/helper/helper.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { REQUEST } from '@nestjs/core';

@Injectable({ scope: Scope.REQUEST })
export class HelperService {
  constructor(@Inject(REQUEST) public readonly request) {}

  public noop() {}
}



================================================
FILE: integration/scopes/src/request-chain/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { HelperService } from '../helper/helper.service';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  constructor(private readonly helperSvc: HelperService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    this.helperSvc.noop();
    if (!this.helperSvc.request) {
      throw new Error('error');
    }
    return next.handle();
  }
}



================================================
FILE: integration/scopes/src/resolve-scoped/logger.provider.ts
================================================
import { FactoryProvider } from '@nestjs/common';

export const LOGGER_PROVIDER = 'LOGGER_PROVIDER';
export const loggerProvider: FactoryProvider = {
  provide: LOGGER_PROVIDER,
  useFactory: () => {
    return { logger: true };
  },
};



================================================
FILE: integration/scopes/src/resolve-scoped/logger.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';
import { LOGGER_PROVIDER } from './logger.provider';

@Injectable({ scope: Scope.TRANSIENT })
export class LoggerService {
  constructor(@Inject(LOGGER_PROVIDER) public logger) {}
}



================================================
FILE: integration/scopes/src/resolve-scoped/request-logger.service.ts
================================================
import { Injectable, Scope } from '@nestjs/common';
import { LoggerService } from './logger.service';

@Injectable({ scope: Scope.REQUEST })
export class RequestLoggerService {
  constructor(public loggerService: LoggerService) {}
}



================================================
FILE: integration/scopes/src/transient/hello.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { HelloService } from './hello.service';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';
import { UsersService } from './users/users.service';

@Controller('hello')
export class HelloController {
  static COUNTER = 0;
  constructor(
    private readonly helloService: HelloService,
    private readonly usersService: UsersService,
  ) {
    HelloController.COUNTER++;
  }

  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return this.helloService.greeting();
  }
}



================================================
FILE: integration/scopes/src/transient/hello.module.ts
================================================
import { DynamicModule, Inject, Module, Provider } from '@nestjs/common';
import { HelloController } from './hello.controller';
import { HelloService } from './hello.service';
import { TestController } from './test.controller';
import { UsersService } from './users/users.service';

@Module({
  controllers: [HelloController, TestController],
  providers: [HelloService, UsersService],
})
export class HelloModule {
  constructor(@Inject('META') private readonly meta) {}

  static forRoot(meta: Provider): DynamicModule {
    return {
      module: HelloModule,
      providers: [meta],
    };
  }
}



================================================
FILE: integration/scopes/src/transient/hello.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class HelloService {
  constructor(@Inject('META') private readonly meta) {}

  greeting(): string {
    return 'Hello world!';
  }
}



================================================
FILE: integration/scopes/src/transient/test.controller.ts
================================================
import {
  Controller,
  Get,
  Param,
  UseGuards,
  UseInterceptors,
} from '@nestjs/common';
import { Guard } from './guards/request-scoped.guard';
import { Interceptor } from './interceptors/logging.interceptor';
import { UserByIdPipe } from './users/user-by-id.pipe';

@Controller('test')
export class TestController {
  @UseGuards(Guard)
  @UseInterceptors(Interceptor)
  @Get()
  greeting(@Param('id', UserByIdPipe) id): string {
    return 'hey';
  }
}



================================================
FILE: integration/scopes/src/transient/dto/test.dto.ts
================================================
import { IsString, IsNotEmpty, IsNumber } from 'class-validator';

export class TestDto {
  @IsString()
  @IsNotEmpty()
  string: string;

  @IsNumber()
  number: number;
}



================================================
FILE: integration/scopes/src/transient/guards/request-scoped.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.TRANSIENT })
export class Guard implements CanActivate {
  static COUNTER = 0;
  constructor() {
    Guard.COUNTER++;
  }

  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean> {
    return true;
  }
}



================================================
FILE: integration/scopes/src/transient/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  Scope,
} from '@nestjs/common';
import { Observable } from 'rxjs';

@Injectable({ scope: Scope.TRANSIENT })
export class Interceptor implements NestInterceptor {
  static COUNTER = 0;
  constructor() {
    Interceptor.COUNTER++;
  }
  intercept(context: ExecutionContext, call: CallHandler): Observable<any> {
    return call.handle();
  }
}



================================================
FILE: integration/scopes/src/transient/users/user-by-id.pipe.ts
================================================
import { Injectable, PipeTransform, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.TRANSIENT })
export class UserByIdPipe implements PipeTransform<string> {
  static COUNTER = 0;
  constructor() {
    UserByIdPipe.COUNTER++;
  }

  transform(value: string) {
    return value;
  }
}



================================================
FILE: integration/scopes/src/transient/users/users.service.ts
================================================
import { Inject, Injectable, Scope } from '@nestjs/common';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {
  static COUNTER = 0;
  constructor(@Inject('META') private readonly meta) {
    UsersService.COUNTER++;
  }

  findById(id: string) {
    return { id };
  }
}



================================================
FILE: integration/send-files/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/send-files/e2e/express.spec.ts
================================================
import {
  ExpressAdapter,
  NestExpressApplication,
} from '@nestjs/platform-express';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { readFileSync } from 'fs';
import { join } from 'path';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';
import {
  getHttpBaseOptions,
  sendCanceledHttpRequest,
  sendHttpRequest,
} from './utils';

const readme = readFileSync(join(process.cwd(), 'Readme.md'));
const readmeString = readme.toString();

describe('Express FileSend', () => {
  let app: NestExpressApplication;

  beforeEach(async () => {
    const modRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = modRef.createNestApplication(new ExpressAdapter());
    await app.init();
  });

  it('should return a file from a stream', async () => {
    return request(app.getHttpServer())
      .get('/file/stream/')
      .expect(200)
      .expect(res => {
        expect(res.body.toString()).to.be.eq(readmeString);
      });
  });
  it('should return a file from a buffer', async () => {
    return request(app.getHttpServer())
      .get('/file/buffer')
      .expect(200)
      .expect(res => {
        expect(res.body.toString()).to.be.eq(readmeString);
      });
  });
  it('should not stream a non-file', async () => {
    return request(app.getHttpServer())
      .get('/non-file/pipe-method')
      .expect(200)
      .expect({ value: 'Hello world' });
  });
  it('should return a file from an RxJS stream', async () => {
    return request(app.getHttpServer())
      .get('/file/rxjs/stream/')
      .expect(200)
      .expect(res => {
        expect(res.body.toString()).to.be.eq(readmeString);
      });
  });
  it('should return a file with correct headers', async () => {
    return request(app.getHttpServer())
      .get('/file/with/headers')
      .expect(200)
      .expect('Content-Type', 'text/markdown')
      .expect('Content-Disposition', 'attachment; filename="Readme.md"')
      .expect('Content-Length', readme.byteLength.toString())
      .expect(res => {
        expect(res.text).to.be.eq(readmeString);
      });
  });
  it('should return an error if the file does not exist', async () => {
    return request(app.getHttpServer()).get('/file/not/exist').expect(400);
  });
  // TODO: temporarily turned off (flaky test)
  it.skip(
    'should allow for the client to end the response and be able to make another',
    async () => {
      await app.listen(0);
      const url = await getHttpBaseOptions(app);
      await sendCanceledHttpRequest(new URL('/file/slow', url));
      const res = await sendHttpRequest(new URL('/file/stream', url));
      expect(res.statusCode).to.be.eq(200);
    },
  ).timeout(5000);
});



================================================
FILE: integration/send-files/e2e/fastify.spec.ts
================================================
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { readFileSync } from 'fs';
import { join } from 'path';
import { AppModule } from '../src/app.module';

const readme = readFileSync(join(process.cwd(), 'Readme.md'));
const readmeString = readme.toString();

describe('Fastify FileSend', () => {
  let app: NestFastifyApplication;

  beforeEach(async () => {
    const modRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = modRef.createNestApplication(new FastifyAdapter());
    await app.init();
  });

  it('should return a file from a stream', async () => {
    return app
      .inject({
        method: 'GET',
        url: '/file/stream',
      })
      .then(({ payload }) => {
        expect(payload.toString()).to.be.eq(readmeString);
      });
  });
  it('should return a file from a buffer', async () => {
    return app
      .inject({
        method: 'GET',
        url: '/file/buffer',
      })
      .then(({ payload }) => {
        expect(payload.toString()).to.be.eq(readmeString);
      });
  });
  /**
   * It seems that Fastify has a similar issue as Kamil initially pointed out
   * If a class has a `pipe` method, it will be treated as a stream. This means
   * that the `NonFile` test is a failed case for fastify, hence the skip.
   */
  it.skip('should not stream a non-file', async () => {
    return app
      .inject({
        url: '/non-file/pipe-method',
        method: 'get',
      })
      .then(({ payload }) => {
        expect(payload).to.be.eq({ value: 'Hello world' });
      });
  });
  it('should return a file from an RxJS stream', async () => {
    return app
      .inject({
        method: 'GET',
        url: '/file/rxjs/stream',
      })
      .then(({ payload }) => {
        expect(payload.toString()).to.be.eq(readmeString);
      });
  });
  it('should return a file with correct headers', async () => {
    return app
      .inject({ url: '/file/with/headers', method: 'get' })
      .then(({ statusCode, headers, payload }) => {
        expect(statusCode).to.equal(200);
        expect(headers['content-type']).to.equal('text/markdown');
        expect(headers['content-disposition']).to.equal(
          'attachment; filename="Readme.md"',
        );
        expect(headers['content-length']).to.equal(`${readme.byteLength}`);
        expect(payload).to.equal(readmeString);
      });
  });
});



================================================
FILE: integration/send-files/e2e/utils.ts
================================================
import { INestApplication } from '@nestjs/common';
import { IncomingMessage, request } from 'http';
import { URL } from 'url';

export const getHttpBaseOptions = async (
  app: INestApplication,
): Promise<URL> => {
  const url = await app.getUrl();
  return new URL(url);
};

export const sendCanceledHttpRequest = async (url: URL) => {
  return new Promise(resolve => {
    const req = request(url, res => {
      // close the request once we get the first response of data
      res.on('data', () => {
        req.destroy();
      });
      // response is closed, move on to next request and verify it's doable
      res.on('close', resolve);
    });
    // fire the request
    req.end();
  });
};

export const sendHttpRequest = async (url: URL) => {
  return new Promise<IncomingMessage>((resolve, reject) => {
    const req = request(url, res => {
      // this makes sure that the response actually starts and is read. We could verify this value against the same
      // that is in an earlier test, but all we care about in _this_ test is that the status code is 200
      res.on('data', () => {
        // no op
      });
      // fail the test if something goes wrong
      res.on('error', err => {
        reject(err);
      });
      // pass the response back so we can verify values in the test
      res.on('end', () => {
        resolve(res);
      });
    });
    // fire the request
    req.end();
  });
};



================================================
FILE: integration/send-files/src/app.controller.ts
================================================
import { Controller, Get, StreamableFile } from '@nestjs/common';
import { Observable } from 'rxjs';
import { AppService } from './app.service';
import { NonFile } from './non-file';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get('file/stream')
  getFile(): StreamableFile {
    return this.appService.getReadStream();
  }

  @Get('file/buffer')
  getBuffer(): StreamableFile {
    return this.appService.getBuffer();
  }

  @Get('non-file/pipe-method')
  getNonFile(): NonFile {
    return this.appService.getNonFile();
  }

  @Get('file/rxjs/stream')
  getRxJSFile(): Observable<StreamableFile> {
    return this.appService.getRxJSFile();
  }

  @Get('file/with/headers')
  getFileWithHeaders(): StreamableFile {
    return this.appService.getFileWithHeaders();
  }

  @Get('file/not/exist')
  getNonExistantFile(): StreamableFile {
    return this.appService.getFileThatDoesNotExist();
  }

  @Get('/file/slow')
  getSlowFile(): StreamableFile {
    return this.appService.getSlowStream();
  }
}



================================================
FILE: integration/send-files/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: integration/send-files/src/app.service.ts
================================================
import { Injectable, StreamableFile } from '@nestjs/common';
import { randomBytes } from 'crypto';
import { createReadStream, readFileSync } from 'fs';
import { join } from 'path';
import { Observable, of } from 'rxjs';
import { Readable } from 'stream';
import { NonFile } from './non-file';

@Injectable()
export class AppService {
  // `randomBytes` has a max value of 2^31 -1. That's all this is
  private readonly MAX_BITES = Math.pow(2, 31) - 1;

  getReadStream(): StreamableFile {
    return new StreamableFile(
      createReadStream(join(process.cwd(), 'Readme.md')),
    );
  }

  getBuffer(): StreamableFile {
    return new StreamableFile(readFileSync(join(process.cwd(), 'Readme.md')));
  }

  getNonFile(): NonFile {
    return new NonFile('Hello world');
  }

  getRxJSFile(): Observable<StreamableFile> {
    return of(this.getReadStream());
  }

  getFileWithHeaders(): StreamableFile {
    const file = readFileSync(join(process.cwd(), 'Readme.md'));
    return new StreamableFile(
      createReadStream(join(process.cwd(), 'Readme.md')),
      {
        type: 'text/markdown',
        disposition: 'attachment; filename="Readme.md"',
        length: file.byteLength,
      },
    );
  }

  getFileThatDoesNotExist(): StreamableFile {
    return new StreamableFile(createReadStream('does-not-exist.txt'));
  }

  getSlowStream(): StreamableFile {
    const stream = new Readable();
    stream.push(Buffer.from(randomBytes(this.MAX_BITES)));
    // necessary for a `new Readable()`. Doesn't do anything
    stream._read = () => {};
    return new StreamableFile(stream);
  }
}



================================================
FILE: integration/send-files/src/non-file.ts
================================================
export class NonFile {
  constructor(private readonly value: string) {}

  pipe() {
    return this.value;
  }
}



================================================
FILE: integration/testing-module-override/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": ["src/**/*", "e2e/**/*"],
}



================================================
FILE: integration/testing-module-override/circular-dependency/a.module.ts
================================================
import { Injectable, Module, forwardRef } from '@nestjs/common';
import { BModule } from './b.module';

@Injectable()
export class AProvider {}

@Module({
  imports: [forwardRef(() => BModule)],
  providers: [AProvider],
  exports: [AProvider],
})
export class AModule {}



================================================
FILE: integration/testing-module-override/circular-dependency/b.module.ts
================================================
import { Injectable, Module, forwardRef } from '@nestjs/common';
import { AModule } from './a.module';

@Injectable()
export class BProvider {}

@Module({
  imports: [forwardRef(() => AModule)],
  providers: [BProvider],
  exports: [BProvider],
})
export class BModule {}



================================================
FILE: integration/testing-module-override/e2e/modules-override.spec.ts
================================================
import {
  Controller,
  DynamicModule,
  forwardRef,
  Global,
  Injectable,
  Module,
} from '@nestjs/common';
import { LazyModuleLoader } from '@nestjs/core';
import { Test, TestingModule } from '@nestjs/testing';
import { expect } from 'chai';
import { AModule, AProvider } from '../circular-dependency/a.module';
import { BModule, BProvider } from '../circular-dependency/b.module';

describe('Modules overriding', () => {
  describe('Top-level module', () => {
    @Controller()
    class ControllerOverwritten {}

    @Module({
      controllers: [ControllerOverwritten],
    })
    class ModuleToBeOverwritten {}

    @Controller()
    class ControllerOverride {}

    @Module({
      controllers: [ControllerOverride],
    })
    class ModuleOverride {}

    let testingModule: TestingModule;

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [ModuleToBeOverwritten],
      })
        .overrideModule(ModuleToBeOverwritten)
        .useModule(ModuleOverride)
        .compile();
    });

    it('should override top-level modules using testing module builder', () => {
      expect(() =>
        testingModule.get<ControllerOverwritten>(ControllerOverwritten),
      ).to.throw();
      expect(
        testingModule.get<ControllerOverride>(ControllerOverride),
      ).to.be.an.instanceof(ControllerOverride);
    });
  });

  describe('Dynamic module', () => {
    @Controller()
    class ControllerOverwritten {}

    @Module({})
    class DynamicModuleToBeOverwritten {}

    const dynamicModuleOverwritten: DynamicModule = {
      module: DynamicModuleToBeOverwritten,
      controllers: [ControllerOverwritten],
    };

    @Controller()
    class ControllerOverride {}

    @Module({})
    class DynamicModuleOverride {}

    const dynamicModuleOverride: DynamicModule = {
      module: DynamicModuleOverride,
      controllers: [ControllerOverride],
    };

    let testingModule: TestingModule;

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [dynamicModuleOverwritten],
      })
        .overrideModule(dynamicModuleOverwritten)
        .useModule(dynamicModuleOverride)
        .compile();
    });

    it('should override dynamic modules using testing module builder', () => {
      expect(() =>
        testingModule.get<ControllerOverwritten>(ControllerOverwritten),
      ).to.throw();
      expect(
        testingModule.get<ControllerOverride>(ControllerOverride),
      ).to.be.an.instanceof(ControllerOverride);
    });
  });

  describe('Circular dependency module', () => {
    let testingModule: TestingModule;

    @Injectable()
    class CProvider {}

    @Module({
      providers: [CProvider],
    })
    class CModule {}

    @Injectable()
    class BProviderOverride {}

    @Module({
      imports: [forwardRef(() => AModule), forwardRef(() => CModule)],
      providers: [BProviderOverride],
      exports: [BProviderOverride],
    })
    class BModuleOverride {}

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [AModule],
      })
        .overrideModule(BModule)
        .useModule(BModuleOverride)
        .compile();
    });

    it('should override top-level modules using testing module builder', () => {
      expect(testingModule.get<AProvider>(AProvider)).to.be.an.instanceof(
        AProvider,
      );
      expect(() => testingModule.get<BProvider>(BProvider)).to.throw();
      expect(testingModule.get<CProvider>(CProvider)).to.be.an.instanceof(
        CProvider,
      );
      expect(
        testingModule.get<BProviderOverride>(BProviderOverride),
      ).to.be.an.instanceof(BProviderOverride);
    });
  });

  describe('Nested module', () => {
    let testingModule: TestingModule;

    @Controller()
    class OverwrittenNestedModuleController {}

    @Module({
      controllers: [OverwrittenNestedModuleController],
    })
    class OverwrittenNestedModule {}

    @Controller()
    class OverrideNestedModuleController {}

    @Module({
      controllers: [OverrideNestedModuleController],
    })
    class OverrideNestedModule {}

    @Module({
      imports: [OverwrittenNestedModule],
    })
    class AppModule {}

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [AppModule],
      })
        .overrideModule(OverwrittenNestedModule)
        .useModule(OverrideNestedModule)
        .compile();
    });

    it('should override nested modules using testing module builder', () => {
      expect(
        testingModule.get<OverrideNestedModuleController>(
          OverrideNestedModuleController,
        ),
      ).to.be.an.instanceof(OverrideNestedModuleController);
      expect(() =>
        testingModule.get<OverwrittenNestedModuleController>(
          OverwrittenNestedModuleController,
        ),
      ).to.throw();
    });
  });

  describe('Lazy-loaded module', () => {
    let testingModule: TestingModule;

    @Injectable()
    class OverwrittenLazyProvider {
      value() {
        return 'overwritten lazy';
      }
    }

    @Module({
      providers: [
        {
          provide: 'LAZY_PROVIDER',
          useClass: OverwrittenLazyProvider,
        },
      ],
    })
    class OverwrittenLazyModule {}

    @Injectable()
    class OverrideLazyProvider {
      value() {
        return 'override lazy';
      }
    }

    @Module({
      providers: [
        {
          provide: 'LAZY_PROVIDER',
          useClass: OverrideLazyProvider,
        },
      ],
    })
    class OverrideLazyModule {}

    @Injectable()
    class AppService {
      constructor(private lazyModuleLoader: LazyModuleLoader) {}

      async value() {
        const moduleRef = await this.lazyModuleLoader.load(
          () => OverwrittenLazyModule,
        );
        return moduleRef.get('LAZY_PROVIDER').value();
      }
    }

    @Module({
      imports: [],
      providers: [AppService],
    })
    class AppModule {}

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [AppModule],
      })
        .overrideModule(OverwrittenLazyModule)
        .useModule(OverrideLazyModule)
        .compile();
    });

    it('should override lazy loaded modules using testing module builder', async () => {
      const result = await testingModule.get<AppService>(AppService).value();
      expect(result).to.be.equal('override lazy');
    });
  });

  describe('Global module', () => {
    let testingModule: TestingModule;

    @Injectable()
    class OverwrittenProvider {
      value() {
        return 'overwritten lazy';
      }
    }

    @Global()
    @Module({
      providers: [OverwrittenProvider],
      exports: [OverwrittenProvider],
    })
    class OverwrittenModule {}

    @Injectable()
    class OverrideProvider {
      value() {
        return 'override lazy';
      }
    }

    @Global()
    @Module({
      providers: [OverrideProvider],
      exports: [OverrideProvider],
    })
    class OverrideModule {}

    beforeEach(async () => {
      testingModule = await Test.createTestingModule({
        imports: [OverwrittenModule],
      })
        .overrideModule(OverwrittenModule)
        .useModule(OverrideModule)
        .compile();
    });

    it('should override global modules using testing module builder', () => {
      expect(
        testingModule.get<OverrideProvider>(OverrideProvider),
      ).to.be.an.instanceof(OverrideProvider);
      expect(() =>
        testingModule.get<OverwrittenProvider>(OverwrittenProvider),
      ).to.throw();
    });
  });
});



================================================
FILE: integration/typeorm/ormconfig.json
================================================
{
  "type": "mysql",
  "host": "127.0.0.1",
  "port": 3306,
  "username": "root",
  "password": "root",
  "database": "test",
  "entities": ["src/**/**.entity{.ts,.js}"],
  "synchronize": true
}



================================================
FILE: integration/typeorm/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/typeorm/e2e/typeorm-async-class.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsClassModule } from '../src/async-class-options.module';

describe('TypeOrm (async configuration)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsClassModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    return request(server)
      .post('/photo')
      .expect(201, { name: 'Nest', description: 'Is great!', views: 6000 });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/typeorm/e2e/typeorm-async-existing.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsExistingModule } from '../src/async-existing-options.module';

describe('TypeOrm (async configuration)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsExistingModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    return request(server)
      .post('/photo')
      .expect(201, { name: 'Nest', description: 'Is great!', views: 6000 });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/typeorm/e2e/typeorm-async-options.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncOptionsFactoryModule } from '../src/async-options.module';

describe('TypeOrm (async configuration)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncOptionsFactoryModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    return request(server)
      .post('/photo')
      .expect(201, { name: 'Nest', description: 'Is great!', views: 6000 });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/typeorm/e2e/typeorm-async.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AsyncApplicationModule } from '../src/app-async.module';

describe('TypeOrm (async configuration)', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AsyncApplicationModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    return request(server)
      .post('/photo')
      .expect(201, { name: 'Nest', description: 'Is great!', views: 6000 });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/typeorm/e2e/typeorm.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('TypeOrm', () => {
  let server;
  let app: INestApplication;

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = module.createNestApplication();
    server = app.getHttpServer();
    await app.init();
  });

  it(`should return created entity`, () => {
    return request(server)
      .post('/photo')
      .expect(201, { name: 'Nest', description: 'Is great!', views: 6000 });
  });

  afterEach(async () => {
    await app.close();
  });
});



================================================
FILE: integration/typeorm/src/app-async.module.ts
================================================
import { Module } from '@nestjs/common';
import { DatabaseModule } from './database.module';
import { PhotoModule } from './photo/photo.module';

@Module({
  imports: [DatabaseModule.forRoot(), PhotoModule],
})
export class AsyncApplicationModule {}



================================================
FILE: integration/typeorm/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';
import { PhotoModule } from './photo/photo.module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: '127.0.0.1',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [Photo],
      synchronize: true,
      retryAttempts: 2,
      retryDelay: 1000,
    }),
    PhotoModule,
  ],
})
export class AppModule {}



================================================
FILE: integration/typeorm/src/async-class-options.module.ts
================================================
import { Module } from '@nestjs/common';
import {
  TypeOrmModule,
  TypeOrmModuleOptions,
  TypeOrmOptionsFactory,
} from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';
import { PhotoModule } from './photo/photo.module';

class ConfigService implements TypeOrmOptionsFactory {
  createTypeOrmOptions(): TypeOrmModuleOptions {
    return {
      type: 'mysql',
      host: '127.0.0.1',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [Photo],
      synchronize: true,
      retryAttempts: 2,
      retryDelay: 1000,
    };
  }
}

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useClass: ConfigService,
    }),
    PhotoModule,
  ],
})
export class AsyncOptionsClassModule {}



================================================
FILE: integration/typeorm/src/async-existing-options.module.ts
================================================
import { Module } from '@nestjs/common';
import {
  TypeOrmModule,
  TypeOrmModuleOptions,
  TypeOrmOptionsFactory,
} from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';
import { PhotoModule } from './photo/photo.module';

class ConfigService implements TypeOrmOptionsFactory {
  createTypeOrmOptions(): TypeOrmModuleOptions {
    return {
      type: 'mysql',
      host: '127.0.0.1',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      entities: [Photo],
      synchronize: true,
      retryAttempts: 2,
      retryDelay: 1000,
    };
  }
}

@Module({
  providers: [ConfigService],
  exports: [ConfigService],
})
class ConfigModule {}

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useExisting: ConfigService,
    }),
    PhotoModule,
  ],
})
export class AsyncOptionsExistingModule {}



================================================
FILE: integration/typeorm/src/async-options.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';
import { PhotoModule } from './photo/photo.module';

@Module({
  imports: [
    TypeOrmModule.forRootAsync({
      useFactory: () => ({
        type: 'mysql',
        host: '127.0.0.1',
        port: 3306,
        username: 'root',
        password: 'root',
        database: 'test',
        entities: [Photo],
        synchronize: true,
        retryAttempts: 2,
        retryDelay: 1000,
      }),
    }),
    PhotoModule,
  ],
})
export class AsyncOptionsFactoryModule {}



================================================
FILE: integration/typeorm/src/database.module.ts
================================================
import { DynamicModule, Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';

@Module({})
export class DatabaseModule {
  static async forRoot(): Promise<DynamicModule> {
    await new Promise(resolve => setTimeout(resolve, 1000));
    return {
      module: DatabaseModule,
      imports: [
        TypeOrmModule.forRoot({
          type: 'mysql',
          host: '127.0.0.1',
          port: 3306,
          username: 'root',
          password: 'root',
          database: 'test',
          entities: [Photo],
          synchronize: true,
          retryAttempts: 2,
          retryDelay: 1000,
        }),
      ],
    };
  }
}



================================================
FILE: integration/typeorm/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3001);
}
void bootstrap();



================================================
FILE: integration/typeorm/src/photo/photo.controller.ts
================================================
import { Controller, Get, Post } from '@nestjs/common';
import { Photo } from './photo.entity';
import { PhotoService } from './photo.service';

@Controller('photo')
export class PhotoController {
  constructor(private readonly photoService: PhotoService) {}

  @Get()
  findAll(): Promise<Photo[]> {
    return this.photoService.findAll();
  }

  @Post()
  create(): Promise<Photo> {
    return this.photoService.create();
  }
}



================================================
FILE: integration/typeorm/src/photo/photo.entity.ts
================================================
import { Entity, Column, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class Photo {
  @PrimaryGeneratedColumn() id: number;

  @Column({ length: 500 })
  name: string;

  @Column('text') description: string;

  @Column() filename: string;

  @Column('int') views: number;

  @Column() isPublished: boolean;
}



================================================
FILE: integration/typeorm/src/photo/photo.module.ts
================================================
import { Module } from '@nestjs/common';
import { PhotoService } from './photo.service';
import { PhotoController } from './photo.controller';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Photo } from './photo.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}



================================================
FILE: integration/typeorm/src/photo/photo.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Photo } from './photo.entity';

@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: Repository<Photo>,
  ) {}

  async findAll(): Promise<Photo[]> {
    return this.photoRepository.find();
  }

  async create(): Promise<Photo> {
    const photoEntity = new Photo();
    photoEntity.name = 'Nest';
    photoEntity.description = 'Is great!';
    photoEntity.views = 6000;

    return this.photoRepository.create(photoEntity);
  }
}



================================================
FILE: integration/versioning/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/versioning/e2e/custom-versioning-fastify.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import { FastifyRequest } from 'fastify';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Custom Versioning (fastify)', () => {
  const extractor = (request: FastifyRequest): string | string[] => {
    const versions = [request.headers['accept'] ?? '']
      .flatMap(v => v.split(','))
      .map(header => header.match(/v(\d+\.?\d*)\+json$/))
      .filter(match => match && match.length)
      .map(matchArray => matchArray![1])
      .sort()
      .reverse();

    return versions;
  };
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.CUSTOM,
        extractor,
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.CUSTOM,
        extractor,
        defaultVersion: '1',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V2, if two versions are requested, select the highest version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept:
              'application/foo.v1+json, application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(404);
      });

      it('V2, if a non-existent version is requested, select the highest supported version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json, application/foo.v2+json',
          })
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/custom-versioning.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { Request } from 'express';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Custom Versioning', () => {
  const extractor = (request: Request): string | string[] => {
    const versions = request
      .header('Accept')
      ?.split(',')
      .map(header => header.match(/v(\d+\.?\d*)\+json$/))
      .filter(match => match && match.length)
      .map(matchArray => matchArray![1])
      .sort()
      .reverse();

    return versions!;
  };
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.CUSTOM,
        extractor,
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      // There's a known limitation of the express-adapter, where
      // it cannot handle selection of the highest matched version properly.
      //
      // it('V2, if two versions are requested, select the highest version', () => {
      //   return request(app.getHttpServer())
      //     .get('/')
      //     .set({
      //       Accept: 'application/foo.v1+json, application/foo.v2+json',
      //     })
      //     .expect(200)
      //     .expect('Hello World V2!');
      // });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2, if an unsupported version is specified, select the lower supported version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v2+json, application/foo.v3+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      // There's a known limitation of the express-adapter, where
      // it cannot handle selection of the highest matched version properly.
      //
      // it('V2, if two versions are requested, select the highest version', () => {
      //   return request(app.getHttpServer())
      //     .get('/override')
      //     .set({
      //       Accept: 'application/foo.v1+json, application/foo.v2+json',
      //     })
      //     .expect(200)
      //     .expect('Override Version 2');
      // });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.CUSTOM,
        extractor,
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v1+json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v2+json',
          })
          .expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/foo.v3+json',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/default-versioning.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

/**
 * `.enableVersioning()` uses `VersioningType.URI` type by default
 * Regression test for #13496
 * @see [Versioning](https://docs.nestjs.com/techniques/versioning)
 */
describe('Default Versioning behavior', () => {
  // ======================================================================== //
  describe('Express', () => {
    let app: INestApplication;
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning();
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('Fastify', () => {
    let app: INestApplication;
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning();
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/header-versioning-fastify.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Header Versioning (fastify)', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.HEADER,
        header: 'X-API-Version',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '3',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.HEADER,
        header: 'X-API-Version',
        defaultVersion: '1',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '2',
          })
          .expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/header-versioning.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Header Versioning', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.HEADER,
        header: 'X-API-Version',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '3',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.HEADER,
        header: 'X-API-Version',
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            'X-API-Version': '',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '2',
          })
          .expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            'X-API-Version': '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/media-type-versioning-fastify.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Media Type Versioning (fastify)', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.MEDIA_TYPE,
        key: 'v=',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.MEDIA_TYPE,
        key: 'v=',
        defaultVersion: '1',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/media-type-versioning.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('Media Type Versioning', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.MEDIA_TYPE,
        key: 'v=',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.MEDIA_TYPE,
        key: 'v=',
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/param/hello')
          .set({
            Accept: '',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/multiple')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .set({
            Accept: 'application/json',
          })
          .expect(200)
          .expect('Neutral');
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=1',
          })
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=2',
          })
          .expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json;v=3',
          })
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .set({
            Accept: 'application/json',
          })
          .expect(404);
      });

      it('No Header', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/uri-versioning-fastify.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('URI Versioning (fastify)', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.URI,
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2')
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/param/hello')
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/param/hello')
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/param/hello').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/param/hello').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/multiple').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override')
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override')
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/override').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override-partial')
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override-partial')
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/v3/override-partial')
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer()).get('/v1/foo/bar').expect(404);
      });

      it('V2', () => {
        return request(app.getHttpServer()).get('/v2/foo/bar').expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/foo/bar').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication<NestFastifyApplication>(
        new FastifyAdapter(),
      );
      app.enableVersioning({
        type: VersioningType.URI,
        defaultVersion: '1',
      });
      await app.init();
      await app.getHttpAdapter().getInstance().ready();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2')
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/param/hello')
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/param/hello')
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/param/hello').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/param/hello').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/multiple').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override')
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override')
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/override').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override-partial')
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override-partial')
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/v3/override-partial')
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer()).get('/v2/foo/bar').expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/foo/bar').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/e2e/uri-versioning.spec.ts
================================================
import { INestApplication, VersioningType } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../src/app.module';

describe('URI Versioning', () => {
  let app: INestApplication;

  // ======================================================================== //
  describe('without global default version', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.URI,
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/')
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/param/hello')
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/param/hello')
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/param/hello').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/param/hello').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/multiple').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override')
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override')
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/override').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override-partial')
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override-partial')
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/v3/override-partial')
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer()).get('/v1/foo/bar').expect(404);
      });

      it('V2', () => {
        return request(app.getHttpServer()).get('/v2/foo/bar').expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/foo/bar').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global default version: "1"', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.URI,
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2')
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/').expect(404);
      });
    });

    describe('GET /:param', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/param/hello')
          .expect(200)
          .expect('Parameter V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/param/hello')
          .expect(200)
          .expect('Parameter V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/param/hello').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/param/hello').expect(404);
      });
    });

    describe('GET /multiple', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/multiple')
          .expect(200)
          .expect('Multiple Versions 1 or 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/multiple').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/multiple').expect(404);
      });
    });

    describe('GET /neutral', () => {
      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/neutral')
          .expect(200)
          .expect('Neutral');
      });
    });

    describe('GET /override', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override')
          .expect(200)
          .expect('Override Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override')
          .expect(200)
          .expect('Override Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/override').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/override').expect(404);
      });
    });

    describe('GET /override-partial', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/override-partial')
          .expect(200)
          .expect('Override Partial Version 1');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/v2/override-partial')
          .expect(200)
          .expect('Override Partial Version 2');
      });

      it('V3', () => {
        return request(app.getHttpServer())
          .get('/v3/override-partial')
          .expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer())
          .get('/override-partial')
          .expect(404);
      });
    });

    describe('GET /foo/bar', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer()).get('/v2/foo/bar').expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/foo/bar').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with the global prefix enabled and an excluded route', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.setGlobalPrefix('api', { exclude: ['/foo/bar'] });
      app.enableVersioning({
        type: VersioningType.URI,
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/api/v1')
          .expect(200)
          .expect('Hello World V1!');
      });

      it('V2', () => {
        return request(app.getHttpServer())
          .get('/api/v2')
          .expect(200)
          .expect('Hello World V2!');
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/api/v3').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/api').expect(404);
      });
    });

    describe('GET /foo/bar (excluded from the API prefix)', () => {
      it('V1', () => {
        return request(app.getHttpServer())
          .get('/v1/foo/bar')
          .expect(200)
          .expect('Hello FooBar!');
      });

      it('V2', () => {
        return request(app.getHttpServer()).get('/v2/foo/bar').expect(404);
      });

      it('V3', () => {
        return request(app.getHttpServer()).get('/v3/foo/bar').expect(404);
      });

      it('No Version', () => {
        return request(app.getHttpServer()).get('/foo/bar').expect(404);
      });
    });

    after(async () => {
      await app.close();
    });
  });

  // ======================================================================== //
  describe('with middleware applied', () => {
    before(async () => {
      const moduleRef = await Test.createTestingModule({
        imports: [AppModule],
      }).compile();

      app = moduleRef.createNestApplication();
      app.enableVersioning({
        type: VersioningType.URI,
        defaultVersion: '1',
      });
      await app.init();
    });

    describe('GET /middleware', () => {
      it('should return "Hello from middleware function!"', () => {
        return request(app.getHttpServer())
          .get('/v1/middleware')
          .expect(200)
          .expect('Hello from middleware function!');
      });
    });

    describe('GET /middleware/override', () => {
      it('should return "Hello from middleware function!"', () => {
        return request(app.getHttpServer())
          .get('/v2/middleware/override')
          .expect(200)
          .expect('Hello from middleware function!');
      });
    });

    describe('GET /middleware/multiple', () => {
      it('should return "Hello from middleware function!" (v1)', () => {
        return request(app.getHttpServer())
          .get('/v1/middleware/multiple')
          .expect(200)
          .expect('Hello from middleware function!');
      });

      it('should return "Hello from middleware function!" (v2)', () => {
        return request(app.getHttpServer())
          .get('/v2/middleware/multiple')
          .expect(200)
          .expect('Hello from middleware function!');
      });
    });

    describe('GET /middleware/neutral', () => {
      it('should return "Hello from middleware function!"', () => {
        return request(app.getHttpServer())
          .get('/middleware/neutral')
          .expect(200)
          .expect('Hello from middleware function!');
      });
    });

    after(async () => {
      await app.close();
    });
  });
});



================================================
FILE: integration/versioning/src/app-v1.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller({
  version: '1',
})
export class AppV1Controller {
  @Get('/')
  helloWorldV1() {
    return 'Hello World V1!';
  }

  @Get('/:param/hello')
  paramV1() {
    return 'Parameter V1!';
  }
}



================================================
FILE: integration/versioning/src/app-v2.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller({
  version: '2',
})
export class AppV2Controller {
  @Get('/')
  helloWorldV2() {
    return 'Hello World V2!';
  }

  @Get('/:param/hello')
  paramV1() {
    return 'Parameter V2!';
  }
}



================================================
FILE: integration/versioning/src/app.module.ts
================================================
import { MiddlewareConsumer, Module } from '@nestjs/common';
import { AppV1Controller } from './app-v1.controller';
import { AppV2Controller } from './app-v2.controller';
import { MiddlewareController } from './middleware.controller';
import { MultipleMiddlewareVersionController } from './multiple-middleware.controller';
import { MultipleVersionController } from './multiple.controller';
import { VersionNeutralMiddlewareController } from './neutral-middleware.controller';
import { VersionNeutralController } from './neutral.controller';
import { NoVersioningController } from './no-versioning.controller';
import { OverridePartialController } from './override-partial.controller';
import { OverrideController } from './override.controller';

@Module({
  imports: [],
  controllers: [
    AppV1Controller,
    AppV2Controller,
    MultipleVersionController,
    NoVersioningController,
    VersionNeutralController,
    OverrideController,
    OverridePartialController,
    MiddlewareController,
    MultipleMiddlewareVersionController,
    VersionNeutralMiddlewareController,
  ],
})
export class AppModule {
  configure(consumer: MiddlewareConsumer) {
    consumer
      .apply((req, res) => res.end('Hello from middleware function!'))
      .forRoutes(
        MiddlewareController,
        MultipleMiddlewareVersionController,
        VersionNeutralMiddlewareController,
      );
  }
}



================================================
FILE: integration/versioning/src/main.ts
================================================
import { VersioningType } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.enableVersioning({
    type: VersioningType.MEDIA_TYPE,
    key: 'v=',
  });

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
void bootstrap();



================================================
FILE: integration/versioning/src/middleware.controller.ts
================================================
import { Controller, Get, Version } from '@nestjs/common';

@Controller({
  path: 'middleware',
  version: '1',
})
export class MiddlewareController {
  @Get('/')
  hello() {
    return 'Hello from "MiddlewareController"!';
  }

  @Version('2')
  @Get('/override')
  hellov2() {
    return 'Hello from "MiddlewareController"!';
  }
}



================================================
FILE: integration/versioning/src/multiple-middleware.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller({
  version: ['1', '2'],
  path: 'middleware',
})
export class MultipleMiddlewareVersionController {
  @Get('/multiple')
  multiple() {
    return 'Multiple Versions 1 or 2';
  }
}



================================================
FILE: integration/versioning/src/multiple.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller({
  version: ['1', '2'],
})
export class MultipleVersionController {
  @Get('/multiple')
  multiple() {
    return 'Multiple Versions 1 or 2';
  }
}



================================================
FILE: integration/versioning/src/neutral-middleware.controller.ts
================================================
import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';

@Controller({
  path: 'middleware',
  version: VERSION_NEUTRAL,
})
export class VersionNeutralMiddlewareController {
  @Get('/neutral')
  neutral() {
    return 'Neutral';
  }
}



================================================
FILE: integration/versioning/src/neutral.controller.ts
================================================
import { Controller, Get, VERSION_NEUTRAL } from '@nestjs/common';

@Controller({
  version: VERSION_NEUTRAL,
})
export class VersionNeutralController {
  @Get('/neutral')
  neutral() {
    return 'Neutral';
  }
}



================================================
FILE: integration/versioning/src/no-versioning.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller('foo')
export class NoVersioningController {
  @Get('/bar')
  helloFoo() {
    return 'Hello FooBar!';
  }
}



================================================
FILE: integration/versioning/src/override-partial.controller.ts
================================================
import { Controller, Get, Version } from '@nestjs/common';

@Controller({
  version: '1',
})
export class OverridePartialController {
  @Get('/override-partial')
  overridePartialV1() {
    return 'Override Partial Version 1';
  }

  @Version('2')
  @Get('/override-partial')
  overridePartialV2() {
    return 'Override Partial Version 2';
  }
}



================================================
FILE: integration/versioning/src/override.controller.ts
================================================
import { Controller, Get, Version } from '@nestjs/common';

@Controller()
export class OverrideController {
  @Version('1')
  @Get('/override')
  overrideV1() {
    return 'Override Version 1';
  }

  @Version('2')
  @Get('/override')
  overrideV2() {
    return 'Override Version 2';
  }
}



================================================
FILE: integration/websockets/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": false,
    "noImplicitAny": false,
    "removeComments": true,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "allowJs": true,
    "strictNullChecks": true,
    "outDir": "./dist",
    "paths": {
      "@nestjs/common": ["../../packages/common"],
      "@nestjs/common/*": ["../../packages/common/*"],
      "@nestjs/core": ["../../packages/core"],
      "@nestjs/core/*": ["../../packages/core/*"],
      "@nestjs/microservices": ["../../packages/microservices"],
      "@nestjs/microservices/*": ["../../packages/microservices/*"],
      "@nestjs/websockets": ["../../packages/websockets"],
      "@nestjs/websockets/*": ["../../packages/websockets/*"],
      "@nestjs/testing": ["../../packages/testing"],
      "@nestjs/testing/*": ["../../packages/testing/*"],
      "@nestjs/platform-express": ["../../packages/platform-express"],
      "@nestjs/platform-express/*": ["../../packages/platform-express/*"],
      "@nestjs/platform-socket.io": ["../../packages/platform-socket.io"],
      "@nestjs/platform-socket.io/*": ["../../packages/platform-socket.io/*"],
      "@nestjs/platform-ws": ["../../packages/platform-ws"],
      "@nestjs/platform-ws/*": ["../../packages/platform-ws/*"]
    }
  },
  "include": [
    "src/**/*",
    "e2e/**/*"
  ],
  "exclude": [
    "node_modules",
  ]
}


================================================
FILE: integration/websockets/e2e/error-gateway.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { io } from 'socket.io-client';
import { ErrorGateway } from '../src/error.gateway';

describe('ErrorGateway', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const testingModule = await Test.createTestingModule({
      providers: [ErrorGateway],
    }).compile();

    app = testingModule.createNestApplication();
    await app.listen(3000);
  });

  it(`should handle error`, async () => {
    const ws = io('http://localhost:8080');
    const pattern = 'push';
    const data = { test: 'test' };

    ws.emit(pattern, data);

    await new Promise<void>(resolve =>
      ws.on('exception', error => {
        expect(error).to.be.eql({
          status: 'error',
          message: 'test',
          cause: {
            pattern,
            data,
          },
        });
        resolve();
      }),
    );
  });

  afterEach(() => app.close());
});



================================================
FILE: integration/websockets/e2e/gateway-ack.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { io } from 'socket.io-client';
import { AckGateway } from '../src/ack.gateway';

async function createNestApp(...gateways): Promise<INestApplication> {
  const testingModule = await Test.createTestingModule({
    providers: gateways,
  }).compile();
  const app = testingModule.createNestApplication();
  return app;
}

describe('WebSocketGateway (ack)', () => {
  let ws, app;

  it(`should handle message with ack (http)`, async () => {
    app = await createNestApp(AckGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    await new Promise<void>(resolve =>
      ws.emit('push', { test: 'test' }, data => {
        expect(data).to.be.eql('pong');
        resolve();
      }),
    );
  });

  it(`should handle message with ack & without data (http)`, async () => {
    app = await createNestApp(AckGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    await new Promise<void>(resolve =>
      ws.emit('push', data => {
        expect(data).to.be.eql('pong');
        resolve();
      }),
    );
  });

  afterEach(() => app.close());
});



================================================
FILE: integration/websockets/e2e/gateway.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import { EventSource } from 'eventsource';
import { io } from 'socket.io-client';
import { AppController as LongConnectionController } from '../../nest-application/sse/src/app.controller';
import { ApplicationGateway } from '../src/app.gateway';
import { NamespaceGateway } from '../src/namespace.gateway';
import { ServerGateway } from '../src/server.gateway';

async function createNestApp(...gateways): Promise<INestApplication> {
  const testingModule = await Test.createTestingModule({
    providers: gateways,
  }).compile();
  const app = testingModule.createNestApplication();
  return app;
}

describe('WebSocketGateway', () => {
  let ws: ReturnType<typeof io>, app: INestApplication;

  it(`should handle message (2nd port)`, async () => {
    app = await createNestApp(ApplicationGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    ws.emit('push', {
      test: 'test',
    });
    await new Promise<void>(resolve =>
      ws.on('pop', data => {
        expect(data.test).to.be.eql('test');
        resolve();
      }),
    );
  });

  it(`should handle message (http)`, async () => {
    app = await createNestApp(ServerGateway);
    await app.listen(3000);

    ws = io('http://localhost:3000');
    ws.emit('push', {
      test: 'test',
    });
    await new Promise<void>(resolve =>
      ws.on('pop', data => {
        expect(data.test).to.be.eql('test');
        resolve();
      }),
    );
  });

  it(`should handle message (2 gateways)`, async () => {
    app = await createNestApp(ApplicationGateway, NamespaceGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    io('http://localhost:8080/test').emit('push', {});
    ws.emit('push', {
      test: 'test',
    });
    await new Promise<void>(resolve =>
      ws.on('pop', data => {
        expect(data.test).to.be.eql('test');
        resolve();
      }),
    );
  });

  it(`should be able to get the pattern in an interceptor`, async () => {
    app = await createNestApp(ApplicationGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    ws.emit('getClient', {
      test: 'test',
    });
    await new Promise<void>(resolve =>
      ws.on('popClient', data => {
        expect(data.path).to.be.eql('getClient');
        resolve();
      }),
    );
  });

  it(`should be able to get the pattern in a filter (when the error comes from a known handler)`, async () => {
    app = await createNestApp(ApplicationGateway);
    await app.listen(3000);

    ws = io('http://localhost:8080');
    ws.emit('getClientWithError', {
      test: 'test',
    });
    await new Promise<void>(resolve =>
      ws.on('exception', data => {
        expect(data.pattern).to.be.eql('getClientWithError');
        resolve();
      }),
    );
  });

  describe('shared server for WS and Long-Running connections', () => {
    afterEach(() => {});
    it('should block application shutdown', function (done) {
      let eventSource: EventSource;

      void (async () => {
        this.timeout(30000);

        setTimeout(() => {
          const instance = testingModule.get(ServerGateway);
          expect(instance.onApplicationShutdown.called).to.be.false;
          eventSource.close();
          done();
        }, 25000);

        const testingModule = await Test.createTestingModule({
          providers: [ServerGateway],
          controllers: [LongConnectionController],
        }).compile();
        app = testingModule.createNestApplication();

        await app.listen(3000);

        ws = io(`http://localhost:3000`);
        eventSource = new EventSource(`http://localhost:3000/sse`);

        await new Promise<void>((resolve, reject) => {
          ws.on('connect', resolve);
          ws.on('error', reject);
        });

        await new Promise((resolve, reject) => {
          eventSource.onmessage = resolve;
          eventSource.onerror = reject;
        });

        await app.close();
      })();
    });

    it('should shutdown application immediately when forceCloseConnections is true', async () => {
      const testingModule = await Test.createTestingModule({
        providers: [ServerGateway],
        controllers: [LongConnectionController],
      }).compile();

      app = testingModule.createNestApplication({
        forceCloseConnections: true,
      });

      await app.listen(3000);

      ws = io(`http://localhost:3000`);
      const eventSource = new EventSource(`http://localhost:3000/sse`);

      await new Promise<void>((resolve, reject) => {
        ws.on('connect', resolve);
        ws.on('error', reject);
      });

      await new Promise((resolve, reject) => {
        eventSource.onmessage = resolve;
        eventSource.onerror = reject;
      });

      await app.close();

      const instance = testingModule.get(ServerGateway);
      expect(instance.onApplicationShutdown.called).to.be.true;
      eventSource.close();
    });
  });

  afterEach(() => app.close());
});



================================================
FILE: integration/websockets/e2e/ws-gateway.spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { WsAdapter } from '@nestjs/platform-ws';
import { Test } from '@nestjs/testing';
import { expect } from 'chai';
import * as WebSocket from 'ws';
import { ApplicationGateway } from '../src/app.gateway';
import { CoreGateway } from '../src/core.gateway';
import { ExamplePathGateway } from '../src/example-path.gateway';
import { ServerGateway } from '../src/server.gateway';
import { WsPathGateway } from '../src/ws-path.gateway';
import { WsPathGateway2 } from '../src/ws-path2.gateway';

async function createNestApp(...gateways: any[]): Promise<INestApplication> {
  const testingModule = await Test.createTestingModule({
    providers: gateways,
  }).compile();
  const app = testingModule.createNestApplication();
  app.useWebSocketAdapter(new WsAdapter(app) as any);
  return app;
}

describe('WebSocketGateway (WsAdapter)', () => {
  let ws: WebSocket, ws2: WebSocket, app: INestApplication;

  it(`should handle message (2nd port)`, async () => {
    app = await createNestApp(ApplicationGateway);
    await app.listen(3000);

    ws = new WebSocket('ws://localhost:8080');
    await new Promise(resolve => ws.on('open', resolve));

    ws.send(
      JSON.stringify({
        event: 'push',
        data: {
          test: 'test',
        },
      }),
    );
    await new Promise<void>(resolve =>
      ws.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws.close();
        resolve();
      }),
    );
  });

  it(`should handle message (http)`, async () => {
    app = await createNestApp(ServerGateway);
    await app.listen(3000);

    ws = new WebSocket('ws://localhost:3000');
    await new Promise(resolve => ws.on('open', resolve));

    ws.send(
      JSON.stringify({
        event: 'push',
        data: {
          test: 'test',
        },
      }),
    );
    await new Promise<void>(resolve =>
      ws.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws.close();
        resolve();
      }),
    );
  });

  it(`should handle message on a different path`, async () => {
    app = await createNestApp(WsPathGateway);
    await app.listen(3000);
    try {
      ws = new WebSocket('ws://localhost:3000/ws-path');
      await new Promise((resolve, reject) => {
        ws.on('open', resolve);
        ws.on('error', reject);
      });

      ws.send(
        JSON.stringify({
          event: 'push',
          data: {
            test: 'test',
          },
        }),
      );
      await new Promise<void>(resolve =>
        ws.on('message', data => {
          expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
          ws.close();
          resolve();
        }),
      );
    } catch (err) {
      console.log(err);
    }
  });

  it(`should support 2 different gateways running on different paths`, async function () {
    this.retries(10);

    app = await createNestApp(ExamplePathGateway, WsPathGateway2);
    await app.listen(3000);

    // open websockets delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    ws = new WebSocket('ws://localhost:3000/example');
    ws2 = new WebSocket('ws://localhost:3000/ws-path');

    await new Promise<void>(resolve =>
      ws.on('open', () => {
        ws.on('message', data => {
          expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
          ws.close();
          resolve();
        });
        ws.send(
          JSON.stringify({
            event: 'push',
            data: {
              test: 'test',
            },
          }),
        );
      }),
    );

    await new Promise<void>(resolve => {
      ws2.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws2.close();
        resolve();
      });
      ws2.send(
        JSON.stringify({
          event: 'push',
          data: {
            test: 'test',
          },
        }),
      );
    });
  }).timeout(5000);

  it(`should support 2 different gateways running on the same path (but different ports)`, async function () {
    this.retries(10);

    app = await createNestApp(ApplicationGateway, CoreGateway);
    await app.listen(3000);

    // open websockets delay
    await new Promise(resolve => setTimeout(resolve, 1000));

    ws = new WebSocket('ws://localhost:8080');
    ws2 = new WebSocket('ws://localhost:8090');

    await new Promise<void>(resolve =>
      ws.on('open', () => {
        ws.on('message', data => {
          expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
          ws.close();
          resolve();
        });
        ws.send(
          JSON.stringify({
            event: 'push',
            data: {
              test: 'test',
            },
          }),
        );
      }),
    );

    await new Promise<void>(resolve => {
      ws2.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws2.close();
        resolve();
      });
      ws2.send(
        JSON.stringify({
          event: 'push',
          data: {
            test: 'test',
          },
        }),
      );
    });
  });

  it('should let the execution context have a getPattern() method on getClient()', async () => {
    app = await createNestApp(ApplicationGateway);
    await app.listen(3000);

    ws = new WebSocket('ws://localhost:8080');
    await new Promise(resolve => ws.on('open', resolve));

    ws.send(
      JSON.stringify({
        event: 'getClient',
        data: {
          test: 'test',
        },
      }),
    );
    await new Promise<void>(resolve =>
      ws.on('message', data => {
        expect(JSON.parse(data.toString()).data.path).to.be.eql('getClient');
        ws.close();
        resolve();
      }),
    );
  });

  it('should set messageParser by using setMessageParser method', async () => {
    const testingModule = await Test.createTestingModule({
      providers: [ApplicationGateway],
    }).compile();
    app = testingModule.createNestApplication();

    const wsAdapter = new WsAdapter(app);
    wsAdapter.setMessageParser(data => {
      const [event, payload] = JSON.parse(data.toString());
      return { event, data: payload };
    });
    app.useWebSocketAdapter(wsAdapter);
    await app.listen(3000);

    ws = new WebSocket('ws://localhost:8080');
    await new Promise(resolve => ws.on('open', resolve));

    ws.send(JSON.stringify(['push', { test: 'test' }]));
    await new Promise<void>(resolve =>
      ws.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws.close();
        resolve();
      }),
    );
  });

  it('should set messageParser by using constructor options', async () => {
    const testingModule = await Test.createTestingModule({
      providers: [ApplicationGateway],
    }).compile();
    app = testingModule.createNestApplication();

    const wsAdapter = new WsAdapter(app, {
      messageParser: data => {
        const [event, payload] = JSON.parse(data.toString());
        return { event, data: payload };
      },
    });
    app.useWebSocketAdapter(wsAdapter);
    await app.listen(3000);

    ws = new WebSocket('ws://localhost:8080');
    await new Promise(resolve => ws.on('open', resolve));

    ws.send(JSON.stringify(['push', { test: 'test' }]));
    await new Promise<void>(resolve =>
      ws.on('message', data => {
        expect(JSON.parse(data.toString()).data.test).to.be.eql('test');
        ws.close();
        resolve();
      }),
    );
  });

  afterEach(async function () {
    await app.close();
  });
});



================================================
FILE: integration/websockets/src/ack.gateway.ts
================================================
import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';

@WebSocketGateway(8080)
export class AckGateway {
  @SubscribeMessage('push')
  onPush() {
    return 'pong';
  }
}



================================================
FILE: integration/websockets/src/app.gateway.ts
================================================
import { UseFilters, UseInterceptors } from '@nestjs/common';
import {
  MessageBody,
  SubscribeMessage,
  WebSocketGateway,
  WsException,
} from '@nestjs/websockets';
import { RequestInterceptor } from './request.interceptor';
import { throwError } from 'rxjs';
import { RequestFilter } from './request.filter';

@WebSocketGateway(8080)
export class ApplicationGateway {
  @SubscribeMessage('push')
  onPush(@MessageBody() data) {
    return {
      event: 'pop',
      data,
    };
  }

  @UseInterceptors(RequestInterceptor)
  @SubscribeMessage('getClient')
  getPathCalled(client, data) {
    return {
      event: 'popClient',
      data: { ...data, path: client.pattern },
    };
  }

  @UseFilters(RequestFilter)
  @SubscribeMessage('getClientWithError')
  getPathCalledWithError() {
    return throwError(() => new WsException('This is an error'));
  }
}



================================================
FILE: integration/websockets/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { ApplicationGateway } from './app.gateway';

@Module({
  providers: [ApplicationGateway],
})
export class ApplicationModule {}



================================================
FILE: integration/websockets/src/core.gateway.ts
================================================
import {
  ConnectedSocket,
  MessageBody,
  SubscribeMessage,
  WebSocketGateway,
} from '@nestjs/websockets';

@WebSocketGateway(8090)
export class CoreGateway {
  @SubscribeMessage('push')
  onPush(@ConnectedSocket() client, @MessageBody() data) {
    return {
      event: 'pop',
      data,
    };
  }
}



================================================
FILE: integration/websockets/src/error.gateway.ts
================================================
import {
  SubscribeMessage,
  WebSocketGateway,
  WsException,
} from '@nestjs/websockets';
import { throwError } from 'rxjs';

@WebSocketGateway(8080)
export class ErrorGateway {
  @SubscribeMessage('push')
  onPush() {
    return throwError(() => new WsException('test'));
  }
}



================================================
FILE: integration/websockets/src/example-path.gateway.ts
================================================
import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';

@WebSocketGateway({
  path: '/example',
})
export class ExamplePathGateway {
  @SubscribeMessage('push')
  onPush(client, data) {
    return {
      event: 'pop',
      data,
    };
  }
}



================================================
FILE: integration/websockets/src/namespace.gateway.ts
================================================
import { WebSocketGateway, SubscribeMessage } from '@nestjs/websockets';

@WebSocketGateway(8080, {
  namespace: 'test',
})
export class NamespaceGateway {
  @SubscribeMessage('push')
  onPush(client, data) {
    return {
      event: 'pop',
      data,
    };
  }
}



================================================
FILE: integration/websockets/src/request.filter.ts
================================================
import { ArgumentsHost, Catch, ExceptionFilter } from '@nestjs/common';
import { WsException } from '@nestjs/websockets';

@Catch(WsException)
export class RequestFilter implements ExceptionFilter {
  catch(exception: WsException, host: ArgumentsHost) {
    const wsCtx = host.switchToWs();
    const pattern = wsCtx.getPattern();
    const client = wsCtx.getClient();
    client.emit('exception', { pattern, message: exception.message });
  }
}



================================================
FILE: integration/websockets/src/request.interceptor.ts
================================================
import { CallHandler, ExecutionContext, Injectable } from '@nestjs/common';

@Injectable()
export class RequestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler) {
    const client = context.switchToWs().getClient();
    const pattern = context.switchToWs().getPattern();
    client.pattern = pattern;
    return next.handle();
  }
}



================================================
FILE: integration/websockets/src/server.gateway.ts
================================================
import { OnApplicationShutdown, UseInterceptors } from '@nestjs/common';
import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';
import * as Sinon from 'sinon';
import { RequestInterceptor } from './request.interceptor';

@WebSocketGateway()
export class ServerGateway implements OnApplicationShutdown {
  @SubscribeMessage('push')
  onPush(client, data) {
    return {
      event: 'pop',
      data,
    };
  }

  @UseInterceptors(RequestInterceptor)
  @SubscribeMessage('getClient')
  getPathCalled(client, data) {
    return {
      event: 'popClient',
      data: { ...data, path: client.pattern },
    };
  }

  onApplicationShutdown = Sinon.spy();
}



================================================
FILE: integration/websockets/src/ws-path.gateway.ts
================================================
import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';

@WebSocketGateway({
  path: '/ws-path',
})
export class WsPathGateway {
  @SubscribeMessage('push')
  onPush(client, data) {
    return {
      event: 'pop',
      data,
    };
  }
}



================================================
FILE: integration/websockets/src/ws-path2.gateway.ts
================================================
import { SubscribeMessage, WebSocketGateway } from '@nestjs/websockets';

@WebSocketGateway({
  path: '/ws-path',
})
export class WsPathGateway2 {
  @SubscribeMessage('push')
  onPush(client, data) {
    return {
      event: 'pop',
      data,
    };
  }
}



================================================
FILE: packages/tsconfig.build.json
================================================
{
  "compilerOptions": {
    "composite": true,
    "module": "commonjs",
    "declaration": true,
    "noImplicitAny": false,
    "skipLibCheck": true,
    "noUnusedLocals": false,
    "importHelpers": true,
    "removeComments": false,
    "noLib": false,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "useUnknownInCatchVariables": false,
    "target": "ES2021",
    "sourceMap": false,
    "allowJs": false,
    "strict": true,
    "strictNullChecks": true,
    "forceConsistentCasingInFileNames": true,
    "strictPropertyInitialization": false,
    "types": ["node"]
  }
}



================================================
FILE: packages/tsconfig.json
================================================
{
  "files": [],
  "references": [
    {
      "path": "./common/tsconfig.build.json"
    },
    {
      "path": "./core/tsconfig.build.json"
    },
    {
      "path": "./microservices/tsconfig.build.json"
    },
    {
      "path": "./platform-express/tsconfig.build.json"
    },
    {
      "path": "./platform-fastify/tsconfig.build.json"
    },
    {
      "path": "./platform-socket.io/tsconfig.build.json"
    },
    {
      "path": "./platform-ws/tsconfig.build.json"
    },
    {
      "path": "./testing/tsconfig.build.json"
    },
    {
      "path": "./websockets/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/common/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/common/constants.ts
================================================
export const MODULE_METADATA = {
  IMPORTS: 'imports',
  PROVIDERS: 'providers',
  CONTROLLERS: 'controllers',
  EXPORTS: 'exports',
};

export const GLOBAL_MODULE_METADATA = '__module:global__';
export const HOST_METADATA = 'host';
export const PATH_METADATA = 'path';
export const PARAMTYPES_METADATA = 'design:paramtypes';
export const SELF_DECLARED_DEPS_METADATA = 'self:paramtypes';
export const OPTIONAL_DEPS_METADATA = 'optional:paramtypes';
export const PROPERTY_DEPS_METADATA = 'self:properties_metadata';
export const OPTIONAL_PROPERTY_DEPS_METADATA = 'optional:properties_metadata';
export const SCOPE_OPTIONS_METADATA = 'scope:options';
export const METHOD_METADATA = 'method';
export const ROUTE_ARGS_METADATA = '__routeArguments__';
export const CUSTOM_ROUTE_ARGS_METADATA = '__customRouteArgs__';
export const FILTER_CATCH_EXCEPTIONS = '__filterCatchExceptions__';

export const PIPES_METADATA = '__pipes__';
export const GUARDS_METADATA = '__guards__';
export const INTERCEPTORS_METADATA = '__interceptors__';
export const EXCEPTION_FILTERS_METADATA = '__exceptionFilters__';
export const ENHANCER_KEY_TO_SUBTYPE_MAP = {
  [GUARDS_METADATA]: 'guard',
  [INTERCEPTORS_METADATA]: 'interceptor',
  [PIPES_METADATA]: 'pipe',
  [EXCEPTION_FILTERS_METADATA]: 'filter',
} as const;

export type EnhancerSubtype =
  (typeof ENHANCER_KEY_TO_SUBTYPE_MAP)[keyof typeof ENHANCER_KEY_TO_SUBTYPE_MAP];

export const RENDER_METADATA = '__renderTemplate__';
export const HTTP_CODE_METADATA = '__httpCode__';
export const MODULE_PATH = '__module_path__';
export const HEADERS_METADATA = '__headers__';
export const REDIRECT_METADATA = '__redirect__';
export const RESPONSE_PASSTHROUGH_METADATA = '__responsePassthrough__';
export const SSE_METADATA = '__sse__';
export const VERSION_METADATA = '__version__';
export const INJECTABLE_WATERMARK = '__injectable__';
export const CONTROLLER_WATERMARK = '__controller__';
export const CATCH_WATERMARK = '__catch__';
export const ENTRY_PROVIDER_WATERMARK = '__entryProvider__';



================================================
FILE: packages/common/index.ts
================================================
/*
 * Nest @common
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */
import 'reflect-metadata';

export * from './decorators';
export * from './enums';
export * from './exceptions';
export * from './file-stream';
export {
  Abstract,
  ArgumentMetadata,
  ArgumentsHost,
  BeforeApplicationShutdown,
  CallHandler,
  CanActivate,
  ClassProvider,
  ContextType,
  DynamicModule,
  ExceptionFilter,
  ExecutionContext,
  ExistingProvider,
  FactoryProvider,
  ForwardReference,
  HttpServer,
  HttpExceptionBody,
  HttpExceptionBodyMessage,
  HttpRedirectResponse,
  INestApplication,
  INestApplicationContext,
  INestMicroservice,
  InjectionToken,
  IntrospectionResult,
  MessageEvent,
  MiddlewareConsumer,
  ModuleMetadata,
  NestApplicationOptions,
  NestHybridApplicationOptions,
  NestInterceptor,
  NestMiddleware,
  NestModule,
  OnApplicationBootstrap,
  OnApplicationShutdown,
  OnModuleDestroy,
  OnModuleInit,
  OptionalFactoryDependency,
  Paramtype,
  PipeTransform,
  Provider,
  RawBodyRequest,
  RpcExceptionFilter,
  Scope,
  ScopeOptions,
  Type,
  ValidationError,
  ValueProvider,
  VersioningOptions,
  VERSION_NEUTRAL,
  WebSocketAdapter,
  WsExceptionFilter,
  WsMessageHandler,
} from './interfaces';
export * from './module-utils';
export * from './pipes';
export * from './serializer';
export * from './services';
export * from './utils';



================================================
FILE: packages/common/package.json
================================================
{
  "name": "@nestjs/common",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@common)",
  "author": "Kamil Mysliwiec",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/common"
  },
  "publishConfig": {
    "access": "public"
  },
  "license": "MIT",
  "dependencies": {
    "iterare": "1.2.1",
    "tslib": "2.8.1",
    "uid": "2.0.2"
  },
  "peerDependencies": {
    "class-transformer": "*",
    "class-validator": "*",
    "reflect-metadata": "^0.1.12 || ^0.2.0",
    "rxjs": "^7.1.0"
  },
  "peerDependenciesMeta": {
    "class-validator": {
      "optional": true
    },
    "class-transformer": {
      "optional": true
    }
  }
}



================================================
FILE: packages/common/PACKAGE.md
================================================
The common package comes with decorators such as `@Controller()`, `@Injectable()` and so on.



================================================
FILE: packages/common/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {}
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": []
}



================================================
FILE: packages/common/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/common/decorators/index.ts
================================================
export * from './core';
export * from './modules';
export * from './http';



================================================
FILE: packages/common/decorators/core/apply-decorators.ts
================================================
/**
 * Function that returns a new decorator that applies all decorators provided by param
 *
 * Useful to build new decorators (or a decorator factory) encapsulating multiple decorators related with the same feature
 *
 * @param decorators one or more decorators (e.g., `ApplyGuard(...)`)
 *
 * @publicApi
 */
export function applyDecorators(
  ...decorators: Array<ClassDecorator | MethodDecorator | PropertyDecorator>
) {
  return <TFunction extends Function, Y>(
    target: TFunction | object,
    propertyKey?: string | symbol,
    descriptor?: TypedPropertyDescriptor<Y>,
  ) => {
    for (const decorator of decorators) {
      if (target instanceof Function && !descriptor) {
        (decorator as ClassDecorator)(target);
        continue;
      }
      (decorator as MethodDecorator | PropertyDecorator)(
        target,
        propertyKey!,
        descriptor!,
      );
    }
  };
}



================================================
FILE: packages/common/decorators/core/bind.decorator.ts
================================================
/**
 * Decorator that binds *parameter decorators* to the method that follows.
 *
 * Useful when the language doesn't provide a 'Parameter Decorator' feature
 * (i.e., vanilla JavaScript).
 *
 * @param decorators one or more parameter decorators (e.g., `Req()`)
 *
 * @publicApi
 */
export function Bind(...decorators: any[]): MethodDecorator {
  return <T>(
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<T>,
  ) => {
    decorators.forEach((fn, index) => fn(target, key, index));
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/core/catch.decorator.ts
================================================
import { CATCH_WATERMARK, FILTER_CATCH_EXCEPTIONS } from '../../constants';
import { Type, Abstract } from '../../interfaces';

/**
 * Decorator that marks a class as a Nest exception filter. An exception filter
 * handles exceptions thrown by or not handled by your application code.
 *
 * The decorated class must implement the `ExceptionFilter` interface.
 *
 * @param exceptions one or more exception *types* specifying
 * the exceptions to be caught and handled by this filter.
 *
 * @see [Exception Filters](https://docs.nestjs.com/exception-filters)
 *
 * @usageNotes
 * Exception filters are applied using the `@UseFilters()` decorator, or (globally)
 * with `app.useGlobalFilters()`.
 *
 * @publicApi
 */
export function Catch(
  ...exceptions: Array<Type<any> | Abstract<any>>
): ClassDecorator {
  return (target: object) => {
    Reflect.defineMetadata(CATCH_WATERMARK, true, target);
    Reflect.defineMetadata(FILTER_CATCH_EXCEPTIONS, exceptions, target);
  };
}



================================================
FILE: packages/common/decorators/core/controller.decorator.ts
================================================
import {
  CONTROLLER_WATERMARK,
  HOST_METADATA,
  PATH_METADATA,
  SCOPE_OPTIONS_METADATA,
  VERSION_METADATA,
} from '../../constants';
import { ScopeOptions, VersionOptions } from '../../interfaces';
import { isString, isUndefined } from '../../utils/shared.utils';

/**
 * Interface defining options that can be passed to `@Controller()` decorator
 *
 * @publicApi
 */
export interface ControllerOptions extends ScopeOptions, VersionOptions {
  /**
   * Specifies an optional `route path prefix`.  The prefix is pre-pended to the
   * path specified in any request decorator in the class.
   *
   * Supported only by HTTP-based applications (does not apply to non-HTTP microservices).
   *
   * @see [Routing](https://docs.nestjs.com/controllers#routing)
   */
  path?: string | string[];

  /**
   * Specifies an optional HTTP Request host filter.  When configured, methods
   * within the controller will only be routed if the request host matches the
   * specified value.
   *
   * @see [Routing](https://docs.nestjs.com/controllers#routing)
   */
  host?: string | RegExp | Array<string | RegExp>;
}

/**
 * Decorator that marks a class as a Nest controller that can receive inbound
 * requests and produce responses.
 *
 * An HTTP Controller responds to inbound HTTP Requests and produces HTTP Responses.
 * It defines a class that provides the context for one or more related route
 * handlers that correspond to HTTP request methods and associated routes
 * for example `GET /api/profile`, `POST /users/resume`.
 *
 * A Microservice Controller responds to requests as well as events, running over
 * a variety of transports [(read more here)](https://docs.nestjs.com/microservices/basics).
 * It defines a class that provides a context for one or more message or event
 * handlers.
 *
 * @see [Controllers](https://docs.nestjs.com/controllers)
 * @see [Microservices](https://docs.nestjs.com/microservices/basics#request-response)
 *
 * @publicApi
 */
export function Controller(): ClassDecorator;

/**
 * Decorator that marks a class as a Nest controller that can receive inbound
 * requests and produce responses.
 *
 * An HTTP Controller responds to inbound HTTP Requests and produces HTTP Responses.
 * It defines a class that provides the context for one or more related route
 * handlers that correspond to HTTP request methods and associated routes
 * for example `GET /api/profile`, `POST /users/resume`.
 *
 * A Microservice Controller responds to requests as well as events, running over
 * a variety of transports [(read more here)](https://docs.nestjs.com/microservices/basics).
 * It defines a class that provides a context for one or more message or event
 * handlers.
 *
 * @param {string|Array} prefix string that defines a `route path prefix`.  The prefix
 * is pre-pended to the path specified in any request decorator in the class.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 * @see [Controllers](https://docs.nestjs.com/controllers)
 * @see [Microservices](https://docs.nestjs.com/microservices/basics#request-response)
 *
 * @publicApi
 */
export function Controller(prefix: string | string[]): ClassDecorator;

/**
 * Decorator that marks a class as a Nest controller that can receive inbound
 * requests and produce responses.
 *
 * An HTTP Controller responds to inbound HTTP Requests and produces HTTP Responses.
 * It defines a class that provides the context for one or more related route
 * handlers that correspond to HTTP request methods and associated routes
 * for example `GET /api/profile`, `POST /users/resume`.
 *
 * A Microservice Controller responds to requests as well as events, running over
 * a variety of transports [(read more here)](https://docs.nestjs.com/microservices/basics).
 * It defines a class that provides a context for one or more message or event
 * handlers.
 *
 * @param {object} options configuration object specifying:
 *
 * - `scope` - symbol that determines the lifetime of a Controller instance.
 * [See Scope](https://docs.nestjs.com/fundamentals/injection-scopes#usage) for
 * more details.
 * - `prefix` - string that defines a `route path prefix`.  The prefix
 * is pre-pended to the path specified in any request decorator in the class.
 * - `version` - string, array of strings, or Symbol that defines the version
 * of all routes in the class. [See Versioning](https://docs.nestjs.com/techniques/versioning)
 * for more details.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 * @see [Controllers](https://docs.nestjs.com/controllers)
 * @see [Microservices](https://docs.nestjs.com/microservices/basics#request-response)
 * @see [Versioning](https://docs.nestjs.com/techniques/versioning)
 *
 * @publicApi
 */
export function Controller(options: ControllerOptions): ClassDecorator;

/**
 * Decorator that marks a class as a Nest controller that can receive inbound
 * requests and produce responses.
 *
 * An HTTP Controller responds to inbound HTTP Requests and produces HTTP Responses.
 * It defines a class that provides the context for one or more related route
 * handlers that correspond to HTTP request methods and associated routes
 * for example `GET /api/profile`, `POST /users/resume`
 *
 * A Microservice Controller responds to requests as well as events, running over
 * a variety of transports [(read more here)](https://docs.nestjs.com/microservices/basics).
 * It defines a class that provides a context for one or more message or event
 * handlers.
 *
 * @param prefixOrOptions a `route path prefix` or a `ControllerOptions` object.
 * A `route path prefix` is pre-pended to the path specified in any request decorator
 * in the class. `ControllerOptions` is an options configuration object specifying:
 * - `scope` - symbol that determines the lifetime of a Controller instance.
 * [See Scope](https://docs.nestjs.com/fundamentals/injection-scopes#usage) for
 * more details.
 * - `prefix` - string that defines a `route path prefix`.  The prefix
 * is pre-pended to the path specified in any request decorator in the class.
 * - `version` - string, array of strings, or Symbol that defines the version
 * of all routes in the class. [See Versioning](https://docs.nestjs.com/techniques/versioning)
 * for more details.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 * @see [Controllers](https://docs.nestjs.com/controllers)
 * @see [Microservices](https://docs.nestjs.com/microservices/basics#request-response)
 * @see [Scope](https://docs.nestjs.com/fundamentals/injection-scopes#usage)
 * @see [Versioning](https://docs.nestjs.com/techniques/versioning)
 *
 * @publicApi
 */
export function Controller(
  prefixOrOptions?: string | string[] | ControllerOptions,
): ClassDecorator {
  const defaultPath = '/';

  const [path, host, scopeOptions, versionOptions] = isUndefined(
    prefixOrOptions,
  )
    ? [defaultPath, undefined, undefined, undefined]
    : isString(prefixOrOptions) || Array.isArray(prefixOrOptions)
      ? [prefixOrOptions, undefined, undefined, undefined]
      : [
          prefixOrOptions.path || defaultPath,
          prefixOrOptions.host,
          { scope: prefixOrOptions.scope, durable: prefixOrOptions.durable },
          Array.isArray(prefixOrOptions.version)
            ? Array.from(new Set(prefixOrOptions.version))
            : prefixOrOptions.version,
        ];

  return (target: object) => {
    Reflect.defineMetadata(CONTROLLER_WATERMARK, true, target);
    Reflect.defineMetadata(PATH_METADATA, path, target);
    Reflect.defineMetadata(HOST_METADATA, host, target);
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, scopeOptions, target);
    Reflect.defineMetadata(VERSION_METADATA, versionOptions, target);
  };
}



================================================
FILE: packages/common/decorators/core/dependencies.decorator.ts
================================================
import { PARAMTYPES_METADATA } from '../../constants';

export function flatten<T extends Array<unknown> = any>(
  arr: T,
): T extends Array<infer R> ? R : never {
  const flat = ([] as any[]).concat(...arr);
  return flat.some(Array.isArray) ? flatten(flat) : flat;
}

/**
 * Decorator that sets required dependencies (required with a vanilla JavaScript objects)
 *
 * @publicApi
 */
export const Dependencies = (
  ...dependencies: Array<unknown>
): ClassDecorator => {
  const flattenDeps = flatten(dependencies);
  return (target: object) => {
    Reflect.defineMetadata(PARAMTYPES_METADATA, flattenDeps, target);
  };
};



================================================
FILE: packages/common/decorators/core/exception-filters.decorator.ts
================================================
import { EXCEPTION_FILTERS_METADATA } from '../../constants';
import { ExceptionFilter } from '../../index';
import { extendArrayMetadata } from '../../utils/extend-metadata.util';
import { isFunction } from '../../utils/shared.utils';
import { validateEach } from '../../utils/validate-each.util';

/**
 * Decorator that binds exception filters to the scope of the controller or
 * method, depending on its context.
 *
 * When `@UseFilters` is used at the controller level, the filter will be
 * applied to every handler (method) in the controller.
 *
 * When `@UseFilters` is used at the individual handler level, the filter
 * will apply only to that specific method.
 *
 * @param filters exception filter instance or class, or a list of exception
 * filter instances or classes.
 *
 * @see [Exception filters](https://docs.nestjs.com/exception-filters)
 *
 * @usageNotes
 * Exception filters can also be set up globally for all controllers and routes
 * using `app.useGlobalFilters()`.  [See here for details](https://docs.nestjs.com/exception-filters#binding-filters)
 *
 * @publicApi
 */

export const UseFilters = (...filters: (ExceptionFilter | Function)[]) =>
  addExceptionFiltersMetadata(...filters);

function addExceptionFiltersMetadata(
  ...filters: (Function | ExceptionFilter)[]
): MethodDecorator & ClassDecorator {
  return (
    target: any,
    key?: string | symbol,
    descriptor?: TypedPropertyDescriptor<any>,
  ) => {
    const isFilterValid = <T extends Function | Record<string, any>>(
      filter: T,
    ) => filter && (isFunction(filter) || isFunction(filter.catch));

    if (descriptor) {
      validateEach(
        target.constructor,
        filters,
        isFilterValid,
        '@UseFilters',
        'filter',
      );
      extendArrayMetadata(
        EXCEPTION_FILTERS_METADATA,
        filters,
        descriptor.value,
      );
      return descriptor;
    }
    validateEach(target, filters, isFilterValid, '@UseFilters', 'filter');
    extendArrayMetadata(EXCEPTION_FILTERS_METADATA, filters, target);
    return target;
  };
}



================================================
FILE: packages/common/decorators/core/index.ts
================================================
export * from './bind.decorator';
export * from './catch.decorator';
export * from './controller.decorator';
export * from './dependencies.decorator';
export * from './exception-filters.decorator';
export * from './inject.decorator';
export * from './injectable.decorator';
export * from './optional.decorator';
export * from './set-metadata.decorator';
export * from './use-guards.decorator';
export * from './use-interceptors.decorator';
export * from './use-pipes.decorator';
export * from './apply-decorators';
export * from './version.decorator';



================================================
FILE: packages/common/decorators/core/inject.decorator.ts
================================================
import {
  PARAMTYPES_METADATA,
  PROPERTY_DEPS_METADATA,
  SELF_DECLARED_DEPS_METADATA,
} from '../../constants';
import { ForwardReference, InjectionToken } from '../../interfaces';
import { isUndefined } from '../../utils/shared.utils';

/**
 * Decorator that marks a constructor parameter as a target for
 * [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection).
 *
 * Any injected provider must be visible within the module scope (loosely
 * speaking, the containing module) of the class it is being injected into. This
 * can be done by:
 *
 * - defining the provider in the same module scope
 * - exporting the provider from one module scope and importing that module into the
 *   module scope of the class being injected into
 * - exporting the provider from a module that is marked as global using the
 *   `@Global()` decorator
 *
 * #### Injection tokens
 * Can be *types* (class names), *strings* or *symbols*. This depends on how the
 * provider with which it is associated was defined. Providers defined with the
 * `@Injectable()` decorator use the class name. Custom Providers may use strings
 * or symbols as the injection token.
 *
 * @param token lookup key for the provider to be injected (assigned to the constructor
 * parameter).
 *
 * @see [Providers](https://docs.nestjs.com/providers)
 * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)
 * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 *
 * @publicApi
 */
export function Inject(
  token?: InjectionToken | ForwardReference,
): PropertyDecorator & ParameterDecorator {
  const injectCallHasArguments = arguments.length > 0;

  return (target: object, key: string | symbol | undefined, index?: number) => {
    let type = token || Reflect.getMetadata('design:type', target, key!);
    // Try to infer the token in a constructor-based injection
    if (!type && !injectCallHasArguments) {
      type = Reflect.getMetadata(PARAMTYPES_METADATA, target, key!)?.[index!];
    }

    if (!isUndefined(index)) {
      let dependencies =
        Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, target) || [];

      dependencies = [...dependencies, { index, param: type }];
      Reflect.defineMetadata(SELF_DECLARED_DEPS_METADATA, dependencies, target);
      return;
    }
    let properties =
      Reflect.getMetadata(PROPERTY_DEPS_METADATA, target.constructor) || [];

    properties = [...properties, { key, type }];
    Reflect.defineMetadata(
      PROPERTY_DEPS_METADATA,
      properties,
      target.constructor,
    );
  };
}



================================================
FILE: packages/common/decorators/core/injectable.decorator.ts
================================================
import { uid } from 'uid';
import { INJECTABLE_WATERMARK, SCOPE_OPTIONS_METADATA } from '../../constants';
import { ScopeOptions } from '../../interfaces/scope-options.interface';
import { Type } from '../../interfaces/type.interface';

/**
 * Defines the injection scope.
 *
 * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 *
 * @publicApi
 */
export type InjectableOptions = ScopeOptions;

/**
 * Decorator that marks a class as a [provider](https://docs.nestjs.com/providers).
 * Providers can be injected into other classes via constructor parameter injection
 * using Nest's built-in [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection)
 * system.
 *
 * When injecting a provider, it must be visible within the module scope (loosely
 * speaking, the containing module) of the class it is being injected into. This
 * can be done by:
 *
 * - defining the provider in the same module scope
 * - exporting the provider from one module scope and importing that module into the
 *   module scope of the class being injected into
 * - exporting the provider from a module that is marked as global using the
 *   `@Global()` decorator
 *
 * Providers can also be defined in a more explicit and imperative form using
 * various [custom provider](https://docs.nestjs.com/fundamentals/custom-providers) techniques that expose
 * more capabilities of the DI system.
 *
 * @param options options specifying scope of injectable
 *
 * @see [Providers](https://docs.nestjs.com/providers)
 * @see [Custom Providers](https://docs.nestjs.com/fundamentals/custom-providers)
 * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 *
 * @publicApi
 */
export function Injectable(options?: InjectableOptions): ClassDecorator {
  return (target: object) => {
    Reflect.defineMetadata(INJECTABLE_WATERMARK, true, target);
    Reflect.defineMetadata(SCOPE_OPTIONS_METADATA, options, target);
  };
}

/**
 * @publicApi
 */
export function mixin<T>(mixinClass: Type<T>) {
  Object.defineProperty(mixinClass, 'name', {
    value: uid(21),
  });
  Injectable()(mixinClass);
  return mixinClass;
}



================================================
FILE: packages/common/decorators/core/optional.decorator.ts
================================================
import {
  OPTIONAL_DEPS_METADATA,
  OPTIONAL_PROPERTY_DEPS_METADATA,
} from '../../constants';
import { isUndefined } from '../../utils/shared.utils';

/**
 * Parameter decorator for an injected dependency marking the
 * dependency as optional.
 *
 * For example:
 * ```typescript
 * constructor(@Optional() @Inject('HTTP_OPTIONS')private readonly httpClient: T) {}
 * ```
 *
 * @see [Optional providers](https://docs.nestjs.com/providers#optional-providers)
 *
 * @publicApi
 */
export function Optional(): PropertyDecorator & ParameterDecorator {
  return (target: object, key: string | symbol | undefined, index?: number) => {
    if (!isUndefined(index)) {
      const args = Reflect.getMetadata(OPTIONAL_DEPS_METADATA, target) || [];
      Reflect.defineMetadata(OPTIONAL_DEPS_METADATA, [...args, index], target);
      return;
    }
    const properties =
      Reflect.getMetadata(
        OPTIONAL_PROPERTY_DEPS_METADATA,
        target.constructor,
      ) || [];
    Reflect.defineMetadata(
      OPTIONAL_PROPERTY_DEPS_METADATA,
      [...properties, key],
      target.constructor,
    );
  };
}



================================================
FILE: packages/common/decorators/core/set-metadata.decorator.ts
================================================
export type CustomDecorator<TKey = string> = MethodDecorator &
  ClassDecorator & {
    KEY: TKey;
  };

/**
 * Decorator that assigns metadata to the class/function using the
 * specified `key`.
 *
 * Requires two parameters:
 * - `key` - a value defining the key under which the metadata is stored
 * - `value` - metadata to be associated with `key`
 *
 * This metadata can be reflected using the `Reflector` class.
 *
 * Example: `@SetMetadata('roles', ['admin'])`
 *
 * @see [Reflection](https://docs.nestjs.com/fundamentals/execution-context#reflection-and-metadata)
 *
 * @publicApi
 */
export const SetMetadata = <K = string, V = any>(
  metadataKey: K,
  metadataValue: V,
): CustomDecorator<K> => {
  const decoratorFactory = (target: object, key?: any, descriptor?: any) => {
    if (descriptor) {
      Reflect.defineMetadata(metadataKey, metadataValue, descriptor.value);
      return descriptor;
    }
    Reflect.defineMetadata(metadataKey, metadataValue, target);
    return target;
  };
  decoratorFactory.KEY = metadataKey;
  return decoratorFactory;
};



================================================
FILE: packages/common/decorators/core/use-guards.decorator.ts
================================================
import { GUARDS_METADATA } from '../../constants';
import { CanActivate } from '../../interfaces';
import { extendArrayMetadata } from '../../utils/extend-metadata.util';
import { isFunction } from '../../utils/shared.utils';
import { validateEach } from '../../utils/validate-each.util';

/**
 * Decorator that binds guards to the scope of the controller or method,
 * depending on its context.
 *
 * When `@UseGuards` is used at the controller level, the guard will be
 * applied to every handler (method) in the controller.
 *
 * When `@UseGuards` is used at the individual handler level, the guard
 * will apply only to that specific method.
 *
 * @param guards a single guard instance or class, or a list of guard instances
 * or classes.
 *
 * @see [Guards](https://docs.nestjs.com/guards)
 *
 * @usageNotes
 * Guards can also be set up globally for all controllers and routes
 * using `app.useGlobalGuards()`.  [See here for details](https://docs.nestjs.com/guards#binding-guards)
 *
 * @publicApi
 */
export function UseGuards(
  ...guards: (CanActivate | Function)[]
): MethodDecorator & ClassDecorator {
  return (
    target: any,
    key?: string | symbol,
    descriptor?: TypedPropertyDescriptor<any>,
  ) => {
    const isGuardValid = <T extends Function | Record<string, any>>(guard: T) =>
      guard && (isFunction(guard) || isFunction(guard.canActivate));

    if (descriptor) {
      validateEach(
        target.constructor,
        guards,
        isGuardValid,
        '@UseGuards',
        'guard',
      );
      extendArrayMetadata(GUARDS_METADATA, guards, descriptor.value);
      return descriptor;
    }
    validateEach(target, guards, isGuardValid, '@UseGuards', 'guard');
    extendArrayMetadata(GUARDS_METADATA, guards, target);
    return target;
  };
}



================================================
FILE: packages/common/decorators/core/use-interceptors.decorator.ts
================================================
import { INTERCEPTORS_METADATA } from '../../constants';
import { NestInterceptor } from '../../interfaces';
import { extendArrayMetadata } from '../../utils/extend-metadata.util';
import { isFunction } from '../../utils/shared.utils';
import { validateEach } from '../../utils/validate-each.util';

/**
 * Decorator that binds interceptors to the scope of the controller or method,
 * depending on its context.
 *
 * When `@UseInterceptors` is used at the controller level, the interceptor will
 * be applied to every handler (method) in the controller.
 *
 * When `@UseInterceptors` is used at the individual handler level, the interceptor
 * will apply only to that specific method.
 *
 * @param interceptors a single interceptor instance or class, or a list of
 * interceptor instances or classes.
 *
 * @see [Interceptors](https://docs.nestjs.com/interceptors)
 *
 * @usageNotes
 * Interceptors can also be set up globally for all controllers and routes
 * using `app.useGlobalInterceptors()`.  [See here for details](https://docs.nestjs.com/interceptors#binding-interceptors)
 *
 * @publicApi
 */
export function UseInterceptors(
  ...interceptors: (NestInterceptor | Function)[]
): MethodDecorator & ClassDecorator {
  return (
    target: any,
    key?: string | symbol,
    descriptor?: TypedPropertyDescriptor<any>,
  ) => {
    const isInterceptorValid = <T extends Function | Record<string, any>>(
      interceptor: T,
    ) =>
      interceptor &&
      (isFunction(interceptor) || isFunction(interceptor.intercept));

    if (descriptor) {
      validateEach(
        target.constructor,
        interceptors,
        isInterceptorValid,
        '@UseInterceptors',
        'interceptor',
      );
      extendArrayMetadata(
        INTERCEPTORS_METADATA,
        interceptors,
        descriptor.value,
      );
      return descriptor;
    }
    validateEach(
      target,
      interceptors,
      isInterceptorValid,
      '@UseInterceptors',
      'interceptor',
    );
    extendArrayMetadata(INTERCEPTORS_METADATA, interceptors, target);
    return target;
  };
}



================================================
FILE: packages/common/decorators/core/use-pipes.decorator.ts
================================================
import { PIPES_METADATA } from '../../constants';
import { PipeTransform } from '../../interfaces/index';
import { extendArrayMetadata } from '../../utils/extend-metadata.util';
import { isFunction } from '../../utils/shared.utils';
import { validateEach } from '../../utils/validate-each.util';

/**
 * Decorator that binds pipes to the scope of the controller or method,
 * depending on its context.
 *
 * When `@UsePipes` is used at the controller level, the pipe will be
 * applied to every handler (method) in the controller.
 *
 * When `@UsePipes` is used at the individual handler level, the pipe
 * will apply only to that specific method.
 *
 * @param pipes a single pipe instance or class, or a list of pipe instances or
 * classes.
 *
 * @see [Pipes](https://docs.nestjs.com/pipes)
 *
 * @usageNotes
 * Pipes can also be set up globally for all controllers and routes
 * using `app.useGlobalPipes()`.  [See here for details](https://docs.nestjs.com/pipes#class-validator)
 *
 * @publicApi
 */

export function UsePipes(
  ...pipes: (PipeTransform | Function)[]
): ClassDecorator & MethodDecorator {
  return (
    target: any,
    key?: string | symbol,
    descriptor?: TypedPropertyDescriptor<any>,
  ) => {
    const isPipeValid = <T extends Function | Record<string, any>>(pipe: T) =>
      pipe && (isFunction(pipe) || isFunction(pipe.transform));

    if (descriptor) {
      extendArrayMetadata(PIPES_METADATA, pipes, descriptor.value);
      return descriptor;
    }
    validateEach(target, pipes, isPipeValid, '@UsePipes', 'pipe');
    extendArrayMetadata(PIPES_METADATA, pipes, target);
    return target;
  };
}



================================================
FILE: packages/common/decorators/core/version.decorator.ts
================================================
import { VERSION_METADATA } from '../../constants';
import { VersionValue } from '../../interfaces/version-options.interface';

/**
 * Sets the version of the endpoint to the passed version
 *
 * @publicApi
 */
export function Version(version: VersionValue): MethodDecorator {
  if (Array.isArray(version)) {
    // Drop duplicated versions
    version = Array.from(new Set(version));
  }

  return (
    target: any,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    Reflect.defineMetadata(VERSION_METADATA, version, descriptor.value);
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/http/create-route-param-metadata.decorator.ts
================================================
import { uid } from 'uid';
import { ROUTE_ARGS_METADATA } from '../../constants';
import { PipeTransform } from '../../index';
import { Type } from '../../interfaces';
import { CustomParamFactory } from '../../interfaces/features/custom-route-param-factory.interface';
import { assignCustomParameterMetadata } from '../../utils/assign-custom-metadata.util';
import { isFunction, isNil } from '../../utils/shared.utils';

export type ParamDecoratorEnhancer = ParameterDecorator;

/**
 * Defines HTTP route param decorator
 *
 * @param factory
 * @param enhancers
 *
 * @publicApi
 */
export function createParamDecorator<FactoryData = any, FactoryOutput = any>(
  factory: CustomParamFactory<FactoryData, FactoryOutput>,
  enhancers: ParamDecoratorEnhancer[] = [],
): (
  ...dataOrPipes: (Type<PipeTransform> | PipeTransform | FactoryData)[]
) => ParameterDecorator {
  const paramtype = uid(21);
  return (
      data?,
      ...pipes: (Type<PipeTransform> | PipeTransform | FactoryData)[]
    ): ParameterDecorator =>
    (target, key, index) => {
      const args =
        Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key!) ||
        {};

      const isPipe = (pipe: any) =>
        pipe &&
        ((isFunction(pipe) &&
          pipe.prototype &&
          isFunction(pipe.prototype.transform)) ||
          isFunction(pipe.transform));

      const hasParamData = isNil(data) || !isPipe(data);
      const paramData = hasParamData ? (data as any) : undefined;
      const paramPipes = hasParamData ? pipes : [data, ...pipes];

      Reflect.defineMetadata(
        ROUTE_ARGS_METADATA,
        assignCustomParameterMetadata(
          args,
          paramtype,
          index,
          factory,
          paramData,
          ...(paramPipes as PipeTransform[]),
        ),
        target.constructor,
        key!,
      );
      enhancers.forEach(fn => fn(target, key, index));
    };
}



================================================
FILE: packages/common/decorators/http/header.decorator.ts
================================================
import { HEADERS_METADATA } from '../../constants';
import { extendArrayMetadata } from '../../utils/extend-metadata.util';

/**
 * Request method Decorator.  Sets a response header.
 *
 * For example:
 * `@Header('Cache-Control', 'none')`
 * `@Header('Cache-Control', () => 'none')`
 *
 * @param name string to be used for header name
 * @param value string to be used for header value
 *
 * @see [Headers](https://docs.nestjs.com/controllers#headers)
 *
 * @publicApi
 */
export function Header(
  name: string,
  value: string | (() => string),
): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    extendArrayMetadata(HEADERS_METADATA, [{ name, value }], descriptor.value);
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/http/http-code.decorator.ts
================================================
import { HTTP_CODE_METADATA } from '../../constants';

/**
 * Request method Decorator.  Defines the HTTP response status code.  Overrides
 * default status code for the decorated request method.
 *
 * @param statusCode HTTP response code to be returned by route handler.
 *
 * @see [Http Status Codes](https://docs.nestjs.com/controllers#status-code)
 *
 * @publicApi
 */
export function HttpCode(statusCode: number): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    Reflect.defineMetadata(HTTP_CODE_METADATA, statusCode, descriptor.value);
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/http/index.ts
================================================
export * from './request-mapping.decorator';
export * from './route-params.decorator';
export * from './http-code.decorator';
export * from './create-route-param-metadata.decorator';
export * from './render.decorator';
export * from './header.decorator';
export * from './redirect.decorator';
export * from './sse.decorator';



================================================
FILE: packages/common/decorators/http/redirect.decorator.ts
================================================
import { REDIRECT_METADATA } from '../../constants';

/**
 * Redirects request to the specified URL.
 *
 * @publicApi
 */
export function Redirect(url = '', statusCode?: number): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    Reflect.defineMetadata(
      REDIRECT_METADATA,
      { statusCode, url },
      descriptor.value,
    );
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/http/render.decorator.ts
================================================
import { RENDER_METADATA } from '../../constants';

/**
 * Route handler method Decorator.  Defines a template to be rendered by the controller.
 *
 * For example: `@Render('index')`
 *
 * @param template name of the render engine template file
 *
 * @see [Model-View-Controller](https://docs.nestjs.com/techniques/mvc)
 *
 * @publicApi
 */
export function Render(template: string): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    Reflect.defineMetadata(RENDER_METADATA, template, descriptor.value);
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/http/request-mapping.decorator.ts
================================================
import { METHOD_METADATA, PATH_METADATA } from '../../constants';
import { RequestMethod } from '../../enums/request-method.enum';

export interface RequestMappingMetadata {
  path?: string | string[];
  method?: RequestMethod;
}

const defaultMetadata = {
  [PATH_METADATA]: '/',
  [METHOD_METADATA]: RequestMethod.GET,
};

export const RequestMapping = (
  metadata: RequestMappingMetadata = defaultMetadata,
): MethodDecorator => {
  const pathMetadata = metadata[PATH_METADATA];
  const path = pathMetadata && pathMetadata.length ? pathMetadata : '/';
  const requestMethod = metadata[METHOD_METADATA] || RequestMethod.GET;

  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    Reflect.defineMetadata(PATH_METADATA, path, descriptor.value);
    Reflect.defineMetadata(METHOD_METADATA, requestMethod, descriptor.value);
    return descriptor;
  };
};

const createMappingDecorator =
  (method: RequestMethod) =>
  (path?: string | string[]): MethodDecorator => {
    return RequestMapping({
      [PATH_METADATA]: path,
      [METHOD_METADATA]: method,
    });
  };

/**
 * Route handler (method) Decorator. Routes HTTP POST requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Post = createMappingDecorator(RequestMethod.POST);

/**
 * Route handler (method) Decorator. Routes HTTP GET requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Get = createMappingDecorator(RequestMethod.GET);

/**
 * Route handler (method) Decorator. Routes HTTP DELETE requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Delete = createMappingDecorator(RequestMethod.DELETE);

/**
 * Route handler (method) Decorator. Routes HTTP PUT requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Put = createMappingDecorator(RequestMethod.PUT);

/**
 * Route handler (method) Decorator. Routes HTTP PATCH requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Patch = createMappingDecorator(RequestMethod.PATCH);

/**
 * Route handler (method) Decorator. Routes HTTP OPTIONS requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Options = createMappingDecorator(RequestMethod.OPTIONS);

/**
 * Route handler (method) Decorator. Routes HTTP HEAD requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Head = createMappingDecorator(RequestMethod.HEAD);

/**
 * Route handler (method) Decorator. Routes all HTTP requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const All = createMappingDecorator(RequestMethod.ALL);

/**
 * Route handler (method) Decorator. Routes HTTP SEARCH requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Search = createMappingDecorator(RequestMethod.SEARCH);

/**
 * Route handler (method) Decorator. Routes Webdav PROPFIND requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Propfind = createMappingDecorator(RequestMethod.PROPFIND);

/**
 * Route handler (method) Decorator. Routes Webdav PROPPATCH requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Proppatch = createMappingDecorator(RequestMethod.PROPPATCH);

/**
 * Route handler (method) Decorator. Routes Webdav MKCOL requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Mkcol = createMappingDecorator(RequestMethod.MKCOL);

/**
 * Route handler (method) Decorator. Routes Webdav COPY requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Copy = createMappingDecorator(RequestMethod.COPY);

/**
 * Route handler (method) Decorator. Routes Webdav MOVE requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Move = createMappingDecorator(RequestMethod.MOVE);

/**
 * Route handler (method) Decorator. Routes Webdav LOCK requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Lock = createMappingDecorator(RequestMethod.LOCK);

/**
 * Route handler (method) Decorator. Routes Webdav UNLOCK requests to the specified path.
 *
 * @see [Routing](https://docs.nestjs.com/controllers#routing)
 *
 * @publicApi
 */
export const Unlock = createMappingDecorator(RequestMethod.UNLOCK);



================================================
FILE: packages/common/decorators/http/route-params.decorator.ts
================================================
import {
  RESPONSE_PASSTHROUGH_METADATA,
  ROUTE_ARGS_METADATA,
} from '../../constants';
import { RouteParamtypes } from '../../enums/route-paramtypes.enum';
import { PipeTransform } from '../../index';
import { Type } from '../../interfaces';
import { isNil, isString } from '../../utils/shared.utils';

/**
 * The `@Response()`/`@Res` parameter decorator options.
 */
export interface ResponseDecoratorOptions {
  /**
   * Determines whether the response will be sent manually within the route handler,
   * with the use of native response handling methods exposed by the platform-specific response object,
   * or if it should passthrough Nest response processing pipeline.
   *
   * @default false
   */
  passthrough: boolean;
}

export type ParamData = object | string | number;
export interface RouteParamMetadata {
  index: number;
  data?: ParamData;
}

export function assignMetadata<TParamtype = any, TArgs = any>(
  args: TArgs,
  paramtype: TParamtype,
  index: number,
  data?: ParamData,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
) {
  return {
    ...args,
    [`${paramtype as string}:${index}`]: {
      index,
      data,
      pipes,
    },
  };
}

function createRouteParamDecorator(paramtype: RouteParamtypes) {
  return (data?: ParamData): ParameterDecorator =>
    (target, key, index) => {
      const args =
        Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key!) ||
        {};
      Reflect.defineMetadata(
        ROUTE_ARGS_METADATA,
        assignMetadata<RouteParamtypes, Record<number, RouteParamMetadata>>(
          args,
          paramtype,
          index,
          data,
        ),
        target.constructor,
        key!,
      );
    };
}

const createPipesRouteParamDecorator =
  (paramtype: RouteParamtypes) =>
  (
    data?: any,
    ...pipes: (Type<PipeTransform> | PipeTransform)[]
  ): ParameterDecorator =>
  (target, key, index) => {
    const args =
      Reflect.getMetadata(ROUTE_ARGS_METADATA, target.constructor, key!) || {};
    const hasParamData = isNil(data) || isString(data);
    const paramData = hasParamData ? data : undefined;
    const paramPipes = hasParamData ? pipes : [data, ...pipes];

    Reflect.defineMetadata(
      ROUTE_ARGS_METADATA,
      assignMetadata(args, paramtype, index, paramData!, ...paramPipes),
      target.constructor,
      key!,
    );
  };

/**
 * Route handler parameter decorator. Extracts the `Request`
 * object from the underlying platform and populates the decorated
 * parameter with the value of `Request`.
 *
 * Example: `logout(@Request() req)`
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export const Request: () => ParameterDecorator = createRouteParamDecorator(
  RouteParamtypes.REQUEST,
);

/**
 * Route handler parameter decorator. Extracts the `Response`
 * object from the underlying platform and populates the decorated
 * parameter with the value of `Response`.
 *
 * Example: `logout(@Response() res)`
 *
 * @publicApi
 */
export const Response: (
  options?: ResponseDecoratorOptions,
) => ParameterDecorator =
  (options?: ResponseDecoratorOptions) => (target, key, index) => {
    if (options?.passthrough) {
      Reflect.defineMetadata(
        RESPONSE_PASSTHROUGH_METADATA,
        options?.passthrough,
        target.constructor,
        key!,
      );
    }
    return createRouteParamDecorator(RouteParamtypes.RESPONSE)()(
      target,
      key,
      index,
    );
  };

/**
 * Route handler parameter decorator. Extracts reference to the `Next` function
 * from the underlying platform and populates the decorated
 * parameter with the value of `Next`.
 *
 * @publicApi
 */
export const Next: () => ParameterDecorator = createRouteParamDecorator(
  RouteParamtypes.NEXT,
);

/**
 * Route handler parameter decorator. Extracts the `Ip` property
 * from the `req` object and populates the decorated
 * parameter with the value of `ip`.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export const Ip: () => ParameterDecorator = createRouteParamDecorator(
  RouteParamtypes.IP,
);

/**
 * Route handler parameter decorator. Extracts the `Session` object
 * from the underlying platform and populates the decorated
 * parameter with the value of `Session`.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export const Session: () => ParameterDecorator = createRouteParamDecorator(
  RouteParamtypes.SESSION,
);

/**
 * Route handler parameter decorator. Extracts the `file` object
 * and populates the decorated parameter with the value of `file`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFile() file) {
 *   console.log(file);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFile(): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `file` object
 * and populates the decorated parameter with the value of `file`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFile() file) {
 *   console.log(file);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFile(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts the `file` object
 * and populates the decorated parameter with the value of `file`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFile() file) {
 *   console.log(file);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFile(
  fileKey?: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `file` object
 * and populates the decorated parameter with the value of `file`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFile() file) {
 *   console.log(file);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFile(
  fileKey?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.FILE)(
    fileKey,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the `files` object
 * and populates the decorated parameter with the value of `files`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFiles() files) {
 *   console.log(files);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFiles(): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `files` object
 * and populates the decorated parameter with the value of `files`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFiles() files) {
 *   console.log(files);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFiles(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `files` object
 * and populates the decorated parameter with the value of `files`.
 * Used in conjunction with
 * [multer middleware](https://github.com/expressjs/multer) for Express-based applications.
 *
 * For example:
 * ```typescript
 * uploadFile(@UploadedFiles() files) {
 *   console.log(files);
 * }
 * ```
 * @see [Request object](https://docs.nestjs.com/techniques/file-upload)
 *
 * @publicApi
 */
export function UploadedFiles(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.FILES)(
    undefined,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the `headers`
 * property from the `req` object and populates the decorated
 * parameter with the value of `headers`.
 *
 * For example: `async update(@Headers('Cache-Control') cacheControl: string)`
 *
 * @param property name of single header property to extract.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export const Headers: (property?: string) => ParameterDecorator =
  createRouteParamDecorator(RouteParamtypes.HEADERS);

/**
 * Route handler parameter decorator. Extracts the `query`
 * property from the `req` object and populates the decorated
 * parameter with the value of `query`. May also apply pipes to the bound
 * query parameter.
 *
 * For example:
 * ```typescript
 * async find(@Query('user') user: string)
 * ```
 *
 * @param property name of single property to extract from the `query` object
 * @param pipes one or more pipes to apply to the bound query parameter
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function Query(): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `query`
 * property from the `req` object and populates the decorated
 * parameter with the value of `query`. May also apply pipes to the bound
 * query parameter.
 *
 * For example:
 * ```typescript
 * async find(@Query('user') user: string)
 * ```
 *
 * @param property name of single property to extract from the `query` object
 * @param pipes one or more pipes to apply to the bound query parameter
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function Query(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `query`
 * property from the `req` object and populates the decorated
 * parameter with the value of `query`. May also apply pipes to the bound
 * query parameter.
 *
 * For example:
 * ```typescript
 * async find(@Query('user') user: string)
 * ```
 *
 * @param property name of single property to extract from the `query` object
 * @param pipes one or more pipes to apply to the bound query parameter
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function Query(
  property: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `query`
 * property from the `req` object and populates the decorated
 * parameter with the value of `query`. May also apply pipes to the bound
 * query parameter.
 *
 * For example:
 * ```typescript
 * async find(@Query('user') user: string)
 * ```
 *
 * @param property name of single property to extract from the `query` object
 * @param pipes one or more pipes to apply to the bound query parameter
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function Query(
  property?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.QUERY)(
    property,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the entire `body`
 * object from the `req` object and populates the decorated
 * parameter with the value of `body`.
 *
 * For example:
 * ```typescript
 * async create(@Body() createDto: CreateCatDto)
 * ```
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function Body(): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts the entire `body`
 * object from the `req` object and populates the decorated
 * parameter with the value of `body`. Also applies the specified
 * pipes to that parameter.
 *
 * For example:
 * ```typescript
 * async create(@Body(new ValidationPipe()) createDto: CreateCatDto)
 * ```
 *
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound body parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Body(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts a single property from
 * the `body` object property of the `req` object and populates the decorated
 * parameter with the value of that property. Also applies pipes to the bound
 * body parameter.
 *
 * For example:
 * ```typescript
 * async create(@Body('role', new ValidationPipe()) role: string)
 * ```
 *
 * @param property name of single property to extract from the `body` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound body parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Body(
  property: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts the entire `body` object
 * property, or optionally a named property of the `body` object, from
 * the `req` object and populates the decorated parameter with that value.
 * Also applies pipes to the bound body parameter.
 *
 * For example:
 * ```typescript
 * async create(@Body('role', new ValidationPipe()) role: string)
 * ```
 *
 * @param property name of single property to extract from the `body` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound body parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Body(
  property?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.BODY)(
    property,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the `rawBody` Buffer
 * property from the `req` object and populates the decorated parameter with that value.
 *
 * For example:
 * ```typescript
 * async create(@RawBody() rawBody: Buffer | undefined)
 * ```
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Raw body](https://docs.nestjs.com/faq/raw-body)
 *
 * @publicApi
 */
export function RawBody(): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts the `rawBody` Buffer
 * property from the `req` object and populates the decorated parameter with that value.
 * Also applies pipes to the bound rawBody parameter.
 *
 * For example:
 * ```typescript
 * async create(@RawBody(new ValidationPipe()) rawBody: Buffer)
 * ```
 *
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound body parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Raw body](https://docs.nestjs.com/faq/raw-body)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function RawBody(
  ...pipes: (
    | Type<PipeTransform<Buffer | undefined>>
    | PipeTransform<Buffer | undefined>
  )[]
): ParameterDecorator;

/**
 * Route handler parameter decorator. Extracts the `rawBody` Buffer
 * property from the `req` object and populates the decorated parameter with that value.
 * Also applies pipes to the bound rawBody parameter.
 *
 * For example:
 * ```typescript
 * async create(@RawBody(new ValidationPipe()) rawBody: Buffer)
 * ```
 *
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound body parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Raw body](https://docs.nestjs.com/faq/raw-body)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function RawBody(
  ...pipes: (
    | Type<PipeTransform<Buffer | undefined>>
    | PipeTransform<Buffer | undefined>
  )[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.RAW_BODY)(
    undefined,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the `params`
 * property from the `req` object and populates the decorated
 * parameter with the value of `params`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@Param() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@Param('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Param(): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `params`
 * property from the `req` object and populates the decorated
 * parameter with the value of `params`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@Param() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@Param('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Param(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `params`
 * property from the `req` object and populates the decorated
 * parameter with the value of `params`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@Param() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@Param('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Param(
  property: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `params`
 * property from the `req` object and populates the decorated
 * parameter with the value of `params`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@Param() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@Param('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 * @see [Working with pipes](https://docs.nestjs.com/custom-decorators#working-with-pipes)
 *
 * @publicApi
 */
export function Param(
  property?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRouteParamDecorator(RouteParamtypes.PARAM)(
    property,
    ...pipes,
  );
}

/**
 * Route handler parameter decorator. Extracts the `hosts`
 * property from the `req` object and populates the decorated
 * parameter with the value of `hosts`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@HostParam() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@HostParam('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function HostParam(): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `hosts`
 * property from the `req` object and populates the decorated
 * parameter with the value of `hosts`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@HostParam() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@HostParam('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function HostParam(property: string): ParameterDecorator;
/**
 * Route handler parameter decorator. Extracts the `hosts`
 * property from the `req` object and populates the decorated
 * parameter with the value of `params`. May also apply pipes to the bound
 * parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findOne(@HostParam() params: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * findOne(@HostParam('id') id: string)
 * ```
 * @param property name of single property to extract from the `req` object
 *
 * @see [Request object](https://docs.nestjs.com/controllers#request-object)
 *
 * @publicApi
 */
export function HostParam(
  property?: string | (Type<PipeTransform> | PipeTransform),
): ParameterDecorator {
  return createRouteParamDecorator(RouteParamtypes.HOST)(property);
}

export const Req = Request;
export const Res = Response;



================================================
FILE: packages/common/decorators/http/sse.decorator.ts
================================================
import { METHOD_METADATA, PATH_METADATA, SSE_METADATA } from '../../constants';
import { RequestMethod } from '../../enums/request-method.enum';

/**
 * Declares this route as a Server-Sent-Events endpoint
 *
 * @publicApi
 */
export function Sse(path?: string): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    path = path && path.length ? path : '/';

    Reflect.defineMetadata(PATH_METADATA, path, descriptor.value);
    Reflect.defineMetadata(
      METHOD_METADATA,
      RequestMethod.GET,
      descriptor.value,
    );
    Reflect.defineMetadata(SSE_METADATA, true, descriptor.value);
    return descriptor;
  };
}



================================================
FILE: packages/common/decorators/modules/global.decorator.ts
================================================
import { GLOBAL_MODULE_METADATA } from '../../constants';

/**
 * Decorator that makes a module global-scoped.
 *
 * Once imported into any module, a global-scoped module will be visible
 * in all modules. Thereafter, modules that wish to inject a service exported
 * from a global module do not need to import the provider module.
 *
 * @see [Global modules](https://docs.nestjs.com/modules#global-modules)
 *
 * @publicApi
 */
export function Global(): ClassDecorator {
  return (target: Function) => {
    Reflect.defineMetadata(GLOBAL_MODULE_METADATA, true, target);
  };
}



================================================
FILE: packages/common/decorators/modules/index.ts
================================================
export * from './global.decorator';
export * from './module.decorator';



================================================
FILE: packages/common/decorators/modules/module.decorator.ts
================================================
import { ModuleMetadata } from '../../interfaces/modules/module-metadata.interface';
import { validateModuleKeys } from '../../utils/validate-module-keys.util';

/**
 * Decorator that marks a class as a [module](https://docs.nestjs.com/modules).
 *
 * Modules are used by Nest to organize the application structure into scopes. Controllers
 * and Providers are scoped by the module they are declared in. Modules and their
 * classes (Controllers and Providers) form a graph that determines how Nest
 * performs [Dependency Injection (DI)](https://docs.nestjs.com/providers#dependency-injection).
 *
 * @param metadata module configuration metadata
 *
 * @see [Modules](https://docs.nestjs.com/modules)
 *
 * @publicApi
 */
export function Module(metadata: ModuleMetadata): ClassDecorator {
  const propsKeys = Object.keys(metadata);
  validateModuleKeys(propsKeys);

  return (target: Function) => {
    for (const property in metadata) {
      if (Object.hasOwnProperty.call(metadata, property)) {
        Reflect.defineMetadata(property, (metadata as any)[property], target);
      }
    }
  };
}



================================================
FILE: packages/common/enums/http-status.enum.ts
================================================
/**
 * @publicApi
 */
export enum HttpStatus {
  CONTINUE = 100,
  SWITCHING_PROTOCOLS = 101,
  PROCESSING = 102,
  EARLYHINTS = 103,
  OK = 200,
  CREATED = 201,
  ACCEPTED = 202,
  NON_AUTHORITATIVE_INFORMATION = 203,
  NO_CONTENT = 204,
  RESET_CONTENT = 205,
  PARTIAL_CONTENT = 206,
  MULTI_STATUS = 207,
  ALREADY_REPORTED = 208,
  CONTENT_DIFFERENT = 210,
  AMBIGUOUS = 300,
  MOVED_PERMANENTLY = 301,
  FOUND = 302,
  SEE_OTHER = 303,
  NOT_MODIFIED = 304,
  TEMPORARY_REDIRECT = 307,
  PERMANENT_REDIRECT = 308,
  BAD_REQUEST = 400,
  UNAUTHORIZED = 401,
  PAYMENT_REQUIRED = 402,
  FORBIDDEN = 403,
  NOT_FOUND = 404,
  METHOD_NOT_ALLOWED = 405,
  NOT_ACCEPTABLE = 406,
  PROXY_AUTHENTICATION_REQUIRED = 407,
  REQUEST_TIMEOUT = 408,
  CONFLICT = 409,
  GONE = 410,
  LENGTH_REQUIRED = 411,
  PRECONDITION_FAILED = 412,
  PAYLOAD_TOO_LARGE = 413,
  URI_TOO_LONG = 414,
  UNSUPPORTED_MEDIA_TYPE = 415,
  REQUESTED_RANGE_NOT_SATISFIABLE = 416,
  EXPECTATION_FAILED = 417,
  I_AM_A_TEAPOT = 418,
  MISDIRECTED = 421,
  UNPROCESSABLE_ENTITY = 422,
  LOCKED = 423,
  FAILED_DEPENDENCY = 424,
  PRECONDITION_REQUIRED = 428,
  TOO_MANY_REQUESTS = 429,
  UNRECOVERABLE_ERROR = 456,
  INTERNAL_SERVER_ERROR = 500,
  NOT_IMPLEMENTED = 501,
  BAD_GATEWAY = 502,
  SERVICE_UNAVAILABLE = 503,
  GATEWAY_TIMEOUT = 504,
  HTTP_VERSION_NOT_SUPPORTED = 505,
  INSUFFICIENT_STORAGE = 507,
  LOOP_DETECTED = 508,
}



================================================
FILE: packages/common/enums/index.ts
================================================
export * from './request-method.enum';
export * from './http-status.enum';
export * from './shutdown-signal.enum';
export * from './version-type.enum';



================================================
FILE: packages/common/enums/request-method.enum.ts
================================================
export enum RequestMethod {
  GET = 0,
  POST,
  PUT,
  DELETE,
  PATCH,
  ALL,
  OPTIONS,
  HEAD,
  SEARCH,
  PROPFIND,
  PROPPATCH,
  MKCOL,
  COPY,
  MOVE,
  LOCK,
  UNLOCK,
}



================================================
FILE: packages/common/enums/route-paramtypes.enum.ts
================================================
export enum RouteParamtypes {
  REQUEST = 0,
  RESPONSE = 1,
  NEXT = 2,
  BODY = 3,
  QUERY = 4,
  PARAM = 5,
  HEADERS = 6,
  SESSION = 7,
  FILE = 8,
  FILES = 9,
  HOST = 10,
  IP = 11,
  RAW_BODY = 12,
}



================================================
FILE: packages/common/enums/shutdown-signal.enum.ts
================================================
/**
 * System signals which shut down a process
 */
export enum ShutdownSignal {
  SIGHUP = 'SIGHUP',
  SIGINT = 'SIGINT',
  SIGQUIT = 'SIGQUIT',
  SIGILL = 'SIGILL',
  SIGTRAP = 'SIGTRAP',
  SIGABRT = 'SIGABRT',
  SIGBUS = 'SIGBUS',
  SIGFPE = 'SIGFPE',
  SIGSEGV = 'SIGSEGV',
  SIGUSR2 = 'SIGUSR2',
  SIGTERM = 'SIGTERM',
}



================================================
FILE: packages/common/enums/version-type.enum.ts
================================================
/**
 * @publicApi
 */
export enum VersioningType {
  URI,
  HEADER,
  MEDIA_TYPE,
  CUSTOM,
}



================================================
FILE: packages/common/exceptions/bad-gateway.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Bad Gateway* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class BadGatewayException extends HttpException {
  /**
   * Instantiate a `BadGatewayException` Exception.
   *
   * @example
   * `throw new BadGatewayException()`
   *
   * @usageNotes
   * The HTTP response status code will be 502.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 502.
   * - `message`: the string `'Bad Gateway'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Bad Gateway',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.BAD_GATEWAY,
      ),
      HttpStatus.BAD_GATEWAY,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/bad-request.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Bad Request* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class BadRequestException extends HttpException {
  /**
   * Instantiate a `BadRequestException` Exception.
   *
   * @example
   * `throw new BadRequestException()`
   *
   * @usageNotes
   * The HTTP response status code will be 400.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 400.
   * - `message`: the string `'Bad Request'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Bad Request',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.BAD_REQUEST,
      ),
      HttpStatus.BAD_REQUEST,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/conflict.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Conflict* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class ConflictException extends HttpException {
  /**
   * Instantiate a `ConflictException` Exception.
   *
   * @example
   * `throw new ConflictException()`
   *
   * @usageNotes
   * The HTTP response status code will be 409.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 409.
   * - `message`: the string `'Conflict'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Conflict',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.CONFLICT,
      ),
      HttpStatus.CONFLICT,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/forbidden.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Forbidden* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class ForbiddenException extends HttpException {
  /**
   * Instantiate a `ForbiddenException` Exception.
   *
   * @example
   * `throw new ForbiddenException()`
   *
   * @usageNotes
   * The HTTP response status code will be 403.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 403.
   * - `message`: the string `'Forbidden'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Forbidden',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.FORBIDDEN,
      ),
      HttpStatus.FORBIDDEN,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/gateway-timeout.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Gateway Timeout* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class GatewayTimeoutException extends HttpException {
  /**
   * Instantiate a `GatewayTimeoutException` Exception.
   *
   * @example
   * `throw new GatewayTimeoutException()`
   *
   * @usageNotes
   * The HTTP response status code will be 504.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 504.
   * - `message`: the string `'Gateway Timeout'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Gateway Timeout',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.GATEWAY_TIMEOUT,
      ),
      HttpStatus.GATEWAY_TIMEOUT,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/gone.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Gone* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class GoneException extends HttpException {
  /**
   * Instantiate a `GoneException` Exception.
   *
   * @example
   * `throw new GoneException()`
   *
   * @usageNotes
   * The HTTP response status code will be 410.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 410.
   * - `message`: the string `'Gone'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Gone',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(objectOrError, description!, HttpStatus.GONE),
      HttpStatus.GONE,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/http-version-not-supported.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Http Version Not Supported* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class HttpVersionNotSupportedException extends HttpException {
  /**
   * Instantiate a `HttpVersionNotSupportedException` Exception.
   *
   * @example
   * `throw new HttpVersionNotSupportedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 505.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 505.
   * - `message`: the string `'HTTP Version Not Supported'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions:
      | string
      | HttpExceptionOptions = 'HTTP Version Not Supported',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.HTTP_VERSION_NOT_SUPPORTED,
      ),
      HttpStatus.HTTP_VERSION_NOT_SUPPORTED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/http.exception.ts
================================================
import {
  HttpExceptionBody,
  HttpExceptionBodyMessage,
} from '../interfaces/http/http-exception-body.interface';
import { isNumber, isObject, isString } from '../utils/shared.utils';
import { IntrinsicException } from './intrinsic.exception';

export interface HttpExceptionOptions {
  /** original cause of the error */
  cause?: unknown;
  description?: string;
}

export interface DescriptionAndOptions {
  description?: string;
  httpExceptionOptions?: HttpExceptionOptions;
}

/**
 * Defines the base Nest HTTP exception, which is handled by the default
 * Exceptions Handler.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class HttpException extends IntrinsicException {
  /**
   * Exception cause. Indicates the specific original cause of the error.
   * It is used when catching and re-throwing an error with a more-specific or useful error message in order to still have access to the original error.
   */
  public cause: unknown;

  /**
   * Instantiate a plain HTTP Exception.
   *
   * @example
   * throw new HttpException('message', HttpStatus.BAD_REQUEST)
   * throw new HttpException('custom message', HttpStatus.BAD_REQUEST, {
   *  cause: new Error('Cause Error'),
   * })
   *
   *
   * @usageNotes
   * The constructor arguments define the response and the HTTP response status code.
   * - The `response` argument (required) defines the JSON response body. alternatively, it can also be
   *  an error object that is used to define an error [cause](https://nodejs.org/en/blog/release/v16.9.0/#error-cause).
   * - The `status` argument (required) defines the HTTP Status Code.
   * - The `options` argument (optional) defines additional error options. Currently, it supports the `cause` attribute,
   *  and can be used as an alternative way to specify the error cause: `const error = new HttpException('description', 400, { cause: new Error() });`
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: the Http Status Code.
   * - `message`: a short description of the HTTP error by default; override this
   * by supplying a string in the `response` parameter.
   *
   * To override the entire JSON response body, pass an object to the `createBody`
   * method. Nest will serialize the object and return it as the JSON response body.
   *
   * The `status` argument is required, and should be a valid HTTP status code.
   * Best practice is to use the `HttpStatus` enum imported from `nestjs/common`.
   *
   * @param response string, object describing the error condition or the error cause.
   * @param status HTTP response status code.
   * @param options An object used to add an error cause.
   */
  constructor(
    private readonly response: string | Record<string, any>,
    private readonly status: number,
    private readonly options?: HttpExceptionOptions,
  ) {
    super();
    this.initMessage();
    this.initName();
    this.initCause();
  }

  /**
   * Configures error chaining support
   *
   * @see https://nodejs.org/en/blog/release/v16.9.0/#error-cause
   * @see https://github.com/microsoft/TypeScript/issues/45167
   */
  public initCause(): void {
    if (this.options?.cause) {
      this.cause = this.options.cause;
      return;
    }
  }

  public initMessage() {
    if (isString(this.response)) {
      this.message = this.response;
    } else if (isObject(this.response) && isString(this.response.message)) {
      this.message = this.response.message;
    } else if (this.constructor) {
      this.message =
        this.constructor.name.match(/[A-Z][a-z]+|[0-9]+/g)?.join(' ') ??
        'Error';
    }
  }

  public initName(): void {
    this.name = this.constructor.name;
  }

  public getResponse(): string | object {
    return this.response;
  }

  public getStatus(): number {
    return this.status;
  }

  public static createBody(
    nil: null | '',
    message: HttpExceptionBodyMessage,
    statusCode: number,
  ): HttpExceptionBody;
  public static createBody(
    message: HttpExceptionBodyMessage,
    error: string,
    statusCode: number,
  ): HttpExceptionBody;
  public static createBody<Body extends Record<string, unknown>>(
    custom: Body,
  ): Body;
  public static createBody<Body extends Record<string, unknown>>(
    arg0: null | HttpExceptionBodyMessage | Body,
    arg1?: HttpExceptionBodyMessage | string,
    statusCode?: number,
  ): HttpExceptionBody | Body {
    if (!arg0) {
      return {
        message: arg1!,
        statusCode: statusCode!,
      };
    }

    if (isString(arg0) || Array.isArray(arg0) || isNumber(arg0)) {
      return {
        message: arg0,
        error: arg1 as string,
        statusCode: statusCode!,
      };
    }

    return arg0;
  }

  public static getDescriptionFrom(
    descriptionOrOptions: string | HttpExceptionOptions,
  ): string {
    return isString(descriptionOrOptions)
      ? descriptionOrOptions
      : (descriptionOrOptions?.description as string);
  }

  public static getHttpExceptionOptionsFrom(
    descriptionOrOptions: string | HttpExceptionOptions,
  ): HttpExceptionOptions {
    return isString(descriptionOrOptions) ? {} : descriptionOrOptions;
  }

  /**
   * Utility method used to extract the error description and httpExceptionOptions from the given argument.
   * This is used by inheriting classes to correctly parse both options.
   * @returns the error description and the httpExceptionOptions as an object.
   */
  public static extractDescriptionAndOptionsFrom(
    descriptionOrOptions: string | HttpExceptionOptions,
  ): DescriptionAndOptions {
    const description = isString(descriptionOrOptions)
      ? descriptionOrOptions
      : descriptionOrOptions?.description;

    const httpExceptionOptions = isString(descriptionOrOptions)
      ? {}
      : descriptionOrOptions;

    return {
      description,
      httpExceptionOptions,
    };
  }
}



================================================
FILE: packages/common/exceptions/im-a-teapot.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *ImATeapotException* type errors.
 *
 * Any attempt to brew coffee with a teapot should result in the error code
 * "418 I'm a teapot". The resulting entity body MAY be short and stout.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class ImATeapotException extends HttpException {
  /**
   * Instantiate an `ImATeapotException` Exception.
   *
   * @example
   * `throw new ImATeapotException()`
   *
   * @usageNotes
   * The HTTP response status code will be 418.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 418.
   * - `message`: the string `"I'm a Teapot"` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = `I'm a teapot`,
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.I_AM_A_TEAPOT,
      ),
      HttpStatus.I_AM_A_TEAPOT,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/index.ts
================================================
export * from './bad-gateway.exception';
export * from './bad-request.exception';
export * from './conflict.exception';
export * from './forbidden.exception';
export * from './gateway-timeout.exception';
export * from './gone.exception';
export * from './http-version-not-supported.exception';
export * from './http.exception';
export * from './im-a-teapot.exception';
export * from './internal-server-error.exception';
export * from './intrinsic.exception';
export * from './method-not-allowed.exception';
export * from './misdirected.exception';
export * from './not-acceptable.exception';
export * from './not-found.exception';
export * from './not-implemented.exception';
export * from './payload-too-large.exception';
export * from './precondition-failed.exception';
export * from './request-timeout.exception';
export * from './service-unavailable.exception';
export * from './unauthorized.exception';
export * from './unprocessable-entity.exception';
export * from './unsupported-media-type.exception';



================================================
FILE: packages/common/exceptions/internal-server-error.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Internal Server Error* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class InternalServerErrorException extends HttpException {
  /**
   * Instantiate an `InternalServerErrorException` Exception.
   *
   * @example
   * `throw new InternalServerErrorException()`
   *
   * @usageNotes
   * The HTTP response status code will be 500.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 500.
   * - `message`: the string `'Internal Server Error'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions:
      | string
      | HttpExceptionOptions = 'Internal Server Error',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.INTERNAL_SERVER_ERROR,
      ),
      HttpStatus.INTERNAL_SERVER_ERROR,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/intrinsic.exception.ts
================================================
/**
 * Exception that represents an intrinsic error in the application.
 * When thrown, the default exception filter will not log the error message.
 *
 * @publicApi
 */
export class IntrinsicException extends Error {}



================================================
FILE: packages/common/exceptions/method-not-allowed.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Method Not Allowed* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class MethodNotAllowedException extends HttpException {
  /**
   * Instantiate a `MethodNotAllowedException` Exception.
   *
   * @example
   * `throw new MethodNotAllowedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 405.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 405.
   * - `message`: the string `'Method Not Allowed'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Method Not Allowed',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.METHOD_NOT_ALLOWED,
      ),
      HttpStatus.METHOD_NOT_ALLOWED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/misdirected.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Misdirected* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class MisdirectedException extends HttpException {
  /**
   * Instantiate a `MisdirectedException` Exception.
   *
   * @example
   * `throw new MisdirectedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 421.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 421.
   * - `message`: the string `'Bad Gateway'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Misdirected',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.MISDIRECTED,
      ),
      HttpStatus.MISDIRECTED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/not-acceptable.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Not Acceptable* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class NotAcceptableException extends HttpException {
  /**
   * Instantiate a `NotAcceptableException` Exception.
   *
   * @example
   * `throw new NotAcceptableException()`
   *
   * @usageNotes
   * The HTTP response status code will be 406.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 406.
   * - `error`: the string `'Not Acceptable'` by default; override this by supplying
   * a string in the `error` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Not Acceptable',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.NOT_ACCEPTABLE,
      ),
      HttpStatus.NOT_ACCEPTABLE,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/not-found.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Not Found* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class NotFoundException extends HttpException {
  /**
   * Instantiate a `NotFoundException` Exception.
   *
   * @example
   * `throw new NotFoundException()`
   *
   * @usageNotes
   * The HTTP response status code will be 404.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 404.
   * - `message`: the string `'Not Found'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Not Found',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.NOT_FOUND,
      ),
      HttpStatus.NOT_FOUND,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/not-implemented.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Not Implemented* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class NotImplementedException extends HttpException {
  /**
   * Instantiate a `NotImplementedException` Exception.
   *
   * @example
   * `throw new NotImplementedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 501.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 501.
   * - `message`: the string `'Not Implemented'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   * @param error a short description of the HTTP error.
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Not Implemented',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.NOT_IMPLEMENTED,
      ),
      HttpStatus.NOT_IMPLEMENTED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/payload-too-large.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Payload Too Large* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class PayloadTooLargeException extends HttpException {
  /**
   * Instantiate a `PayloadTooLargeException` Exception.
   *
   * @example
   * `throw new PayloadTooLargeException()`
   *
   * @usageNotes
   * The HTTP response status code will be 413.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 413.
   * - `message`: the string `'Payload Too Large'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Payload Too Large',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.PAYLOAD_TOO_LARGE,
      ),
      HttpStatus.PAYLOAD_TOO_LARGE,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/precondition-failed.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Precondition Failed* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class PreconditionFailedException extends HttpException {
  /**
   * Instantiate a `PreconditionFailedException` Exception.
   *
   * @example
   * `throw new PreconditionFailedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 412.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 412.
   * - `message`: the string `'Precondition Failed'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Precondition Failed',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.PRECONDITION_FAILED,
      ),
      HttpStatus.PRECONDITION_FAILED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/request-timeout.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Request Timeout* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class RequestTimeoutException extends HttpException {
  /**
   * Instantiate a `RequestTimeoutException` Exception.
   *
   * @example
   * `throw new RequestTimeoutException()`
   *
   * @usageNotes
   * The HTTP response status code will be 408.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 408.
   * - `message`: the string `'Request Timeout'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Request Timeout',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.REQUEST_TIMEOUT,
      ),
      HttpStatus.REQUEST_TIMEOUT,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/service-unavailable.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Service Unavailable* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class ServiceUnavailableException extends HttpException {
  /**
   * Instantiate a `ServiceUnavailableException` Exception.
   *
   * @example
   * `throw new ServiceUnavailableException()`
   *
   * @usageNotes
   * The HTTP response status code will be 503.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 503.
   * - `message`: the string `'Service Unavailable'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Service Unavailable',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.SERVICE_UNAVAILABLE,
      ),
      HttpStatus.SERVICE_UNAVAILABLE,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/unauthorized.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Unauthorized* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class UnauthorizedException extends HttpException {
  /**
   * Instantiate an `UnauthorizedException` Exception.
   *
   * @example
   * `throw new UnauthorizedException()`
   *
   * @usageNotes
   * The HTTP response status code will be 401.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 401.
   * - `message`: the string `'Unauthorized'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions: string | HttpExceptionOptions = 'Unauthorized',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.UNAUTHORIZED,
      ),
      HttpStatus.UNAUTHORIZED,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/unprocessable-entity.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Unprocessable Entity* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class UnprocessableEntityException extends HttpException {
  /**
   * Instantiate an `UnprocessableEntityException` Exception.
   *
   * @example
   * `throw new UnprocessableEntityException()`
   *
   * @usageNotes
   * The HTTP response status code will be 422.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 422.
   * - `message`: the string `'Unprocessable Entity'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions:
      | string
      | HttpExceptionOptions = 'Unprocessable Entity',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.UNPROCESSABLE_ENTITY,
      ),
      HttpStatus.UNPROCESSABLE_ENTITY,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/exceptions/unsupported-media-type.exception.ts
================================================
import { HttpStatus } from '../enums/http-status.enum';
import { HttpException, HttpExceptionOptions } from './http.exception';

/**
 * Defines an HTTP exception for *Unsupported Media Type* type errors.
 *
 * @see [Built-in HTTP exceptions](https://docs.nestjs.com/exception-filters#built-in-http-exceptions)
 *
 * @publicApi
 */
export class UnsupportedMediaTypeException extends HttpException {
  /**
   * Instantiate an `UnsupportedMediaTypeException` Exception.
   *
   * @example
   * `throw new UnsupportedMediaTypeException()`
   *
   * @usageNotes
   * The HTTP response status code will be 415.
   * - The `objectOrError` argument defines the JSON response body or the message string.
   * - The `descriptionOrOptions` argument contains either a short description of the HTTP error or an options object used to provide an underlying error cause.
   *
   * By default, the JSON response body contains two properties:
   * - `statusCode`: this will be the value 415.
   * - `message`: the string `'Unsupported Media Type'` by default; override this by supplying
   * a string in the `objectOrError` parameter.
   *
   * If the parameter `objectOrError` is a string, the response body will contain an
   * additional property, `error`, with a short description of the HTTP error. To override the
   * entire JSON response body, pass an object instead. Nest will serialize the object
   * and return it as the JSON response body.
   *
   * @param objectOrError string or object describing the error condition.
   * @param descriptionOrOptions either a short description of the HTTP error or an options object used to provide an underlying error cause
   */
  constructor(
    objectOrError?: any,
    descriptionOrOptions:
      | string
      | HttpExceptionOptions = 'Unsupported Media Type',
  ) {
    const { description, httpExceptionOptions } =
      HttpException.extractDescriptionAndOptionsFrom(descriptionOrOptions);

    super(
      HttpException.createBody(
        objectOrError,
        description!,
        HttpStatus.UNSUPPORTED_MEDIA_TYPE,
      ),
      HttpStatus.UNSUPPORTED_MEDIA_TYPE,
      httpExceptionOptions,
    );
  }
}



================================================
FILE: packages/common/file-stream/index.ts
================================================
export * from './streamable-file';



================================================
FILE: packages/common/file-stream/streamable-file.ts
================================================
import { Readable } from 'stream';
import { types } from 'util';
import { HttpStatus } from '../enums';
import { Logger } from '../services';
import { isFunction } from '../utils/shared.utils';
import { StreamableFileOptions, StreamableHandlerResponse } from './interfaces';

/**
 * @see [Streaming files](https://docs.nestjs.com/techniques/streaming-files)
 *
 * @publicApi
 */
export class StreamableFile {
  private readonly stream: Readable;
  protected logger = new Logger('StreamableFile');

  protected handleError: (
    err: Error,
    response: StreamableHandlerResponse,
  ) => void = (err: Error, res) => {
    if (res.destroyed) {
      return;
    }
    if (res.headersSent) {
      res.end();
      return;
    }

    res.statusCode = HttpStatus.BAD_REQUEST;
    res.send(err.message);
  };

  protected logError: (err: Error) => void = (err: Error) => {
    this.logger.error(err);
  };

  constructor(buffer: Uint8Array, options?: StreamableFileOptions);
  constructor(readable: Readable, options?: StreamableFileOptions);
  constructor(
    bufferOrReadStream: Uint8Array | Readable,
    readonly options: StreamableFileOptions = {},
  ) {
    if (types.isUint8Array(bufferOrReadStream)) {
      this.stream = new Readable();
      this.stream.push(bufferOrReadStream);
      this.stream.push(null);
      this.options.length ??= bufferOrReadStream.length;
    } else if (bufferOrReadStream.pipe && isFunction(bufferOrReadStream.pipe)) {
      this.stream = bufferOrReadStream;
    }
  }

  getStream(): Readable {
    return this.stream;
  }

  getHeaders() {
    const {
      type = 'application/octet-stream',
      disposition = undefined,
      length = undefined,
    } = this.options;
    return {
      type,
      disposition,
      length,
    };
  }

  get errorHandler(): (
    err: Error,
    response: StreamableHandlerResponse,
  ) => void {
    return this.handleError;
  }

  setErrorHandler(
    handler: (err: Error, response: StreamableHandlerResponse) => void,
  ) {
    this.handleError = handler;
    return this;
  }

  get errorLogger() {
    return this.logError;
  }

  setErrorLogger(handler: (err: Error) => void) {
    this.logError = handler;
    return this;
  }
}



================================================
FILE: packages/common/file-stream/interfaces/index.ts
================================================
export * from './streamable-options.interface';
export * from './streamable-handler-response.interface';



================================================
FILE: packages/common/file-stream/interfaces/streamable-handler-response.interface.ts
================================================
export interface StreamableHandlerResponse {
  /** `true` if the connection is destroyed, `false` otherwise. */
  destroyed: boolean;
  /** `true` if headers were sent, `false` otherwise. */
  headersSent: boolean;
  /** The status code that will be sent to the client when the headers get flushed. */
  statusCode: number;
  /** Sends the HTTP response. */
  send: (body: string) => void;
  /** Signals to the server that all of the response headers and body have been sent. */
  end: () => void;
}



================================================
FILE: packages/common/file-stream/interfaces/streamable-options.interface.ts
================================================
/**
 * Options for `StreamableFile`
 *
 * @see [Streaming files](https://docs.nestjs.com/techniques/streaming-files)
 *
 * @publicApi
 */
export interface StreamableFileOptions {
  /**
   * The value that will be used for the `Content-Type` response header.
   * @default `"application/octet-stream"`
   */
  type?: string;
  /**
   * The value that will be used for the `Content-Disposition` response header.
   */
  disposition?: string;
  /**
   * The value that will be used for the `Content-Length` response header.
   */
  length?: number;
}



================================================
FILE: packages/common/interfaces/abstract.interface.ts
================================================
export interface Abstract<T> extends Function {
  prototype: T;
}



================================================
FILE: packages/common/interfaces/global-prefix-options.interface.ts
================================================
import { RouteInfo } from './middleware';

/**
 * @publicApi
 */
export interface GlobalPrefixOptions<T = string | RouteInfo> {
  exclude?: T[];
}



================================================
FILE: packages/common/interfaces/index.ts
================================================
export * from './abstract.interface';
export * from './controllers/controller-metadata.interface';
export * from './controllers/controller.interface';
export * from './exceptions/exception-filter.interface';
export * from './exceptions/rpc-exception-filter.interface';
export * from './exceptions/ws-exception-filter.interface';
export * from './external/validation-error.interface';
export * from './features/arguments-host.interface';
export * from './features/can-activate.interface';
export * from './features/custom-route-param-factory.interface';
export * from './features/execution-context.interface';
export * from './features/nest-interceptor.interface';
export * from './features/paramtype.interface';
export * from './features/pipe-transform.interface';
export * from './global-prefix-options.interface';
export * from './hooks';
export * from './http';
export * from './injectable.interface';
export * from './microservices/nest-hybrid-application-options.interface';
export * from './middleware';
export * from './modules';
export * from './nest-application-context.interface';
export * from './nest-application-options.interface';
export * from './nest-application.interface';
export * from './nest-microservice.interface';
export * from './scope-options.interface';
export * from './type.interface';
export * from './version-options.interface';
export * from './websockets/web-socket-adapter.interface';



================================================
FILE: packages/common/interfaces/injectable.interface.ts
================================================
export type Injectable = unknown;



================================================
FILE: packages/common/interfaces/nest-application-context-options.interface.ts
================================================
import { LoggerService, LogLevel } from '../services/logger.service';

/**
 * @publicApi
 */
export class NestApplicationContextOptions {
  /**
   * Specifies the logger to use.  Pass `false` to turn off logging.
   */
  logger?: LoggerService | LogLevel[] | false;

  /**
   * Whether to abort the process on Error. By default, the process is exited.
   * Pass `false` to override the default behavior. If `false` is passed, Nest will not exit
   * the application and instead will rethrow the exception.
   * @default true
   */
  abortOnError?: boolean | undefined;

  /**
   * If enabled, logs will be buffered until the "Logger#flush" method is called.
   * @default false
   */
  bufferLogs?: boolean;

  /**
   * If enabled, logs will be automatically flushed and buffer detached when
   * application initialization process either completes or fails.
   * @default true
   */
  autoFlushLogs?: boolean;

  /**
   * Whether to run application in the preview mode.
   * In the preview mode, providers/controllers are not instantiated & resolved.
   *
   * @default false
   */
  preview?: boolean;

  /**
   * Whether to generate a serialized graph snapshot.
   *
   * @default false
   */
  snapshot?: boolean;

  /**
   * Determines what algorithm use to generate module ids.
   * When set to `deep-hash`, the module id is generated based on the serialized module definition.
   * When set to `reference`, each module obtains a unique id based on its reference.
   *
   * @default 'reference'
   */
  moduleIdGeneratorAlgorithm?: 'deep-hash' | 'reference';
}



================================================
FILE: packages/common/interfaces/nest-application-context.interface.ts
================================================
import { ShutdownSignal } from '../enums/shutdown-signal.enum';
import { LoggerService, LogLevel } from '../services/logger.service';
import { DynamicModule } from './modules';
import { NestApplicationContextOptions } from './nest-application-context-options.interface';
import { Type } from './type.interface';

export type SelectOptions = Pick<NestApplicationContextOptions, 'abortOnError'>;

export interface GetOrResolveOptions {
  /**
   * If enabled, lookup will only be performed in the host module.
   * @default false
   */
  strict?: boolean;
  /**
   * If enabled, instead of returning a first instance registered under a given token,
   * a list of instances will be returned.
   * @default false
   */
  each?: boolean;
}

/**
 * Interface defining NestApplicationContext.
 *
 * @publicApi
 */
export interface INestApplicationContext {
  /**
   * Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.
   * @returns {INestApplicationContext}
   */
  select<T>(
    module: Type<T> | DynamicModule,
    options?: SelectOptions,
  ): INestApplicationContext;

  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): TResult;
  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: { strict?: boolean; each?: undefined | false },
  ): TResult;
  /**
   * Retrieves a list of instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: { strict?: boolean; each: true },
  ): Array<TResult>;
  /**
   * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {TResult | Array<TResult>}
   */
  get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options?: GetOrResolveOptions,
  ): TResult | Array<TResult>;

  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: { strict?: boolean; each?: undefined | false },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: { strict?: boolean; each: true },
  ): Promise<Array<TResult>>;
  /**
   * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {Promise<TResult | Array<TResult>>}
   */
  resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: GetOrResolveOptions,
  ): Promise<TResult | Array<TResult>>;

  /**
   * Registers the request/context object for a given context ID (DI container sub-tree).
   * @returns {void}
   */
  registerRequestByContextId<T = any>(
    request: T,
    contextId: { id: number },
  ): void;

  /**
   * Terminates the application
   * @returns {Promise<void>}
   */
  close(): Promise<void>;

  /**
   * Sets custom logger service.
   * Flushes buffered logs if auto flush is on.
   * @returns {void}
   */
  useLogger(logger: LoggerService | LogLevel[] | false): void;

  /**
   * Prints buffered logs and detaches buffer.
   * @returns {void}
   */
  flushLogs(): void;

  /**
   * Enables the usage of shutdown hooks. Will call the
   * `onApplicationShutdown` function of a provider if the
   * process receives a shutdown signal.
   *
   * @returns {this} The Nest application context instance
   */
  enableShutdownHooks(signals?: ShutdownSignal[] | string[]): this;

  /**
   * Initializes the Nest application.
   * Calls the Nest lifecycle events.
   * It isn't mandatory to call this method directly.
   *
   * @returns {Promise<this>} The NestApplicationContext instance as Promise
   */
  init(): Promise<this>;
}



================================================
FILE: packages/common/interfaces/nest-application-options.interface.ts
================================================
import {
  CorsOptions,
  CorsOptionsDelegate,
} from './external/cors-options.interface';
import { HttpsOptions } from './external/https-options.interface';
import { NestApplicationContextOptions } from './nest-application-context-options.interface';

/**
 * @publicApi
 */
export interface NestApplicationOptions extends NestApplicationContextOptions {
  /**
   * CORS options from [CORS package](https://github.com/expressjs/cors#configuration-options)
   */
  cors?: boolean | CorsOptions | CorsOptionsDelegate<any>;
  /**
   * Whether to use underlying platform body parser.
   */
  bodyParser?: boolean;
  /**
   * Set of configurable HTTPS options
   */
  httpsOptions?: HttpsOptions;
  /**
   * Whether to register the raw request body on the request. Use `req.rawBody`.
   */
  rawBody?: boolean;
  /**
   * Force close open HTTP connections. Useful if restarting your application hangs due to
   * keep-alive connections in the HTTP adapter.
   */
  forceCloseConnections?: boolean;
}



================================================
FILE: packages/common/interfaces/nest-application.interface.ts
================================================
import { CanActivate } from './features/can-activate.interface';
import { NestInterceptor } from './features/nest-interceptor.interface';
import { GlobalPrefixOptions } from './global-prefix-options.interface';
import { HttpServer } from './http/http-server.interface';
import {
  ExceptionFilter,
  INestMicroservice,
  NestHybridApplicationOptions,
  PipeTransform,
} from './index';
import { INestApplicationContext } from './nest-application-context.interface';
import { VersioningOptions } from './version-options.interface';
import { WebSocketAdapter } from './websockets/web-socket-adapter.interface';

/**
 * Interface defining the core NestApplication object.
 *
 * @publicApi
 */
export interface INestApplication<TServer = any>
  extends INestApplicationContext {
  /**
   * A wrapper function around HTTP adapter method: `adapter.use()`.
   * Example `app.use(cors())`
   *
   * @returns {this}
   */
  use(...args: any[]): this;

  /**
   * Enables CORS (Cross-Origin Resource Sharing)
   *
   * @returns {void}
   */
  enableCors(options?: any): void;

  /**
   * Enables Versioning for the application.
   * By default, URI-based versioning is used.
   *
   * @param {VersioningOptions} options
   * @returns {this}
   */
  enableVersioning(options?: VersioningOptions): this;

  /**
   * Starts the application.
   *
   * @param {number|string} port
   * @param {string} [hostname]
   * @param {Function} [callback] Optional callback
   * @returns {Promise} A Promise that, when resolved, is a reference to the underlying HttpServer.
   */
  listen(port: number | string, callback?: () => void): Promise<any>;
  listen(
    port: number | string,
    hostname: string,
    callback?: () => void,
  ): Promise<any>;

  /**
   * Returns the url the application is listening at, based on OS and IP version. Returns as an IP value either in IPv6 or IPv4
   *
   * @returns {Promise<string>} The IP where the server is listening
   */
  getUrl(): Promise<string>;

  /**
   * Registers a prefix for every HTTP route path.
   *
   * @param {string} prefix The prefix for every HTTP route path (for example `/v1/api`)
   * @param {GlobalPrefixOptions} options Global prefix options object
   * @returns {this}
   */
  setGlobalPrefix(prefix: string, options?: GlobalPrefixOptions): this;

  /**
   * Register Ws Adapter which will be used inside Gateways.
   * Use when you want to override default `socket.io` library.
   *
   * @param {WebSocketAdapter} adapter
   * @returns {this}
   */
  useWebSocketAdapter(adapter: WebSocketAdapter): this;

  /**
   * Connects microservice to the NestApplication instance. Transforms application
   * to a hybrid instance.
   *
   * @template {object} T
   * @param {T} options Microservice options object
   * @param {NestHybridApplicationOptions} hybridOptions Hybrid options object
   * @returns {INestMicroservice}
   */
  connectMicroservice<T extends object = any>(
    options: T,
    hybridOptions?: NestHybridApplicationOptions,
  ): INestMicroservice;

  /**
   * Returns array of the microservices connected to the NestApplication.
   *
   * @returns {INestMicroservice[]}
   */
  getMicroservices(): INestMicroservice[];

  /**
   * Returns the underlying native HTTP server.
   *
   * @returns {TServer}
   */
  getHttpServer(): TServer;

  /**
   * Returns the underlying HTTP adapter.
   *
   * @returns {HttpServer}
   */
  getHttpAdapter(): HttpServer;

  /**
   * Starts all connected microservices asynchronously.
   *
   * @returns {Promise}
   */
  startAllMicroservices(): Promise<this>;

  /**
   * Registers exception filters as global filters (will be used within
   * every HTTP route handler)
   *
   * @param {...ExceptionFilter} filters
   */
  useGlobalFilters(...filters: ExceptionFilter[]): this;

  /**
   * Registers pipes as global pipes (will be used within every HTTP route handler)
   *
   * @param {...PipeTransform} pipes
   */
  useGlobalPipes(...pipes: PipeTransform<any>[]): this;

  /**
   * Registers interceptors as global interceptors (will be used within
   * every HTTP route handler)
   *
   * @param {...NestInterceptor} interceptors
   */
  useGlobalInterceptors(...interceptors: NestInterceptor[]): this;

  /**
   * Registers guards as global guards (will be used within every HTTP route handler)
   *
   * @param {...CanActivate} guards
   */
  useGlobalGuards(...guards: CanActivate[]): this;

  /**
   * Terminates the application (including NestApplication, Gateways, and each connected
   * microservice)
   *
   * @returns {Promise<void>}
   */
  close(): Promise<void>;
}



================================================
FILE: packages/common/interfaces/nest-microservice.interface.ts
================================================
import { Observable } from 'rxjs';
import { ExceptionFilter } from './exceptions/exception-filter.interface';
import { CanActivate } from './features/can-activate.interface';
import { NestInterceptor } from './features/nest-interceptor.interface';
import { PipeTransform } from './features/pipe-transform.interface';
import { INestApplicationContext } from './nest-application-context.interface';
import { WebSocketAdapter } from './websockets/web-socket-adapter.interface';

/**
 * Interface describing Microservice Context.
 *
 * @publicApi
 */
export interface INestMicroservice extends INestApplicationContext {
  /**
   * Starts the microservice.
   *
   * @returns {void}
   */
  listen(): Promise<any>;

  /**
   * Registers a web socket adapter that will be used for Gateways.
   * Use to override the default `socket.io` library.
   *
   * @param {WebSocketAdapter} adapter
   * @returns {this}
   */
  useWebSocketAdapter(adapter: WebSocketAdapter): this;

  /**
   * Registers global exception filters (will be used for every pattern handler).
   *
   * @param {...ExceptionFilter} filters
   */
  useGlobalFilters(...filters: ExceptionFilter[]): this;

  /**
   * Registers global pipes (will be used for every pattern handler).
   *
   * @param {...PipeTransform} pipes
   */
  useGlobalPipes(...pipes: PipeTransform<any>[]): this;

  /**
   * Registers global interceptors (will be used for every pattern handler).
   *
   * @param {...NestInterceptor} interceptors
   */
  useGlobalInterceptors(...interceptors: NestInterceptor[]): this;

  /**
   * Registers global guards (will be used for every pattern handler).
   *
   * @param {...CanActivate} guards
   */
  useGlobalGuards(...guards: CanActivate[]): this;

  /**
   * Terminates the application.
   *
   * @returns {Promise<void>}
   */
  close(): Promise<void>;

  /**
   * Returns an observable that emits status changes.
   *
   * @returns {Observable<string>}
   */
  status: Observable<string>;

  /**
   * Registers an event listener for the given event.
   * @param event Event name
   * @param callback Callback to be executed when the event is emitted
   */
  on<
    EventsMap extends Record<string, Function> = Record<string, Function>,
    EventKey extends keyof EventsMap = keyof EventsMap,
    EventCallback extends EventsMap[EventKey] = EventsMap[EventKey],
  >(
    event: EventKey,
    callback: EventCallback,
  ): void;

  /**
   * Returns an instance of the underlying server/broker instance,
   * or a group of servers if there are more than one.
   */
  unwrap<T>(): T;
}



================================================
FILE: packages/common/interfaces/scope-options.interface.ts
================================================
/**
 * @publicApi
 */
export enum Scope {
  /**
   * The provider can be shared across multiple classes. The provider lifetime
   * is strictly tied to the application lifecycle. Once the application has
   * bootstrapped, all providers have been instantiated.
   */
  DEFAULT,
  /**
   * A new private instance of the provider is instantiated for every use
   */
  TRANSIENT,
  /**
   * A new instance is instantiated for each request processing pipeline
   */
  REQUEST,
}

/**
 * @publicApi
 *
 * @see [Injection Scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 */
export interface ScopeOptions {
  /**
   * Specifies the lifetime of an injected Provider or Controller.
   */
  scope?: Scope;
  /**
   * Flags provider as durable. This flag can be used in combination with custom context id
   * factory strategy to construct lazy DI subtrees.
   *
   * This flag can be used only in conjunction with scope = Scope.REQUEST.
   */
  durable?: boolean;
}



================================================
FILE: packages/common/interfaces/type.interface.ts
================================================
export interface Type<T = any> extends Function {
  new (...args: any[]): T;
}



================================================
FILE: packages/common/interfaces/version-options.interface.ts
================================================
import { VersioningType } from '../enums/version-type.enum';

/**
 * Indicates that this will work for any version passed in the request, or no version.
 *
 * @publicApi
 */
export const VERSION_NEUTRAL = Symbol('VERSION_NEUTRAL');

/**
 * @publicApi
 */
export type VersionValue =
  | string
  | typeof VERSION_NEUTRAL
  | Array<string | typeof VERSION_NEUTRAL>;

/**
 * @publicApi
 */
export interface VersionOptions {
  /**
   * Specifies an optional API Version. When configured, methods
   * within the controller will only be routed if the request version
   * matches the specified value.
   *
   * Supported only by HTTP-based applications (does not apply to non-HTTP microservices).
   *
   * @see [Versioning](https://docs.nestjs.com/techniques/versioning)
   */
  version?: VersionValue;
}

/**
 * @publicApi
 */
export interface HeaderVersioningOptions {
  type: VersioningType.HEADER;
  /**
   * The name of the Request Header that contains the version.
   */
  header: string;
}

/**
 * @publicApi
 */
export interface UriVersioningOptions {
  type: VersioningType.URI;
  /**
   * Optional prefix that will prepend the version within the URI.
   *
   * Defaults to `v`.
   *
   * Ex. Assuming a version of `1`, for `/api/v1/route`, `v` is the prefix.
   */
  prefix?: string | false;
}

/**
 * @publicApi
 */
export interface MediaTypeVersioningOptions {
  type: VersioningType.MEDIA_TYPE;
  /**
   * The key within the Media Type Header to determine the version from.
   *
   * Ex. For `application/json;v=1`, the key is `v=`.
   */
  key: string;
}

/**
 * @publicApi
 */
export interface CustomVersioningOptions {
  type: VersioningType.CUSTOM;

  /**
   * A function that accepts a request object (specific to the underlying platform, ie Express or Fastify)
   * and returns a single version value or an ordered array of versions, in order from HIGHEST to LOWEST.
   *
   * Ex. Returned version array = ['3.1', '3.0', '2.5', '2', '1.9']
   *
   * Use type assertion or narrowing to identify the specific request type.
   */
  extractor: (request: unknown) => string | string[];
}

/**
 * @publicApi
 */
interface VersioningCommonOptions {
  /**
   * The default version to be used as a fallback when you did not provide some
   * version to `@Controller()` nor `@Version()`.
   */
  defaultVersion?: VersionOptions['version'];
}

/**
 * @publicApi
 */
export type VersioningOptions = VersioningCommonOptions &
  (
    | HeaderVersioningOptions
    | UriVersioningOptions
    | MediaTypeVersioningOptions
    | CustomVersioningOptions
  );



================================================
FILE: packages/common/interfaces/controllers/controller-metadata.interface.ts
================================================
export interface ControllerMetadata {
  path?: string;
}



================================================
FILE: packages/common/interfaces/controllers/controller.interface.ts
================================================
export type Controller = object;



================================================
FILE: packages/common/interfaces/controllers/index.ts
================================================
export * from './controller-metadata.interface';
export * from './controller.interface';



================================================
FILE: packages/common/interfaces/exceptions/exception-filter-metadata.interface.ts
================================================
import { ExceptionFilter } from './exception-filter.interface';
import { Type } from '../type.interface';

export interface ExceptionFilterMetadata {
  func: ExceptionFilter['catch'];
  exceptionMetatypes: Type<any>[];
}



================================================
FILE: packages/common/interfaces/exceptions/exception-filter.interface.ts
================================================
import { ArgumentsHost } from '../features/arguments-host.interface';

/**
 * Interface describing implementation of an exception filter.
 *
 * @see [Exception Filters](https://docs.nestjs.com/exception-filters)
 *
 * @publicApi
 */
export interface ExceptionFilter<T = any> {
  /**
   * Method to implement a custom exception filter.
   *
   * @param exception the class of the exception being handled
   * @param host used to access an array of arguments for
   * the in-flight request
   */
  catch(exception: T, host: ArgumentsHost): any;
}



================================================
FILE: packages/common/interfaces/exceptions/index.ts
================================================
export * from './exception-filter-metadata.interface';
export * from './exception-filter.interface';
export * from './rpc-exception-filter-metadata.interface';
export * from './rpc-exception-filter.interface';
export * from './ws-exception-filter.interface';



================================================
FILE: packages/common/interfaces/exceptions/rpc-exception-filter-metadata.interface.ts
================================================
import { RpcExceptionFilter } from './rpc-exception-filter.interface';
import { Type } from '../type.interface';

export interface RpcExceptionFilterMetadata {
  func: RpcExceptionFilter['catch'];
  exceptionMetatypes: Type<any>[];
}



================================================
FILE: packages/common/interfaces/exceptions/rpc-exception-filter.interface.ts
================================================
import { Observable } from 'rxjs';
import { ArgumentsHost } from '../features/arguments-host.interface';

/**
 * Interface describing implementation of an RPC exception filter.
 *
 * @see [Exception Filters](https://docs.nestjs.com/microservices/exception-filters)
 *
 * @publicApi
 */
export interface RpcExceptionFilter<T = any, R = any> {
  /**
   * Method to implement a custom (microservice) exception filter.
   *
   * @param exception the type (class) of the exception being handled
   * @param host used to access an array of arguments for
   * the in-flight message
   */
  catch(exception: T, host: ArgumentsHost): Observable<R>;
}



================================================
FILE: packages/common/interfaces/exceptions/ws-exception-filter.interface.ts
================================================
import { ArgumentsHost } from '../features/arguments-host.interface';

/**
 * Interface describing implementation of a Web Sockets exception filter.
 *
 * @see [Exception Filters](https://docs.nestjs.com/websockets/exception-filters)
 *
 * @publicApi
 */

export interface WsExceptionFilter<T = any> {
  /**
   * Method to implement a custom (web sockets) exception filter.
   *
   * @param exception the type (class) of the exception being handled
   * @param host used to access an array of arguments for
   * the in-flight message  catch(exception: T, host: ArgumentsHost): any;
   */
  catch(exception: T, host: ArgumentsHost): any;
}



================================================
FILE: packages/common/interfaces/external/class-transform-options.interface.ts
================================================
/**
 * Options to be passed during transformation.
 *
 * @see https://github.com/typestack/class-transformer
 *
 * @publicApi
 */
export interface ClassTransformOptions {
  /**
   * Exclusion strategy. By default exposeAll is used, which means that it will expose all properties that
   * are transformed by default.
   */
  strategy?: 'excludeAll' | 'exposeAll';
  /**
   * Only properties with given groups will be transformed.
   */
  groups?: string[];
  /**
   * Only properties with "since" > version < "until" will be transformed.
   */
  version?: number;
  /**
   * Excludes properties with the given prefixes. For example, if you mark your private properties with "_" and "__"
   * you can set this option's value to ["_", "__"] and all private properties will be skipped.
   * This works only for "exposeAll" strategy.
   */
  excludePrefixes?: string[];
  /**
   * If set to true then class transformer will ignore all @Expose and @Exclude decorators and what's inside them.
   * This option is useful if you want to "clone" your object but not apply decorators affects.
   */
  ignoreDecorators?: boolean;
  /**
   * Target maps allows to set a Types of the transforming object without using @Type decorator.
   * This is useful when you are transforming external classes, or if you already have type metadata for
   * objects and you don't want to set it up again.
   */
  targetMaps?: any[];
  /**
   * If set to true then class transformer will perform a circular check. (Circular check is turned off by default)
   * This option is useful when you know for sure that your types might have a circular dependency.
   */
  enableCircularCheck?: boolean;
  /**
   * If set to true class-transformer will attempt conversion based on TS reflected type
   */
  enableImplicitConversion?: boolean;
  /**
   * If set to true class-transformer will exclude properties which are not part of the original class
   * and exposing all class properties (with undefined, if nothing else is given)
   */
  excludeExtraneousValues?: boolean;
  /**
   * If set to true then class transformer will take default values for unprovided fields.
   * This is useful when you convert a plain object to a class and have an optional field with a default value.
   */
  exposeDefaultValues?: boolean;
  /**
   * When set to true, fields with `undefined` as value will be included in class to plain transformation. Otherwise
   * those fields will be omitted from the result.
   *
   * DEFAULT: `true`
   */
  exposeUnsetFields?: boolean;
}



================================================
FILE: packages/common/interfaces/external/cors-options.interface.ts
================================================
type StaticOrigin = boolean | string | RegExp | (string | RegExp)[];

/**
 * Set origin to a function implementing some custom logic. The function takes the
 * request origin as the first parameter and a callback (which expects the signature
 * err [object], allow [bool]) as the second.
 *
 * @see https://github.com/expressjs/cors
 *
 * @publicApi
 */
export type CustomOrigin = (
  requestOrigin: string,
  callback: (err: Error | null, origin?: StaticOrigin) => void,
) => void;

/**
 * Interface describing CORS options that can be set.
 *
 * @see https://github.com/expressjs/cors
 * @publicApi
 */
export interface CorsOptions {
  /**
   * Configures the `Access-Control-Allow-Origins` CORS header.  See [here for more detail.](https://github.com/expressjs/cors#configuration-options)
   */
  origin?: StaticOrigin | CustomOrigin;
  /**
   * Configures the Access-Control-Allow-Methods CORS header.
   */
  methods?: string | string[];
  /**
   * Configures the Access-Control-Allow-Headers CORS header.
   */
  allowedHeaders?: string | string[];
  /**
   * Configures the Access-Control-Expose-Headers CORS header.
   */
  exposedHeaders?: string | string[];
  /**
   * Configures the Access-Control-Allow-Credentials CORS header.
   */
  credentials?: boolean;
  /**
   * Configures the Access-Control-Max-Age CORS header.
   */
  maxAge?: number;
  /**
   * Whether to pass the CORS preflight response to the next handler.
   */
  preflightContinue?: boolean;
  /**
   * Provides a status code to use for successful OPTIONS requests.
   */
  optionsSuccessStatus?: number;
}

export interface CorsOptionsCallback {
  (error: Error | null, options: CorsOptions): void;
}
export interface CorsOptionsDelegate<T> {
  (req: T, cb: CorsOptionsCallback): void;
}



================================================
FILE: packages/common/interfaces/external/https-options.interface.ts
================================================
/**
 * Interface describing Https Options that can be set.
 *
 * @see https://nodejs.org/api/tls.html
 *
 * @publicApi
 */
export interface HttpsOptions {
  /**
   * PFX or PKCS12 encoded private key and certificate chain. pfx is an alternative
   * to providing key and cert individually. PFX is usually encrypted, if it is,
   * passphrase will be used to decrypt it. Multiple PFX can be provided either
   * as an array of unencrypted PFX buffers, or an array of objects in the form
   * {buf: <string|buffer>[, passphrase: <string>]}. The object form can only
   * occur in an array. object.passphrase is optional. Encrypted PFX will be decrypted
   * with object.passphrase if provided, or options.passphrase if it is not.
   */
  pfx?: any;
  /**
   * Private keys in PEM format. PEM allows the option of private keys being encrypted.
   * Encrypted keys will be decrypted with options.passphrase. Multiple keys using
   * different algorithms can be provided either as an array of unencrypted key
   * strings or buffers, or an array of objects in the form {pem: <string|buffer>[, passphrase: <string>]}.
   * The object form can only occur in an array. object.passphrase is optional.
   * Encrypted keys will be decrypted with object.passphrase if provided, or options.passphrase
   * if it is not
   */
  key?: any;
  /**
   * Shared passphrase used for a single private key and/or a PFX.
   */
  passphrase?: string;
  /**
   * Cert chains in PEM format. One cert chain should be provided per private key.
   * Each cert chain should consist of the PEM formatted certificate for a provided
   * private key, followed by the PEM formatted intermediate certificates (if any),
   * in order, and not including the root CA (the root CA must be pre-known to the
   * peer, see ca). When providing multiple cert chains, they do not have to be
   * in the same order as their private keys in key. If the intermediate certificates
   * are not provided, the peer will not be able to validate the certificate, and
   * the handshake will fail.
   */
  cert?: any;
  /**
   * Optionally override the trusted CA certificates. Default is to trust the well-known
   * CAs curated by Mozilla. Mozilla's CAs are completely replaced when CAs are
   * explicitly specified using this option. The value can be a string or Buffer,
   * or an Array of strings and/or Buffers. Any string or Buffer can contain multiple
   * PEM CAs concatenated together. The peer's certificate must be chainable to
   * a CA trusted by the server for the connection to be authenticated. When using
   * certificates that are not chainable to a well-known CA, the certificate's CA
   * must be explicitly specified as a trusted or the connection will fail to authenticate.
   * If the peer uses a certificate that doesn't match or chain to one of the default
   * CAs, use the ca option to provide a CA certificate that the peer's certificate
   * can match or chain to. For self-signed certificates, the certificate is its
   * own CA, and must be provided. For PEM encoded certificates, supported types
   * are "TRUSTED CERTIFICATE", "X509 CERTIFICATE", and "CERTIFICATE". See also tls.rootCertificates.
   */
  ca?: any;
  /**
   * PEM formatted CRLs (Certificate Revocation Lists).
   */
  crl?: any;
  /**
   * Cipher suite specification, replacing the default. For more information, see
   * modifying the default cipher suite. Permitted ciphers can be obtained via tls.getCiphers().
   * Cipher names must be uppercased in order for OpenSSL to accept them.
   */
  ciphers?: string;
  /**
   * Attempt to use the server's cipher suite preferences instead of the client's.
   * When true, causes SSL_OP_CIPHER_SERVER_PREFERENCE to be set in secureOptions,
   * see OpenSSL Options for more information.
   */
  honorCipherOrder?: boolean;
  /**
   * If true the server will request a certificate from clients that connect and
   * attempt to verify that certificate. Default: false.
   */
  requestCert?: boolean;
  /**
   * If not false the server will reject any connection which is not authorized
   * with the list of supplied CAs. This option only has an effect if requestCert is true. Default: true
   */
  rejectUnauthorized?: boolean;
  /**
   * An array or Buffer of possible NPN protocols. (Protocols should be ordered
   * by their priority).
   */
  NPNProtocols?: any;
  /**
   * A function that will be called if the client supports SNI TLS extension. Two
   * arguments will be passed when called: servername and cb. SNICallback should
   * invoke cb(null, ctx), where ctx is a SecureContext instance. (tls.createSecureContext(...)
   * can be used to get a proper SecureContext.) If SNICallback wasn't provided
   * the default callback with high-level API will be used.
   */
  SNICallback?: (servername: string, cb: (err: Error, ctx: any) => any) => any;
  /**
   * Optionally affect the OpenSSL protocol behavior, which is not usually necessary.
   * This should be used carefully if at all! Value is a numeric bitmask of the SSL_OP_* options
   * from OpenSSL Options.
   */
  secureOptions?: number;
}



================================================
FILE: packages/common/interfaces/external/transformer-package.interface.ts
================================================
import { Type } from '../type.interface';
import { ClassTransformOptions } from './class-transform-options.interface';

export interface TransformerPackage {
  plainToInstance<T>(
    cls: Type<T>,
    plain: unknown,
    options?: ClassTransformOptions,
  ): T | T[];
  classToPlain(
    object: unknown,
    options?: ClassTransformOptions,
  ): Record<string, any> | Record<string, any>[];
}



================================================
FILE: packages/common/interfaces/external/validation-error.interface.ts
================================================
/**
 * Validation error description.
 * @see https://github.com/typestack/class-validator
 *
 * class-validator@0.13.0
 *
 * @publicApi
 */
export interface ValidationError {
  /**
   * Object that was validated.
   *
   * OPTIONAL - configurable via the ValidatorOptions.validationError.target option
   */
  target?: Record<string, any>;
  /**
   * Object's property that hasn't passed validation.
   */
  property: string;
  /**
   * Value that haven't pass a validation.
   *
   * OPTIONAL - configurable via the ValidatorOptions.validationError.value option
   */
  value?: any;
  /**
   * Constraints that failed validation with error messages.
   */
  constraints?: {
    [type: string]: string;
  };
  /**
   * Contains all nested validation errors of the property.
   */
  children?: ValidationError[];
  /**
   * A transient set of data passed through to the validation result for response mapping
   */
  contexts?: {
    [type: string]: any;
  };
}



================================================
FILE: packages/common/interfaces/external/validator-options.interface.ts
================================================
/**
 * Options passed to validator during validation.
 * @see https://github.com/typestack/class-validator
 *
 * class-validator@0.13.0
 *
 * @publicApi
 */
export interface ValidatorOptions {
  /**
   * If set to true then class-validator will print extra warning messages to the console when something is not right.
   */
  enableDebugMessages?: boolean;
  /**
   * If set to true then validator will skip validation of all properties that are undefined in the validating object.
   */
  skipUndefinedProperties?: boolean;
  /**
   * If set to true then validator will skip validation of all properties that are null in the validating object.
   */
  skipNullProperties?: boolean;
  /**
   * If set to true then validator will skip validation of all properties that are null or undefined in the validating object.
   */
  skipMissingProperties?: boolean;
  /**
   * If set to true validator will strip validated object of any properties that do not have any decorators.
   *
   * Tip: if no other decorator is suitable for your property use @Allow decorator.
   */
  whitelist?: boolean;
  /**
   * If set to true, instead of stripping non-whitelisted properties validator will throw an error
   */
  forbidNonWhitelisted?: boolean;
  /**
   * Groups to be used during validation of the object.
   */
  groups?: string[];
  /**
   * Set default for `always` option of decorators. Default can be overridden in decorator options.
   */
  always?: boolean;
  /**
   * If [groups]{@link ValidatorOptions#groups} is not given or is empty,
   * ignore decorators with at least one group.
   */
  strictGroups?: boolean;
  /**
   * If set to true, the validation will not use default messages.
   * Error message always will be undefined if its not explicitly set.
   */
  dismissDefaultMessages?: boolean;
  /**
   * ValidationError special options.
   */
  validationError?: {
    /**
     * Indicates if target should be exposed in ValidationError.
     */
    target?: boolean;
    /**
     * Indicates if validated value should be exposed in ValidationError.
     */
    value?: boolean;
  };
  /**
   * Settings true will cause fail validation of unknown objects.
   */
  forbidUnknownValues?: boolean;
  /**
   * When set to true, validation of the given property will stop after encountering the first error.
   * This is enabled by default.
   */
  stopAtFirstError?: boolean;
}



================================================
FILE: packages/common/interfaces/external/validator-package.interface.ts
================================================
import { ValidationError } from './validation-error.interface';
import { ValidatorOptions } from './validator-options.interface';

export interface ValidatorPackage {
  validate(
    object: unknown,
    validatorOptions?: ValidatorOptions,
  ): ValidationError[] | Promise<ValidationError[]>;
}



================================================
FILE: packages/common/interfaces/features/arguments-host.interface.ts
================================================
export type ContextType = 'http' | 'ws' | 'rpc';

/**
 * Methods to obtain request and response objects.
 *
 * @publicApi
 */
export interface HttpArgumentsHost {
  /**
   * Returns the in-flight `request` object.
   */
  getRequest<T = any>(): T;
  /**
   * Returns the in-flight `response` object.
   */
  getResponse<T = any>(): T;
  getNext<T = any>(): T;
}

/**
 * Methods to obtain WebSocket data and client objects.
 *
 * @publicApi
 */
export interface WsArgumentsHost {
  /**
   * Returns the data object.
   */
  getData<T = any>(): T;
  /**
   * Returns the client object.
   */
  getClient<T = any>(): T;
  /**
   * Returns the pattern for the event
   */
  getPattern(): string;
}

/**
 * Methods to obtain RPC data object.
 *
 * @publicApi
 */
export interface RpcArgumentsHost {
  /**
   * Returns the data object.
   */
  getData<T = any>(): T;

  /**
   * Returns the context object.
   */
  getContext<T = any>(): T;
}

/**
 * Provides methods for retrieving the arguments being passed to a handler.
 * Allows choosing the appropriate execution context (e.g., Http, RPC, or
 * WebSockets) to retrieve the arguments from.
 *
 * @publicApi
 */
export interface ArgumentsHost {
  /**
   * Returns the array of arguments being passed to the handler.
   */
  getArgs<T extends Array<any> = any[]>(): T;
  /**
   * Returns a particular argument by index.
   * @param index index of argument to retrieve
   */
  getArgByIndex<T = any>(index: number): T;
  /**
   * Switch context to RPC.
   * @returns interface with methods to retrieve RPC arguments
   */
  switchToRpc(): RpcArgumentsHost;
  /**
   * Switch context to HTTP.
   * @returns interface with methods to retrieve HTTP arguments
   */
  switchToHttp(): HttpArgumentsHost;
  /**
   * Switch context to WebSockets.
   * @returns interface with methods to retrieve WebSockets arguments
   */
  switchToWs(): WsArgumentsHost;
  /**
   * Returns the current execution context type (string)
   */
  getType<TContext extends string = ContextType>(): TContext;
}



================================================
FILE: packages/common/interfaces/features/can-activate.interface.ts
================================================
import { Observable } from 'rxjs';
import { ExecutionContext } from './execution-context.interface';

/**
 * Interface defining the `canActivate()` function that must be implemented
 * by a guard.  Return value indicates whether or not the current request is
 * allowed to proceed.  Return can be either synchronous (`boolean`)
 * or asynchronous (`Promise` or `Observable`).
 *
 * @see [Guards](https://docs.nestjs.com/guards)
 *
 * @publicApi
 */
export interface CanActivate {
  /**
   * @param context Current execution context. Provides access to details about
   * the current request pipeline.
   *
   * @returns Value indicating whether or not the current request is allowed to
   * proceed.
   */
  canActivate(
    context: ExecutionContext,
  ): boolean | Promise<boolean> | Observable<boolean>;
}



================================================
FILE: packages/common/interfaces/features/custom-route-param-factory.interface.ts
================================================
import { ExecutionContext } from './execution-context.interface';

/**
 * @publicApi
 */
export type CustomParamFactory<TData = any, TOutput = any> = (
  data: TData,
  context: ExecutionContext,
) => TOutput;



================================================
FILE: packages/common/interfaces/features/execution-context.interface.ts
================================================
import { Type } from '../index';
import { ArgumentsHost } from './arguments-host.interface';

/**
 * Interface describing details about the current request pipeline.
 *
 * @see [Execution Context](https://docs.nestjs.com/guards#execution-context)
 *
 * @publicApi
 */
export interface ExecutionContext extends ArgumentsHost {
  /**
   * Returns the *type* of the controller class which the current handler belongs to.
   */
  getClass<T = any>(): Type<T>;
  /**
   * Returns a reference to the handler (method) that will be invoked next in the
   * request pipeline.
   */
  getHandler(): Function;
}



================================================
FILE: packages/common/interfaces/features/nest-interceptor.interface.ts
================================================
import { Observable } from 'rxjs';
import { ExecutionContext } from './execution-context.interface';

/**
 * Interface providing access to the response stream.
 *
 * @see [Interceptors](https://docs.nestjs.com/interceptors)
 *
 * @publicApi
 */
export interface CallHandler<T = any> {
  /**
   * Returns an `Observable` representing the response stream from the route
   * handler.
   */
  handle(): Observable<T>;
}

/**
 * Interface describing implementation of an interceptor.
 *
 * @see [Interceptors](https://docs.nestjs.com/interceptors)
 *
 * @publicApi
 */

export interface NestInterceptor<T = any, R = any> {
  /**
   * Method to implement a custom interceptor.
   *
   * @param context an `ExecutionContext` object providing methods to access the
   * route handler and class about to be invoked.
   * @param next a reference to the `CallHandler`, which provides access to an
   * `Observable` representing the response stream from the route handler.
   */
  intercept(
    context: ExecutionContext,
    next: CallHandler<T>,
  ): Observable<R> | Promise<Observable<R>>;
}



================================================
FILE: packages/common/interfaces/features/paramtype.interface.ts
================================================
/**
 * @publicApi
 */
export type Paramtype = 'body' | 'query' | 'param' | 'custom';



================================================
FILE: packages/common/interfaces/features/pipe-transform.interface.ts
================================================
import { Type } from '../type.interface';
import { Paramtype } from './paramtype.interface';

export type Transform<T = any> = (value: T, metadata: ArgumentMetadata) => any;

/**
 * Interface describing a pipe implementation's `transform()` method metadata argument.
 *
 * @see [Pipes](https://docs.nestjs.com/pipes)
 *
 * @publicApi
 */
export interface ArgumentMetadata {
  /**
   * Indicates whether argument is a body, query, param, or custom parameter
   */
  readonly type: Paramtype;
  /**
   * Underlying base type (e.g., `String`) of the parameter, based on the type
   * definition in the route handler.
   */
  readonly metatype?: Type<any> | undefined;
  /**
   * String passed as an argument to the decorator.
   * Example: `@Body('userId')` would yield `userId`
   */
  readonly data?: string | undefined;
}

/**
 * Interface describing implementation of a pipe.
 *
 * @see [Pipes](https://docs.nestjs.com/pipes)
 *
 * @publicApi
 */
export interface PipeTransform<T = any, R = any> {
  /**
   * Method to implement a custom pipe.  Called with two parameters
   *
   * @param value argument before it is received by route handler method
   * @param metadata contains metadata about the value
   */
  transform(value: T, metadata: ArgumentMetadata): R;
}



================================================
FILE: packages/common/interfaces/hooks/before-application-shutdown.interface.ts
================================================
export interface BeforeApplicationShutdown {
  beforeApplicationShutdown(signal?: string): any;
}



================================================
FILE: packages/common/interfaces/hooks/index.ts
================================================
export * from './before-application-shutdown.interface';
export * from './on-application-bootstrap.interface';
export * from './on-application-shutdown.interface';
export * from './on-destroy.interface';
export * from './on-init.interface';



================================================
FILE: packages/common/interfaces/hooks/on-application-bootstrap.interface.ts
================================================
/**
 * Interface defining method called once the application has fully started and
 * is bootstrapped.
 *
 * @see [Lifecycle Events](https://docs.nestjs.com/fundamentals/lifecycle-events)
 *
 * @publicApi
 */
export interface OnApplicationBootstrap {
  onApplicationBootstrap(): any;
}



================================================
FILE: packages/common/interfaces/hooks/on-application-shutdown.interface.ts
================================================
/**
 * Interface defining method to respond to system signals (when application gets
 * shutdown by, e.g., SIGTERM)
 *
 * @see [Lifecycle Events](https://docs.nestjs.com/fundamentals/lifecycle-events)
 *
 * @publicApi
 */
export interface OnApplicationShutdown {
  onApplicationShutdown(signal?: string): any;
}



================================================
FILE: packages/common/interfaces/hooks/on-destroy.interface.ts
================================================
/**
 * Interface defining method called just before Nest destroys the host module
 * (`app.close()` method has been evaluated).  Use to perform cleanup on
 * resources (e.g., Database connections).
 *
 * @see [Lifecycle Events](https://docs.nestjs.com/fundamentals/lifecycle-events)
 *
 * @publicApi
 */
export interface OnModuleDestroy {
  onModuleDestroy(): any;
}



================================================
FILE: packages/common/interfaces/hooks/on-init.interface.ts
================================================
/**
 * Interface defining method called once the host module has been initialized.
 *
 * @see [Lifecycle Events](https://docs.nestjs.com/fundamentals/lifecycle-events)
 *
 * @publicApi
 */
export interface OnModuleInit {
  onModuleInit(): any;
}



================================================
FILE: packages/common/interfaces/http/http-exception-body.interface.ts
================================================
export type HttpExceptionBodyMessage = string | string[] | number;

export interface HttpExceptionBody {
  message: HttpExceptionBodyMessage;
  error?: string;
  statusCode: number;
}



================================================
FILE: packages/common/interfaces/http/http-redirect-response.interface.ts
================================================
import { HttpStatus } from '../../enums';

export interface HttpRedirectResponse {
  url: string;
  statusCode: HttpStatus;
}



================================================
FILE: packages/common/interfaces/http/http-server.interface.ts
================================================
import { RequestMethod } from '../../enums';
import { NestApplicationOptions } from '../../interfaces/nest-application-options.interface';
import { VersionValue, VersioningOptions } from '../version-options.interface';

export type ErrorHandler<TRequest = any, TResponse = any> = (
  error: any,
  req: TRequest,
  res: TResponse,
  next?: Function,
) => any;
export type RequestHandler<TRequest = any, TResponse = any> = (
  req: TRequest,
  res: TResponse,
  next?: Function,
) => any;

export interface HttpServer<
  TRequest = any,
  TResponse = any,
  ServerInstance = any,
> {
  use(
    handler:
      | RequestHandler<TRequest, TResponse>
      | ErrorHandler<TRequest, TResponse>,
  ): any;
  use(
    path: string,
    handler:
      | RequestHandler<TRequest, TResponse>
      | ErrorHandler<TRequest, TResponse>,
  ): any;
  useBodyParser?(...args: any[]): any;
  get(handler: RequestHandler<TRequest, TResponse>): any;
  get(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  post(handler: RequestHandler<TRequest, TResponse>): any;
  post(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  head(handler: RequestHandler<TRequest, TResponse>): any;
  head(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  delete(handler: RequestHandler<TRequest, TResponse>): any;
  delete(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  put(handler: RequestHandler<TRequest, TResponse>): any;
  put(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  patch(handler: RequestHandler<TRequest, TResponse>): any;
  patch(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  propfind?(handler: RequestHandler<TRequest, TResponse>): any;
  propfind?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  proppatch?(handler: RequestHandler<TRequest, TResponse>): any;
  proppatch?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  mkcol?(handler: RequestHandler<TRequest, TResponse>): any;
  mkcol?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  copy?(handler: RequestHandler<TRequest, TResponse>): any;
  copy?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  move?(handler: RequestHandler<TRequest, TResponse>): any;
  move?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  lock?(handler: RequestHandler<TRequest, TResponse>): any;
  lock?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  unlock?(handler: RequestHandler<TRequest, TResponse>): any;
  unlock?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  all(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  all(handler: RequestHandler<TRequest, TResponse>): any;
  options(handler: RequestHandler<TRequest, TResponse>): any;
  options(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  search?(handler: RequestHandler<TRequest, TResponse>): any;
  search?(path: string, handler: RequestHandler<TRequest, TResponse>): any;
  listen(port: number | string, callback?: () => void): any;
  listen(port: number | string, hostname: string, callback?: () => void): any;
  reply(response: any, body: any, statusCode?: number): any;
  status(response: any, statusCode: number): any;
  end(response: any, message?: string): any;
  render(response: any, view: string, options: any): any;
  redirect(response: any, statusCode: number, url: string): any;
  isHeadersSent(response: any): boolean;
  setHeader(response: any, name: string, value: string): any;
  setErrorHandler?(handler: Function, prefix?: string): any;
  setNotFoundHandler?(handler: Function, prefix?: string): any;
  useStaticAssets?(...args: any[]): this;
  setBaseViewsDir?(path: string | string[]): this;
  setViewEngine?(engineOrOptions: any): this;
  createMiddlewareFactory(
    method: RequestMethod,
  ):
    | ((path: string, callback: Function) => any)
    | Promise<(path: string, callback: Function) => any>;
  getRequestHostname?(request: TRequest): string;
  getRequestMethod?(request: TRequest): string;
  getRequestUrl?(request: TRequest): string;
  getInstance(): ServerInstance;
  registerParserMiddleware(...args: any[]): any;
  enableCors(options: any): any;
  getHttpServer(): any;
  initHttpServer(options: NestApplicationOptions): void;
  close(): any;
  getType(): string;
  init?(): Promise<void>;
  applyVersionFilter(
    handler: Function,
    version: VersionValue,
    versioningOptions: VersioningOptions,
  ): (req: TRequest, res: TResponse, next: () => void) => Function;
  normalizePath?(path: string): string;
}



================================================
FILE: packages/common/interfaces/http/index.ts
================================================
export * from './http-exception-body.interface';
export * from './http-redirect-response.interface';
export * from './http-server.interface';
export * from './message-event.interface';
export * from './raw-body-request.interface';



================================================
FILE: packages/common/interfaces/http/message-event.interface.ts
================================================
export interface MessageEvent {
  data: string | object;
  id?: string;
  type?: string;
  retry?: number;
}



================================================
FILE: packages/common/interfaces/http/raw-body-request.interface.ts
================================================
/**
 * @publicApi
 */
export type RawBodyRequest<T> = T & { rawBody?: Buffer };



================================================
FILE: packages/common/interfaces/microservices/nest-hybrid-application-options.interface.ts
================================================
/**
 * @publicApi
 */
export interface NestHybridApplicationOptions {
  inheritAppConfig?: boolean;
}



================================================
FILE: packages/common/interfaces/microservices/nest-microservice-options.interface.ts
================================================
import { NestApplicationContextOptions } from '../nest-application-context-options.interface';

/**
 * @publicApi
 */
export type NestMicroserviceOptions = NestApplicationContextOptions;



================================================
FILE: packages/common/interfaces/middleware/index.ts
================================================
export * from './middleware-config-proxy.interface';
export * from './middleware-configuration.interface';
export * from './middleware-consumer.interface';
export * from './nest-middleware.interface';



================================================
FILE: packages/common/interfaces/middleware/middleware-config-proxy.interface.ts
================================================
import { Type } from '../type.interface';
import { RouteInfo } from './middleware-configuration.interface';
import { MiddlewareConsumer } from './middleware-consumer.interface';

/**
 * @publicApi
 */
export interface MiddlewareConfigProxy {
  /**
   * Routes to exclude from the current middleware.
   *
   * @param {(string | RouteInfo)[]} routes
   * @returns {MiddlewareConfigProxy}
   */
  exclude(...routes: (string | RouteInfo)[]): MiddlewareConfigProxy;

  /**
   * Attaches either routes or controllers to the current middleware.
   * If you pass a controller class, Nest will attach the current middleware to every path
   * defined within it.
   *
   * @param {(string | Type | RouteInfo)[]} routes
   * @returns {MiddlewareConsumer}
   */
  forRoutes(...routes: (string | Type<any> | RouteInfo)[]): MiddlewareConsumer;
}



================================================
FILE: packages/common/interfaces/middleware/middleware-configuration.interface.ts
================================================
import { RequestMethod } from '../../enums';
import { Type } from '../type.interface';
import { VersionValue } from '../version-options.interface';

export interface RouteInfo {
  path: string;
  method: RequestMethod;
  version?: VersionValue;
}

export interface MiddlewareConfiguration<T = any> {
  middleware: T;
  forRoutes: (Type<any> | string | RouteInfo)[];
}



================================================
FILE: packages/common/interfaces/middleware/middleware-consumer.interface.ts
================================================
import { Type } from '../type.interface';
import { MiddlewareConfigProxy } from './middleware-config-proxy.interface';

/**
 * Interface defining method for applying user defined middleware to routes.
 *
 * @see [MiddlewareConsumer](https://docs.nestjs.com/middleware#middleware-consumer)
 *
 * @publicApi
 */
export interface MiddlewareConsumer {
  /**
   * @param {...(Type | Function)} middleware middleware class/function or array of classes/functions
   * to be attached to the passed routes.
   *
   * @returns {MiddlewareConfigProxy}
   */
  apply(...middleware: (Type<any> | Function)[]): MiddlewareConfigProxy;
}



================================================
FILE: packages/common/interfaces/middleware/nest-middleware.interface.ts
================================================
/**
 * @see [Middleware](https://docs.nestjs.com/middleware)
 *
 * @publicApi
 */
export interface NestMiddleware<TRequest = any, TResponse = any> {
  use(req: TRequest, res: TResponse, next: (error?: any) => void): any;
}



================================================
FILE: packages/common/interfaces/modules/dynamic-module.interface.ts
================================================
import { Type } from '../type.interface';
import { ModuleMetadata } from './module-metadata.interface';

/**
 * Interface defining a Dynamic Module.
 *
 * @see [Dynamic Modules](https://docs.nestjs.com/modules#dynamic-modules)
 *
 * @publicApi
 */
export interface DynamicModule extends ModuleMetadata {
  /**
   * A module reference
   */
  module: Type<any>;

  /**
   * When "true", makes a module global-scoped.
   *
   * Once imported into any module, a global-scoped module will be visible
   * in all modules. Thereafter, modules that wish to inject a service exported
   * from a global module do not need to import the provider module.
   *
   * @default false
   */
  global?: boolean;
}



================================================
FILE: packages/common/interfaces/modules/forward-reference.interface.ts
================================================
export interface ForwardReference<T = any> {
  forwardRef: T;
}



================================================
FILE: packages/common/interfaces/modules/index.ts
================================================
export * from './dynamic-module.interface';
export * from './forward-reference.interface';
export * from './injection-token.interface';
export * from './introspection-result.interface';
export * from './module-metadata.interface';
export * from './nest-module.interface';
export * from './optional-factory-dependency.interface';
export * from './provider.interface';



================================================
FILE: packages/common/interfaces/modules/injection-token.interface.ts
================================================
import { Abstract } from '../abstract.interface';
import { Type } from '../type.interface';

/**
 * @publicApi
 */
export type InjectionToken<T = any> =
  | string
  | symbol
  | Type<T>
  | Abstract<T>
  | Function;



================================================
FILE: packages/common/interfaces/modules/introspection-result.interface.ts
================================================
import { Scope } from '../scope-options.interface';

/**
 * @publicApi
 */
export interface IntrospectionResult {
  /**
   * Enum defining lifetime of host class or factory.
   */
  scope: Scope;
}



================================================
FILE: packages/common/interfaces/modules/module-metadata.interface.ts
================================================
import { Abstract } from '../abstract.interface';
import { Type } from '../type.interface';
import { DynamicModule } from './dynamic-module.interface';
import { ForwardReference } from './forward-reference.interface';
import { Provider } from './provider.interface';

/**
 * Interface defining the property object that describes the module.
 *
 * @see [Modules](https://docs.nestjs.com/modules)
 *
 * @publicApi
 */
export interface ModuleMetadata {
  /**
   * Optional list of imported modules that export the providers which are
   * required in this module.
   */
  imports?: Array<
    Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference
  >;
  /**
   * Optional list of controllers defined in this module which have to be
   * instantiated.
   */
  controllers?: Type<any>[];
  /**
   * Optional list of providers that will be instantiated by the Nest injector
   * and that may be shared at least across this module.
   */
  providers?: Provider[];
  /**
   * Optional list of the subset of providers that are provided by this module
   * and should be available in other modules which import this module.
   */
  exports?: Array<
    | DynamicModule
    | string
    | symbol
    | Provider
    | ForwardReference
    | Abstract<any>
    | Function
  >;
}



================================================
FILE: packages/common/interfaces/modules/nest-module.interface.ts
================================================
import { MiddlewareConsumer } from '../middleware/middleware-consumer.interface';

/**
 * @publicApi
 */
export interface NestModule {
  configure(consumer: MiddlewareConsumer);
}



================================================
FILE: packages/common/interfaces/modules/optional-factory-dependency.interface.ts
================================================
import { InjectionToken } from './injection-token.interface';

/**
 * @publicApi
 */
export type OptionalFactoryDependency = {
  token: InjectionToken;
  optional: boolean;
};



================================================
FILE: packages/common/interfaces/modules/provider.interface.ts
================================================
import { Scope } from '../scope-options.interface';
import { Type } from '../type.interface';
import { InjectionToken } from './injection-token.interface';
import { OptionalFactoryDependency } from './optional-factory-dependency.interface';

/**
 *
 * @publicApi
 */
export type Provider<T = any> =
  | Type<any>
  | ClassProvider<T>
  | ValueProvider<T>
  | FactoryProvider<T>
  | ExistingProvider<T>;

/**
 * Interface defining a *Class* type provider.
 *
 * For example:
 * ```typescript
 * const configServiceProvider = {
 * provide: ConfigService,
 * useClass:
 *   process.env.NODE_ENV === 'development'
 *     ? DevelopmentConfigService
 *     : ProductionConfigService,
 * };
 * ```
 *
 * @see [Class providers](https://docs.nestjs.com/fundamentals/custom-providers#class-providers-useclass)
 * @see [Injection scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 *
 * @publicApi
 */
export interface ClassProvider<T = any> {
  /**
   * Injection token
   */
  provide: InjectionToken;
  /**
   * Type (class name) of provider (instance to be injected).
   */
  useClass: Type<T>;
  /**
   * Optional enum defining lifetime of the provider that is injected.
   */
  scope?: Scope;
  /**
   * This option is only available on factory providers!
   *
   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
   */
  inject?: never;
  /**
   * Flags provider as durable. This flag can be used in combination with custom context id
   * factory strategy to construct lazy DI subtrees.
   *
   * This flag can be used only in conjunction with scope = Scope.REQUEST.
   */
  durable?: boolean;
}

/**
 * Interface defining a *Value* type provider.
 *
 * For example:
 * ```typescript
 * const connectionProvider = {
 *   provide: 'CONNECTION',
 *   useValue: connection,
 * };
 * ```
 *
 * @see [Value providers](https://docs.nestjs.com/fundamentals/custom-providers#value-providers-usevalue)
 *
 * @publicApi
 */
export interface ValueProvider<T = any> {
  /**
   * Injection token
   */
  provide: InjectionToken;
  /**
   * Instance of a provider to be injected.
   */
  useValue: T;
  /**
   * This option is only available on factory providers!
   *
   * @see [Use factory](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
   */
  inject?: never;
}

/**
 * Interface defining a *Factory* type provider.
 *
 * For example:
 * ```typescript
 * const connectionFactory = {
 *   provide: 'CONNECTION',
 *   useFactory: (optionsProvider: OptionsProvider) => {
 *     const options = optionsProvider.get();
 *     return new DatabaseConnection(options);
 *   },
 *   inject: [OptionsProvider],
 * };
 * ```
 *
 * @see [Factory providers](https://docs.nestjs.com/fundamentals/custom-providers#factory-providers-usefactory)
 * @see [Injection scopes](https://docs.nestjs.com/fundamentals/injection-scopes)
 *
 * @publicApi
 */
export interface FactoryProvider<T = any> {
  /**
   * Injection token
   */
  provide: InjectionToken;
  /**
   * Factory function that returns an instance of the provider to be injected.
   */
  useFactory: (...args: any[]) => T | Promise<T>;
  /**
   * Optional list of providers to be injected into the context of the Factory function.
   */
  inject?: Array<InjectionToken | OptionalFactoryDependency>;
  /**
   * Optional enum defining lifetime of the provider that is returned by the Factory function.
   */
  scope?: Scope;
  /**
   * Flags provider as durable. This flag can be used in combination with custom context id
   * factory strategy to construct lazy DI subtrees.
   *
   * This flag can be used only in conjunction with scope = Scope.REQUEST.
   */
  durable?: boolean;
}

/**
 * Interface defining an *Existing* (aliased) type provider.
 *
 * For example:
 * ```typescript
 * const loggerAliasProvider = {
 *   provide: 'AliasedLoggerService',
 *   useExisting: LoggerService
 * };
 * ```
 *
 * @see [Alias providers](https://docs.nestjs.com/fundamentals/custom-providers#alias-providers-useexisting)
 *
 * @publicApi
 */
export interface ExistingProvider<T = any> {
  /**
   * Injection token
   */
  provide: InjectionToken;
  /**
   * Provider to be aliased by the Injection token.
   */
  useExisting: any;
}



================================================
FILE: packages/common/interfaces/websockets/web-socket-adapter.interface.ts
================================================
import { Observable } from 'rxjs';

/**
 * @publicApi
 */
export interface WsMessageHandler<T = string> {
  message: T;
  callback: (...args: any[]) => Observable<any> | Promise<any>;
}

/**
 * @publicApi
 */
export interface WebSocketAdapter<
  TServer = any,
  TClient = any,
  TOptions = any,
> {
  create(port: number, options?: TOptions): TServer;
  bindClientConnect(server: TServer, callback: Function): any;
  bindClientDisconnect?(client: TClient, callback: Function): any;
  bindMessageHandlers(
    client: TClient,
    handlers: WsMessageHandler[],
    transform: (data: any) => Observable<any>,
  ): any;
  close(server: TServer): any;
}



================================================
FILE: packages/common/module-utils/configurable-module.builder.ts
================================================
/* eslint-disable @typescript-eslint/no-empty-object-type */
import { DynamicModule, Provider } from '../interfaces';
import { Logger } from '../services/logger.service';
import { randomStringGenerator } from '../utils/random-string-generator.util';
import {
  ASYNC_METHOD_SUFFIX,
  CONFIGURABLE_MODULE_ID,
  DEFAULT_FACTORY_CLASS_METHOD_KEY,
  DEFAULT_METHOD_KEY,
} from './constants';
import {
  ConfigurableModuleAsyncOptions,
  ConfigurableModuleCls,
  ConfigurableModuleHost,
  ConfigurableModuleOptionsFactory,
} from './interfaces';
import { generateOptionsInjectionToken, getInjectionProviders } from './utils';

/**
 * @publicApi
 */
export interface ConfigurableModuleBuilderOptions {
  /**
   * Specifies what injection token should be used for the module options provider.
   * By default, an auto-generated UUID will be used.
   */
  optionsInjectionToken?: string | symbol;
  /**
   * By default, an UUID will be used as a module options provider token.
   * Explicitly specifying the "moduleName" will instruct the "ConfigurableModuleBuilder"
   * to use a more descriptive provider token.
   *
   * For example, `moduleName: "Cache"` will auto-generate the provider token: "CACHE_MODULE_OPTIONS".
   */
  moduleName?: string;
  /**
   * Indicates whether module should always be "transient" - meaning,
   * every time you call the static method to construct a dynamic module,
   * regardless of what arguments you pass in, a new "unique" module will be created.
   *
   * @default false
   */
  alwaysTransient?: boolean;
}

/**
 * Factory that lets you create configurable modules and
 * provides a way to reduce the majority of dynamic module boilerplate.
 *
 * @publicApi
 */
export class ConfigurableModuleBuilder<
  ModuleOptions,
  StaticMethodKey extends string = typeof DEFAULT_METHOD_KEY,
  FactoryClassMethodKey extends
    string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
  ExtraModuleDefinitionOptions = {},
> {
  protected staticMethodKey: StaticMethodKey;
  protected factoryClassMethodKey: FactoryClassMethodKey;
  protected extras: ExtraModuleDefinitionOptions;
  protected transformModuleDefinition: (
    definition: DynamicModule,
    extraOptions: ExtraModuleDefinitionOptions,
  ) => DynamicModule;

  protected readonly logger = new Logger(ConfigurableModuleBuilder.name);

  constructor(
    protected readonly options: ConfigurableModuleBuilderOptions = {},
    parentBuilder?: ConfigurableModuleBuilder<ModuleOptions>,
  ) {
    if (parentBuilder) {
      this.staticMethodKey = parentBuilder.staticMethodKey as StaticMethodKey;
      this.factoryClassMethodKey =
        parentBuilder.factoryClassMethodKey as FactoryClassMethodKey;
      this.transformModuleDefinition =
        parentBuilder.transformModuleDefinition as (
          definition: DynamicModule,
          extraOptions: ExtraModuleDefinitionOptions,
        ) => DynamicModule;
      this.extras = parentBuilder.extras as ExtraModuleDefinitionOptions;
    }
  }

  /**
   * Registers the "extras" object (a set of extra options that can be used to modify the dynamic module definition).
   * Values you specify within the "extras" object will be used as default values (that can be overridden by module consumers).
   *
   * This method also applies the so-called "module definition transform function" that takes the auto-generated
   * dynamic module object ("DynamicModule") and the actual consumer "extras" object as input parameters.
   * The "extras" object consists of values explicitly specified by module consumers and default values.
   *
   * @example
   * ```typescript
   * .setExtras<{ isGlobal?: boolean }>({ isGlobal: false }, (definition, extras) =>
   *    ({ ...definition, global: extras.isGlobal })
   * )
   * ```
   */
  setExtras<ExtraModuleDefinitionOptions>(
    extras: ExtraModuleDefinitionOptions,
    transformDefinition: (
      definition: DynamicModule,
      extras: ExtraModuleDefinitionOptions,
    ) => DynamicModule = def => def,
  ) {
    const builder = new ConfigurableModuleBuilder<
      ModuleOptions,
      StaticMethodKey,
      FactoryClassMethodKey,
      ExtraModuleDefinitionOptions
    >(this.options, this as any);
    builder.extras = extras;
    builder.transformModuleDefinition = transformDefinition;
    return builder;
  }

  /**
   * Dynamic modules must expose public static methods that let you pass in
   * configuration parameters (control the module's behavior from the outside).
   * Some frequently used names that you may have seen in other modules are:
   * "forRoot", "forFeature", "register", "configure".
   *
   * This method "setClassMethodName" lets you specify the name of the
   * method that will be auto-generated.
   *
   * @param key name of the method
   */
  setClassMethodName<StaticMethodKey extends string>(key: StaticMethodKey) {
    const builder = new ConfigurableModuleBuilder<
      ModuleOptions,
      StaticMethodKey,
      FactoryClassMethodKey,
      ExtraModuleDefinitionOptions
    >(this.options, this as any);
    builder.staticMethodKey = key;
    return builder;
  }

  /**
   * Asynchronously configured modules (that rely on other modules, i.e. "ConfigModule")
   * let you pass the configuration factory class that will be registered and instantiated as a provider.
   * This provider then will be used to retrieve the module's configuration. To provide the configuration,
   * the corresponding factory method must be implemented.
   *
   * This method ("setFactoryMethodName") lets you control what method name will have to be
   * implemented by the config factory (default is "create").
   *
   * @param key name of the method
   */
  setFactoryMethodName<FactoryClassMethodKey extends string>(
    key: FactoryClassMethodKey,
  ) {
    const builder = new ConfigurableModuleBuilder<
      ModuleOptions,
      StaticMethodKey,
      FactoryClassMethodKey,
      ExtraModuleDefinitionOptions
    >(this.options, this as any);
    builder.factoryClassMethodKey = key;
    return builder;
  }

  /**
   * Returns an object consisting of multiple properties that lets you
   * easily construct dynamic configurable modules. See "ConfigurableModuleHost" interface for more details.
   */
  build(): ConfigurableModuleHost<
    ModuleOptions,
    StaticMethodKey,
    FactoryClassMethodKey,
    ExtraModuleDefinitionOptions
  > {
    this.staticMethodKey ??= DEFAULT_METHOD_KEY as StaticMethodKey;
    this.factoryClassMethodKey ??=
      DEFAULT_FACTORY_CLASS_METHOD_KEY as FactoryClassMethodKey;
    this.options.optionsInjectionToken ??= this.options.moduleName
      ? this.constructInjectionTokenString()
      : generateOptionsInjectionToken();
    this.transformModuleDefinition ??= definition => definition;

    return {
      ConfigurableModuleClass:
        this.createConfigurableModuleCls<ModuleOptions>(),
      MODULE_OPTIONS_TOKEN: this.options.optionsInjectionToken,
      ASYNC_OPTIONS_TYPE: this.createTypeProxy('ASYNC_OPTIONS_TYPE'),
      OPTIONS_TYPE: this.createTypeProxy('OPTIONS_TYPE'),
    };
  }

  private constructInjectionTokenString(): string {
    const moduleNameInSnakeCase = this.options
      .moduleName!.trim()
      .split(/(?=[A-Z])/)
      .join('_')
      .toUpperCase();
    return `${moduleNameInSnakeCase}_MODULE_OPTIONS`;
  }

  private createConfigurableModuleCls<ModuleOptions>(): ConfigurableModuleCls<
    ModuleOptions,
    StaticMethodKey,
    FactoryClassMethodKey
  > {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    const asyncMethodKey = this.staticMethodKey + ASYNC_METHOD_SUFFIX;

    class InternalModuleClass {
      static [self.staticMethodKey](
        options: ModuleOptions & ExtraModuleDefinitionOptions,
      ): DynamicModule {
        const providers: Array<Provider> = [
          {
            provide: self.options.optionsInjectionToken!,
            useValue: this.omitExtras(options, self.extras),
          },
        ];
        if (self.options.alwaysTransient) {
          providers.push({
            provide: CONFIGURABLE_MODULE_ID,
            useValue: randomStringGenerator(),
          });
        }
        return self.transformModuleDefinition(
          {
            module: this,
            providers,
          },
          {
            ...self.extras,
            ...options,
          },
        );
      }

      static [asyncMethodKey](
        options: ConfigurableModuleAsyncOptions<ModuleOptions> &
          ExtraModuleDefinitionOptions,
      ): DynamicModule {
        const providers = this.createAsyncProviders(options);
        if (self.options.alwaysTransient) {
          providers.push({
            provide: CONFIGURABLE_MODULE_ID,
            useValue: randomStringGenerator(),
          });
        }
        return self.transformModuleDefinition(
          {
            module: this,
            imports: options.imports || [],
            providers,
          },
          {
            ...self.extras,
            ...options,
          },
        );
      }

      private static omitExtras(
        input: ModuleOptions & ExtraModuleDefinitionOptions,
        extras: ExtraModuleDefinitionOptions | undefined,
      ): ModuleOptions {
        if (!extras) {
          return input;
        }
        const moduleOptions = {};
        const extrasKeys = Object.keys(extras);

        Object.keys(input as object)
          .filter(key => !extrasKeys.includes(key))
          .forEach(key => {
            moduleOptions[key] = input[key];
          });
        return moduleOptions as ModuleOptions;
      }

      private static createAsyncProviders(
        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
      ): Provider[] {
        if (options.useExisting || options.useFactory) {
          if (options.inject && options.provideInjectionTokensFrom) {
            return [
              this.createAsyncOptionsProvider(options),
              ...getInjectionProviders(
                options.provideInjectionTokensFrom,
                options.inject,
              ),
            ];
          }
          return [this.createAsyncOptionsProvider(options)];
        }
        return [
          this.createAsyncOptionsProvider(options),
          {
            provide: options.useClass!,
            useClass: options.useClass!,
          },
        ];
      }

      private static createAsyncOptionsProvider(
        options: ConfigurableModuleAsyncOptions<ModuleOptions>,
      ): Provider {
        if (options.useFactory) {
          return {
            provide: self.options.optionsInjectionToken!,
            useFactory: options.useFactory,
            inject: options.inject || [],
          };
        }
        return {
          provide: self.options.optionsInjectionToken!,
          useFactory: async (
            optionsFactory: ConfigurableModuleOptionsFactory<
              ModuleOptions,
              FactoryClassMethodKey
            >,
          ) =>
            await optionsFactory[
              self.factoryClassMethodKey as keyof typeof optionsFactory
            ](),
          inject: [options.useExisting || options.useClass!],
        };
      }
    }
    return InternalModuleClass as unknown as ConfigurableModuleCls<
      ModuleOptions,
      StaticMethodKey,
      FactoryClassMethodKey
    >;
  }

  private createTypeProxy(
    typeName: 'OPTIONS_TYPE' | 'ASYNC_OPTIONS_TYPE' | 'OptionsFactoryInterface',
  ) {
    const proxy = new Proxy(
      {},
      {
        get: () => {
          throw new Error(
            `"${typeName}" is not supposed to be used as a value.`,
          );
        },
      },
    );
    return proxy as any;
  }
}



================================================
FILE: packages/common/module-utils/constants.ts
================================================
export const DEFAULT_METHOD_KEY = 'register';
export const DEFAULT_FACTORY_CLASS_METHOD_KEY = 'create';

export const ASYNC_METHOD_SUFFIX = 'Async';
export const CONFIGURABLE_MODULE_ID = 'CONFIGURABLE_MODULE_ID';



================================================
FILE: packages/common/module-utils/index.ts
================================================
export * from './configurable-module.builder';
export * from './interfaces';



================================================
FILE: packages/common/module-utils/interfaces/configurable-module-async-options.interface.ts
================================================
import {
  FactoryProvider,
  ModuleMetadata,
  Provider,
  Type,
} from '../../interfaces';
import { DEFAULT_FACTORY_CLASS_METHOD_KEY } from '../constants';

/**
 * Interface that must be implemented by the module options factory class.
 * Method key varies depending on the "FactoryClassMethodKey" type argument.
 *
 * @publicApi
 */
export type ConfigurableModuleOptionsFactory<
  ModuleOptions,
  FactoryClassMethodKey extends string,
> = Record<
  `${FactoryClassMethodKey}`,
  () => Promise<ModuleOptions> | ModuleOptions
>;

/**
 * Interface that represents the module async options object
 * Factory method name varies depending on the "FactoryClassMethodKey" type argument.
 *
 * @publicApi
 */
export interface ConfigurableModuleAsyncOptions<
  ModuleOptions,
  FactoryClassMethodKey extends
    string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
> extends Pick<ModuleMetadata, 'imports'> {
  /**
   * Injection token resolving to an existing provider. The provider must implement
   * the corresponding interface.
   */
  useExisting?: Type<
    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
  >;
  /**
   * Injection token resolving to a class that will be instantiated as a provider.
   * The class must implement the corresponding interface.
   */
  useClass?: Type<
    ConfigurableModuleOptionsFactory<ModuleOptions, FactoryClassMethodKey>
  >;
  /**
   * Function returning options (or a Promise resolving to options) to configure the
   * cache module.
   */
  useFactory?: (...args: any[]) => Promise<ModuleOptions> | ModuleOptions;
  /**
   * Dependencies that a Factory may inject.
   */
  inject?: FactoryProvider['inject'];
  /**
   * List of parent module's providers that will be filtered to only provide necessary
   * providers for the 'inject' array
   * useful to pass options to nested async modules
   */
  provideInjectionTokensFrom?: Provider[];
}



================================================
FILE: packages/common/module-utils/interfaces/configurable-module-cls.interface.ts
================================================
/* eslint-disable @typescript-eslint/no-empty-object-type */
import { DynamicModule } from '../../interfaces';
import {
  DEFAULT_FACTORY_CLASS_METHOD_KEY,
  DEFAULT_METHOD_KEY,
} from '../constants';
import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';

/**
 * Class that represents a blueprint/prototype for a configurable Nest module.
 * This class provides static methods for constructing dynamic modules. Their names
 * can be controlled through the "MethodKey" type argument.
 *
 * @publicApi
 */
export type ConfigurableModuleCls<
  ModuleOptions,
  MethodKey extends string = typeof DEFAULT_METHOD_KEY,
  FactoryClassMethodKey extends
    string = typeof DEFAULT_FACTORY_CLASS_METHOD_KEY,
  ExtraModuleDefinitionOptions = {},
> = {
  new (): any;
} & Record<
  `${MethodKey}`,
  (
    options: ModuleOptions & Partial<ExtraModuleDefinitionOptions>,
  ) => DynamicModule
> &
  Record<
    `${MethodKey}Async`,
    (
      options: ConfigurableModuleAsyncOptions<
        ModuleOptions,
        FactoryClassMethodKey
      > &
        Partial<ExtraModuleDefinitionOptions>,
    ) => DynamicModule
  >;



================================================
FILE: packages/common/module-utils/interfaces/configurable-module-host.interface.ts
================================================
/* eslint-disable @typescript-eslint/no-empty-object-type */
import { ConfigurableModuleAsyncOptions } from './configurable-module-async-options.interface';
import { ConfigurableModuleCls } from './configurable-module-cls.interface';

/**
 * Configurable module host. See properties for more details
 *
 * @publicApi
 */
export interface ConfigurableModuleHost<
  ModuleOptions = Record<string, unknown>,
  MethodKey extends string = string,
  FactoryClassMethodKey extends string = string,
  ExtraModuleDefinitionOptions = {},
> {
  /**
   * Class that represents a blueprint/prototype for a configurable Nest module.
   * This class provides static methods for constructing dynamic modules. Their names
   * can be controlled through the "MethodKey" type argument.
   *
   * Your module class should inherit from this class to make the static methods available.
   *
   * @example
   * ```typescript
   * @Module({})
   * class IntegrationModule extends ConfigurableModuleCls {
   *  // ...
   * }
   * ```
   */
  ConfigurableModuleClass: ConfigurableModuleCls<
    ModuleOptions,
    MethodKey,
    FactoryClassMethodKey,
    ExtraModuleDefinitionOptions
  >;
  /**
   * Module options provider token. Can be used to inject the "options object" to
   * providers registered within the host module.
   */
  MODULE_OPTIONS_TOKEN: string | symbol;
  /**
   * Can be used to auto-infer the compound "async module options" type.
   * Note: this property is not supposed to be used as a value.
   *
   * @example
   * ```typescript
   * @Module({})
   * class IntegrationModule extends ConfigurableModuleCls {
   *  static module = initializer(IntegrationModule);
   *
   * static registerAsync(options: typeof ASYNC_OPTIONS_TYPE): DynamicModule {
   *  return super.registerAsync(options);
   * }
   * ```
   */
  ASYNC_OPTIONS_TYPE: ConfigurableModuleAsyncOptions<
    ModuleOptions,
    FactoryClassMethodKey
  > &
    Partial<ExtraModuleDefinitionOptions>;
  /**
   * Can be used to auto-infer the compound "module options" type (options interface + extra module definition options).
   * Note: this property is not supposed to be used as a value.
   *
   * @example
   * ```typescript
   * @Module({})
   * class IntegrationModule extends ConfigurableModuleCls {
   *  static module = initializer(IntegrationModule);
   *
   * static register(options: typeof OPTIONS_TYPE): DynamicModule {
   *  return super.register(options);
   * }
   * ```
   */
  OPTIONS_TYPE: ModuleOptions & Partial<ExtraModuleDefinitionOptions>;
}



================================================
FILE: packages/common/module-utils/interfaces/index.ts
================================================
export * from './configurable-module-async-options.interface';
export * from './configurable-module-cls.interface';
export * from './configurable-module-host.interface';



================================================
FILE: packages/common/module-utils/utils/generate-options-injection-token.util.ts
================================================
import { randomStringGenerator } from '../../utils/random-string-generator.util';

export function generateOptionsInjectionToken() {
  const hash = randomStringGenerator();
  return `CONFIGURABLE_MODULE_OPTIONS[${hash}]`;
}



================================================
FILE: packages/common/module-utils/utils/get-injection-providers.util.ts
================================================
import { isUndefined } from '../../utils/shared.utils';
import {
  FactoryProvider,
  InjectionToken,
  OptionalFactoryDependency,
  Provider,
} from '../../interfaces';

/**
 * @param value
 * @returns `true` if value is `OptionalFactoryDependency`
 */
function isOptionalFactoryDependency(
  value: InjectionToken | OptionalFactoryDependency,
): value is OptionalFactoryDependency {
  return (
    !isUndefined((value as OptionalFactoryDependency).token) &&
    !isUndefined((value as OptionalFactoryDependency).optional) &&
    !(value as any).prototype
  );
}

const mapInjectToTokens = (t: InjectionToken | OptionalFactoryDependency) =>
  isOptionalFactoryDependency(t) ? t.token : t;

/**
 *
 * @param providers List of a module's providers
 * @param tokens Injection tokens needed for a useFactory function (usually the module's options' token)
 * @returns All the providers needed for the tokens' injection (searched recursively)
 */
export function getInjectionProviders(
  providers: Provider[],
  tokens: FactoryProvider['inject'],
): Provider[] {
  const result: Provider[] = [];
  let search: InjectionToken[] = tokens!.map(mapInjectToTokens);
  while (search.length > 0) {
    const match = (providers ?? []).filter(
      p =>
        !result.includes(p) && // this prevents circular loops and duplication
        (search.includes(p as any) || search.includes((p as any)?.provide)),
    );
    result.push(...match);
    // get injection tokens of the matched providers, if any
    search = match
      .filter(p => (p as any)?.inject)
      .flatMap(p => (p as FactoryProvider).inject!)
      .map(mapInjectToTokens);
  }
  return result;
}



================================================
FILE: packages/common/module-utils/utils/index.ts
================================================
export * from './generate-options-injection-token.util';
export * from './get-injection-providers.util';



================================================
FILE: packages/common/pipes/default-value.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import { isNil, isNumber } from '../utils/shared.utils';

/**
 * Defines the built-in DefaultValue Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class DefaultValuePipe<T = any, R = any>
  implements PipeTransform<T, T | R>
{
  constructor(protected readonly defaultValue: R) {}

  transform(value?: T, _metadata?: ArgumentMetadata): T | R {
    if (
      isNil(value) ||
      (isNumber(value) && isNaN(value as unknown as number))
    ) {
      return this.defaultValue;
    }
    return value;
  }
}



================================================
FILE: packages/common/pipes/index.ts
================================================
export * from './default-value.pipe';
export * from './file';
export * from './parse-array.pipe';
export * from './parse-bool.pipe';
export * from './parse-date.pipe';
export * from './parse-enum.pipe';
export * from './parse-float.pipe';
export * from './parse-int.pipe';
export * from './parse-uuid.pipe';
export * from './validation.pipe';



================================================
FILE: packages/common/pipes/parse-array.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import { Optional } from '../decorators/core/optional.decorator';
import { HttpStatus } from '../enums/http-status.enum';
import { Type } from '../interfaces';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import { HttpErrorByCode } from '../utils/http-error-by-code.util';
import { isNil, isString, isUndefined } from '../utils/shared.utils';
import { ValidationPipe, ValidationPipeOptions } from './validation.pipe';

const VALIDATION_ERROR_MESSAGE = 'Validation failed (parsable array expected)';
const DEFAULT_ARRAY_SEPARATOR = ',';

/**
 * @publicApi
 */
export interface ParseArrayOptions
  extends Omit<
    ValidationPipeOptions,
    'transform' | 'validateCustomDecorators' | 'exceptionFactory'
  > {
  /**
   * Type for items to be converted into
   */
  items?: Type<unknown>;
  /**
   * Items separator to split string by
   * @default ','
   */
  separator?: string;
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message or object
   * @returns The exception object
   */
  exceptionFactory?: (error: any) => any;
}

/**
 * Defines the built-in ParseArray Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseArrayPipe implements PipeTransform {
  protected readonly validationPipe: ValidationPipe;
  protected exceptionFactory: (error: string) => any;

  constructor(@Optional() protected readonly options: ParseArrayOptions = {}) {
    this.validationPipe = new ValidationPipe({
      transform: true,
      validateCustomDecorators: true,
      ...options,
    });

    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;
    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  async transform(value: any, metadata: ArgumentMetadata): Promise<any> {
    if (!value && !this.options.optional) {
      throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
    } else if (isNil(value) && this.options.optional) {
      return value;
    }

    if (!Array.isArray(value)) {
      if (!isString(value)) {
        throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
      } else {
        try {
          value = value
            .trim()
            .split(this.options.separator || DEFAULT_ARRAY_SEPARATOR);
        } catch {
          throw this.exceptionFactory(VALIDATION_ERROR_MESSAGE);
        }
      }
    }
    if (this.options.items) {
      const validationMetadata: ArgumentMetadata = {
        metatype: this.options.items,
        type: 'query',
      };

      const isExpectedTypePrimitive = this.isExpectedTypePrimitive();
      const toClassInstance = (item: any, index?: number) => {
        if (this.options.items !== String) {
          try {
            item = JSON.parse(item);
          } catch {
            // Do nothing
          }
        }
        if (isExpectedTypePrimitive) {
          return this.validatePrimitive(item, index);
        }
        return this.validationPipe.transform(item, validationMetadata);
      };
      if (this.options.stopAtFirstError === false) {
        // strict compare to "false" to make sure
        // that this option is disabled by default
        let errors: string[] = [];

        const targetArray = value as Array<unknown>;
        for (let i = 0; i < targetArray.length; i++) {
          try {
            targetArray[i] = await toClassInstance(targetArray[i]);
          } catch (err) {
            let message: string[] | string;
            if (err.getResponse) {
              const response = err.getResponse();
              if (Array.isArray(response.message)) {
                message = response.message.map(
                  (item: string) => `[${i}] ${item}`,
                );
              } else {
                message = `[${i}] ${response.message}`;
              }
            } else {
              message = err;
            }
            errors = errors.concat(message);
          }
        }
        if (errors.length > 0) {
          throw this.exceptionFactory(errors as any);
        }
        return targetArray;
      } else {
        value = await Promise.all(value.map(toClassInstance));
      }
    }
    return value;
  }

  protected isExpectedTypePrimitive(): boolean {
    return [Boolean, Number, String].includes(this.options.items as any);
  }

  protected validatePrimitive(originalValue: any, index?: number) {
    if (this.options.items === Number) {
      const value =
        originalValue !== null && originalValue !== '' ? +originalValue : NaN;
      if (isNaN(value)) {
        throw this.exceptionFactory(
          `${isUndefined(index) ? '' : `[${index}] `}item must be a number`,
        );
      }
      return value;
    } else if (this.options.items === String) {
      if (!isString(originalValue)) {
        return `${originalValue}`;
      }
    } else if (this.options.items === Boolean) {
      if (typeof originalValue !== 'boolean') {
        throw this.exceptionFactory(
          `${
            isUndefined(index) ? '' : `[${index}] `
          }item must be a boolean value`,
        );
      }
    }
    return originalValue;
  }
}



================================================
FILE: packages/common/pipes/parse-bool.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import { Optional } from '../decorators/core/optional.decorator';
import { HttpStatus } from '../enums/http-status.enum';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ParseBoolPipeOptions {
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (error: string) => any;
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
}

/**
 * Defines the built-in ParseBool Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseBoolPipe
  implements PipeTransform<string | boolean, Promise<boolean>>
{
  protected exceptionFactory: (error: string) => any;

  constructor(@Optional() protected readonly options?: ParseBoolPipeOptions) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;
    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  async transform(
    value: string | boolean,
    metadata: ArgumentMetadata,
  ): Promise<boolean> {
    if (isNil(value) && this.options?.optional) {
      return value;
    }
    if (this.isTrue(value)) {
      return true;
    }
    if (this.isFalse(value)) {
      return false;
    }
    throw this.exceptionFactory(
      'Validation failed (boolean string is expected)',
    );
  }

  /**
   * @param value currently processed route argument
   * @returns `true` if `value` is said 'true', ie., if it is equal to the boolean
   * `true` or the string `"true"`
   */
  protected isTrue(value: string | boolean): boolean {
    return value === true || value === 'true';
  }

  /**
   * @param value currently processed route argument
   * @returns `true` if `value` is said 'false', ie., if it is equal to the boolean
   * `false` or the string `"false"`
   */
  protected isFalse(value: string | boolean): boolean {
    return value === false || value === 'false';
  }
}



================================================
FILE: packages/common/pipes/parse-date.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import { HttpStatus } from '../enums/http-status.enum';
import { PipeTransform } from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil } from '../utils/shared.utils';

export interface ParseDatePipeOptions {
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
  /**
   * Default value for the date
   */
  default?: () => Date;
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (error: string) => any;
}

@Injectable()
export class ParseDatePipe
  implements PipeTransform<string | number | undefined | null>
{
  protected exceptionFactory: (error: string) => any;

  constructor(private readonly options: ParseDatePipeOptions = {}) {
    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;

    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  transform(
    value: string | number | undefined | null,
  ): Date | null | undefined {
    if (this.options.optional && isNil(value)) {
      return this.options.default ? this.options.default() : value;
    }

    if (!value) {
      throw this.exceptionFactory('Validation failed (no Date provided)');
    }

    const transformedValue = new Date(value);

    if (isNaN(transformedValue.getTime())) {
      throw this.exceptionFactory('Validation failed (invalid date format)');
    }

    return transformedValue;
  }
}



================================================
FILE: packages/common/pipes/parse-enum.pipe.ts
================================================
import { Injectable, Optional } from '../decorators/core';
import { ArgumentMetadata, HttpStatus } from '../index';
import { PipeTransform } from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ParseEnumPipeOptions {
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (error: string) => any;
}

/**
 * Defines the built-in ParseEnum Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseEnumPipe<T = any> implements PipeTransform<T> {
  protected exceptionFactory: (error: string) => any;
  constructor(
    protected readonly enumType: T,
    @Optional() protected readonly options?: ParseEnumPipeOptions,
  ) {
    if (!enumType) {
      throw new Error(
        `"ParseEnumPipe" requires "enumType" argument specified (to validate input values).`,
      );
    }
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;

    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  async transform(value: T, metadata: ArgumentMetadata): Promise<T> {
    if (isNil(value) && this.options?.optional) {
      return value;
    }
    if (!this.isEnum(value)) {
      throw this.exceptionFactory(
        'Validation failed (enum string is expected)',
      );
    }
    return value;
  }

  protected isEnum(value: T): boolean {
    const enumValues = Object.keys(this.enumType as object).map(
      item => this.enumType[item],
    );
    return enumValues.includes(value);
  }
}



================================================
FILE: packages/common/pipes/parse-float.pipe.ts
================================================
import { Injectable, Optional } from '../decorators/core';
import { ArgumentMetadata, HttpStatus } from '../index';
import { PipeTransform } from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ParseFloatPipeOptions {
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (error: string) => any;
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
}

/**
 * Defines the built-in ParseFloat Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseFloatPipe implements PipeTransform<string> {
  protected exceptionFactory: (error: string) => any;

  constructor(@Optional() protected readonly options?: ParseFloatPipeOptions) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;

    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  async transform(value: string, metadata: ArgumentMetadata): Promise<number> {
    if (isNil(value) && this.options?.optional) {
      return value;
    }
    if (!this.isNumeric(value)) {
      throw this.exceptionFactory(
        'Validation failed (numeric string is expected)',
      );
    }
    return parseFloat(value);
  }

  /**
   * @param value currently processed route argument
   * @returns `true` if `value` is a valid float number
   */
  protected isNumeric(value: string): boolean {
    return (
      ['string', 'number'].includes(typeof value) &&
      !isNaN(parseFloat(value)) &&
      isFinite(value as any)
    );
  }
}



================================================
FILE: packages/common/pipes/parse-int.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import { Optional } from '../decorators/core/optional.decorator';
import { HttpStatus } from '../enums/http-status.enum';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ParseIntPipeOptions {
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (error: string) => any;
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
}

/**
 * Defines the built-in ParseInt Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseIntPipe implements PipeTransform<string> {
  protected exceptionFactory: (error: string) => any;

  constructor(@Optional() protected readonly options?: ParseIntPipeOptions) {
    options = options || {};
    const { exceptionFactory, errorHttpStatusCode = HttpStatus.BAD_REQUEST } =
      options;

    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  /**
   * Method that accesses and performs optional transformation on argument for
   * in-flight requests.
   *
   * @param value currently processed route argument
   * @param metadata contains metadata about the currently processed route argument
   */
  async transform(value: string, metadata: ArgumentMetadata): Promise<number> {
    if (isNil(value) && this.options?.optional) {
      return value;
    }
    if (!this.isNumeric(value)) {
      throw this.exceptionFactory(
        'Validation failed (numeric string is expected)',
      );
    }
    return parseInt(value, 10);
  }

  /**
   * @param value currently processed route argument
   * @returns `true` if `value` is a valid integer number
   */
  protected isNumeric(value: string): boolean {
    return (
      ['string', 'number'].includes(typeof value) &&
      /^-?\d+$/.test(value) &&
      isFinite(value as any)
    );
  }
}



================================================
FILE: packages/common/pipes/parse-uuid.pipe.ts
================================================
import { Injectable } from '../decorators/core/injectable.decorator';
import { Optional } from '../decorators/core/optional.decorator';
import { HttpStatus } from '../enums/http-status.enum';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { isNil, isString } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ParseUUIDPipeOptions {
  /**
   * UUID version to validate
   */
  version?: '3' | '4' | '5' | '7';
  /**
   * The HTTP status code to be used in the response when the validation fails.
   */
  errorHttpStatusCode?: ErrorHttpStatusCode;
  /**
   * A factory function that returns an exception object to be thrown
   * if validation fails.
   * @param error Error message
   * @returns The exception object
   */
  exceptionFactory?: (errors: string) => any;
  /**
   * If true, the pipe will return null or undefined if the value is not provided
   * @default false
   */
  optional?: boolean;
}

/**
 * Defines the built-in ParseUUID Pipe
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseUUIDPipe implements PipeTransform<string> {
  protected static uuidRegExps = {
    3: /^[0-9A-F]{8}-[0-9A-F]{4}-3[0-9A-F]{3}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
    4: /^[0-9A-F]{8}-[0-9A-F]{4}-4[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    5: /^[0-9A-F]{8}-[0-9A-F]{4}-5[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    7: /^[0-9A-F]{8}-[0-9A-F]{4}-7[0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i,
    all: /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i,
  };
  private readonly version: '3' | '4' | '5' | '7' | undefined;
  protected exceptionFactory: (errors: string) => any;

  constructor(@Optional() protected readonly options?: ParseUUIDPipeOptions) {
    options = options || {};
    const {
      exceptionFactory,
      errorHttpStatusCode = HttpStatus.BAD_REQUEST,
      version,
    } = options;

    this.version = version;
    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));
  }

  async transform(value: string, metadata: ArgumentMetadata): Promise<string> {
    if (isNil(value) && this.options?.optional) {
      return value;
    }
    if (!this.isUUID(value, this.version)) {
      throw this.exceptionFactory(
        `Validation failed (uuid${
          this.version ? ` v ${this.version}` : ''
        } is expected)`,
      );
    }
    return value;
  }

  protected isUUID(str: unknown, version = 'all') {
    if (!isString(str)) {
      throw this.exceptionFactory('The value passed as UUID is not a string');
    }
    const pattern = ParseUUIDPipe.uuidRegExps[version];
    return pattern?.test(str);
  }
}



================================================
FILE: packages/common/pipes/validation.pipe.ts
================================================
import { iterate } from 'iterare';
import { types } from 'util';
import { Optional } from '../decorators';
import { Injectable } from '../decorators/core';
import { HttpStatus } from '../enums/http-status.enum';
import { ClassTransformOptions } from '../interfaces/external/class-transform-options.interface';
import { TransformerPackage } from '../interfaces/external/transformer-package.interface';
import { ValidationError } from '../interfaces/external/validation-error.interface';
import { ValidatorOptions } from '../interfaces/external/validator-options.interface';
import { ValidatorPackage } from '../interfaces/external/validator-package.interface';
import {
  ArgumentMetadata,
  PipeTransform,
} from '../interfaces/features/pipe-transform.interface';
import { Type } from '../interfaces/type.interface';
import {
  ErrorHttpStatusCode,
  HttpErrorByCode,
} from '../utils/http-error-by-code.util';
import { loadPackage } from '../utils/load-package.util';
import { isNil, isUndefined } from '../utils/shared.utils';

/**
 * @publicApi
 */
export interface ValidationPipeOptions extends ValidatorOptions {
  transform?: boolean;
  disableErrorMessages?: boolean;
  transformOptions?: ClassTransformOptions;
  errorHttpStatusCode?: ErrorHttpStatusCode;
  exceptionFactory?: (errors: ValidationError[]) => any;
  validateCustomDecorators?: boolean;
  expectedType?: Type<any>;
  validatorPackage?: ValidatorPackage;
  transformerPackage?: TransformerPackage;
}

let classValidator: ValidatorPackage = {} as any;
let classTransformer: TransformerPackage = {} as any;

/**
 * @see [Validation](https://docs.nestjs.com/techniques/validation)
 *
 * @publicApi
 */
@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  protected isTransformEnabled: boolean;
  protected isDetailedOutputDisabled?: boolean;
  protected validatorOptions: ValidatorOptions;
  protected transformOptions: ClassTransformOptions | undefined;
  protected errorHttpStatusCode: ErrorHttpStatusCode;
  protected expectedType: Type<any> | undefined;
  protected exceptionFactory: (errors: ValidationError[]) => any;
  protected validateCustomDecorators: boolean;

  constructor(@Optional() options?: ValidationPipeOptions) {
    options = options || {};
    const {
      transform,
      disableErrorMessages,
      errorHttpStatusCode,
      expectedType,
      transformOptions,
      validateCustomDecorators,
      ...validatorOptions
    } = options;

    // @see https://github.com/nestjs/nest/issues/10683#issuecomment-1413690508
    this.validatorOptions = { forbidUnknownValues: false, ...validatorOptions };

    this.isTransformEnabled = !!transform;
    this.transformOptions = transformOptions;
    this.isDetailedOutputDisabled = disableErrorMessages;
    this.validateCustomDecorators = validateCustomDecorators || false;
    this.errorHttpStatusCode = errorHttpStatusCode || HttpStatus.BAD_REQUEST;
    this.expectedType = expectedType;
    this.exceptionFactory =
      options.exceptionFactory || this.createExceptionFactory();

    classValidator = this.loadValidator(options.validatorPackage);
    classTransformer = this.loadTransformer(options.transformerPackage);
  }

  protected loadValidator(
    validatorPackage?: ValidatorPackage,
  ): ValidatorPackage {
    return (
      validatorPackage ??
      loadPackage('class-validator', 'ValidationPipe', () =>
        require('class-validator'),
      )
    );
  }

  protected loadTransformer(
    transformerPackage?: TransformerPackage,
  ): TransformerPackage {
    return (
      transformerPackage ??
      loadPackage('class-transformer', 'ValidationPipe', () =>
        require('class-transformer'),
      )
    );
  }

  public async transform(value: any, metadata: ArgumentMetadata) {
    if (this.expectedType) {
      metadata = { ...metadata, metatype: this.expectedType };
    }

    const metatype = metadata.metatype;
    if (!metatype || !this.toValidate(metadata)) {
      return this.isTransformEnabled
        ? this.transformPrimitive(value, metadata)
        : value;
    }
    const originalValue = value;
    value = this.toEmptyIfNil(value, metatype);

    const isNil = value !== originalValue;
    const isPrimitive = this.isPrimitive(value);
    this.stripProtoKeys(value);
    let entity = classTransformer.plainToInstance(
      metatype,
      value,
      this.transformOptions,
    );

    const originalEntity = entity;
    const isCtorNotEqual = entity.constructor !== metatype;

    if (isCtorNotEqual && !isPrimitive) {
      entity.constructor = metatype;
    } else if (isCtorNotEqual) {
      // when "entity" is a primitive value, we have to temporarily
      // replace the entity to perform the validation against the original
      // metatype defined inside the handler
      entity = { constructor: metatype };
    }

    const errors = await this.validate(entity, this.validatorOptions);
    if (errors.length > 0) {
      throw await this.exceptionFactory(errors);
    }

    if (originalValue === undefined && originalEntity === '') {
      // Since SWC requires empty string for validation (to avoid an error),
      // a fallback is needed to revert to the original value (when undefined).
      // @see https://github.com/nestjs/nest/issues/14430
      return originalValue;
    }
    if (isPrimitive) {
      // if the value is a primitive value and the validation process has been successfully completed
      // we have to revert the original value passed through the pipe
      entity = originalEntity;
    }
    if (this.isTransformEnabled) {
      return entity;
    }
    if (isNil) {
      // if the value was originally undefined or null, revert it back
      return originalValue;
    }

    // we check if the number of keys of the "validatorOptions" is higher than 1 (instead of 0)
    // because the "forbidUnknownValues" now fallbacks to "false" (in case it wasn't explicitly specified)
    const shouldTransformToPlain =
      Object.keys(this.validatorOptions).length > 1;
    return shouldTransformToPlain
      ? classTransformer.classToPlain(entity, this.transformOptions)
      : value;
  }

  public createExceptionFactory() {
    return (validationErrors: ValidationError[] = []) => {
      if (this.isDetailedOutputDisabled) {
        return new HttpErrorByCode[this.errorHttpStatusCode]();
      }
      const errors = this.flattenValidationErrors(validationErrors);
      return new HttpErrorByCode[this.errorHttpStatusCode](errors);
    };
  }

  protected toValidate(metadata: ArgumentMetadata): boolean {
    const { metatype, type } = metadata;
    if (type === 'custom' && !this.validateCustomDecorators) {
      return false;
    }
    const types = [String, Boolean, Number, Array, Object, Buffer, Date];
    return !types.some(t => metatype === t) && !isNil(metatype);
  }

  protected transformPrimitive(value: any, metadata: ArgumentMetadata) {
    if (!metadata.data) {
      // leave top-level query/param objects unmodified
      return value;
    }
    const { type, metatype } = metadata;
    if (type !== 'param' && type !== 'query') {
      return value;
    }
    if (metatype === Boolean) {
      if (isUndefined(value)) {
        // This is an workaround to deal with optional boolean values since
        // optional booleans shouldn't be parsed to a valid boolean when
        // they were not defined
        return undefined;
      }
      // Any fasly value but `undefined` will be parsed to `false`
      return value === true || value === 'true';
    }
    if (metatype === Number) {
      if (isUndefined(value)) {
        // This is a workaround to deal with optional numeric values since
        // optional numerics shouldn't be parsed to a valid number when
        // they were not defined
        return undefined;
      }
      return +value;
    }
    if (metatype === String && !isUndefined(value)) {
      return String(value);
    }
    return value;
  }

  protected toEmptyIfNil<T = any, R = T>(
    value: T,
    metatype: Type<unknown> | object,
  ): R | object | string {
    if (!isNil(value)) {
      return value as any as R;
    }
    if (
      typeof metatype === 'function' ||
      (metatype && 'prototype' in metatype && metatype.prototype?.constructor)
    ) {
      return {} as object;
    }
    // SWC requires empty string to be returned instead of an empty object
    // when the value is nil and the metatype is not a class instance, but a plain object (enum, for example).
    // Otherwise, the error will be thrown.
    // @see https://github.com/nestjs/nest/issues/12680
    return '';
  }

  protected stripProtoKeys(value: any) {
    if (
      value == null ||
      typeof value !== 'object' ||
      types.isTypedArray(value)
    ) {
      return;
    }
    if (Array.isArray(value)) {
      for (const v of value) {
        this.stripProtoKeys(v);
      }
      return;
    }
    delete value.__proto__;
    for (const key in value) {
      this.stripProtoKeys(value[key]);
    }
  }

  protected isPrimitive(value: unknown): boolean {
    return ['number', 'boolean', 'string'].includes(typeof value);
  }

  protected validate(
    object: object,
    validatorOptions?: ValidatorOptions,
  ): Promise<ValidationError[]> | ValidationError[] {
    return classValidator.validate(object, validatorOptions);
  }

  protected flattenValidationErrors(
    validationErrors: ValidationError[],
  ): string[] {
    return iterate(validationErrors)
      .map(error => this.mapChildrenToValidationErrors(error))
      .flatten()
      .filter(item => !!item.constraints)
      .map(item => Object.values(item.constraints!))
      .flatten()
      .toArray();
  }

  protected mapChildrenToValidationErrors(
    error: ValidationError,
    parentPath?: string,
  ): ValidationError[] {
    if (!(error.children && error.children.length)) {
      return [error];
    }
    const validationErrors: ValidationError[] = [];
    parentPath = parentPath
      ? `${parentPath}.${error.property}`
      : error.property;
    for (const item of error.children) {
      if (item.children && item.children.length) {
        validationErrors.push(
          ...this.mapChildrenToValidationErrors(item, parentPath),
        );
      }
      validationErrors.push(
        this.prependConstraintsWithParentProp(parentPath, item),
      );
    }
    return validationErrors;
  }

  protected prependConstraintsWithParentProp(
    parentPath: string,
    error: ValidationError,
  ): ValidationError {
    const constraints = {};
    for (const key in error.constraints) {
      constraints[key] = `${parentPath}.${error.constraints[key]}`;
    }
    return {
      ...error,
      constraints,
    };
  }
}



================================================
FILE: packages/common/pipes/file/file-type.validator.ts
================================================
import { FileValidator } from './file-validator.interface';
import { IFile } from './interfaces';

export type FileTypeValidatorOptions = {
  fileType: string | RegExp;
};

/**
 * Defines the built-in FileType File Validator. It validates incoming files mime-type
 * matching a string or a regular expression. Note that this validator uses a naive strategy
 * to check the mime-type and could be fooled if the client provided a file with renamed extension.
 * (for instance, renaming a 'malicious.bat' to 'malicious.jpeg'). To handle such security issues
 * with more reliability, consider checking against the file's [magic-numbers](https://en.wikipedia.org/wiki/Magic_number_%28programming%29)
 *
 * @see [File Validators](https://docs.nestjs.com/techniques/file-upload#validators)
 *
 * @publicApi
 */
export class FileTypeValidator extends FileValidator<
  FileTypeValidatorOptions,
  IFile
> {
  buildErrorMessage(file?: IFile): string {
    if (file?.mimetype) {
      return `Validation failed (current file type is ${file.mimetype}, expected type is ${this.validationOptions.fileType})`;
    }
    return `Validation failed (expected type is ${this.validationOptions.fileType})`;
  }

  isValid(file?: IFile): boolean {
    if (!this.validationOptions) {
      return true;
    }

    return (
      !!file &&
      'mimetype' in file &&
      !!file.mimetype.match(this.validationOptions.fileType)
    );
  }
}



================================================
FILE: packages/common/pipes/file/file-validator.interface.ts
================================================
import { IFile } from './interfaces';

/**
 * Interface describing FileValidators, which can be added to a ParseFilePipe
 *
 * @see {ParseFilePipe}
 * @publicApi
 */
export abstract class FileValidator<
  TValidationOptions = Record<string, any>,
  TFile extends IFile = IFile,
> {
  constructor(protected readonly validationOptions: TValidationOptions) {}

  /**
   * Indicates if this file should be considered valid, according to the options passed in the constructor.
   * @param file the file from the request object
   */
  abstract isValid(
    file?: TFile | TFile[] | Record<string, TFile[]>,
  ): boolean | Promise<boolean>;

  /**
   * Builds an error message in case the validation fails.
   * @param file the file from the request object
   */
  abstract buildErrorMessage(file: any): string;
}



================================================
FILE: packages/common/pipes/file/index.ts
================================================
export * from './file-type.validator';
export * from './file-validator.interface';
export * from './max-file-size.validator';
export * from './parse-file-options.interface';
export * from './parse-file.pipe';
export * from './parse-file-pipe.builder';



================================================
FILE: packages/common/pipes/file/max-file-size.validator.ts
================================================
import { FileValidator } from './file-validator.interface';
import { IFile } from './interfaces';

export type MaxFileSizeValidatorOptions = {
  maxSize: number;
  message?: string | ((maxSize: number) => string);
};

/**
 * Defines the built-in MaxSize File Validator
 *
 * @see [File Validators](https://docs.nestjs.com/techniques/file-upload#file-validation)
 *
 * @publicApi
 */
export class MaxFileSizeValidator extends FileValidator<
  MaxFileSizeValidatorOptions,
  IFile
> {
  buildErrorMessage(file?: IFile): string {
    if ('message' in this.validationOptions) {
      if (typeof this.validationOptions.message === 'function') {
        return this.validationOptions.message(this.validationOptions.maxSize);
      }

      return this.validationOptions.message!;
    }

    if (file?.size) {
      return `Validation failed (current file size is ${file.size}, expected size is less than ${this.validationOptions.maxSize})`;
    }
    return `Validation failed (expected size is less than ${this.validationOptions.maxSize})`;
  }

  public isValid(file?: IFile): boolean {
    if (!this.validationOptions || !file) {
      return true;
    }

    return 'size' in file && file.size < this.validationOptions.maxSize;
  }
}



================================================
FILE: packages/common/pipes/file/parse-file-options.interface.ts
================================================
import { ErrorHttpStatusCode } from '../../utils/http-error-by-code.util';
import { FileValidator } from './file-validator.interface';

/**
 * @publicApi
 */
export interface ParseFileOptions {
  validators?: FileValidator[];
  errorHttpStatusCode?: ErrorHttpStatusCode;
  exceptionFactory?: (error: string) => any;

  /**
   * Defines if file parameter is required.
   * @default true
   */
  fileIsRequired?: boolean;
}



================================================
FILE: packages/common/pipes/file/parse-file-pipe.builder.ts
================================================
import {
  FileTypeValidator,
  FileTypeValidatorOptions,
} from './file-type.validator';
import { FileValidator } from './file-validator.interface';
import {
  MaxFileSizeValidator,
  MaxFileSizeValidatorOptions,
} from './max-file-size.validator';
import { ParseFileOptions } from './parse-file-options.interface';
import { ParseFilePipe } from './parse-file.pipe';

/**
 * @publicApi
 */
export class ParseFilePipeBuilder {
  private validators: FileValidator[] = [];

  addMaxSizeValidator(options: MaxFileSizeValidatorOptions) {
    return this.addValidator(new MaxFileSizeValidator(options));
  }

  addFileTypeValidator(options: FileTypeValidatorOptions) {
    return this.addValidator(new FileTypeValidator(options));
  }

  addValidator(validator: FileValidator) {
    this.validators.push(validator);
    return this;
  }

  build(
    additionalOptions?: Omit<ParseFileOptions, 'validators'>,
  ): ParseFilePipe {
    const parseFilePipe = new ParseFilePipe({
      ...additionalOptions,
      validators: this.validators,
    });

    this.validators = [];
    return parseFilePipe;
  }
}



================================================
FILE: packages/common/pipes/file/parse-file.pipe.ts
================================================
import { Injectable, Optional } from '../../decorators/core';
import { HttpStatus } from '../../enums';
import { PipeTransform } from '../../interfaces/features/pipe-transform.interface';
import { HttpErrorByCode } from '../../utils/http-error-by-code.util';
import { isEmpty, isObject, isUndefined } from '../../utils/shared.utils';
import { FileValidator } from './file-validator.interface';
import { ParseFileOptions } from './parse-file-options.interface';

/**
 * Defines the built-in ParseFile Pipe. This pipe can be used to validate incoming files
 * with `@UploadedFile()` decorator. You can use either other specific built-in validators
 * or provide one of your own, simply implementing it through FileValidator interface
 * and adding it to ParseFilePipe's constructor.
 *
 * @see [Built-in Pipes](https://docs.nestjs.com/pipes#built-in-pipes)
 *
 * @publicApi
 */
@Injectable()
export class ParseFilePipe implements PipeTransform<any> {
  protected exceptionFactory: (error: string) => any;
  private readonly validators: FileValidator[];
  private readonly fileIsRequired: boolean;

  constructor(@Optional() options: ParseFileOptions = {}) {
    const {
      exceptionFactory,
      errorHttpStatusCode = HttpStatus.BAD_REQUEST,
      validators = [],
      fileIsRequired,
    } = options;

    this.exceptionFactory =
      exceptionFactory ||
      (error => new HttpErrorByCode[errorHttpStatusCode](error));

    this.validators = validators;
    this.fileIsRequired = fileIsRequired ?? true;
  }

  async transform(value: any): Promise<any> {
    const areThereAnyFilesIn = this.thereAreNoFilesIn(value);

    if (areThereAnyFilesIn && this.fileIsRequired) {
      throw this.exceptionFactory('File is required');
    }
    if (!areThereAnyFilesIn && this.validators.length) {
      await this.validateFilesOrFile(value);
    }

    return value;
  }

  private async validateFilesOrFile(value: any): Promise<void> {
    if (Array.isArray(value)) {
      await Promise.all(value.map(f => this.validate(f)));
    } else {
      await this.validate(value);
    }
  }

  private thereAreNoFilesIn(value: any): boolean {
    const isEmptyArray = Array.isArray(value) && isEmpty(value);
    const isEmptyObject = isObject(value) && isEmpty(Object.keys(value));
    return isUndefined(value) || isEmptyArray || isEmptyObject;
  }

  protected async validate(file: any): Promise<any> {
    for (const validator of this.validators) {
      await this.validateOrThrow(file, validator);
    }
    return file;
  }

  private async validateOrThrow(file: any, validator: FileValidator) {
    const isValid = await validator.isValid(file);

    if (!isValid) {
      const errorMessage = validator.buildErrorMessage(file);
      throw this.exceptionFactory(errorMessage);
    }
  }

  /**
   * @returns list of validators used in this pipe.
   */
  getValidators() {
    return this.validators;
  }
}



================================================
FILE: packages/common/pipes/file/interfaces/file.interface.ts
================================================
export interface IFile {
  mimetype: string;
  size: number;
}



================================================
FILE: packages/common/pipes/file/interfaces/index.ts
================================================
export * from './file.interface';



================================================
FILE: packages/common/serializer/class-serializer.constants.ts
================================================
export const CLASS_SERIALIZER_OPTIONS = 'class_serializer:options';



================================================
FILE: packages/common/serializer/class-serializer.interceptor.ts
================================================
import { ClassSerializerContextOptions } from './class-serializer.interfaces';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Inject, Injectable, Optional } from '../decorators/core';
import { StreamableFile } from '../file-stream';
import { CallHandler, ExecutionContext, NestInterceptor } from '../interfaces';
import { ClassTransformOptions } from '../interfaces/external/class-transform-options.interface';
import { TransformerPackage } from '../interfaces/external/transformer-package.interface';
import { loadPackage } from '../utils/load-package.util';
import { isObject } from '../utils/shared.utils';
import { CLASS_SERIALIZER_OPTIONS } from './class-serializer.constants';

let classTransformer: TransformerPackage = {} as any;

export interface PlainLiteralObject {
  [key: string]: any;
}

// NOTE (external)
// We need to deduplicate them here due to the circular dependency
// between core and common packages
const REFLECTOR = 'Reflector';

/**
 * @publicApi
 */
export interface ClassSerializerInterceptorOptions
  extends ClassTransformOptions {
  transformerPackage?: TransformerPackage;
}

/**
 * @publicApi
 */
@Injectable()
export class ClassSerializerInterceptor implements NestInterceptor {
  constructor(
    @Inject(REFLECTOR) protected readonly reflector: any,
    @Optional()
    protected readonly defaultOptions: ClassSerializerInterceptorOptions = {},
  ) {
    classTransformer =
      defaultOptions?.transformerPackage ??
      loadPackage('class-transformer', 'ClassSerializerInterceptor', () =>
        require('class-transformer'),
      );

    if (!defaultOptions?.transformerPackage) {
      require('class-transformer');
    }
  }

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const contextOptions = this.getContextOptions(context);
    const options = {
      ...this.defaultOptions,
      ...contextOptions,
    };
    return next
      .handle()
      .pipe(
        map((res: PlainLiteralObject | Array<PlainLiteralObject>) =>
          this.serialize(res, options),
        ),
      );
  }

  /**
   * Serializes responses that are non-null objects nor streamable files.
   */
  serialize(
    response: PlainLiteralObject | Array<PlainLiteralObject>,
    options: ClassSerializerContextOptions,
  ): PlainLiteralObject | Array<PlainLiteralObject> {
    if (!isObject(response) || response instanceof StreamableFile) {
      return response;
    }

    return Array.isArray(response)
      ? response.map(item => this.transformToPlain(item, options))
      : this.transformToPlain(response, options);
  }

  transformToPlain(
    plainOrClass: any,
    options: ClassSerializerContextOptions,
  ): PlainLiteralObject {
    if (!plainOrClass) {
      return plainOrClass;
    }
    if (!options.type) {
      return classTransformer.classToPlain(plainOrClass, options);
    }
    if (plainOrClass instanceof options.type) {
      return classTransformer.classToPlain(plainOrClass, options);
    }
    const instance = classTransformer.plainToInstance(
      options.type,
      plainOrClass,
      options,
    );
    return classTransformer.classToPlain(instance, options);
  }

  protected getContextOptions(
    context: ExecutionContext,
  ): ClassSerializerContextOptions | undefined {
    return this.reflector.getAllAndOverride(CLASS_SERIALIZER_OPTIONS, [
      context.getHandler(),
      context.getClass(),
    ]);
  }
}



================================================
FILE: packages/common/serializer/class-serializer.interfaces.ts
================================================
import { ClassTransformOptions } from '../interfaces/external/class-transform-options.interface';
import { Type } from '../interfaces';

/**
 * @publicApi
 */
export interface ClassSerializerContextOptions extends ClassTransformOptions {
  type?: Type<any>;
}



================================================
FILE: packages/common/serializer/index.ts
================================================
export * from './class-serializer.interceptor';
export * from './decorators';
export * from './class-serializer.interfaces';



================================================
FILE: packages/common/serializer/decorators/index.ts
================================================
export * from './serialize-options.decorator';



================================================
FILE: packages/common/serializer/decorators/serialize-options.decorator.ts
================================================
import { SetMetadata } from '../../decorators';
import { ClassSerializerContextOptions } from '../class-serializer.interfaces';
import { CLASS_SERIALIZER_OPTIONS } from '../class-serializer.constants';

/**
 * @publicApi
 */
export const SerializeOptions = (options: ClassSerializerContextOptions) =>
  SetMetadata(CLASS_SERIALIZER_OPTIONS, options);



================================================
FILE: packages/common/services/console-logger.service.ts
================================================
import { inspect, InspectOptions } from 'util';
import { Injectable, Optional } from '../decorators/core';
import { clc, yellow } from '../utils/cli-colors.util';
import {
  isFunction,
  isPlainObject,
  isString,
  isUndefined,
} from '../utils/shared.utils';
import { LoggerService, LogLevel } from './logger.service';
import { isLogLevelEnabled } from './utils';

const DEFAULT_DEPTH = 5;

export interface ConsoleLoggerOptions {
  /**
   * Enabled log levels.
   */
  logLevels?: LogLevel[];
  /**
   * If enabled, will print timestamp (time difference) between current and previous log message.
   * Note: This option is not used when `json` is enabled.
   */
  timestamp?: boolean;
  /**
   * A prefix to be used for each log message.
   * Note: This option is not used when `json` is enabled.
   */
  prefix?: string;
  /**
   * If enabled, will print the log message in JSON format.
   */
  json?: boolean;
  /**
   * If enabled, will print the log message in color.
   * Default true if json is disabled, false otherwise
   */
  colors?: boolean;
  /**
   * The context of the logger.
   */
  context?: string;
  /**
   * If enabled, will print the log message in a single line, even if it is an object with multiple properties.
   * If set to a number, the most n inner elements are united on a single line as long as all properties fit into breakLength. Short array elements are also grouped together.
   * Default true when `json` is enabled, false otherwise.
   */
  compact?: boolean | number;
  /**
   * Specifies the maximum number of Array, TypedArray, Map, Set, WeakMap, and WeakSet elements to include when formatting.
   * Set to null or Infinity to show all elements. Set to 0 or negative to show no elements.
   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
   * @default 100
   */
  maxArrayLength?: number;
  /**
   * Specifies the maximum number of characters to include when formatting.
   * Set to null or Infinity to show all elements. Set to 0 or negative to show no characters.
   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
   * @default 10000.
   */
  maxStringLength?: number;
  /**
   * If enabled, will sort keys while formatting objects.
   * Can also be a custom sorting function.
   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
   * @default false
   */
  sorted?: boolean | ((a: string, b: string) => number);
  /**
   * Specifies the number of times to recurse while formatting object. T
   * This is useful for inspecting large objects. To recurse up to the maximum call stack size pass Infinity or null.
   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
   * @default 5
   */
  depth?: number;
  /**
   * If true, object's non-enumerable symbols and properties are included in the formatted result.
   * WeakMap and WeakSet entries are also included as well as user defined prototype properties
   * @default false
   */
  showHidden?: boolean;
  /**
   * The length at which input values are split across multiple lines. Set to Infinity to format the input as a single line (in combination with "compact" set to true).
   * Default Infinity when "compact" is true, 80 otherwise.
   * Ignored when `json` is enabled, colors are disabled, and `compact` is set to true as it produces a parseable JSON output.
   */
  breakLength?: number;
}

const DEFAULT_LOG_LEVELS: LogLevel[] = [
  'log',
  'error',
  'warn',
  'debug',
  'verbose',
  'fatal',
];

const dateTimeFormatter = new Intl.DateTimeFormat(undefined, {
  year: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric',
  day: '2-digit',
  month: '2-digit',
});

@Injectable()
export class ConsoleLogger implements LoggerService {
  /**
   * The options of the logger.
   */
  protected options: ConsoleLoggerOptions;
  /**
   * The context of the logger (can be set manually or automatically inferred).
   */
  protected context?: string;
  /**
   * The original context of the logger (set in the constructor).
   */
  protected originalContext?: string;
  /**
   * The options used for the "inspect" method.
   */
  protected inspectOptions: InspectOptions;
  /**
   * The last timestamp at which the log message was printed.
   */
  protected static lastTimestampAt?: number;

  constructor();
  constructor(context: string);
  constructor(options: ConsoleLoggerOptions);
  constructor(context: string, options: ConsoleLoggerOptions);
  constructor(
    @Optional()
    contextOrOptions?: string | ConsoleLoggerOptions,
    @Optional()
    options?: ConsoleLoggerOptions,
  ) {
    // eslint-disable-next-line prefer-const
    let [context, opts] = isString(contextOrOptions)
      ? [contextOrOptions, options]
      : options
        ? [undefined, options]
        : [contextOrOptions?.context, contextOrOptions];

    opts = opts ?? {};
    opts.logLevels ??= DEFAULT_LOG_LEVELS;
    opts.colors ??= opts.colors ?? (opts.json ? false : true);
    opts.prefix ??= 'Nest';

    this.options = opts;
    this.inspectOptions = this.getInspectOptions();

    if (context) {
      this.context = context;
      this.originalContext = context;
    }
  }

  /**
   * Write a 'log' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  log(message: any, context?: string): void;
  log(message: any, ...optionalParams: [...any, string?]): void;
  log(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('log')) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message,
      ...optionalParams,
    ]);
    this.printMessages(messages, context, 'log');
  }

  /**
   * Write an 'error' level log, if the configured level allows for it.
   * Prints to `stderr` with newline.
   */
  error(message: any, stackOrContext?: string): void;
  error(message: any, stack?: string, context?: string): void;
  error(message: any, ...optionalParams: [...any, string?, string?]): void;
  error(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('error')) {
      return;
    }
    const { messages, context, stack } =
      this.getContextAndStackAndMessagesToPrint([message, ...optionalParams]);

    this.printMessages(messages, context, 'error', 'stderr', stack);
    this.printStackTrace(stack!);
  }

  /**
   * Write a 'warn' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  warn(message: any, context?: string): void;
  warn(message: any, ...optionalParams: [...any, string?]): void;
  warn(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('warn')) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message,
      ...optionalParams,
    ]);
    this.printMessages(messages, context, 'warn');
  }

  /**
   * Write a 'debug' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  debug(message: any, context?: string): void;
  debug(message: any, ...optionalParams: [...any, string?]): void;
  debug(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('debug')) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message,
      ...optionalParams,
    ]);
    this.printMessages(messages, context, 'debug');
  }

  /**
   * Write a 'verbose' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  verbose(message: any, context?: string): void;
  verbose(message: any, ...optionalParams: [...any, string?]): void;
  verbose(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('verbose')) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message,
      ...optionalParams,
    ]);
    this.printMessages(messages, context, 'verbose');
  }

  /**
   * Write a 'fatal' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  fatal(message: any, context?: string): void;
  fatal(message: any, ...optionalParams: [...any, string?]): void;
  fatal(message: any, ...optionalParams: any[]) {
    if (!this.isLevelEnabled('fatal')) {
      return;
    }
    const { messages, context } = this.getContextAndMessagesToPrint([
      message,
      ...optionalParams,
    ]);
    this.printMessages(messages, context, 'fatal');
  }

  /**
   * Set log levels
   * @param levels log levels
   */
  setLogLevels(levels: LogLevel[]) {
    if (!this.options) {
      this.options = {};
    }
    this.options.logLevels = levels;
  }

  /**
   * Set logger context
   * @param context context
   */
  setContext(context: string) {
    this.context = context;
  }

  /**
   * Resets the logger context to the value that was passed in the constructor.
   */
  resetContext() {
    this.context = this.originalContext;
  }

  isLevelEnabled(level: LogLevel): boolean {
    const logLevels = this.options?.logLevels;
    return isLogLevelEnabled(level, logLevels);
  }

  protected getTimestamp(): string {
    return dateTimeFormatter.format(Date.now());
  }

  protected printMessages(
    messages: unknown[],
    context = '',
    logLevel: LogLevel = 'log',
    writeStreamType?: 'stdout' | 'stderr',
    errorStack?: unknown,
  ) {
    messages.forEach(message => {
      if (this.options.json) {
        this.printAsJson(message, {
          context,
          logLevel,
          writeStreamType,
          errorStack,
        });
        return;
      }
      const pidMessage = this.formatPid(process.pid);
      const contextMessage = this.formatContext(context);
      const timestampDiff = this.updateAndGetTimestampDiff();
      const formattedLogLevel = logLevel.toUpperCase().padStart(7, ' ');
      const formattedMessage = this.formatMessage(
        logLevel,
        message,
        pidMessage,
        formattedLogLevel,
        contextMessage,
        timestampDiff,
      );

      process[writeStreamType ?? 'stdout'].write(formattedMessage);
    });
  }

  protected printAsJson(
    message: unknown,
    options: {
      context: string;
      logLevel: LogLevel;
      writeStreamType?: 'stdout' | 'stderr';
      errorStack?: unknown;
    },
  ) {
    type JsonLogObject = {
      level: LogLevel;
      pid: number;
      timestamp: number;
      message: unknown;
      context?: string;
      stack?: unknown;
    };

    const logObject: JsonLogObject = {
      level: options.logLevel,
      pid: process.pid,
      timestamp: Date.now(),
      message,
    };

    if (options.context) {
      logObject.context = options.context;
    }

    if (options.errorStack) {
      logObject.stack = options.errorStack;
    }

    const formattedMessage =
      !this.options.colors && this.inspectOptions.compact === true
        ? JSON.stringify(logObject, this.stringifyReplacer)
        : inspect(logObject, this.inspectOptions);
    process[options.writeStreamType ?? 'stdout'].write(`${formattedMessage}\n`);
  }

  protected formatPid(pid: number) {
    return `[${this.options.prefix}] ${pid}  - `;
  }

  protected formatContext(context: string): string {
    if (!context) {
      return '';
    }

    context = `[${context}] `;
    return this.options.colors ? yellow(context) : context;
  }

  protected formatMessage(
    logLevel: LogLevel,
    message: unknown,
    pidMessage: string,
    formattedLogLevel: string,
    contextMessage: string,
    timestampDiff: string,
  ) {
    const output = this.stringifyMessage(message, logLevel);
    pidMessage = this.colorize(pidMessage, logLevel);
    formattedLogLevel = this.colorize(formattedLogLevel, logLevel);
    return `${pidMessage}${this.getTimestamp()} ${formattedLogLevel} ${contextMessage}${output}${timestampDiff}\n`;
  }

  protected stringifyMessage(message: unknown, logLevel: LogLevel) {
    if (isFunction(message)) {
      const messageAsStr = Function.prototype.toString.call(message);
      const isClass = messageAsStr.startsWith('class ');
      if (isClass) {
        // If the message is a class, we will display the class name.
        return this.stringifyMessage(message.name, logLevel);
      }
      // If the message is a non-class function, call it and re-resolve its value.
      return this.stringifyMessage(message(), logLevel);
    }

    if (typeof message === 'string') {
      return this.colorize(message, logLevel);
    }

    const outputText = inspect(message, this.inspectOptions);
    if (isPlainObject(message)) {
      return `Object(${Object.keys(message).length}) ${outputText}`;
    }
    if (Array.isArray(message)) {
      return `Array(${message.length}) ${outputText}`;
    }
    return outputText;
  }

  protected colorize(message: string, logLevel: LogLevel) {
    if (!this.options.colors || this.options.json) {
      return message;
    }
    const color = this.getColorByLogLevel(logLevel);
    return color(message);
  }

  protected printStackTrace(stack: string) {
    if (!stack || this.options.json) {
      return;
    }
    process.stderr.write(`${stack}\n`);
  }

  protected updateAndGetTimestampDiff(): string {
    const includeTimestamp =
      ConsoleLogger.lastTimestampAt && this.options?.timestamp;
    const result = includeTimestamp
      ? this.formatTimestampDiff(Date.now() - ConsoleLogger.lastTimestampAt!)
      : '';
    ConsoleLogger.lastTimestampAt = Date.now();
    return result;
  }

  protected formatTimestampDiff(timestampDiff: number) {
    const formattedDiff = ` +${timestampDiff}ms`;
    return this.options.colors ? yellow(formattedDiff) : formattedDiff;
  }

  protected getInspectOptions() {
    let breakLength = this.options.breakLength;
    if (typeof breakLength === 'undefined') {
      breakLength = this.options.colors
        ? this.options.compact
          ? Infinity
          : undefined
        : this.options.compact === false
          ? undefined
          : Infinity; // default breakLength to Infinity if inline is not set and colors is false
    }

    const inspectOptions: InspectOptions = {
      depth: this.options.depth ?? DEFAULT_DEPTH,
      sorted: this.options.sorted,
      showHidden: this.options.showHidden,
      compact: this.options.compact ?? (this.options.json ? true : false),
      colors: this.options.colors,
      breakLength,
    };

    if (this.options.maxArrayLength) {
      inspectOptions.maxArrayLength = this.options.maxArrayLength;
    }
    if (this.options.maxStringLength) {
      inspectOptions.maxStringLength = this.options.maxStringLength;
    }

    return inspectOptions;
  }

  protected stringifyReplacer(key: string, value: unknown) {
    // Mimic util.inspect behavior for JSON logger with compact on and colors off
    if (typeof value === 'bigint') {
      return value.toString();
    }
    if (typeof value === 'symbol') {
      return value.toString();
    }

    if (
      value instanceof Map ||
      value instanceof Set ||
      value instanceof Error
    ) {
      return `${inspect(value, this.inspectOptions)}`;
    }
    return value;
  }

  private getContextAndMessagesToPrint(args: unknown[]) {
    if (args?.length <= 1) {
      return { messages: args, context: this.context };
    }
    const lastElement = args[args.length - 1];
    const isContext = isString(lastElement);
    if (!isContext) {
      return { messages: args, context: this.context };
    }
    return {
      context: lastElement,
      messages: args.slice(0, args.length - 1),
    };
  }

  private getContextAndStackAndMessagesToPrint(args: unknown[]) {
    if (args.length === 2) {
      return this.isStackFormat(args[1])
        ? {
            messages: [args[0]],
            stack: args[1] as string,
            context: this.context,
          }
        : {
            messages: [args[0]],
            context: args[1] as string,
          };
    }

    const { messages, context } = this.getContextAndMessagesToPrint(args);
    if (messages?.length <= 1) {
      return { messages, context };
    }
    const lastElement = messages[messages.length - 1];
    const isStack = isString(lastElement);
    // https://github.com/nestjs/nest/issues/11074#issuecomment-1421680060
    if (!isStack && !isUndefined(lastElement)) {
      return { messages, context };
    }
    return {
      stack: lastElement,
      messages: messages.slice(0, messages.length - 1),
      context,
    };
  }

  private isStackFormat(stack: unknown) {
    if (!isString(stack) && !isUndefined(stack)) {
      return false;
    }

    return /^(.)+\n\s+at .+:\d+:\d+/.test(stack!);
  }

  private getColorByLogLevel(level: LogLevel) {
    switch (level) {
      case 'debug':
        return clc.magentaBright;
      case 'warn':
        return clc.yellow;
      case 'error':
        return clc.red;
      case 'verbose':
        return clc.cyanBright;
      case 'fatal':
        return clc.bold;
      default:
        return clc.green;
    }
  }
}



================================================
FILE: packages/common/services/index.ts
================================================
export * from './console-logger.service';
export * from './logger.service';



================================================
FILE: packages/common/services/logger.service.ts
================================================
import { Injectable, Optional } from '../decorators/core';
import { isObject } from '../utils/shared.utils';
import { ConsoleLogger } from './console-logger.service';
import { isLogLevelEnabled } from './utils';

/**
 * @publicApi
 */
export type LogLevel = 'log' | 'error' | 'warn' | 'debug' | 'verbose' | 'fatal';

/**
 * @publicApi
 */
export interface LoggerService {
  /**
   * Write a 'log' level log.
   */
  log(message: any, ...optionalParams: any[]): any;

  /**
   * Write an 'error' level log.
   */
  error(message: any, ...optionalParams: any[]): any;

  /**
   * Write a 'warn' level log.
   */
  warn(message: any, ...optionalParams: any[]): any;

  /**
   * Write a 'debug' level log.
   */
  debug?(message: any, ...optionalParams: any[]): any;

  /**
   * Write a 'verbose' level log.
   */
  verbose?(message: any, ...optionalParams: any[]): any;

  /**
   * Write a 'fatal' level log.
   */
  fatal?(message: any, ...optionalParams: any[]): any;

  /**
   * Set log levels.
   * @param levels log levels
   */
  setLogLevels?(levels: LogLevel[]): any;
}

interface LogBufferRecord {
  /**
   * Method to execute.
   */
  methodRef: Function;

  /**
   * Arguments to pass to the method.
   */
  arguments: unknown[];
}

const DEFAULT_LOGGER = new ConsoleLogger();

const dateTimeFormatter = new Intl.DateTimeFormat(undefined, {
  year: 'numeric',
  hour: 'numeric',
  minute: 'numeric',
  second: 'numeric',
  day: '2-digit',
  month: '2-digit',
});

/**
 * @publicApi
 */
@Injectable()
export class Logger implements LoggerService {
  protected static logBuffer = new Array<LogBufferRecord>();
  protected static staticInstanceRef?: LoggerService = DEFAULT_LOGGER;
  protected static logLevels?: LogLevel[];
  private static isBufferAttached: boolean;

  protected localInstanceRef?: LoggerService;

  private static WrapBuffer: MethodDecorator = (
    target: object,
    propertyKey: string | symbol,
    descriptor: TypedPropertyDescriptor<any>,
  ) => {
    const originalFn = descriptor.value;
    descriptor.value = function (...args: unknown[]) {
      if (Logger.isBufferAttached) {
        Logger.logBuffer.push({
          methodRef: originalFn.bind(this),
          arguments: args,
        });
        return;
      }
      return originalFn.call(this, ...args);
    };
  };

  constructor();
  constructor(context: string);
  constructor(context: string, options?: { timestamp?: boolean });
  constructor(
    @Optional() protected context?: string,
    @Optional() protected options: { timestamp?: boolean } = {},
  ) {}

  get localInstance(): LoggerService {
    if (Logger.staticInstanceRef === DEFAULT_LOGGER) {
      return this.registerLocalInstanceRef();
    } else if (Logger.staticInstanceRef instanceof Logger) {
      const prototype = Object.getPrototypeOf(Logger.staticInstanceRef);
      if (prototype.constructor === Logger) {
        return this.registerLocalInstanceRef();
      }
    }
    return Logger.staticInstanceRef!;
  }

  /**
   * Write an 'error' level log.
   */
  error(message: any, stack?: string, context?: string): void;
  error(message: any, ...optionalParams: [...any, string?, string?]): void;
  @Logger.WrapBuffer
  error(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? (optionalParams.length ? optionalParams : [undefined]).concat(
          this.context,
        )
      : optionalParams;

    this.localInstance?.error(message, ...optionalParams);
  }

  /**
   * Write a 'log' level log.
   */
  log(message: any, context?: string): void;
  log(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  log(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? optionalParams.concat(this.context)
      : optionalParams;
    this.localInstance?.log(message, ...optionalParams);
  }

  /**
   * Write a 'warn' level log.
   */
  warn(message: any, context?: string): void;
  warn(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  warn(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? optionalParams.concat(this.context)
      : optionalParams;
    this.localInstance?.warn(message, ...optionalParams);
  }

  /**
   * Write a 'debug' level log.
   */
  debug(message: any, context?: string): void;
  debug(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  debug(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? optionalParams.concat(this.context)
      : optionalParams;
    this.localInstance?.debug?.(message, ...optionalParams);
  }

  /**
   * Write a 'verbose' level log.
   */
  verbose(message: any, context?: string): void;
  verbose(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  verbose(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? optionalParams.concat(this.context)
      : optionalParams;
    this.localInstance?.verbose?.(message, ...optionalParams);
  }

  /**
   * Write a 'fatal' level log.
   */
  fatal(message: any, context?: string): void;
  fatal(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  fatal(message: any, ...optionalParams: any[]) {
    optionalParams = this.context
      ? optionalParams.concat(this.context)
      : optionalParams;
    this.localInstance?.fatal?.(message, ...optionalParams);
  }

  /**
   * Write an 'error' level log.
   */
  static error(message: any, stackOrContext?: string): void;
  static error(message: any, context?: string): void;
  static error(message: any, stack?: string, context?: string): void;
  static error(
    message: any,
    ...optionalParams: [...any, string?, string?]
  ): void;
  @Logger.WrapBuffer
  static error(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.error(message, ...optionalParams);
  }

  /**
   * Write a 'log' level log.
   */
  static log(message: any, context?: string): void;
  static log(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  static log(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.log(message, ...optionalParams);
  }

  /**
   * Write a 'warn' level log.
   */
  static warn(message: any, context?: string): void;
  static warn(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  static warn(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.warn(message, ...optionalParams);
  }

  /**
   * Write a 'debug' level log, if the configured level allows for it.
   * Prints to `stdout` with newline.
   */
  static debug(message: any, context?: string): void;
  static debug(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  static debug(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.debug?.(message, ...optionalParams);
  }

  /**
   * Write a 'verbose' level log.
   */
  static verbose(message: any, context?: string): void;
  static verbose(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  static verbose(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.verbose?.(message, ...optionalParams);
  }

  /**
   * Write a 'fatal' level log.
   */
  static fatal(message: any, context?: string): void;
  static fatal(message: any, ...optionalParams: [...any, string?]): void;
  @Logger.WrapBuffer
  static fatal(message: any, ...optionalParams: any[]) {
    this.staticInstanceRef?.fatal?.(message, ...optionalParams);
  }

  /**
   * Print buffered logs and detach buffer.
   */
  static flush() {
    this.isBufferAttached = false;
    this.logBuffer.forEach(item =>
      item.methodRef(...(item.arguments as [string])),
    );
    this.logBuffer = [];
  }

  /**
   * Attach buffer.
   * Turns on initialization logs buffering.
   */
  static attachBuffer() {
    this.isBufferAttached = true;
  }

  /**
   * Detach buffer.
   * Turns off initialization logs buffering.
   */
  static detachBuffer() {
    this.isBufferAttached = false;
  }

  static getTimestamp() {
    return dateTimeFormatter.format(Date.now());
  }

  static overrideLogger(logger: LoggerService | LogLevel[] | boolean) {
    if (Array.isArray(logger)) {
      Logger.logLevels = logger;
      return this.staticInstanceRef?.setLogLevels?.(logger);
    }
    if (isObject(logger)) {
      if (logger instanceof Logger && logger.constructor !== Logger) {
        const errorMessage = `Using the "extends Logger" instruction is not allowed in Nest v9. Please, use "extends ConsoleLogger" instead.`;
        this.staticInstanceRef?.error(errorMessage);
        throw new Error(errorMessage);
      }
      this.staticInstanceRef = logger as LoggerService;
    } else {
      this.staticInstanceRef = undefined;
    }
  }

  static isLevelEnabled(level: LogLevel): boolean {
    const logLevels = Logger.logLevels;
    return isLogLevelEnabled(level, logLevels);
  }

  private registerLocalInstanceRef() {
    if (this.localInstanceRef) {
      return this.localInstanceRef;
    }
    this.localInstanceRef = new ConsoleLogger(this.context!, {
      timestamp: this.options?.timestamp,
      logLevels: Logger.logLevels,
    });
    return this.localInstanceRef;
  }
}



================================================
FILE: packages/common/services/utils/index.ts
================================================
export * from './is-log-level-enabled.util';



================================================
FILE: packages/common/services/utils/is-log-level-enabled.util.ts
================================================
import { LogLevel } from '../logger.service';

const LOG_LEVEL_VALUES: Record<LogLevel, number> = {
  verbose: 0,
  debug: 1,
  log: 2,
  warn: 3,
  error: 4,
  fatal: 5,
};

/**
 * Checks if target level is enabled.
 * @param targetLevel target level
 * @param logLevels array of enabled log levels
 */
export function isLogLevelEnabled(
  targetLevel: LogLevel,
  logLevels: LogLevel[] | undefined,
): boolean {
  if (!logLevels || (Array.isArray(logLevels) && logLevels?.length === 0)) {
    return false;
  }
  if (logLevels.includes(targetLevel)) {
    return true;
  }
  const highestLogLevelValue = logLevels
    .map(level => LOG_LEVEL_VALUES[level])
    .sort((a, b) => b - a)?.[0];

  const targetLevelValue = LOG_LEVEL_VALUES[targetLevel];
  return targetLevelValue >= highestLogLevelValue;
}



================================================
FILE: packages/common/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/common/test/decorators/apply-decorators.spec.ts
================================================
import { expect } from 'chai';
import { GUARDS_METADATA } from '../../constants';
import { applyDecorators, UseGuards } from '../../decorators';
import { CanActivate } from '../../interfaces';

describe('applyDecorators', () => {
  function testDecorator1(param: number) {
    return (target: any) => {
      target.myParam = param;
    };
  }

  function testDecorator2(param1: number, param2: number) {
    return (target: any) => {
      target.myParam = (target.myParam || 0) + param1;
      target.myParam2 = param2;
    };
  }

  function testDecorator3() {
    return (target: any) => {
      target.myParam3 = 0;
    };
  }

  it('should apply all decorators', () => {
    const testParams = {
      decorator1: { param: 1 },
      decorator2: { param1: 2, param2: 3 },
    };

    const decoratedTarget = {};
    testDecorator1(testParams.decorator1.param)(decoratedTarget);
    testDecorator2(
      testParams.decorator2.param1,
      testParams.decorator2.param2,
    )(decoratedTarget);
    testDecorator3()(decoratedTarget);

    const customDecoratedTarget = {};
    const customDecorator = applyDecorators(
      testDecorator1(testParams.decorator1.param),
      testDecorator2(
        testParams.decorator2.param1,
        testParams.decorator2.param2,
      ),
      testDecorator3(),
    );
    customDecorator(customDecoratedTarget);

    const expectedTarget = {
      myParam: testParams.decorator1.param + testParams.decorator2.param1,
      myParam2: testParams.decorator2.param2,
      myParam3: 0,
    };

    expect(decoratedTarget).to.be.deep.equal(expectedTarget);
    expect(customDecoratedTarget).to.be.deep.equal(expectedTarget);
  });
});

class Guard implements CanActivate {
  canActivate() {
    return true;
  }
}

const GuardCompositeDecorator = () => {
  return applyDecorators(UseGuards(Guard));
};

describe('applyDecorators @GuardCompositeDecorator', () => {
  @GuardCompositeDecorator()
  class Test {}

  class TestWithMethod {
    @GuardCompositeDecorator()
    public test() {
      return true;
    }
  }

  class TestWithStaticMethod {
    @GuardCompositeDecorator()
    public static test() {
      return true;
    }
  }

  it('should be using the guard defined on the class', () => {
    const classMetadata = Reflect.getMetadata(GUARDS_METADATA, Test);
    expect(classMetadata).to.deep.equal([Guard]);
  });

  it('should be using the guard defined on the prototype method', () => {
    const instance = new TestWithMethod();

    const classMetadata = Reflect.getMetadata(GUARDS_METADATA, TestWithMethod);
    const methodMetadata = Reflect.getMetadata(GUARDS_METADATA, instance.test);
    const instanceMetadata = Reflect.getMetadata(GUARDS_METADATA, instance);

    expect(classMetadata).to.be.undefined;
    expect(methodMetadata).to.deep.equal([Guard]);
    expect(instanceMetadata).to.be.undefined;
  });

  it('should be using the guard defined on the static method', () => {
    const classMetadata = Reflect.getMetadata(
      GUARDS_METADATA,
      TestWithStaticMethod,
    );
    const methodMetadata = Reflect.getMetadata(
      GUARDS_METADATA,
      TestWithStaticMethod.test,
    );

    expect(classMetadata).to.be.undefined;
    expect(methodMetadata).to.deep.equal([Guard]);
  });
});



================================================
FILE: packages/common/test/decorators/bind.decorator.spec.ts
================================================
import { expect } from 'chai';
import { ROUTE_ARGS_METADATA } from '../../constants';
import { Bind } from '../../decorators/core/bind.decorator';
import { Req } from '../../decorators/http/route-params.decorator';

describe('@Bind', () => {
  class TestWithMethod {
    @Bind(Req())
    public test() {}
  }

  it('should enhance method - bind each decorator to method', () => {
    const metadata = Reflect.getMetadata(
      ROUTE_ARGS_METADATA,
      TestWithMethod,
      'test',
    );

    expect(metadata).to.be.deep.equal({
      '0:0': {
        data: undefined,
        index: 0,
        pipes: [],
      },
    });
  });
});



================================================
FILE: packages/common/test/decorators/catch.decorator.spec.ts
================================================
import { expect } from 'chai';
import { CATCH_WATERMARK, FILTER_CATCH_EXCEPTIONS } from '../../constants';
import { Catch } from '../../decorators/core/catch.decorator';

describe('@Catch', () => {
  const exceptions: any = ['exception', 'exception2'];

  @Catch(...exceptions)
  class Test {}

  it(`should enhance component with "${CATCH_WATERMARK}" metadata`, () => {
    const catchWatermark = Reflect.getMetadata(CATCH_WATERMARK, Test);

    expect(catchWatermark).to.be.true;
  });

  it('should enhance class with expected exceptions array', () => {
    const metadata = Reflect.getMetadata(FILTER_CATCH_EXCEPTIONS, Test);
    expect(metadata).to.be.eql(exceptions);
  });
});



================================================
FILE: packages/common/test/decorators/controller.decorator.spec.ts
================================================
import { expect } from 'chai';
import { VERSION_METADATA, CONTROLLER_WATERMARK } from '../../constants';
import { Controller } from '../../decorators/core/controller.decorator';

describe('@Controller', () => {
  const reflectedPath = 'test';
  const reflectedHost = 'api.example.com';
  const reflectedHostArray = ['api1.example.com', 'api2.example.com'];
  const reflectedVersion = '1';
  const reflectedVersionWithDuplicates = ['1', '2', '2', '1', '2', '1'];
  const reflectedVersionWithoutDuplicates = ['1', '2'];

  @Controller()
  class EmptyDecorator {}

  @Controller(reflectedPath)
  class Test {}

  @Controller({ path: reflectedPath, host: reflectedHost })
  class PathAndHostDecorator {}

  @Controller({ path: reflectedPath, host: reflectedHostArray })
  class PathAndHostArrayDecorator {}

  @Controller({ host: reflectedHost })
  class HostOnlyDecorator {}

  @Controller({
    path: reflectedPath,
    host: reflectedHost,
    version: reflectedVersion,
  })
  class PathAndHostAndVersionDecorator {}

  @Controller({ version: reflectedVersion })
  class VersionOnlyDecorator {}

  @Controller({ version: reflectedVersionWithDuplicates })
  class VersionOnlyArrayDecorator {}

  it(`should enhance component with "${CONTROLLER_WATERMARK}" metadata`, () => {
    const controllerWatermark = Reflect.getMetadata(
      CONTROLLER_WATERMARK,
      EmptyDecorator,
    );

    expect(controllerWatermark).to.be.true;
  });

  it('should enhance controller with expected path metadata', () => {
    const path = Reflect.getMetadata('path', Test);
    expect(path).to.be.eql(reflectedPath);
    const path2 = Reflect.getMetadata('path', PathAndHostDecorator);
    expect(path2).to.be.eql(reflectedPath);
    const path3 = Reflect.getMetadata('path', PathAndHostAndVersionDecorator);
    expect(path3).to.be.eql(reflectedPath);
  });

  it('should enhance controller with expected host metadata', () => {
    const host = Reflect.getMetadata('host', PathAndHostDecorator);
    expect(host).to.be.eql(reflectedHost);
    const host2 = Reflect.getMetadata('host', HostOnlyDecorator);
    expect(host2).to.be.eql(reflectedHost);
    const host3 = Reflect.getMetadata('host', PathAndHostArrayDecorator);
    expect(host3).to.be.eql(reflectedHostArray);
    const host4 = Reflect.getMetadata('host', PathAndHostAndVersionDecorator);
    expect(host4).to.be.eql(reflectedHost);
  });

  it('should enhance controller with expected version metadata', () => {
    const version = Reflect.getMetadata(
      VERSION_METADATA,
      PathAndHostAndVersionDecorator,
    );
    expect(version).to.be.eql(reflectedVersion);
    const version2 = Reflect.getMetadata(
      VERSION_METADATA,
      VersionOnlyDecorator,
    );
    expect(version2).to.be.eql(reflectedVersion);
    const version3 = Reflect.getMetadata(
      VERSION_METADATA,
      VersionOnlyArrayDecorator,
    );
    expect(version3).to.be.eql(reflectedVersionWithoutDuplicates);
  });

  it('should set default path when no object passed as param', () => {
    const path = Reflect.getMetadata('path', EmptyDecorator);
    expect(path).to.be.eql('/');
    const path2 = Reflect.getMetadata('path', HostOnlyDecorator);
    expect(path2).to.be.eql('/');
    const path3 = Reflect.getMetadata('path', VersionOnlyDecorator);
    expect(path3).to.be.eql('/');
  });

  it('should not set host when no host passed as param', () => {
    const host = Reflect.getMetadata('host', Test);
    expect(host).to.be.undefined;
    const host2 = Reflect.getMetadata('host', EmptyDecorator);
    expect(host2).to.be.undefined;
  });

  it('should not set version when no version passed as param', () => {
    const version = Reflect.getMetadata(VERSION_METADATA, Test);
    expect(version).to.be.undefined;
    const version2 = Reflect.getMetadata(VERSION_METADATA, EmptyDecorator);
    expect(version2).to.be.undefined;
  });
});



================================================
FILE: packages/common/test/decorators/create-param-decorator.spec.ts
================================================
import { expect } from 'chai';
import { ROUTE_ARGS_METADATA } from '../../constants';
import { createParamDecorator } from '../../decorators/http/create-route-param-metadata.decorator';
import { ParseIntPipe } from '../../index';

describe('createParamDecorator', () => {
  let result;

  beforeEach(() => {
    const fn = (data, req) => true;
    result = createParamDecorator(fn);
  });
  it('should return a function as a first element', () => {
    expect(result).to.be.a('function');
  });
  describe('returned decorator', () => {
    const factoryFn = (data, req) => true;
    const Decorator = createParamDecorator(factoryFn);

    describe('when 0 pipes have been passed', () => {
      const data = { data: 'test' };
      class Test {
        public test(@Decorator(data) param) {}
      }
      it('should enhance param with "data"', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data,
          factory: factoryFn,
          index: 0,
          pipes: [],
        });
      });
    });

    describe('when > 0 pipes have been passed', () => {
      const data = 'test';
      const pipe = new ParseIntPipe();
      class Test {
        public test(
          @Decorator(data, pipe)
          param,
        ) {}

        public testNoData(@Decorator(pipe) param) {}

        public testNoDataClass(@Decorator(ParseIntPipe) param) {}
      }
      it('should enhance param with "data" and ParseIntPipe', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: 'test',
          factory: factoryFn,
          index: 0,
          pipes: [pipe],
        });
      });

      it('should enhance param with ParseIntPipe', () => {
        const metadata = Reflect.getMetadata(
          ROUTE_ARGS_METADATA,
          Test,
          'testNoData',
        );
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: undefined,
          factory: factoryFn,
          index: 0,
          pipes: [pipe],
        });
      });

      it('should enhance param with ParseIntPipe metatype', () => {
        const metadata = Reflect.getMetadata(
          ROUTE_ARGS_METADATA,
          Test,
          'testNoDataClass',
        );
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: undefined,
          factory: factoryFn,
          index: 0,
          pipes: [ParseIntPipe],
        });
      });
    });

    describe('when class type passed as data', () => {
      class Data {}
      class Test {
        public test(@Decorator(Data) prop) {}
      }

      it('should return class type as data parameter', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key].data).to.equal(Data);
      });
    });
  });

  describe('returned generic typed decorator', () => {
    const factoryFn = (data, req) => true;
    interface User {
      name: string;
    }

    const stringOnlyDecorator = createParamDecorator<string>(factoryFn);
    const stringOrNumberDecorator = createParamDecorator<string | number>(
      factoryFn,
    );
    const customTypeDecorator = createParamDecorator<User>(factoryFn);

    describe('when string is passed to stringOnlyDecorator', () => {
      const data = 'test';
      class Test {
        public test(
          @stringOnlyDecorator(data)
          param,
        ) {}
      }
      it('should enhance param with "data" as string', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: 'test',
          factory: factoryFn,
          index: 0,
          pipes: [],
        });
      });
    });

    describe('when number is passed to stringOrNumberDecorator', () => {
      const data = 10;
      class Test {
        public test(
          @stringOrNumberDecorator(data)
          param,
        ) {}
      }
      it('should enhance param with "data" as number', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: 10,
          factory: factoryFn,
          index: 0,
          pipes: [],
        });
      });
    });
    describe('when a custom Type is passed to customTypeDecorator', () => {
      const data = { name: 'john' };
      class Test {
        public test(
          @customTypeDecorator(data)
          param,
        ) {}
      }
      it('should enhance param with "data" as custom Type', () => {
        const metadata = Reflect.getMetadata(ROUTE_ARGS_METADATA, Test, 'test');
        const key = Object.keys(metadata)[0];
        expect(metadata[key]).to.be.eql({
          data: { name: 'john' },
          factory: factoryFn,
          index: 0,
          pipes: [],
        });
      });
    });
  });
});



================================================
FILE: packages/common/test/decorators/dependencies.decorator.spec.ts
================================================
import { expect } from 'chai';
import { Dependencies } from '../../decorators/core/dependencies.decorator';
import { PARAMTYPES_METADATA } from '../../constants';

describe('@Dependencies', () => {
  const dep = 'test',
    dep2 = 'test2';
  const deps = [dep, dep2];

  @Dependencies(deps)
  class Test {}
  @Dependencies(dep, dep2)
  class Test2 {}

  it('should enhance class with expected dependencies array', () => {
    const metadata = Reflect.getMetadata(PARAMTYPES_METADATA, Test);
    expect(metadata).to.be.eql(deps);
  });

  it('should makes passed array flatten', () => {
    const metadata = Reflect.getMetadata(PARAMTYPES_METADATA, Test2);
    expect(metadata).to.be.eql([dep, dep2]);
  });
});



================================================
FILE: packages/common/test/decorators/exception-filters.decorator.spec.ts
================================================
import { expect } from 'chai';
import { EXCEPTION_FILTERS_METADATA } from '../../constants';
import { UseFilters } from '../../decorators/core/exception-filters.decorator';
import { InvalidDecoratorItemException } from '../../utils/validate-each.util';

class Filter {
  catch() {}
}

describe('@UseFilters', () => {
  const filters = [new Filter(), new Filter()];

  @UseFilters(...(filters as any))
  class Test {}

  class TestWithMethod {
    @UseFilters(...(filters as any))
    public static test() {}
  }

  it('should enhance class with expected exception filters array', () => {
    const metadata = Reflect.getMetadata(EXCEPTION_FILTERS_METADATA, Test);
    expect(metadata).to.be.eql(filters);
  });

  it('should enhance method with expected exception filters array', () => {
    const metadata = Reflect.getMetadata(
      EXCEPTION_FILTERS_METADATA,
      TestWithMethod.test,
    );
    expect(metadata).to.be.eql(filters);
  });

  it('when object is invalid should throw exception', () => {
    try {
      UseFilters('test' as any)(() => {});
    } catch (e) {
      expect(e).to.be.instanceof(InvalidDecoratorItemException);
    }
  });
});



================================================
FILE: packages/common/test/decorators/global.decorator.spec.ts
================================================
import { expect } from 'chai';
import { GLOBAL_MODULE_METADATA } from '../../constants';
import { Global } from '../../index';

describe('@Global', () => {
  @Global()
  class Test {}

  it('should enrich metatype with GlobalModule metadata', () => {
    const isGlobal = Reflect.getMetadata(GLOBAL_MODULE_METADATA, Test);
    expect(isGlobal).to.be.true;
  });
});



================================================
FILE: packages/common/test/decorators/header.decorator.spec.ts
================================================
import { expect } from 'chai';
import { Header } from '../../decorators/http';
import { HEADERS_METADATA } from '../../constants';

describe('@Header', () => {
  class Test {
    @Header('Content-Type', 'Test')
    @Header('Authorization', 'JWT')
    public static test() {}
  }

  it('should enhance method with expected template string', () => {
    const metadata = Reflect.getMetadata(HEADERS_METADATA, Test.test);
    expect(metadata).to.be.eql([
      { name: 'Authorization', value: 'JWT' },
      { name: 'Content-Type', value: 'Test' },
    ]);
  });
});



================================================
FILE: packages/common/test/decorators/http-code.decorator.spec.ts
================================================
import { expect } from 'chai';
import { HttpCode } from '../../decorators/http/http-code.decorator';
import { HTTP_CODE_METADATA } from '../../constants';

describe('@HttpCode', () => {
  const httpCode = 200;
  class Test {
    @HttpCode(httpCode)
    public static test() {}
  }

  it('should enhance method with expected http status code', () => {
    const metadata = Reflect.getMetadata(HTTP_CODE_METADATA, Test.test);
    expect(metadata).to.be.eql(httpCode);
  });
});



================================================
FILE: packages/common/test/decorators/inject.decorator.spec.ts
================================================
import { expect } from 'chai';
import { SELF_DECLARED_DEPS_METADATA } from '../../constants';
import { Inject } from '../../index';

describe('@Inject', () => {
  const opaqueToken = () => ({});
  class Test {
    constructor(
      @Inject('test') param,
      @Inject('test2') param2,
      @Inject(opaqueToken) param3,
    ) {}
  }

  it('should enhance class with expected constructor params metadata', () => {
    const metadata = Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, Test);

    const expectedMetadata = [
      { index: 2, param: opaqueToken },
      { index: 1, param: 'test2' },
      { index: 0, param: 'test' },
    ];
    expect(metadata).to.be.eql(expectedMetadata);
  });
});



================================================
FILE: packages/common/test/decorators/injectable.decorator.spec.ts
================================================
import { expect } from 'chai';
import { SCOPE_OPTIONS_METADATA, INJECTABLE_WATERMARK } from '../../constants';
import { Injectable, mixin } from '../../index';

describe('@Injectable', () => {
  const options = {};

  @Injectable(options)
  class TestMiddleware {
    constructor(_param: number, _test: string) {}
  }

  it(`should enhance component with "${INJECTABLE_WATERMARK}" metadata`, () => {
    const injectableWatermark = Reflect.getMetadata(
      INJECTABLE_WATERMARK,
      TestMiddleware,
    );

    expect(injectableWatermark).to.be.eql(true);
  });

  it('should enhance component with "design:paramtypes" metadata', () => {
    const constructorParams = Reflect.getMetadata(
      'design:paramtypes',
      TestMiddleware,
    );

    expect(constructorParams[0]).to.be.eql(Number);
    expect(constructorParams[1]).to.be.eql(String);
  });

  it(`should enhance component with "${SCOPE_OPTIONS_METADATA}" metadata`, () => {
    const constructorParams = Reflect.getMetadata(
      SCOPE_OPTIONS_METADATA,
      TestMiddleware,
    );

    expect(constructorParams).to.be.eql(options);
  });
});

describe('mixin', () => {
  @Injectable()
  class Test {
    constructor(_param: number, _test: string) {}
  }

  it('should set name of metatype', () => {
    const type = mixin(Test);

    expect(type.name).to.not.eql('Test');
  });

  it('should not lost the design:paramtypes metadata', () => {
    const type = mixin(Test);
    const constructorParams = Reflect.getMetadata('design:paramtypes', type);

    expect(constructorParams[0]).to.be.eql(Number);
    expect(constructorParams[1]).to.be.eql(String);
  });
});



================================================
FILE: packages/common/test/decorators/module.decorator.spec.ts
================================================
import { expect } from 'chai';
import { Module } from '../../decorators/modules/module.decorator';

describe('@Module', () => {
  const moduleProps = {
    providers: ['Test'],
    imports: ['Test'],
    exports: ['Test'],
    controllers: ['Test'],
  };

  @Module(moduleProps as any)
  class TestModule {}

  it('should enhance class with expected module metadata', () => {
    const imports = Reflect.getMetadata('imports', TestModule);
    const providers = Reflect.getMetadata('providers', TestModule);
    const exports = Reflect.getMetadata('exports', TestModule);
    const controllers = Reflect.getMetadata('controllers', TestModule);

    expect(imports).to.be.eql(moduleProps.imports);
    expect(providers).to.be.eql(moduleProps.providers);
    expect(controllers).to.be.eql(moduleProps.controllers);
    expect(exports).to.be.eql(moduleProps.exports);
  });

  it('should throw exception when module properties are invalid', () => {
    const invalidProps = {
      ...moduleProps,
      test: [],
    };

    expect(Module.bind(null, invalidProps)).to.throw(Error);
  });
});



================================================
FILE: packages/common/test/decorators/redirect.decorator.spec.ts
================================================
import { expect } from 'chai';
import { REDIRECT_METADATA } from '../../constants';
import { Redirect } from '../../decorators/http/redirect.decorator';
import { HttpStatus } from '../../index';

describe('@Redirect', () => {
  const url = 'http://test.com';
  const statusCode = HttpStatus.FOUND;

  class Test {
    @Redirect(url, statusCode)
    public static test() {}
  }

  it('should enhance method with expected redirect url string', () => {
    const metadata = Reflect.getMetadata(REDIRECT_METADATA, Test.test);
    expect(metadata.url).to.be.eql(url);
  });

  it('should enhance method with expected response code', () => {
    const metadata = Reflect.getMetadata(REDIRECT_METADATA, Test.test);
    expect(metadata.statusCode).to.be.eql(statusCode);
  });
});



================================================
FILE: packages/common/test/decorators/render.decorator.spec.ts
================================================
import { expect } from 'chai';
import { Render } from '../../decorators/http/render.decorator';
import { RENDER_METADATA } from '../../constants';

describe('@Render', () => {
  const template = 'template';

  class Test {
    @Render('template')
    public static test() {}
  }

  it('should enhance method with expected template string', () => {
    const metadata = Reflect.getMetadata(RENDER_METADATA, Test.test);
    expect(metadata).to.be.eql(template);
  });
});



================================================
FILE: packages/common/test/decorators/request-mapping.decorator.spec.ts
================================================
import { expect } from 'chai';
import { RequestMapping } from '../../decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../enums/request-method.enum';

describe('@RequestMapping', () => {
  const requestProps = {
    path: 'test',
    method: RequestMethod.ALL,
  };

  const requestPropsUsingArray = {
    path: ['foo', 'bar'],
    method: RequestMethod.ALL,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @RequestMapping(requestProps)
      public static test() {}

      @RequestMapping(requestPropsUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestProps.path);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPropsUsingArray.path);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set request method on GET by default', () => {
    class Test {
      @RequestMapping({ path: '' })
      public static test() {}
    }

    const method = Reflect.getMetadata('method', Test.test);

    expect(method).to.be.eql(RequestMethod.GET);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @RequestMapping({})
      public static test() {}

      @RequestMapping({ path: [] })
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});



================================================
FILE: packages/common/test/decorators/route-params.decorator.spec.ts
================================================
import { expect } from 'chai';
import { Body, HostParam, Param, Query, Search } from '../../decorators';
import { RequestMethod } from '../../enums/request-method.enum';
import {
  All,
  Delete,
  Get,
  ParseIntPipe,
  Patch,
  Post,
  Put,
  Propfind,
  Proppatch,
  Mkcol,
  Move,
  Copy,
  Lock,
  Unlock,
} from '../../index';
import { ROUTE_ARGS_METADATA } from '../../constants';
import { RouteParamtypes } from '../../enums/route-paramtypes.enum';

describe('@Get', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.GET,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.GET,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Get(requestPath)
      public static test(@Param('id', ParseIntPipe) params) {}

      @Get(requestPathUsingArray)
      public static testUsingArray(@Param('id') params) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const args = Reflect.getMetadata(
      ROUTE_ARGS_METADATA,
      Test.constructor,
      'test',
    );
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(args[`${RouteParamtypes.PARAM}:0`]).to.be.eql({
      index: 0,
      data: 'id',
      pipes: [ParseIntPipe],
    });
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Get()
      public static test() {}

      @Get([])
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Post', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.POST,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.POST,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Post(requestPath)
      public static test() {}

      @Post(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Post()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Post([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Delete', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.DELETE,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.DELETE,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Delete(requestPath)
      public static test(@Body() body) {}

      @Delete(requestPathUsingArray)
      public static testUsingArray(@Body() body) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Delete()
      public static test() {}

      @Delete([])
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@All', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.ALL,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.ALL,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @All(requestPath)
      public static test() {}

      @All(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @All()
      public static test() {}

      @All([])
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Put', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.PUT,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.PUT,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Put(requestPath)
      public static test() {}

      @Put(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Put()
      public static test() {}

      @Put([])
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Patch', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.PATCH,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.PATCH,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Patch(requestPath)
      public static test() {}

      @Patch(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Patch()
      public static test() {}

      @Patch([])
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Search', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.SEARCH,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.SEARCH,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Search(requestPath)
      public static test() {}

      @Search(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Search()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Search([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('Inheritance', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.GET,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.GET,
  };

  it('should enhance subclass with expected request metadata', () => {
    class Parent {
      @Get(requestPath)
      public static test() {}

      @Get(requestPathUsingArray)
      public static testUsingArray() {}
    }

    class Test extends Parent {}

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });
});

describe('@PropFind', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.PROPFIND,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.PROPFIND,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Propfind(requestPath)
      public static test() {}

      @Propfind(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Propfind()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Propfind([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@PropPatch', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.PROPPATCH,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.PROPPATCH,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Proppatch(requestPath)
      public static test() {}

      @Proppatch(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Proppatch()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Proppatch([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@MkCol', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.MKCOL,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.MKCOL,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Mkcol(requestPath)
      public static test() {}

      @Mkcol(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Mkcol()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Mkcol([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Copy', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.COPY,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.COPY,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Copy(requestPath)
      public static test() {}

      @Copy(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Copy()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Copy([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Move', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.MOVE,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.MOVE,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Move(requestPath)
      public static test() {}

      @Move(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Move()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Move([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Lock', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.LOCK,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.LOCK,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Lock(requestPath)
      public static test() {}

      @Lock(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Lock()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Lock([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});

describe('@Unlock', () => {
  const requestPath = 'test';
  const requestProps = {
    path: requestPath,
    method: RequestMethod.UNLOCK,
  };

  const requestPathUsingArray = ['foo', 'bar'];
  const requestPropsUsingArray = {
    path: requestPathUsingArray,
    method: RequestMethod.UNLOCK,
  };

  it('should enhance class with expected request metadata', () => {
    class Test {
      @Unlock(requestPath)
      public static test() {}

      @Unlock(requestPathUsingArray)
      public static testUsingArray() {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const method = Reflect.getMetadata('method', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);
    const methodUsingArray = Reflect.getMetadata('method', Test.testUsingArray);

    expect(path).to.be.eql(requestPath);
    expect(method).to.be.eql(requestProps.method);
    expect(pathUsingArray).to.be.eql(requestPathUsingArray);
    expect(methodUsingArray).to.be.eql(requestPropsUsingArray.method);
  });

  it('should set path on "/" by default', () => {
    class Test {
      @Unlock()
      public static test(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}

      @Unlock([])
      public static testUsingArray(
        @Query() query,
        @Param() params,
        @HostParam() hostParams,
      ) {}
    }

    const path = Reflect.getMetadata('path', Test.test);
    const pathUsingArray = Reflect.getMetadata('path', Test.testUsingArray);

    expect(path).to.be.eql('/');
    expect(pathUsingArray).to.be.eql('/');
  });
});



================================================
FILE: packages/common/test/decorators/set-metadata.decorator.spec.ts
================================================
import { expect } from 'chai';
import { SetMetadata } from '../../decorators/core/set-metadata.decorator';

describe('@SetMetadata', () => {
  const key = 'key',
    value = 'value';

  @SetMetadata(key, value)
  class Test {}

  class TestWithMethod {
    @SetMetadata(key, value)
    public static test() {}
  }

  it('should enhance class with expected metadata', () => {
    const metadata = Reflect.getMetadata(key, Test);
    expect(metadata).to.be.eql(value);
  });

  it('should enhance method with expected metadata', () => {
    const metadata = Reflect.getMetadata(key, TestWithMethod.test);
    expect(metadata).to.be.eql(value);
  });
});



================================================
FILE: packages/common/test/decorators/sse.decorator.spec.ts
================================================
import { expect } from 'chai';
import { METHOD_METADATA, PATH_METADATA, SSE_METADATA } from '../../constants';
import { Sse } from '../../decorators/http/sse.decorator';
import { RequestMethod } from '../../enums/request-method.enum';

describe('@Sse', () => {
  const prefix = '/prefix';
  class Test {
    @Sse(prefix)
    public static test() {}
  }

  it('should enhance method with expected http status code', () => {
    const path = Reflect.getMetadata(PATH_METADATA, Test.test);
    expect(path).to.be.eql('/prefix');

    const method = Reflect.getMetadata(METHOD_METADATA, Test.test);
    expect(method).to.be.eql(RequestMethod.GET);

    const metadata = Reflect.getMetadata(SSE_METADATA, Test.test);
    expect(metadata).to.be.eql(true);
  });
});



================================================
FILE: packages/common/test/decorators/use-guards.decorator.spec.ts
================================================
import { expect } from 'chai';
import { GUARDS_METADATA } from '../../constants';
import { UseGuards } from '../../decorators/core/use-guards.decorator';
import { InvalidDecoratorItemException } from '../../utils/validate-each.util';

class Guard {}

describe('@UseGuards', () => {
  const guards = [Guard, Guard];

  @UseGuards(...guards)
  class Test {}

  class TestWithMethod {
    @UseGuards(...guards)
    public static test() {}
  }

  class Test2 {
    @UseGuards(...guards)
    @UseGuards(...guards)
    public static test() {}
  }

  it('should enhance class with expected guards array', () => {
    const metadata = Reflect.getMetadata(GUARDS_METADATA, Test);
    expect(metadata).to.be.eql(guards);
  });

  it('should enhance method with expected guards array', () => {
    const metadata = Reflect.getMetadata(GUARDS_METADATA, TestWithMethod.test);
    expect(metadata).to.be.eql(guards);
  });

  it('should enhance method with multiple guards array', () => {
    const metadata = Reflect.getMetadata(GUARDS_METADATA, Test2.test);
    expect(metadata).to.be.eql(guards.concat(guards));
  });

  it('should throw exception when object is invalid', () => {
    try {
      UseGuards('test' as any)(() => {});
    } catch (e) {
      expect(e).to.be.instanceof(InvalidDecoratorItemException);
    }
  });
});



================================================
FILE: packages/common/test/decorators/use-interceptors.decorator.spec.ts
================================================
import { expect } from 'chai';
import { INTERCEPTORS_METADATA } from '../../constants';
import { UseInterceptors } from '../../decorators/core/use-interceptors.decorator';
import { InvalidDecoratorItemException } from '../../utils/validate-each.util';

class Interceptor {}

describe('@UseInterceptors', () => {
  const interceptors = [Interceptor, Interceptor];

  @UseInterceptors(...interceptors)
  class Test {}

  class TestWithMethod {
    @UseInterceptors(...interceptors)
    public static test() {}
  }

  it('should enhance class with expected interceptors array', () => {
    const metadata = Reflect.getMetadata(INTERCEPTORS_METADATA, Test);
    expect(metadata).to.be.eql(interceptors);
  });

  it('should enhance method with expected interceptors array', () => {
    const metadata = Reflect.getMetadata(
      INTERCEPTORS_METADATA,
      TestWithMethod.test,
    );
    expect(metadata).to.be.eql(interceptors);
  });

  it('when object is invalid should throw exception', () => {
    let error = undefined;
    try {
      UseInterceptors('test' as any)({ name: 'target' } as any);
    } catch (e) {
      error = e;
    }
    expect(error).to.be.instanceof(InvalidDecoratorItemException);
  });

  it('when object is valid should not throw exception', () => {
    let error = undefined;
    try {
      UseInterceptors({
        intercept() {
          return null!;
        },
      })({ name: 'target' } as any);
    } catch (e) {
      error = e;
    }
    expect(error).to.be.undefined;
  });
});



================================================
FILE: packages/common/test/decorators/use-pipes.decorator.spec.ts
================================================
import { expect } from 'chai';
import { PIPES_METADATA } from '../../constants';
import { UsePipes } from '../../decorators/core/use-pipes.decorator';
import { InvalidDecoratorItemException } from '../../utils/validate-each.util';

class Pipe {
  transform() {}
}

describe('@UsePipes', () => {
  const pipes = [new Pipe(), new Pipe()];

  @UsePipes(...pipes)
  class Test {}

  class TestWithMethod {
    @UsePipes(...pipes)
    public static test() {}
  }

  it('should enhance class with expected pipes array', () => {
    const metadata = Reflect.getMetadata(PIPES_METADATA, Test);
    expect(metadata).to.be.eql(pipes);
  });

  it('should enhance method with expected pipes array', () => {
    const metadata = Reflect.getMetadata(PIPES_METADATA, TestWithMethod.test);
    expect(metadata).to.be.eql(pipes);
  });

  it('when object is invalid should throw exception', () => {
    try {
      UsePipes('test' as any)(() => {});
    } catch (e) {
      expect(e).to.be.instanceof(InvalidDecoratorItemException);
    }
  });
});



================================================
FILE: packages/common/test/decorators/version.decorator.spec.ts
================================================
import { expect } from 'chai';
import { VERSION_METADATA } from '../../constants';
import { Version } from '../../decorators/core/version.decorator';

describe('@Version', () => {
  const version = '1';
  const versions = ['1', '2', '2', '1', '2', '1'];
  const versionsWithoutDuplicates = ['1', '2'];

  class Test {
    @Version(version)
    public static oneVersion() {}

    @Version(versions)
    public static multipleVersions() {}
  }

  it('should enhance method with expected version string', () => {
    const metadata = Reflect.getMetadata(VERSION_METADATA, Test.oneVersion);
    expect(metadata).to.be.eql(version);
  });

  it('should enhance method with expected version array', () => {
    const metadata = Reflect.getMetadata(
      VERSION_METADATA,
      Test.multipleVersions,
    );
    expect(metadata).to.be.eql(versionsWithoutDuplicates);
  });
});



================================================
FILE: packages/common/test/exceptions/http.exception.spec.ts
================================================
/* eslint-disable @typescript-eslint/restrict-template-expressions */
import { expect } from 'chai';
import { Type } from '../../../common';
import {
  BadGatewayException,
  BadRequestException,
  ConflictException,
  ForbiddenException,
  GatewayTimeoutException,
  GoneException,
  HttpException,
  HttpVersionNotSupportedException,
  ImATeapotException,
  InternalServerErrorException,
  MethodNotAllowedException,
  MisdirectedException,
  NotAcceptableException,
  NotFoundException,
  NotImplementedException,
  PayloadTooLargeException,
  PreconditionFailedException,
  RequestTimeoutException,
  ServiceUnavailableException,
  UnauthorizedException,
  UnprocessableEntityException,
  UnsupportedMediaTypeException,
} from '../../exceptions';

describe('HttpException', () => {
  describe('getResponse', () => {
    it('should return a response as a string when input is a string', () => {
      const message = 'My error message';
      expect(new HttpException(message, 404).getResponse()).to.be.eql(
        'My error message',
      );
    });

    it('should return a response as an object when input is an object', () => {
      const message = {
        msg: 'My error message',
        reason: 'this can be a human readable reason',
        anything: 'else',
      };
      expect(new HttpException(message, 404).getResponse()).to.be.eql(message);
    });

    it('should return a message from a built-in exception as an object', () => {
      const message = 'My error message';
      expect(new BadRequestException(message).getResponse()).to.be.eql({
        statusCode: 400,
        error: 'Bad Request',
        message: 'My error message',
      });
    });

    it('should return an object even when the message is undefined', () => {
      expect(new BadRequestException().getResponse()).to.be.eql({
        statusCode: 400,
        message: 'Bad Request',
      });
    });
  });

  describe('built-in exceptions', () => {
    describe('getStatus', () => {
      it('should return given status code', () => {
        const testCases: [Type<HttpException>, number][] = [
          [BadRequestException, 400],
          [UnauthorizedException, 401],
          [ForbiddenException, 403],
          [NotFoundException, 404],
          [MethodNotAllowedException, 405],
          [NotAcceptableException, 406],
          [RequestTimeoutException, 408],
          [ConflictException, 409],
          [GoneException, 410],
          [PreconditionFailedException, 412],
          [PayloadTooLargeException, 413],
          [UnsupportedMediaTypeException, 415],
          [ImATeapotException, 418],
          [MisdirectedException, 421],
          [UnprocessableEntityException, 422],
          [InternalServerErrorException, 500],
          [NotImplementedException, 501],
          [BadGatewayException, 502],
          [ServiceUnavailableException, 503],
          [GatewayTimeoutException, 504],
          [HttpVersionNotSupportedException, 505],
        ];

        testCases.forEach(([ExceptionClass, expectedStatus]) => {
          expect(new ExceptionClass().getStatus()).to.be.eql(expectedStatus);
        });
      });
    });

    describe('getResponse', () => {
      it('should return a response with default message and status code', () => {
        const testCases: [Type<HttpException>, number, string][] = [
          [BadRequestException, 400, 'Bad Request'],
          [UnauthorizedException, 401, 'Unauthorized'],
          [ForbiddenException, 403, 'Forbidden'],
          [NotFoundException, 404, 'Not Found'],
          [MethodNotAllowedException, 405, 'Method Not Allowed'],
          [NotAcceptableException, 406, 'Not Acceptable'],
          [RequestTimeoutException, 408, 'Request Timeout'],
          [ConflictException, 409, 'Conflict'],
          [GoneException, 410, 'Gone'],
          [PreconditionFailedException, 412, 'Precondition Failed'],
          [PayloadTooLargeException, 413, 'Payload Too Large'],
          [UnsupportedMediaTypeException, 415, 'Unsupported Media Type'],
          [ImATeapotException, 418, "I'm a teapot"],
          [MisdirectedException, 421, 'Misdirected'],
          [UnprocessableEntityException, 422, 'Unprocessable Entity'],
          [InternalServerErrorException, 500, 'Internal Server Error'],
          [NotImplementedException, 501, 'Not Implemented'],
          [BadGatewayException, 502, 'Bad Gateway'],
          [ServiceUnavailableException, 503, 'Service Unavailable'],
          [GatewayTimeoutException, 504, 'Gateway Timeout'],
          [HttpVersionNotSupportedException, 505, 'HTTP Version Not Supported'],
        ];

        testCases.forEach(
          ([ExceptionClass, expectedStatus, expectedMessage]) => {
            expect(new ExceptionClass().getResponse()).to.be.eql({
              message: expectedMessage,
              statusCode: expectedStatus,
            });
          },
        );
      });

      it('should return a response with an "error" attribute when description was provided as the "option" object', () => {
        const badRequestError = new BadRequestException('ErrorMessage', {
          description: 'Some error description',
        });

        expect(badRequestError.getResponse()).to.be.eql({
          message: 'ErrorMessage',
          error: 'Some error description',
          statusCode: 400,
        });
      });
    });
  });

  it('should inherit from error', () => {
    const error = new HttpException('', 400);
    expect(error instanceof Error).to.be.true;
  });

  describe('when serializing', () => {
    describe('and "response" parameter is a string', () => {
      it('should concatenate HttpException with the given message', () => {
        const responseAsString = 'Some Error';
        const error = new HttpException(responseAsString, 400);
        expect(`${error}`).to.be.eql(`HttpException: ${responseAsString}`);
        expect(`${error}`.includes('[object Object]')).to.not.be.true;
      });
    });

    describe('and "response" parameter is an object', () => {
      it('should use default message', () => {
        const responseAsObject = { foo: 'bar' };
        const error = new HttpException(responseAsObject, 400);
        const badRequestError = new BadRequestException(responseAsObject);

        expect(`${error}`).to.be.eql(`HttpException: Http Exception`);
        expect(`${badRequestError}`).to.be.eql(
          `BadRequestException: Bad Request Exception`,
        );
        expect(`${error}`.includes('[object Object]')).to.not.be.true;
        expect(`${badRequestError}`.includes('[object Object]')).to.not.be.true;
      });
    });
  });

  describe('createBody', () => {
    describe('when object has been passed', () => {
      it('should return expected object', () => {
        const object = {
          message: 'test',
        };
        expect(HttpException.createBody(object)).to.be.eql(object);
      });
    });
    describe('when string has been passed', () => {
      it('should return expected object', () => {
        const error = 'test';
        const status = 500;
        const message = 'error';
        expect(HttpException.createBody(message, error, status)).to.be.eql({
          error,
          message,
          statusCode: status,
        });
      });
    });
    describe('when nil has been passed', () => {
      it('should return expected object', () => {
        const status = 500;
        const error = 'error';
        expect(HttpException.createBody(null, error, status)).to.be.eql({
          message: error,
          statusCode: status,
        });
      });
    });
    it('should not override pre-defined body if message is array', () => {
      expect(
        HttpException.createBody(['a', 'random', 'array'], 'error', 200),
      ).to.eql({
        message: ['a', 'random', 'array'],
        error: 'error',
        statusCode: 200,
      });
    });
  });

  describe('initCause', () => {
    const errorCause = new Error('An internal error cause');
    const customDescription = 'custom description';

    it('configures a cause when message is a string and the options object is passed', () => {
      const error = new HttpException(customDescription, 400, {
        cause: errorCause,
      });

      expect(`${error}`).to.be.eql(`HttpException: ${customDescription}`);
      const { cause } = error;

      expect(cause).to.be.eql(errorCause);
    });

    it('configures a cause when using a built-in exception with options', () => {
      const builtInErrorClasses = [
        BadGatewayException,
        BadRequestException,
        ConflictException,
        ForbiddenException,
        GatewayTimeoutException,
        GoneException,
        HttpVersionNotSupportedException,
        ImATeapotException,
        InternalServerErrorException,
        MethodNotAllowedException,
        MisdirectedException,
        NotAcceptableException,
        NotFoundException,
        NotImplementedException,
        PayloadTooLargeException,
        PreconditionFailedException,
        RequestTimeoutException,
        ServiceUnavailableException,
        UnauthorizedException,
        UnprocessableEntityException,
        UnsupportedMediaTypeException,
      ];

      builtInErrorClasses.forEach(ExceptionClass => {
        const error = new ExceptionClass(customDescription, {
          cause: errorCause,
        });

        const { cause } = error;

        expect(cause).to.be.eql(errorCause);
      });
    });
  });
});



================================================
FILE: packages/common/test/file-stream/streamable-file.spec.ts
================================================
import { expect } from 'chai';
import { Readable } from 'stream';
import { StreamableFile } from '../../file-stream';

describe('StreamableFile', () => {
  describe('when input is a readable stream', () => {
    it('should assign it to a stream class property', () => {
      const stream = new Readable();
      const streamableFile = new StreamableFile(stream);
      expect(streamableFile.getStream()).to.equal(stream);
    });
  });
  describe('when input is an object with "pipe" method', () => {
    it('should assign it to a stream class property', () => {
      const stream = { pipe: () => {} };
      const streamableFile = new StreamableFile(stream as any);
      expect(streamableFile.getStream()).to.equal(stream);
    });
  });
  describe('when options is empty', () => {
    it('should return application/octet-stream for type and undefined for others', () => {
      const stream = new Readable();
      const streamableFile = new StreamableFile(stream);
      expect(streamableFile.getHeaders()).to.deep.equal({
        type: 'application/octet-stream',
        disposition: undefined,
        length: undefined,
      });
    });
  });
  describe('when options is defined', () => {
    it('should pass provided headers', () => {
      const stream = new Readable();
      const streamableFile = new StreamableFile(stream, {
        type: 'application/pdf',
        disposition: 'inline',
        length: 100,
      });
      expect(streamableFile.getHeaders()).to.deep.equal({
        type: 'application/pdf',
        disposition: 'inline',
        length: 100,
      });
    });
  });
  describe('otherwise', () => {
    describe('when input is a Buffer instance', () => {
      it('should create a readable stream and push the input buffer', () => {
        const buffer = Buffer.from('test');
        const streamableFile = new StreamableFile(buffer);
        const stream = streamableFile.getStream();
        expect(stream.read()).to.equal(buffer);
      });
    });
    describe('when input is a Uint8Array', () => {
      it('should create a readable stream and push the input buffer', () => {
        const buffer = Uint8Array.from([0xab, 0xcd, 0xef, 0x00]);
        const streamableFile = new StreamableFile(buffer);
        const stream = streamableFile.getStream();
        expect(stream.read()).to.deep.equal(Buffer.from(buffer));
      });
    });
  });
});



================================================
FILE: packages/common/test/module-utils/configurable-module.builder.spec.ts
================================================
import { expect } from 'chai';
import { Provider } from '../../interfaces';
import { ConfigurableModuleBuilder } from '../../module-utils';

describe('ConfigurableModuleBuilder', () => {
  describe('setExtras', () => {
    it('should apply module definition transformer function and return typed builder', () => {
      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
        .setExtras(
          { isGlobal: false },
          (definition, extras: { isGlobal: boolean }) => ({
            ...definition,
            global: extras.isGlobal,
          }),
        )
        .build();

      expect(
        ConfigurableModuleClass.register({
          // No type error
          isGlobal: true,
        }),
      ).to.deep.include({
        global: true,
      });
    });
  });
  describe('setClassMethodName', () => {
    it('should set static class method name and return typed builder', () => {
      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
        .setClassMethodName('forRoot')
        .build();

      expect(ConfigurableModuleClass.forRoot).to.not.be.undefined;
      expect(ConfigurableModuleClass.forRootAsync).to.not.be.undefined;
      expect((ConfigurableModuleClass as any).register).to.be.undefined;
    });
  });
  describe('setFactoryMethodName', () => {
    it('should set configuration factory class method name and return typed builder', () => {
      const { ConfigurableModuleClass } = new ConfigurableModuleBuilder()
        .setFactoryMethodName('createOptions')
        .build();

      expect(
        ConfigurableModuleClass.registerAsync({
          useClass: class {
            // No type error
            createOptions() {}
          },
        }),
      ).to.not.be.undefined;
    });
  });
  describe('build', () => {
    it('should return a fully typed "ConfigurableModuleClass"', () => {
      type ExtraConfig = { isGlobal?: boolean; extraProviders: Provider[] };

      const {
        ConfigurableModuleClass,
        OPTIONS_TYPE,
        ASYNC_OPTIONS_TYPE,
        MODULE_OPTIONS_TOKEN,
      } = new ConfigurableModuleBuilder({
        moduleName: 'RandomTest',
        alwaysTransient: true,
      })
        .setFactoryMethodName('createOptions')
        .setClassMethodName('forFeature')
        .setExtras<ExtraConfig>(
          { isGlobal: false, extraProviders: [] },
          (definition, extras) => ({
            ...definition,
            global: extras.isGlobal,
            providers: definition.providers?.concat(extras.extraProviders),
          }),
        )
        .build();

      const provideInjectionTokensFrom: Provider[] = [
        {
          provide: 'a',
          useFactory: () => {},
          inject: ['b'],
        },
        {
          provide: 'b',
          useFactory: () => {},
          inject: ['x'],
        },
        {
          provide: 'c',
          useFactory: () => {},
          inject: ['y'],
        },
      ];
      const definition = ConfigurableModuleClass.forFeatureAsync({
        useFactory: () => {},
        inject: ['a'],
        provideInjectionTokensFrom,
        isGlobal: true,
        extraProviders: ['test' as any],
      });

      expect(definition.global).to.equal(true);
      expect(definition.providers).to.have.length(5);
      expect(definition.providers).to.deep.contain('test');
      expect(definition.providers).to.include.members(
        provideInjectionTokensFrom.slice(0, 2),
      );
      expect(definition.providers).not.to.include(
        provideInjectionTokensFrom[2],
      );
      expect(MODULE_OPTIONS_TOKEN).to.equal('RANDOM_TEST_MODULE_OPTIONS');
      expect((definition.providers![0] as any).provide).to.equal(
        'RANDOM_TEST_MODULE_OPTIONS',
      );

      try {
        expect(ASYNC_OPTIONS_TYPE.imports).to.equal(undefined);
      } catch (err) {
        expect(err).to.be.instanceOf(Error);
        expect(err.message).to.equal(
          '"ASYNC_OPTIONS_TYPE" is not supposed to be used as a value.',
        );
      }
      try {
        expect(OPTIONS_TYPE.isGlobal).to.equal(undefined);
      } catch (err) {
        expect(err).to.be.instanceOf(Error);
        expect(err.message).to.equal(
          '"OPTIONS_TYPE" is not supposed to be used as a value.',
        );
      }
    });
  });
});



================================================
FILE: packages/common/test/module-utils/utils/get-injection-providers.util.spec.ts
================================================
import { expect } from 'chai';
import { Provider } from '../../../interfaces';
import { getInjectionProviders } from '../../../module-utils/utils/get-injection-providers.util';

describe('getInjectionProviders', () => {
  it('should take only required providers', () => {
    class C {
      static token = 'anything';
    }
    class G {
      static token = 'anything';
      static optional = true;
    }
    class H {
      static token = 'anything';
      static optional = false;
    }
    const providers: Provider[] = [
      {
        //0
        provide: 'a',
        useValue: 'a',
      },
      {
        //1
        provide: 'b',
        useValue: 'b',
      },
      C, //2
      {
        //3
        provide: 'd',
        useFactory: (c, b) => [c, b],
        inject: [
          C,
          {
            token: 'b',
            optional: true,
          },
          'x',
          G,
          H,
        ],
      },
      {
        //4
        provide: 'e',
        useFactory: (d, b) => [d, b],
        inject: ['d', 'b'],
      },
      {
        //5
        provide: 'f',
        useValue: 'f',
      },
      G, //6
      H, //7
    ];

    const expected = [
      providers[1],
      providers[2],
      providers[3],
      providers[4],
      providers[6],
      providers[7],
    ];

    const result = getInjectionProviders(providers, ['e']);

    expect(result).to.have.members(expected);
  });
});



================================================
FILE: packages/common/test/pipes/default-value.pipe.spec.ts
================================================
import { expect } from 'chai';
import { DefaultValuePipe } from '../../pipes/default-value.pipe';

describe('DefaultValuePipe', () => {
  const defaultValue = 'default';
  const target = new DefaultValuePipe(defaultValue);

  describe('transform', () => {
    it('should return original value if one was provided', () => {
      const value = 'value';
      const result = target.transform(value);
      expect(result).to.equal(value);
    });

    it('should return default value if no value was provided', () => {
      const result = target.transform(undefined);
      expect(result).to.equal(defaultValue);
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-array.pipe.spec.ts
================================================
import * as chai from 'chai';
import { expect } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { Type } from 'class-transformer';
import {
  IsBoolean,
  IsDate,
  IsDefined,
  IsNumber,
  IsString,
  ValidateNested,
} from 'class-validator';
import { BadRequestException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces/features/pipe-transform.interface';
import { ParseArrayPipe } from '../../pipes/parse-array.pipe';
chai.use(chaiAsPromised);

describe('ParseArrayPipe', () => {
  let target: ParseArrayPipe;

  describe('transform', () => {
    describe('when undefined value', () => {
      describe('and optional disabled', () => {
        it('should throw an exception', async () => {
          target = new ParseArrayPipe({ optional: false });

          return expect(
            target.transform(undefined, {} as ArgumentMetadata),
          ).to.to.be.rejectedWith(BadRequestException);
        });
      });
      describe('and optional enabled', () => {
        it('should return undefined', async () => {
          target = new ParseArrayPipe({ optional: true });

          expect(await target.transform(undefined, {} as ArgumentMetadata)).to
            .be.undefined;
        });
      });
    });

    describe('when value is not parseable', () => {
      beforeEach(() => {
        target = new ParseArrayPipe();
      });
      it('should throw an exception (boolean)', async () => {
        return expect(
          target.transform(true, {} as ArgumentMetadata),
        ).to.be.rejectedWith(BadRequestException);
      });
      it('should throw an exception (number)', async () => {
        return expect(
          target.transform(3, {} as ArgumentMetadata),
        ).to.be.rejectedWith(BadRequestException);
      });
      it('should throw an exception (object)', async () => {
        return expect(
          target.transform({}, {} as ArgumentMetadata),
        ).to.be.rejectedWith(BadRequestException);
      });

      describe('and "optional" is enabled', () => {
        it('should throw an exception', async () => {
          const pipe = new ParseArrayPipe({
            optional: true,
            items: String,
            separator: ',',
          });
          return expect(
            pipe.transform({}, {} as ArgumentMetadata),
          ).to.be.rejectedWith(BadRequestException);
        });
      });
    });

    describe('when value is parseable (string)', () => {
      it('should parse an array based on the separator', async () => {
        target = new ParseArrayPipe();

        expect(
          await target.transform(
            '1,2.0,3,{},true,null,,',
            {} as ArgumentMetadata,
          ),
        ).to.be.deep.equal(['1', '2.0', '3', '{}', 'true', 'null', '', '']);

        target = new ParseArrayPipe({ separator: '/' });

        expect(
          await target.transform('1/2/3', {} as ArgumentMetadata),
        ).to.be.deep.equal(['1', '2', '3']);

        target = new ParseArrayPipe({ separator: '.' });

        expect(
          await target.transform('1.2.3', {} as ArgumentMetadata),
        ).to.be.deep.equal(['1', '2', '3']);
      });

      describe('and type is specified', () => {
        it('should parse & validate the array', async () => {
          target = new ParseArrayPipe({ separator: '.', items: Number });

          expect(
            await target.transform('1.2.3', {} as ArgumentMetadata),
          ).to.be.deep.equal([1, 2, 3]);

          target = new ParseArrayPipe({ separator: '.', items: Number });

          try {
            await target.transform('1.2.a.null.3', {} as ArgumentMetadata);
            throw null;
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal(
              '[2] item must be a number',
            );
          }

          target = new ParseArrayPipe({ separator: '.', items: Boolean });

          try {
            await target.transform('1.2.a.null.3', {} as ArgumentMetadata);
            throw null;
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal(
              '[0] item must be a boolean value',
            );
          }

          target = new ParseArrayPipe({
            separator: '.',
            items: Number,
            stopAtFirstError: false,
          });

          try {
            await target.transform('1.2.a.b.null.3', {} as ArgumentMetadata);
            throw null;
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal([
              '[2] item must be a number',
              '[3] item must be a number',
              '[4] item must be a number',
            ]);
          }
        });
      });
    });

    describe('when items type is determined', () => {
      class ArrItem {}

      it('should validate and transform each item', async () => {
        target = new ParseArrayPipe({
          items: ArrItem,
          forbidUnknownValues: false,
        });

        let items = await target.transform(
          [{}, {}, {}],
          {} as ArgumentMetadata,
        );
        items.forEach(item => {
          expect(item).to.be.instanceOf(ArrItem);
        });

        items = await target.transform('{},{},{}', {} as ArgumentMetadata);
        items.forEach(item => {
          expect(item).to.be.instanceOf(ArrItem);
        });

        target = new ParseArrayPipe({ items: Number });
        expect(
          await target.transform('1,2.0,3', {} as ArgumentMetadata),
        ).to.deep.equal([1, 2, 3]);

        target = new ParseArrayPipe({ items: String });
        expect(
          await target.transform(
            '1,2.0,3,{},true,null,,',
            {} as ArgumentMetadata,
          ),
        ).to.deep.equal(['1', '2.0', '3', '{}', 'true', 'null', '', '']);

        target = new ParseArrayPipe({ items: Boolean });
        expect(
          await target.transform('true,false', {} as ArgumentMetadata),
        ).to.deep.equal([true, false]);
      });
      describe('when "stopAtFirstError" is explicitly turned off', () => {
        it('should validate each item and concat errors', async () => {
          class ArrItemWithProp {
            @IsNumber()
            number: number;
          }
          const pipe = new ParseArrayPipe({
            items: ArrItemWithProp,
            stopAtFirstError: false,
          });
          try {
            await pipe.transform(
              [
                { number: '1' },
                { number: '1' },
                { number: 1 },
              ] as ArrItemWithProp[],
              {} as ArgumentMetadata,
            );
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal([
              '[0] number must be a number conforming to the specified constraints',
              '[1] number must be a number conforming to the specified constraints',
            ]);
          }
        });

        it('should validate each nested object and concat errors', async () => {
          class RandomObject {
            @IsDefined()
            @IsBoolean()
            isEnabled: boolean;

            @IsString()
            title: string;

            @IsDate()
            createdAt: Date;

            constructor(partial: Partial<any>) {
              Object.assign(this, partial);
            }
          }
          class ArrItemObject {
            @ValidateNested()
            random: RandomObject;
          }
          const pipe = new ParseArrayPipe({
            items: ArrItemObject,
            stopAtFirstError: false,
          });
          try {
            await pipe.transform(
              [
                {
                  random: new RandomObject({
                    isEnabled: true,
                    title: true,
                    createdAt: new Date(),
                  }),
                },
                {
                  random: new RandomObject({
                    title: 'ok',
                    createdAt: false,
                  }),
                },
              ] as any[],
              {} as ArgumentMetadata,
            );
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal([
              '[0] random.title must be a string',
              '[1] random.isEnabled should not be null or undefined',
              '[1] random.isEnabled must be a boolean value',
              '[1] random.createdAt must be a Date instance',
            ]);
          }
        });

        it('should validate each nested array and concat errors', async () => {
          class RandomObject {
            @IsDefined()
            @IsBoolean()
            isEnabled: boolean;

            @IsString()
            title: string;

            @IsDate()
            createdAt: Date;

            constructor(partial: Partial<any>) {
              Object.assign(this, partial);
            }
          }
          class ArrItemObject {
            @Type(() => RandomObject)
            @ValidateNested({ each: true })
            random: RandomObject[];
          }
          const pipe = new ParseArrayPipe({
            items: ArrItemObject,
            stopAtFirstError: false,
          });
          try {
            await pipe.transform(
              [
                {
                  random: [
                    new RandomObject({
                      isEnabled: true,
                      title: true,
                      createdAt: new Date(),
                    }),
                    new RandomObject({
                      isEnabled: true,
                      title: true,
                      createdAt: new Date(),
                    }),
                  ],
                },
                {
                  random: [
                    new RandomObject({
                      title: 'ok',
                      createdAt: false,
                    }),
                  ],
                },
              ] as any[],
              {} as ArgumentMetadata,
            );
          } catch (err) {
            expect(err).to.be.instanceOf(BadRequestException);
            expect(err.getResponse().message).to.deep.equal([
              '[0] random.0.title must be a string',
              '[0] random.1.title must be a string',
              '[1] random.0.isEnabled should not be null or undefined',
              '[1] random.0.isEnabled must be a boolean value',
              '[1] random.0.createdAt must be a Date instance',
            ]);
          }
        });
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-bool.pipe.spec.ts
================================================
import { expect } from 'chai';
import { ArgumentMetadata } from '../../interfaces';
import { ParseBoolPipe } from '../../pipes/parse-bool.pipe';

describe('ParseBoolPipe', () => {
  let target: ParseBoolPipe;
  beforeEach(() => {
    target = new ParseBoolPipe();
  });
  describe('transform', () => {
    describe('when validation passes', () => {
      it('should return boolean', async () => {
        expect(await target.transform('true', {} as ArgumentMetadata)).to.be
          .true;
        expect(await target.transform(true, {} as ArgumentMetadata)).to.be.true;
        expect(await target.transform('false', {} as ArgumentMetadata)).to.be
          .false;
        expect(await target.transform(false, {} as ArgumentMetadata)).to.be
          .false;
      });

      it('should not throw an error if the value is undefined/null and optional is true', async () => {
        const target = new ParseBoolPipe({ optional: true });
        const value = await target.transform(
          undefined!,
          {} as ArgumentMetadata,
        );
        expect(value).to.equal(undefined);
      });
    });
    describe('when validation fails', () => {
      it('should throw an error', async () => {
        return expect(target.transform('123abc', {} as ArgumentMetadata)).to.be
          .rejected;
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-date.pipe.spec.ts
================================================
import { expect } from 'chai';
import { BadRequestException } from '../../exceptions';
import { ParseDatePipe } from '../../pipes/parse-date.pipe';

describe('ParseDatePipe', () => {
  let target: ParseDatePipe;

  beforeEach(() => {
    target = new ParseDatePipe();
  });

  describe('transform', () => {
    describe('when validation passes', () => {
      it('should return a valid date object', () => {
        const date = new Date().toISOString();

        const transformedDate = target.transform(date)!;
        expect(transformedDate).to.be.instanceOf(Date);
        expect(transformedDate.toISOString()).to.equal(date);

        const asNumber = transformedDate.getTime();
        const transformedNumber = target.transform(asNumber)!;
        expect(transformedNumber).to.be.instanceOf(Date);
        expect(transformedNumber.getTime()).to.equal(asNumber);
      });

      it('should not throw an error if the value is undefined/null and optional is true', () => {
        const target = new ParseDatePipe({ optional: true });
        const value = target.transform(undefined);
        expect(value).to.equal(undefined);
      });
    });
    describe('when default value is provided', () => {
      it('should return the default value if the value is undefined/null', () => {
        const defaultValue = new Date();
        const target = new ParseDatePipe({
          optional: true,
          default: () => defaultValue,
        });
        const value = target.transform(undefined);
        expect(value).to.equal(defaultValue);
      });
    });
    describe('when validation fails', () => {
      it('should throw an error', () => {
        try {
          target.transform('123abc');
          expect.fail();
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          expect(error.message).to.equal(
            'Validation failed (invalid date format)',
          );
        }
      });
    });
    describe('when empty value', () => {
      it('should throw an error', () => {
        try {
          target.transform('');
          expect.fail();
        } catch (error) {
          expect(error).to.be.instanceOf(BadRequestException);
          expect(error.message).to.equal(
            'Validation failed (no Date provided)',
          );
        }
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-enum.pipe.spec.ts
================================================
import { expect } from 'chai';
import { HttpException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces';
import { ParseEnumPipe } from '../../pipes/parse-enum.pipe';

class CustomTestError extends HttpException {
  constructor() {
    super('This is a TestException', 418);
  }
}

describe('ParseEnumPipe', () => {
  enum Direction {
    Up = 'UP',
  }
  let target: ParseEnumPipe;

  beforeEach(() => {
    target = new ParseEnumPipe(Direction, {
      exceptionFactory: (error: any) => new CustomTestError(),
    });
  });
  describe('transform', () => {
    describe('when validation passes', () => {
      it('should return enum value', async () => {
        expect(await target.transform('UP', {} as ArgumentMetadata)).to.equal(
          Direction.Up,
        );
      });

      it('should not throw an error if enumType is undefined/null and optional is true', async () => {
        const target = new ParseEnumPipe('DOWN', { optional: true });
        const value = await target.transform(
          undefined!,
          {} as ArgumentMetadata,
        );
        expect(value).to.equal(undefined);
      });
    });
    describe('when validation fails', () => {
      it('should throw an error', async () => {
        return expect(
          target.transform('DOWN', {} as ArgumentMetadata),
        ).to.be.rejectedWith(CustomTestError);
      });

      it('should throw an error if enumType is wrong and optional is true', async () => {
        target = new ParseEnumPipe(Direction, {
          exceptionFactory: (error: any) => new CustomTestError(),
          optional: true,
        });
        return expect(
          target.transform('DOWN', {} as ArgumentMetadata),
        ).to.be.rejectedWith(CustomTestError);
      });
    });
  });
  describe('constructor', () => {
    it('should throw an error if "enumType" is undefined/null', () => {
      try {
        new ParseEnumPipe(null);
      } catch (err) {
        expect(err.message).to.equal(
          `"ParseEnumPipe" requires "enumType" argument specified (to validate input values).`,
        );
      }
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-float.pipe.spec.ts
================================================
import { expect } from 'chai';
import { HttpException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces';
import { ParseFloatPipe } from '../../pipes/parse-float.pipe';

class CustomTestError extends HttpException {
  constructor() {
    super('This is a TestException', 418);
  }
}

describe('ParseFloatPipe', () => {
  let target: ParseFloatPipe;
  beforeEach(() => {
    target = new ParseFloatPipe({
      exceptionFactory: (error: any) => new CustomTestError(),
    });
  });
  describe('transform', () => {
    describe('when validation passes', () => {
      it('should return number', async () => {
        const num = '3.33';
        expect(await target.transform(num, {} as ArgumentMetadata)).to.equal(
          parseFloat(num),
        );
      });
      it('should not throw an error if the value is undefined/null and optional is true', async () => {
        const target = new ParseFloatPipe({ optional: true });
        const value = await target.transform(
          undefined!,
          {} as ArgumentMetadata,
        );
        expect(value).to.equal(undefined);
      });
    });
    describe('when validation fails', () => {
      it('should throw an error', async () => {
        return expect(
          target.transform('123.123abc', {} as ArgumentMetadata),
        ).to.be.rejectedWith(CustomTestError);
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-int.pipe.spec.ts
================================================
import { expect } from 'chai';
import { HttpException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces';
import { ParseIntPipe } from '../../pipes/parse-int.pipe';

class CustomTestError extends HttpException {
  constructor() {
    super('This is a TestException', 418);
  }
}

describe('ParseIntPipe', () => {
  let target: ParseIntPipe;
  beforeEach(() => {
    target = new ParseIntPipe({
      exceptionFactory: (error: any) => new CustomTestError(),
    });
  });
  describe('transform', () => {
    describe('when validation passes', () => {
      it('should return number', async () => {
        const num = '3';
        expect(await target.transform(num, {} as ArgumentMetadata)).to.equal(
          parseInt(num, 10),
        );
      });
      it('should return negative number', async () => {
        const num = '-3';
        expect(await target.transform(num, {} as ArgumentMetadata)).to.equal(
          -3,
        );
      });
      it('should not throw an error if the value is undefined/null and optional is true', async () => {
        const target = new ParseIntPipe({ optional: true });
        const value = await target.transform(
          undefined!,
          {} as ArgumentMetadata,
        );
        expect(value).to.equal(undefined);
      });
    });
    describe('when validation fails', () => {
      it('should throw an error', async () => {
        return expect(
          target.transform('123abc', {} as ArgumentMetadata),
        ).to.be.rejectedWith(CustomTestError);
      });
      it('should throw an error when number has wrong number encoding', async () => {
        return expect(
          target.transform('0xFF', {} as ArgumentMetadata),
        ).to.be.rejectedWith(CustomTestError);
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/parse-uuid.pipe.spec.ts
================================================
import { expect } from 'chai';
import { HttpStatus } from '../../enums';
import { HttpException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces';
import { ParseUUIDPipe } from '../../pipes/parse-uuid.pipe';

class TestException extends HttpException {
  constructor() {
    super('This is a TestException', HttpStatus.I_AM_A_TEAPOT);
  }
}

describe('ParseUUIDPipe', () => {
  let target: ParseUUIDPipe;
  const exceptionFactory = (error: any) => new TestException();

  describe('transform', () => {
    const v3 = 'e8b5a51d-11c8-3310-a6ab-367563f20686';
    const v4 = '10ba038e-48da-487b-96e8-8d3b99b6d18a';
    const v5 = '630eb68f-e0fa-5ecc-887a-7c7a62614681';

    describe('when validation passes', () => {
      it('should return string if value is uuid v3, v4 or v5', async () => {
        target = new ParseUUIDPipe({ exceptionFactory });
        expect(await target.transform(v3, {} as ArgumentMetadata)).to.equal(v3);
        expect(await target.transform(v4, {} as ArgumentMetadata)).to.equal(v4);
        expect(await target.transform(v5, {} as ArgumentMetadata)).to.equal(v5);
      });

      it('should return string if value is uuid v3', async () => {
        target = new ParseUUIDPipe({ version: '3', exceptionFactory });
        expect(await target.transform(v3, {} as ArgumentMetadata)).to.equal(v3);
      });

      it('should return string if value is uuid v4', async () => {
        target = new ParseUUIDPipe({ version: '4', exceptionFactory });
        expect(await target.transform(v4, {} as ArgumentMetadata)).to.equal(v4);
      });

      it('should return string if value is uuid v5', async () => {
        target = new ParseUUIDPipe({ version: '5', exceptionFactory });
        expect(await target.transform(v5, {} as ArgumentMetadata)).to.equal(v5);
      });
      it('should not throw an error if the value is undefined/null and optional is true', async () => {
        const target = new ParseUUIDPipe({ optional: true });
        const value = await target.transform(
          undefined!,
          {} as ArgumentMetadata,
        );
        expect(value).to.equal(undefined);
      });
    });

    describe('when validation fails', () => {
      it('should throw an error', async () => {
        target = new ParseUUIDPipe({ exceptionFactory });
        await expect(
          target.transform('123a', {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
      });

      it('should throw an error - not a string', async () => {
        target = new ParseUUIDPipe({ exceptionFactory });
        await expect(
          target.transform(undefined!, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
      });

      it('should throw an error - v3', async () => {
        target = new ParseUUIDPipe({ version: '3', exceptionFactory });
        await expect(
          target.transform('123a', {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v4, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v5, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
      });

      it('should throw an error - v4', async () => {
        target = new ParseUUIDPipe({ version: '4', exceptionFactory });
        await expect(
          target.transform('123a', {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v3, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v5, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
      });

      it('should throw an error - v5 ', async () => {
        target = new ParseUUIDPipe({ version: '5', exceptionFactory });
        await expect(
          target.transform('123a', {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v3, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
        await expect(
          target.transform(v4, {} as ArgumentMetadata),
        ).to.be.rejectedWith(TestException);
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/validation.pipe.spec.ts
================================================
import * as chai from 'chai';
import { expect } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import { Exclude, Expose, Type } from 'class-transformer';
import {
  IsArray,
  IsBoolean,
  IsDefined,
  IsOptional,
  IsString,
  ValidateNested,
} from 'class-validator';
import { HttpStatus } from '../../enums';
import { UnprocessableEntityException } from '../../exceptions';
import { ArgumentMetadata } from '../../interfaces';
import { ValidationPipe } from '../../pipes/validation.pipe';
chai.use(chaiAsPromised);

@Exclude()
class TestModelInternal {
  constructor() {}
  @Expose()
  @IsString()
  public prop1: string;

  @Expose()
  @IsString()
  public prop2: string;

  @Expose({ groups: ['internal'] })
  @IsString()
  @IsOptional()
  public propInternal: string;
}

class TestModel {
  @IsString()
  public prop1: string;

  @IsString()
  public prop2: string;

  @IsOptional()
  @IsString()
  public optionalProp: string;
}

class TestModelNoValidation {
  constructor() {}

  public prop1: string;
  public prop2: string;
  public optionalProp: string;
}

describe('ValidationPipe', () => {
  let target: ValidationPipe;
  const metadata: ArgumentMetadata = {
    type: 'body',
    metatype: TestModel,
    data: '',
  };
  const transformMetadata: ArgumentMetadata = {
    type: 'body',
    metatype: TestModelInternal,
    data: '',
  };

  describe('transform', () => {
    describe('when validation passes', () => {
      beforeEach(() => {
        target = new ValidationPipe();
      });
      it('should return the value unchanged if optional value is not defined', async () => {
        const testObj = { prop1: 'value1', prop2: 'value2' };
        expect(await target.transform(testObj, {} as any)).to.equal(testObj);
        expect(
          await target.transform(testObj, metadata as any),
        ).to.not.be.instanceOf(TestModel);
      });
      it('should return the value unchanged if optional value is set undefined', async () => {
        const testObj = {
          prop1: 'value1',
          prop2: 'value2',
          optionalProp: undefined,
        };
        expect(await target.transform(testObj, {} as any)).to.equal(testObj);
        expect(
          await target.transform(testObj, metadata as any),
        ).to.not.be.instanceOf(TestModel);
      });
      it('should return the value unchanged if optional value is null', async () => {
        const testObj = {
          prop1: 'value1',
          prop2: 'value2',
          optionalProp: null,
        };
        expect(await target.transform(testObj, {} as any)).to.equal(testObj);
        expect(
          await target.transform(testObj, metadata as any),
        ).to.not.be.instanceOf(TestModel);
      });
      it('should return the value unchanged if optional value is set', async () => {
        const testObj = {
          prop1: 'value1',
          prop2: 'value2',
          optionalProp: 'optional value',
        };
        expect(await target.transform(testObj, {} as any)).to.equal(testObj);
        expect(
          await target.transform(testObj, metadata as any),
        ).to.not.be.instanceOf(TestModel);
      });
    });
    describe('when validation fails', () => {
      beforeEach(() => {
        target = new ValidationPipe();
      });
      it('should throw an error', async () => {
        const testObj = { prop1: 'value1' };
        return expect(target.transform(testObj, metadata)).to.be.rejected;
      });

      class TestModel2 {
        @IsString()
        public prop1: string;

        @IsBoolean()
        public prop2: string;

        @IsOptional()
        @IsString()
        public optionalProp: string;
      }
      class TestModelWithNested {
        @IsString()
        prop: string;

        @IsDefined()
        @Type(() => TestModel2)
        @ValidateNested()
        test: TestModel2;
      }
      it('should flatten nested errors', async () => {
        try {
          const model = new TestModelWithNested();
          model.test = new TestModel2();
          await target.transform(model, {
            type: 'body',
            metatype: TestModelWithNested,
          });
        } catch (err) {
          expect(err.getResponse().message).to.be.eql([
            'prop must be a string',
            'test.prop1 must be a string',
            'test.prop2 must be a boolean value',
          ]);
        }
      });

      class TestModelForNestedArrayValidation {
        @IsString()
        public prop: string;

        @IsArray()
        @ValidateNested()
        @Type(() => TestModel2)
        public test: TestModel2[];
      }
      it('should provide complete path for nested errors', async () => {
        try {
          const model = new TestModelForNestedArrayValidation();
          model.test = [new TestModel2()];
          await target.transform(model, {
            type: 'body',
            metatype: TestModelForNestedArrayValidation,
          });
        } catch (err) {
          expect(err.getResponse().message).to.be.eql([
            'prop must be a string',
            'test.0.prop1 must be a string',
            'test.0.prop2 must be a boolean value',
          ]);
        }
      });
    });
    describe('when validation transforms', () => {
      it('should return a TestModel instance', async () => {
        target = new ValidationPipe({ transform: true });
        const testObj = { prop1: 'value1', prop2: 'value2', prop3: 'value3' };
        expect(await target.transform(testObj, metadata)).to.be.instanceOf(
          TestModel,
        );
      });
      describe('when input is a query parameter (number)', () => {
        it('should parse to number', async () => {
          target = new ValidationPipe({ transform: true });
          const value = '3.14';

          expect(
            await target.transform(value, {
              metatype: Number,
              data: 'test',
              type: 'query',
            }),
          ).to.be.equal(+value);
        });
        it('should parse undefined to undefined', async () => {
          target = new ValidationPipe({ transform: true });
          const value = undefined;

          expect(
            await target.transform(value, {
              metatype: Number,
              data: 'test',
              type: 'query',
            }),
          ).to.be.undefined;
        });
      });
      describe('when input is a path parameter (number)', () => {
        it('should parse to number', async () => {
          target = new ValidationPipe({ transform: true });
          const value = '3.14';

          expect(
            await target.transform(value, {
              metatype: Number,
              data: 'test',
              type: 'param',
            }),
          ).to.be.equal(+value);
        });
        it('should parse undefined to undefined', async () => {
          target = new ValidationPipe({ transform: true });
          const value = undefined;

          expect(
            await target.transform(value, {
              metatype: Number,
              data: 'test',
              type: 'param',
            }),
          ).to.be.undefined;
        });
      });
      describe('when input is a query parameter (boolean)', () => {
        it('should parse the string "true" to the boolean true', async () => {
          target = new ValidationPipe({ transform: true });
          const value = 'true';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'query',
            }),
          ).to.be.true;
        });
        it('should parse the string "false" to the boolean false', async () => {
          target = new ValidationPipe({ transform: true });
          const value = 'false';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'query',
            }),
          ).to.be.false;
        });
        it('should parse an empty string to false', async () => {
          target = new ValidationPipe({ transform: true });
          const value = '';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'query',
            }),
          ).to.be.false;
        });
        it('should parse undefined to undefined', async () => {
          target = new ValidationPipe({ transform: true });
          const value = undefined;

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'query',
            }),
          ).to.be.undefined;
        });
      });
      describe('when input is a path parameter (boolean)', () => {
        it('should parse the string "true" to boolean true', async () => {
          target = new ValidationPipe({ transform: true });
          const value = 'true';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'param',
            }),
          ).to.be.true;
        });
        it('should parse the string "false" to boolean false', async () => {
          target = new ValidationPipe({ transform: true });
          const value = 'false';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'param',
            }),
          ).to.be.false;
        });
        it('should parse an empty string to false', async () => {
          target = new ValidationPipe({ transform: true });
          const value = '';

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'param',
            }),
          ).to.be.false;
        });
        it('should parse undefined to undefined', async () => {
          target = new ValidationPipe({ transform: true });
          const value = undefined;

          expect(
            await target.transform(value, {
              metatype: Boolean,
              data: 'test',
              type: 'param',
            }),
          ).to.be.undefined;
        });
      });
      describe('when validation strips', () => {
        it('should return a TestModel without extra properties', async () => {
          target = new ValidationPipe({ whitelist: true });
          const testObj = { prop1: 'value1', prop2: 'value2', prop3: 'value3' };
          expect(
            await target.transform(testObj, metadata),
          ).to.not.be.instanceOf(TestModel);
          expect(
            await target.transform(testObj, metadata),
          ).to.not.have.property('prop3');
        });
      });
      describe('when validation rejects', () => {
        it('should throw an error', () => {
          target = new ValidationPipe({
            forbidNonWhitelisted: true,
            whitelist: true,
          });
          const testObj = { prop1: 'value1', prop2: 'value2', prop3: 'value3' };
          expect(target.transform(testObj, metadata)).to.eventually.be.rejected;
        });
      });
      describe('when transformation is internal', () => {
        it('should return a TestModel with internal property', async () => {
          target = new ValidationPipe({
            transform: true,
            transformOptions: { groups: ['internal'] },
          });
          const testObj = {
            prop1: 'value1',
            prop2: 'value2',
            propInternal: 'value3',
          };
          expect(
            await target.transform(testObj, transformMetadata),
          ).to.have.property('propInternal');
        });
      });
      describe('when transformation is external', () => {
        it('should return a TestModel without internal property', async () => {
          target = new ValidationPipe({
            transform: true,
            transformOptions: { groups: ['external'] },
          });
          const testObj = {
            prop1: 'value1',
            prop2: 'value2',
            propInternal: 'value3',
          };
          expect(
            await target.transform(testObj, transformMetadata),
          ).to.not.have.property('propInternal');
        });
      });
    });
    describe('when validation does not transform', () => {
      describe('when validation strips', () => {
        it('should return a plain object without extra properties', async () => {
          target = new ValidationPipe({ transform: false, whitelist: true });
          const testObj = { prop1: 'value1', prop2: 'value2', prop3: 'value3' };
          const result = await target.transform(testObj, metadata);

          expect(result).to.not.be.instanceOf(TestModel);
          expect(result).to.not.have.property('prop3');
          expect(result).to.not.have.property('optionalProp');
        });
        it('should return a plain object without extra properties if optional prop is defined', async () => {
          target = new ValidationPipe({ transform: false, whitelist: true });
          const testObj = {
            prop1: 'value1',
            prop2: 'value2',
            prop3: 'value3',
            optionalProp: 'optional value',
          };
          const result = await target.transform(testObj, metadata);
          expect(result).to.not.be.instanceOf(TestModel);
          expect(result).to.not.have.property('prop3');
          expect(result).to.have.property('optionalProp');
        });
        it('should return a plain object without extra properties if optional prop is undefined', async () => {
          target = new ValidationPipe({ transform: false, whitelist: true });
          const testObj = {
            prop1: 'value1',
            prop2: 'value2',
            prop3: 'value3',
            optionalProp: undefined,
          };
          const result = await target.transform(testObj, metadata);
          expect(result).to.not.be.instanceOf(TestModel);
          expect(result).to.not.have.property('prop3');
          expect(result).to.have.property('optionalProp');
        });
        it('should return a plain object without extra properties if optional prop is null', async () => {
          target = new ValidationPipe({ transform: false, whitelist: true });
          const testObj = {
            prop1: 'value1',
            prop2: 'value2',
            prop3: 'value3',
            optionalProp: null,
          };

          const result = await target.transform(testObj, metadata);
          expect(result).to.not.be.instanceOf(TestModel);
          expect(result).to.not.have.property('prop3');
          expect(result).to.have.property('optionalProp');
        });
      });
      describe('when validation rejects', () => {
        it('should throw an error', () => {
          target = new ValidationPipe({
            transform: false,
            forbidNonWhitelisted: true,
            whitelist: true,
          });
          const testObj = { prop1: 'value1', prop2: 'value2', prop3: 'value3' };
          expect(target.transform(testObj, metadata)).to.eventually.be.rejected;
        });
      });
    });
    describe("when type doesn't match", () => {
      describe('when validation rules are applied', () => {
        it('should throw an error', async () => {
          target = new ValidationPipe();
          const testObj = [
            { prop1: 'value1', prop2: 'value2', prop3: 'value3' },
          ];

          expect(target.transform(testObj, metadata)).to.eventually.be.rejected;
          expect(target.transform('string', metadata)).to.eventually.be
            .rejected;
          expect(target.transform(true, metadata)).to.eventually.be.rejected;
          expect(target.transform(3, metadata)).to.eventually.be.rejected;
        });
      });
      describe('otherwise', () => {
        it('should not reject', async () => {
          target = new ValidationPipe();
          const testObj = [
            { prop1: 'value1', prop2: 'value2', prop3: 'value3' },
          ];

          const objMetadata = { ...metadata, metatype: TestModelNoValidation };
          const result = await target.transform(testObj, objMetadata);

          expect(result).to.not.be.instanceOf(TestModel);
          expect(result).to.be.eql(testObj);

          // primitives
          expect(await target.transform('string', objMetadata)).to.be.eql(
            'string',
          );
          expect(await target.transform(3, objMetadata)).to.be.eql(3);
          expect(await target.transform(true, objMetadata)).to.be.eql(true);
        });
      });
    });
  });

  describe('option: "validateCustomDecorators" when metadata.type is not `body`', () => {
    describe('when is set to `true`', () => {
      it('should transform and validate', async () => {
        const target = new ValidationPipe({
          validateCustomDecorators: true,
        });

        const metadata: ArgumentMetadata = {
          type: 'custom',
          metatype: TestModel,
          data: '',
        };

        const testObj = { prop1: 'value1', prop2: 'value2' };
        expect(await target.transform(testObj, metadata)).to.not.be.undefined;
      });
    });
    describe('when is set to `false`', () => {
      it('should throw an error', async () => {
        const target = new ValidationPipe({
          validateCustomDecorators: false,
        });

        const metadata: ArgumentMetadata = {
          type: 'custom',
          metatype: TestModel,
          data: '',
        };

        const objNotFollowingTestModel = { prop1: undefined, prop2: 'value2' };
        expect(await target.transform(objNotFollowingTestModel, metadata)).to
          .not.be.undefined;
      });
    });
    describe('when is not supplied', () => {
      it('should transform and validate', async () => {
        const target = new ValidationPipe({});

        const metadata: ArgumentMetadata = {
          type: 'custom',
          metatype: TestModel,
          data: '',
        };

        const testObj = { prop1: 'value1', prop2: 'value2' };
        expect(await target.transform(testObj, metadata)).to.not.be.undefined;
      });
    });
  });

  describe('option: "errorHttpStatusCode"', () => {
    describe('when validation fails', () => {
      beforeEach(() => {
        target = new ValidationPipe({
          errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,
        });
      });
      it('should throw an error', async () => {
        const testObj = { prop1: 'value1' };
        try {
          await target.transform(testObj, metadata);
        } catch (err) {
          expect(err).to.be.instanceOf(UnprocessableEntityException);
        }
      });
    });
  });

  describe('option: "expectedType"', () => {
    class TestModel2 {
      @IsString()
      public prop1: string;

      @IsBoolean()
      public prop2: boolean;

      @IsOptional()
      @IsString()
      public optionalProp: string;
    }

    it('should validate against the expected type if presented', async () => {
      const m: ArgumentMetadata = {
        type: 'body',
        metatype: TestModel2,
        data: '',
      };

      target = new ValidationPipe({ expectedType: TestModel });
      const testObj = { prop1: 'value1', prop2: 'value2' };

      expect(await target.transform(testObj, m)).to.deep.equal(testObj);
    });

    it('should validate against the expected type if presented and metatype is primitive type', async () => {
      const m: ArgumentMetadata = {
        type: 'body',
        metatype: String,
        data: '',
      };

      target = new ValidationPipe({ expectedType: TestModel });
      const testObj = { prop1: 'value1', prop2: 'value2' };

      expect(await target.transform(testObj, m)).to.deep.equal(testObj);
    });
  });
});



================================================
FILE: packages/common/test/pipes/file/file-type.validator.spec.ts
================================================
import { expect } from 'chai';
import { FileTypeValidator } from '../../../pipes';

describe('FileTypeValidator', () => {
  describe('isValid', () => {
    it('should return true when the file mimetype is the same as the specified', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: 'image/jpeg',
      });

      const requestFile = {
        mimetype: 'image/jpeg',
      } as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
    });

    it('should return true when the file mimetype ends with the specified option type', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: 'jpeg',
      });

      const requestFile = {
        mimetype: 'image/jpeg',
      } as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
    });

    it('should return true when the file mimetype matches the specified regexp', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: /word/,
      });

      const requestFile = {
        mimetype: 'application/msword',
      } as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(true);
    });

    it('should return false when the file mimetype is different from the specified', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: 'image/jpeg',
      });

      const requestFile = {
        mimetype: 'image/png',
      } as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
    });

    it('should return false when the file mimetype does not match the provided regexp', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: /mp4/,
      });

      const requestFile = {
        mimetype: 'image/png',
      } as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
    });

    it('should return false when the file mimetype was not provided', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: 'image/jpeg',
      });

      const requestFile = {} as any;

      expect(fileTypeValidator.isValid(requestFile)).to.equal(false);
    });

    it('should return false when no file provided', () => {
      const fileTypeValidator = new FileTypeValidator({
        fileType: 'image/jpeg',
      });

      expect(fileTypeValidator.isValid()).to.equal(false);
    });
  });

  describe('buildErrorMessage', () => {
    it('should return a string with the format "Validation failed (expected type is #fileType)"', () => {
      const fileType = 'image/jpeg';
      const fileTypeValidator = new FileTypeValidator({
        fileType,
      });

      expect(fileTypeValidator.buildErrorMessage()).to.equal(
        `Validation failed (expected type is ${fileType})`,
      );
    });

    it('should include the file type in the error message when a file is provided', () => {
      const currentFileType = 'image/png';
      const fileType = 'image/jpeg';
      const fileTypeValidator = new FileTypeValidator({
        fileType,
      });

      const file = { mimetype: currentFileType } as any;

      expect(fileTypeValidator.buildErrorMessage(file)).to.equal(
        `Validation failed (current file type is ${currentFileType}, expected type is ${fileType})`,
      );
    });
  });
});



================================================
FILE: packages/common/test/pipes/file/max-file-size.validator.spec.ts
================================================
import { expect } from 'chai';
import { MaxFileSizeValidator } from '../../../pipes';

describe('MaxFileSizeValidator', () => {
  const oneKb = 1024;

  describe('isValid', () => {
    it('should return true when the file size is less than the maximum size', () => {
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      const requestFile = {
        size: 100,
      } as any;

      expect(maxFileSizeValidator.isValid(requestFile)).to.equal(true);
    });

    it('should return false when the file size is greater than the maximum size', () => {
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      const requestFile = {
        size: oneKb + 1,
      } as any;

      expect(maxFileSizeValidator.isValid(requestFile)).to.equal(false);
    });

    it('should return false when the file size is equal to the maximum size', () => {
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      const requestFile = {
        size: oneKb,
      } as any;

      expect(maxFileSizeValidator.isValid(requestFile)).to.equal(false);
    });

    it('should return true when no file provided', () => {
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      expect(maxFileSizeValidator.isValid()).to.equal(true);
    });
  });

  describe('buildErrorMessage', () => {
    it('should return a string with the format "Validation failed (expected size is less than #maxSize")', () => {
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      expect(maxFileSizeValidator.buildErrorMessage()).to.equal(
        `Validation failed (expected size is less than ${oneKb})`,
      );
    });

    it('should include the file size in the error message when a file is provided', () => {
      const currentFileSize = oneKb + 1;
      const maxFileSizeValidator = new MaxFileSizeValidator({
        maxSize: oneKb,
      });

      const file = { size: currentFileSize } as any;

      expect(maxFileSizeValidator.buildErrorMessage(file)).to.equal(
        `Validation failed (current file size is ${currentFileSize}, expected size is less than ${oneKb})`,
      );
    });
  });
});



================================================
FILE: packages/common/test/pipes/file/parse-file-pipe.builder.spec.ts
================================================
import { expect } from 'chai';
import {
  FileTypeValidator,
  FileValidator,
  MaxFileSizeValidator,
  ParseFilePipeBuilder,
} from '../../../pipes';

describe('ParseFilePipeBuilder', () => {
  let parseFilePipeBuilder: ParseFilePipeBuilder;

  beforeEach(() => {
    parseFilePipeBuilder = new ParseFilePipeBuilder();
  });

  describe('build', () => {
    describe('when no validator was passed', () => {
      it('should return a ParseFilePipe with no validators', () => {
        const parseFilePipe = parseFilePipeBuilder.build();
        expect(parseFilePipe.getValidators()).to.be.empty;
      });
    });

    describe('when addMaxSizeValidator was chained', () => {
      it('should return a ParseFilePipe with MaxSizeValidator and given options', () => {
        const options = {
          maxSize: 1000,
        };
        const parseFilePipe = parseFilePipeBuilder
          .addMaxSizeValidator(options)
          .build();

        expect(parseFilePipe.getValidators()).to.deep.include(
          new MaxFileSizeValidator(options),
        );
      });
    });

    describe('when addFileTypeValidator was chained', () => {
      it('should return a ParseFilePipe with FileTypeValidator and given options', () => {
        const options = {
          fileType: 'image/jpeg',
        };
        const parseFilePipe = parseFilePipeBuilder
          .addFileTypeValidator(options)
          .build();

        expect(parseFilePipe.getValidators()).to.deep.include(
          new FileTypeValidator(options),
        );
      });
    });

    describe('when custom validator was chained', () => {
      it('should return a ParseFilePipe with TestFileValidator and given options', () => {
        class TestFileValidator extends FileValidator<{ name: string }> {
          buildErrorMessage(file: any): string {
            return 'TestFileValidator failed';
          }

          isValid(file: any): boolean | Promise<boolean> {
            return true;
          }
        }

        const options = {
          name: 'test',
        };

        const parseFilePipe = parseFilePipeBuilder
          .addValidator(new TestFileValidator(options))
          .build();

        expect(parseFilePipe.getValidators()).to.deep.include(
          new TestFileValidator(options),
        );
      });
    });

    describe('when it is called twice with different validators', () => {
      it('should not reuse validators', () => {
        const maxSizeValidatorOptions = {
          maxSize: 1000,
        };

        const pipeWithMaxSizeValidator = parseFilePipeBuilder
          .addMaxSizeValidator(maxSizeValidatorOptions)
          .build();

        const fileTypeValidatorOptions = {
          fileType: 'image/jpeg',
        };

        const pipeWithFileTypeValidator = parseFilePipeBuilder
          .addFileTypeValidator(fileTypeValidatorOptions)
          .build();

        expect(pipeWithFileTypeValidator.getValidators()).not.to.deep.equal(
          pipeWithMaxSizeValidator.getValidators(),
        );
      });
    });
  });
});



================================================
FILE: packages/common/test/pipes/file/parse-file.pipe.spec.ts
================================================
import { HttpStatus } from '../../../enums';
import { BadRequestException, ConflictException } from '../../../exceptions';
import { FileValidator, ParseFilePipe } from '../../../pipes';
import { expect } from 'chai';

class AlwaysValidValidator extends FileValidator {
  isValid(): boolean {
    return true;
  }
  buildErrorMessage(): string {
    return '';
  }
}

const customErrorMessage = 'Error!';

class AlwaysInvalidValidator extends FileValidator {
  isValid(): boolean {
    return false;
  }
  buildErrorMessage(): string {
    return customErrorMessage;
  }
}

describe('ParseFilePipe', () => {
  let parseFilePipe: ParseFilePipe;
  describe('transform', () => {
    describe('when there are no validators (explicit)', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe({
          validators: [],
        });
      });

      it('should return the file object', async () => {
        const requestFile = {
          path: 'some-path',
        };

        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(
          requestFile,
        );
      });
    });

    describe('when there are no validators (by default constructor)', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe();
      });

      it('should return the file object', async () => {
        const requestFile = {
          path: 'some-path',
        };

        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(
          requestFile,
        );
      });
    });

    describe('when all the validators validate the file', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe({
          validators: [new AlwaysValidValidator({})],
        });
      });

      it('should return the file object', async () => {
        const requestFile = {
          path: 'some-path',
        };

        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(
          requestFile,
        );
      });
    });

    describe('when some validator invalidates the file', () => {
      describe('and the pipe has the default error', () => {
        beforeEach(() => {
          parseFilePipe = new ParseFilePipe({
            validators: [new AlwaysInvalidValidator({})],
          });
        });

        it('should throw a BadRequestException', async () => {
          const requestFile = {
            path: 'some-path',
          };

          await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(
            BadRequestException,
          );
        });
      });

      describe('and the pipe has a custom error code', () => {
        beforeEach(() => {
          parseFilePipe = new ParseFilePipe({
            validators: [new AlwaysInvalidValidator({})],
            errorHttpStatusCode: HttpStatus.CONFLICT,
          });
        });

        it('should throw this custom Error', async () => {
          const requestFile = {
            path: 'some-path',
          };

          await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(
            ConflictException,
          );
        });
      });
    });

    describe('when fileIsRequired is false', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe({
          validators: [],
          fileIsRequired: false,
        });
      });

      it('should pass validation if no file is provided', async () => {
        const requestFile = undefined;

        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(
          requestFile,
        );
      });
    });

    describe('when fileIsRequired is true', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe({
          validators: [],
          fileIsRequired: true,
        });
      });

      it('should throw an error if no file is provided', async () => {
        const requestFile = undefined;

        await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(
          BadRequestException,
        );
      });

      it('should pass validation if a file is provided', async () => {
        const requestFile = {
          path: 'some-path',
        };

        await expect(parseFilePipe.transform(requestFile)).to.eventually.eql(
          requestFile,
        );
      });
    });

    describe('when fileIsRequired is not explicitly provided', () => {
      beforeEach(() => {
        parseFilePipe = new ParseFilePipe({
          validators: [new AlwaysInvalidValidator({})],
        });
      });

      it('should throw an error if no file is provided', async () => {
        const requestFile = undefined;

        await expect(parseFilePipe.transform(requestFile)).to.be.rejectedWith(
          BadRequestException,
        );
      });
    });
  });
});



================================================
FILE: packages/common/test/services/logger.service.spec.ts
================================================
import { expect } from 'chai';
import 'reflect-metadata';
import * as sinon from 'sinon';
import { ConsoleLogger, Logger, LoggerService, LogLevel } from '../../services';

describe('Logger', () => {
  describe('[static methods]', () => {
    describe('when the default logger is used', () => {
      let processStdoutWriteSpy: sinon.SinonSpy;
      let processStderrWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();
        processStderrWriteSpy.restore();
      });

      it('should print one message to the console', () => {
        const message = 'random message';
        const context = 'RandomContext';

        Logger.log(message, context);

        expect(processStdoutWriteSpy.calledOnce).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print one message without context to the console', () => {
        const message = 'random message without context';

        Logger.log(message);

        expect(processStdoutWriteSpy.calledOnce).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print multiple messages to the console', () => {
        const messages = ['message 1', 'message 2', 'message 3'];
        const context = 'RandomContext';

        Logger.log(messages[0], messages[1], messages[2], context);

        expect(processStdoutWriteSpy.calledThrice).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          messages[0],
        );

        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          messages[1],
        );

        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          messages[2],
        );
      });

      it('should print one error to the console with context', () => {
        const message = 'random error';
        const context = 'RandomContext';

        Logger.error(message, context);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print one error to the console with stacktrace', () => {
        const message = 'random error';
        const stacktrace = 'Error: message\n    at <anonymous>:1:2';

        Logger.error(message, stacktrace);

        expect(processStderrWriteSpy.calledTwice).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.not.include(`[]`);
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
        expect(processStderrWriteSpy.secondCall.firstArg).to.equal(
          stacktrace + '\n',
        );
      });

      it('should print one error without context to the console', () => {
        const message = 'random error without context';

        Logger.error(message);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print error object without context to the console', () => {
        const error = new Error('Random text here');

        Logger.error(error);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `Error: Random text here`,
        );
      });

      it('should serialise a plain JS object (as a message) without context to the console', () => {
        const error = {
          randomError: true,
        };

        Logger.error(error);

        expect(processStderrWriteSpy.calledOnce).to.be.true;

        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `Object(${Object.keys(error).length})`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `randomError: \x1b[33mtrue`,
        );
      });

      it('should print one error with stacktrace and context to the console', () => {
        const message = 'random error with context';
        const stacktrace = 'stacktrace';
        const context = 'ErrorContext';

        Logger.error(message, stacktrace, context);

        expect(processStderrWriteSpy.calledTwice).to.be.true;

        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);

        expect(processStderrWriteSpy.secondCall.firstArg).to.equal(
          stacktrace + '\n',
        );
        expect(processStderrWriteSpy.secondCall.firstArg).to.not.include(
          context,
        );
      });

      it('should print multiple 2 errors and one stacktrace to the console', () => {
        const messages = ['message 1', 'message 2'];
        const stack = 'stacktrace';
        const context = 'RandomContext';

        Logger.error(messages[0], messages[1], stack, context);

        expect(processStderrWriteSpy.calledThrice).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          messages[0],
        );

        expect(processStderrWriteSpy.secondCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.secondCall.firstArg).to.include(
          messages[1],
        );

        expect(processStderrWriteSpy.thirdCall.firstArg).to.not.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.thirdCall.firstArg).to.equal(stack + '\n');
      });
    });

    describe('when the default logger is used and json mode is enabled', () => {
      const logger = new ConsoleLogger({ json: true });

      let processStdoutWriteSpy: sinon.SinonSpy;
      let processStderrWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();
        processStderrWriteSpy.restore();
      });

      it('should print error with stack as JSON to the console', () => {
        const errorMessage = 'error message';
        const error = new Error(errorMessage);

        logger.error(error.message, error.stack);

        const json = JSON.parse(processStderrWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('error');
        expect(json.message).to.equal(errorMessage);
      });
      it('should log out to stdout as JSON', () => {
        const message = 'message 1';

        logger.log(message);

        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal(message);
      });
      it('should log out an error to stderr as JSON', () => {
        const message = 'message 1';

        logger.error(message);

        const json = JSON.parse(processStderrWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('error');
        expect(json.message).to.equal(message);
      });
      it('should log Map object', () => {
        const map = new Map([
          ['key1', 'value1'],
          ['key2', 'value2'],
        ]);

        logger.log(map);

        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal(
          `Map(2) { 'key1' => 'value1', 'key2' => 'value2' }`,
        );
      });
      it('should log Set object', () => {
        const set = new Set(['value1', 'value2']);

        logger.log(set);

        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal(`Set(2) { 'value1', 'value2' }`);
      });
      it('should log bigint', () => {
        const bigInt = BigInt(9007199254740991);

        logger.log(bigInt);

        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal('9007199254740991');
      });
      it('should log symbol', () => {
        const symbol = Symbol('test');

        logger.log(symbol);

        const json = JSON.parse(processStdoutWriteSpy.firstCall?.firstArg);

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal('Symbol(test)');
      });
    });

    describe('when the default logger is used, json mode is enabled and compact is false (utils.inspect)', () => {
      const logger = new ConsoleLogger({ json: true, compact: false });

      let processStdoutWriteSpy: sinon.SinonSpy;
      let processStderrWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();
        processStderrWriteSpy.restore();
      });

      it('should log out to stdout as JSON (utils.inspect)', () => {
        const message = 'message 1';

        logger.log(message);

        const json = convertInspectToJSON(
          processStdoutWriteSpy.firstCall?.firstArg,
        );

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('log');
        expect(json.message).to.equal(message);
      });

      it('should log out an error to stderr as JSON (utils.inspect)', () => {
        const message = 'message 1';

        logger.error(message);

        const json = convertInspectToJSON(
          processStderrWriteSpy.firstCall?.firstArg,
        );

        expect(json.pid).to.equal(process.pid);
        expect(json.level).to.equal('error');
        expect(json.message).to.equal(message);
      });
    });

    describe('when logging is disabled', () => {
      let processStdoutWriteSpy: sinon.SinonSpy;
      let previousLoggerRef: LoggerService;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');

        previousLoggerRef =
          Logger['localInstanceRef'] || Logger['staticInstanceRef'];
        Logger.overrideLogger(false);
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();

        Logger.overrideLogger(previousLoggerRef);
      });

      it('should not print any message to the console', () => {
        const message = 'random message';
        const context = 'RandomContext';

        Logger.log(message, context);

        expect(processStdoutWriteSpy.called).to.be.false;
      });
    });
    describe('when custom logger is being used', () => {
      class CustomLogger implements LoggerService {
        log(message: any, context?: string) {}
        error(message: any, trace?: string, context?: string) {}
        warn(message: any, context?: string) {}
      }

      const customLogger = new CustomLogger();
      let previousLoggerRef: LoggerService;

      beforeEach(() => {
        previousLoggerRef =
          Logger['localInstanceRef'] || Logger['staticInstanceRef'];
        Logger.overrideLogger(customLogger);
      });

      afterEach(() => {
        Logger.overrideLogger(previousLoggerRef);
      });

      it('should call custom logger "#log()" method', () => {
        const message = 'random message';
        const context = 'RandomContext';

        const customLoggerLogSpy = sinon.spy(customLogger, 'log');

        Logger.log(message, context);

        expect(customLoggerLogSpy.called).to.be.true;
        expect(customLoggerLogSpy.calledWith(message, context)).to.be.true;
      });

      it('should call custom logger "#error()" method', () => {
        const message = 'random message';
        const context = 'RandomContext';

        const customLoggerErrorSpy = sinon.spy(customLogger, 'error');

        Logger.error(message, context);

        expect(customLoggerErrorSpy.called).to.be.true;
        expect(customLoggerErrorSpy.calledWith(message, context)).to.be.true;
      });
    });
  });

  describe('ConsoleLogger', () => {
    it('should allow setting and resetting of context', () => {
      const logger = new ConsoleLogger();
      expect(logger['context']).to.be.undefined;
      logger.setContext('context');
      expect(logger['context']).to.equal('context');
      logger.resetContext();
      expect(logger['context']).to.be.undefined;

      const loggerWithContext = new ConsoleLogger('context');
      expect(loggerWithContext['context']).to.equal('context');
      loggerWithContext.setContext('other');
      expect(loggerWithContext['context']).to.equal('other');
      loggerWithContext.resetContext();
      expect(loggerWithContext['context']).to.equal('context');
    });

    describe('functions for message', () => {
      let processStdoutWriteSpy: sinon.SinonSpy;
      const logger = new ConsoleLogger();
      const message = 'Hello World';

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
      });
      afterEach(() => {
        processStdoutWriteSpy.restore();
      });

      it('works', () => {
        logger.log(() => message);

        expect(processStdoutWriteSpy.calledOnce).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(message);
        // Ensure we didn't serialize the function itself.
        expect(processStdoutWriteSpy.firstCall.firstArg).not.to.include(' => ');
        expect(processStdoutWriteSpy.firstCall.firstArg).not.to.include(
          'function',
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).not.to.include(
          'Function',
        );
      });
    });

    describe('classes for message', () => {
      let processStdoutWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
      });
      afterEach(() => {
        processStdoutWriteSpy.restore();
      });

      it("should display class's name or empty for anonymous classes", () => {
        const logger = new ConsoleLogger();

        // in-line anonymous class
        logger.log(class {});

        // named class
        class Test {
          publicField = 'public field';
        }
        logger.log(Test);

        expect(processStdoutWriteSpy.firstCall.firstArg).to.include('');
        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(Test.name);
      });
    });
  });

  describe('[instance methods]', () => {
    describe('when the default logger is used', () => {
      const logger = new Logger();

      let processStdoutWriteSpy: sinon.SinonSpy;
      let processStderrWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();
        processStderrWriteSpy.restore();
      });

      it('should print one message to the console', () => {
        const message = 'random message';
        const context = 'RandomContext';

        logger.log(message, context);

        expect(processStdoutWriteSpy.calledOnce).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print one message without context to the console', () => {
        const message = 'random message without context';

        logger.log(message);

        expect(processStdoutWriteSpy.calledOnce).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print multiple messages to the console', () => {
        const messages = ['message 1', 'message 2', 'message 3'];
        const context = 'RandomContext';

        logger.log(messages[0], messages[1], messages[2], context);

        expect(processStdoutWriteSpy.calledThrice).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          messages[0],
        );

        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          messages[1],
        );

        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          messages[2],
        );
      });

      it('should print one error to the console with context', () => {
        const message = 'random error';
        const context = 'RandomContext';

        logger.error(message, context);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print one error to the console with stacktrace', () => {
        const message = 'random error';
        const stacktrace = new Error('err').stack;

        logger.error(message, stacktrace);

        expect(processStderrWriteSpy.calledTwice).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.not.include(`[]`);
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
        expect(processStderrWriteSpy.secondCall.firstArg).to.equal(
          stacktrace + '\n',
        );
      });

      it('should print one error without context to the console', () => {
        const message = 'random error without context';

        logger.error(message);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
      });

      it('should print one error with stacktrace and context to the console', () => {
        const message = 'random error with context';
        const stacktrace = 'stacktrace';
        const context = 'ErrorContext';

        logger.error(message, stacktrace, context);

        expect(processStderrWriteSpy.calledTwice).to.be.true;

        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);

        expect(processStderrWriteSpy.secondCall.firstArg).to.equal(
          stacktrace + '\n',
        );
      });

      it('should print 2 errors and one stacktrace to the console', () => {
        const messages = ['message 1', 'message 2'];
        const stack = 'stacktrace';
        const context = 'RandomContext';

        logger.error(messages[0], messages[1], stack, context);

        expect(processStderrWriteSpy.calledThrice).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          messages[0],
        );

        expect(processStderrWriteSpy.secondCall.firstArg).to.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.secondCall.firstArg).to.include(
          messages[1],
        );

        expect(processStderrWriteSpy.thirdCall.firstArg).to.not.include(
          `[${context}]`,
        );
        expect(processStderrWriteSpy.thirdCall.firstArg).to.equal(stack + '\n');
      });
    });

    describe('when the default logger is used and global context is set and timestamp enabled', () => {
      const globalContext = 'GlobalContext';
      const logger = new Logger(globalContext, { timestamp: true });

      let processStdoutWriteSpy: sinon.SinonSpy;
      let processStderrWriteSpy: sinon.SinonSpy;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
        processStderrWriteSpy = sinon.spy(process.stderr, 'write');
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();
        processStderrWriteSpy.restore();
      });

      it('should print multiple messages to the console and append global context', () => {
        const messages = ['message 1', 'message 2', 'message 3'];

        logger.log(messages[0], messages[1], messages[2]);

        expect(processStdoutWriteSpy.calledThrice).to.be.true;
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          `[${globalContext}]`,
        );
        expect(processStdoutWriteSpy.firstCall.firstArg).to.include(
          messages[0],
        );

        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          `[${globalContext}]`,
        );
        expect(processStdoutWriteSpy.secondCall.firstArg).to.include(
          messages[1],
        );
        expect(processStdoutWriteSpy.secondCall.firstArg).to.include('ms');

        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          `[${globalContext}]`,
        );
        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include(
          messages[2],
        );
        expect(processStdoutWriteSpy.thirdCall.firstArg).to.include('ms');
      });
      it('should log out an error to stderr but not include an undefined log', () => {
        const message = 'message 1';

        logger.error(message);

        expect(processStderrWriteSpy.calledOnce).to.be.true;
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(
          `[${globalContext}]`,
        );
        expect(processStderrWriteSpy.firstCall.firstArg).to.include(message);
      });
    });

    describe('when logging is disabled', () => {
      const logger = new Logger();

      let processStdoutWriteSpy: sinon.SinonSpy;
      let previousLoggerRef: LoggerService;

      beforeEach(() => {
        processStdoutWriteSpy = sinon.spy(process.stdout, 'write');

        previousLoggerRef =
          Logger['localInstanceRef'] || Logger['staticInstanceRef'];
        Logger.overrideLogger(false);
      });

      afterEach(() => {
        processStdoutWriteSpy.restore();

        Logger.overrideLogger(previousLoggerRef);
      });

      it('should not print any message to the console', () => {
        const message = 'random message';
        const context = 'RandomContext';

        logger.log(message, context);

        expect(processStdoutWriteSpy.called).to.be.false;
      });
    });

    describe('when custom logger is being used', () => {
      class CustomLogger implements LoggerService {
        log(message: any, context?: string) {}
        error(message: any, trace?: string, context?: string) {}
        warn(message: any, context?: string) {}
      }

      describe('with global context', () => {
        const customLogger = new CustomLogger();
        const globalContext = 'RandomContext';
        const originalLogger = new Logger(globalContext);

        let previousLoggerRef: LoggerService;

        beforeEach(() => {
          previousLoggerRef =
            Logger['localInstanceRef'] || Logger['staticInstanceRef'];
          Logger.overrideLogger(customLogger);
        });

        afterEach(() => {
          Logger.overrideLogger(previousLoggerRef);
        });

        it('should call custom logger "#log()" method with context as second argument', () => {
          const message = 'random log message with global context';

          const customLoggerLogSpy = sinon.spy(customLogger, 'log');

          originalLogger.log(message);

          expect(customLoggerLogSpy.called).to.be.true;
          expect(customLoggerLogSpy.calledWith(message, globalContext)).to.be
            .true;
        });
        it('should call custom logger "#error()" method with context as third argument', () => {
          const message = 'random error message with global context';

          const customLoggerErrorSpy = sinon.spy(customLogger, 'error');

          originalLogger.error(message);

          expect(customLoggerErrorSpy.called).to.be.true;
          expect(
            customLoggerErrorSpy.calledWith(message, undefined, globalContext),
          ).to.be.true;
        });
      });
      describe('without global context', () => {
        const customLogger = new CustomLogger();
        const originalLogger = new Logger();

        let previousLoggerRef: LoggerService;

        beforeEach(() => {
          previousLoggerRef =
            Logger['localInstanceRef'] || Logger['staticInstanceRef'];
          Logger.overrideLogger(customLogger);
        });

        afterEach(() => {
          Logger.overrideLogger(previousLoggerRef);
        });

        it('should call custom logger "#log()" method', () => {
          const message = 'random message';
          const context = 'RandomContext';

          const customLoggerLogSpy = sinon.spy(customLogger, 'log');

          originalLogger.log(message, context);

          expect(customLoggerLogSpy.called).to.be.true;
          expect(customLoggerLogSpy.calledWith(message, context)).to.be.true;
        });

        it('should call custom logger "#error()" method', () => {
          const message = 'random message';
          const context = 'RandomContext';

          const customLoggerErrorSpy = sinon.spy(customLogger, 'error');

          originalLogger.error(message, undefined, context);

          expect(customLoggerErrorSpy.called).to.be.true;
          expect(customLoggerErrorSpy.calledWith(message, undefined, context))
            .to.be.true;
        });
      });
    });
  });
  describe('ConsoleLogger', () => {
    let processStdoutWriteSpy: sinon.SinonSpy;

    beforeEach(() => {
      processStdoutWriteSpy = sinon.spy(process.stdout, 'write');
    });
    afterEach(() => {
      processStdoutWriteSpy.restore();
    });

    it('should support custom formatter', () => {
      class CustomConsoleLogger extends ConsoleLogger {
        protected formatMessage(
          logLevel: LogLevel,
          message: unknown,
          pidMessage: string,
          formattedLogLevel: string,
          contextMessage: string,
          timestampDiff: string,
        ) {
          return `Prefix: ${message as string}`;
        }
      }

      const consoleLogger = new CustomConsoleLogger();
      consoleLogger.debug('test');

      expect(processStdoutWriteSpy.firstCall.firstArg).to.equal(`Prefix: test`);
    });

    it('should support custom formatter and colorizer', () => {
      class CustomConsoleLogger extends ConsoleLogger {
        protected formatMessage(
          logLevel: LogLevel,
          message: unknown,
          pidMessage: string,
          formattedLogLevel: string,
          contextMessage: string,
          timestampDiff: string,
        ) {
          const strMessage = this.stringifyMessage(message, logLevel);
          return `Prefix: ${strMessage}`;
        }

        protected colorize(message: string, logLevel: LogLevel): string {
          return `~~~${message}~~~`;
        }
      }

      const consoleLogger = new CustomConsoleLogger();
      consoleLogger.debug('test');

      expect(processStdoutWriteSpy.firstCall.firstArg).to.equal(
        `Prefix: ~~~test~~~`,
      );
    });

    it('should stringify messages', () => {
      class CustomConsoleLogger extends ConsoleLogger {
        protected colorize(message: string, _: LogLevel): string {
          return message;
        }
      }

      const consoleLogger = new CustomConsoleLogger({ colors: false });
      const consoleLoggerSpy = sinon.spy(
        consoleLogger,
        'stringifyMessage' as keyof ConsoleLogger,
      );
      consoleLogger.debug(
        'str1',
        { key: 'str2' },
        ['str3'],
        [{ key: 'str4' }],
        null,
        1,
      );

      expect(consoleLoggerSpy.getCall(0).returnValue).to.equal('str1');
      expect(consoleLoggerSpy.getCall(1).returnValue).to.equal(
        `Object(1) {
  key: 'str2'
}`,
      );
      expect(consoleLoggerSpy.getCall(2).returnValue).to.equal(
        `Array(1) [
  'str3'
]`,
      );
      expect(consoleLoggerSpy.getCall(3).returnValue).to.equal(
        `Array(1) [
  {
    key: 'str4'
  }
]`,
      );
      expect(consoleLoggerSpy.getCall(4).returnValue).to.equal('null');
      expect(consoleLoggerSpy.getCall(5).returnValue).to.equal('1');
    });
  });
});

function convertInspectToJSON(inspectOutput: string) {
  const jsonLikeString = inspectOutput
    .replace(/'([^']+)'/g, '"$1"') // single-quoted strings
    .replace(/([a-zA-Z0-9_]+):/g, '"$1":') // unquoted object keys
    .replace(/\bundefined\b/g, 'null')
    .replace(/\[Function(: [^\]]+)?\]/g, '"[Function]"')
    .replace(/\[Circular\]/g, '"[Circular]"');

  try {
    return JSON.parse(jsonLikeString);
  } catch (error) {
    console.error('Error parsing the modified inspect output:', error);
    throw error;
  }
}



================================================
FILE: packages/common/test/services/utils/is-log-level-enabled.util.spec.ts
================================================
import { expect } from 'chai';
import { LogLevel } from '../../../services/logger.service';
import { isLogLevelEnabled } from '../../../services/utils';

describe('isLogLevelEnabled', () => {
  const tests = [
    { inputArgs: ['log', ['log']], expectedReturnValue: true },
    { inputArgs: ['debug', ['debug']], expectedReturnValue: true },
    { inputArgs: ['verbose', ['verbose']], expectedReturnValue: true },
    { inputArgs: ['error', ['error']], expectedReturnValue: true },
    { inputArgs: ['warn', ['warn']], expectedReturnValue: true },
    /** explicitly included + log level is higher than target */
    { inputArgs: ['log', ['error', 'log']], expectedReturnValue: true },
    { inputArgs: ['warn', ['warn', 'error']], expectedReturnValue: true },
    { inputArgs: ['debug', ['warn', 'debug']], expectedReturnValue: true },
    { inputArgs: ['verbose', ['error', 'verbose']], expectedReturnValue: true },
    /** not explicitly included + log level is higher than target */
    { inputArgs: ['log', ['error', 'warn']], expectedReturnValue: false },
    { inputArgs: ['verbose', ['warn']], expectedReturnValue: false },
    { inputArgs: ['debug', ['warn', 'error']], expectedReturnValue: false },
    { inputArgs: ['warn', ['error']], expectedReturnValue: false },
  ];

  for (const { inputArgs, expectedReturnValue } of tests) {
    describe(`when log levels = [${inputArgs[1] as string}]`, () => {
      describe(`and target level is "${inputArgs[0] as string}"`, () => {
        it('should return true', () => {
          expect(
            isLogLevelEnabled(...(inputArgs as [LogLevel, LogLevel[]])),
          ).to.equal(expectedReturnValue);
        });
      });
    });
  }

  describe(`when log levels = undefined`, () => {
    it('should return false', () => {
      expect(isLogLevelEnabled('warn', undefined)).to.be.false;
    });
  });
});



================================================
FILE: packages/common/test/utils/forward-ref.util.spec.ts
================================================
import { expect } from 'chai';
import { forwardRef } from '../../utils/forward-ref.util';

describe('forwardRef', () => {
  it('should return object with forwardRef property', () => {
    const fn = () => ({});
    const referenceFn = forwardRef(() => fn);
    expect(referenceFn.forwardRef()).to.be.eql(fn);
  });
});



================================================
FILE: packages/common/test/utils/load-package.util.spec.ts
================================================
import { expect } from 'chai';
import { loadPackage } from '../../utils/load-package.util';

describe('loadPackage', () => {
  describe('when package is available', () => {
    it('should return package', () => {
      expect(loadPackage('reflect-metadata', 'ctx')).to.be.eql(
        require('reflect-metadata'),
      );
    });
  });
});



================================================
FILE: packages/common/test/utils/merge-with-values.util.spec.ts
================================================
import { expect } from 'chai';
import { MergeWithValues } from '../../utils/merge-with-values.util';

describe('MergeWithValues', () => {
  let type;
  const data = { test: [1, 2, 3] };
  class Test {}

  beforeEach(() => {
    type = MergeWithValues(data)(Test);
  });
  it('should enrich prototype with given values', () => {
    expect(type.prototype).to.contain(data);
  });
  it('should set name of metatype', () => {
    expect(type.name).to.eq(Test.name + JSON.stringify(data));
  });
});



================================================
FILE: packages/common/test/utils/random-string-generator.util.spec.ts
================================================
import { expect } from 'chai';
import { randomStringGenerator } from '../../utils/random-string-generator.util';

describe('randomStringGenerator', () => {
  it('should generate random string', () => {
    expect(randomStringGenerator()).to.be.a('string');
  });
});



================================================
FILE: packages/common/test/utils/select-exception-filter-metadata.util.spec.ts
================================================
import { expect } from 'chai';
import { selectExceptionFilterMetadata } from '../../utils/select-exception-filter-metadata.util';

class FirstError {}

class SecondError {}

class ThirdError {}

class FourthError {}

describe('selectExceptionFilterMetadata', () => {
  it('should pass error handling to first suitable error handler', () => {
    const metadataList = [
      {
        exceptionMetatypes: [FirstError, SecondError],
        func: () => {},
      },
      {
        exceptionMetatypes: [ThirdError, FourthError],
        func: () => {},
      },
    ];

    expect(
      selectExceptionFilterMetadata(metadataList, new FourthError()),
    ).to.be.equal(metadataList[1]);
  });

  describe('when multiple exception handlers are accepting error handling', () => {
    it('should pass exception handling to the first one', () => {
      const metadataList = [
        {
          exceptionMetatypes: [FirstError, SecondError],
          func: () => {},
        },
        {
          exceptionMetatypes: [FirstError, FourthError],
          func: () => {},
        },
      ];

      expect(
        selectExceptionFilterMetadata(metadataList, new FirstError()),
      ).to.be.equal(metadataList[0]);
    });
  });

  describe('when no exception handler is accepting error handling', () => {
    it('should return undefined', () => {
      const metadataList = [
        {
          exceptionMetatypes: [FirstError, SecondError],
          func: () => {},
        },
        {
          exceptionMetatypes: [FirstError, FourthError],
          func: () => {},
        },
      ];

      expect(selectExceptionFilterMetadata(metadataList, new ThirdError())).to
        .be.undefined;
    });
  });

  describe('when exception handler has empty list of meta types', () => {
    it('should pass any remaining error handling to it', () => {
      const metadataList = [
        {
          exceptionMetatypes: [FirstError, SecondError],
          func: () => {},
        },
        {
          exceptionMetatypes: [],
          func: () => {},
        },
      ];

      expect(
        selectExceptionFilterMetadata(metadataList, new ThirdError()),
      ).to.be.equal(metadataList[1]);
    });
  });
});



================================================
FILE: packages/common/test/utils/shared.utils.spec.ts
================================================
import { expect } from 'chai';
import {
  addLeadingSlash,
  isConstructor,
  isEmpty,
  isFunction,
  isNil,
  isNumber,
  isObject,
  isPlainObject,
  isString,
  isSymbol,
  isUndefined,
  normalizePath,
  stripEndSlash,
} from '../../utils/shared.utils';

function Foo(a) {
  this.a = 1;
}

describe('Shared utils', () => {
  describe('isUndefined', () => {
    it('should return true when obj is undefined', () => {
      expect(isUndefined(undefined)).to.be.true;
    });
    it('should return false when object is not undefined', () => {
      expect(isUndefined({})).to.be.false;
    });
  });
  describe('isFunction', () => {
    it('should return true when obj is function', () => {
      expect(isFunction(() => ({}))).to.be.true;
    });
    it('should return false when object is not function', () => {
      expect(isFunction(null)).to.be.false;
      expect(isFunction(undefined)).to.be.false;
    });
  });
  describe('isObject', () => {
    it('should return true when obj is object', () => {
      expect(isObject({})).to.be.true;
    });
    it('should return false when object is not object', () => {
      expect(isObject(3)).to.be.false;
      expect(isObject(null)).to.be.false;
      expect(isObject(undefined)).to.be.false;
    });
  });
  describe('isPlainObject', () => {
    it('should return true when obj is plain object', () => {
      expect(isPlainObject({})).to.be.true;
      expect(isPlainObject({ prop: true })).to.be.true;
      expect(
        isPlainObject({
          constructor: Foo,
        }),
      ).to.be.true;
      expect(isPlainObject(Object.create(null))).to.be.true;
    });
    it('should return false when object is not object', () => {
      expect(isPlainObject(3)).to.be.false;
      expect(isPlainObject(null)).to.be.false;
      expect(isPlainObject(undefined)).to.be.false;
      expect(isPlainObject([1, 2, 3])).to.be.false;
      expect(isPlainObject(new Date())).to.be.false;
      expect(isPlainObject(new Foo(1))).to.be.false;
    });
  });
  describe('isString', () => {
    it('should return true when val is a string', () => {
      expect(isString('true')).to.be.true;
    });
    it('should return false when val is not a string', () => {
      expect(isString(new String('fine'))).to.be.false;
      expect(isString(false)).to.be.false;
      expect(isString(null)).to.be.false;
      expect(isString(undefined)).to.be.false;
    });
  });
  describe('isSymbol', () => {
    it('should return true when val is a Symbol', () => {
      expect(isSymbol(Symbol())).to.be.true;
    });
    it('should return false when val is not a symbol', () => {
      expect(isSymbol('Symbol()')).to.be.false;
      expect(isSymbol(false)).to.be.false;
      expect(isSymbol(null)).to.be.false;
      expect(isSymbol(undefined)).to.be.false;
    });
  });
  describe('isNumber', () => {
    it('should return true when val is a number or NaN', () => {
      expect(isNumber(1)).to.be.true;
      expect(isNumber(1.23)).to.be.true; // with decimals
      expect(isNumber(123e-5)).to.be.true; // scientific (exponent) notation
      expect(isNumber(0o1)).to.be.true; // octal notation
      expect(isNumber(0b1)).to.be.true; // binary notation
      expect(isNumber(0x1)).to.be.true; // hexadecimal notation
      expect(isNumber(NaN)).to.be.true;
    });
    it('should return false when val is not a number', () => {
      // expect(isNumber(1n)).to.be.false; // big int (available on ES2020)
      expect(isNumber('1')).to.be.false; // string
      expect(isNumber(undefined)).to.be.false; // nullish
      expect(isNumber(null)).to.be.false; // nullish
    });
  });
  describe('isConstructor', () => {
    it('should return true when string is equal to constructor', () => {
      expect(isConstructor('constructor')).to.be.true;
    });
    it('should return false when string is not equal to constructor', () => {
      expect(isConstructor('nope')).to.be.false;
    });
  });
  describe('addLeadingSlash', () => {
    it('should return the validated path ("add / if not exists")', () => {
      expect(addLeadingSlash('nope')).to.be.eql('/nope');
      expect(addLeadingSlash('{:nope}')).to.be.eql('/{:nope}');
    });
    it('should return the same path', () => {
      expect(addLeadingSlash('/nope')).to.be.eql('/nope');
      expect(addLeadingSlash('{/:nope}')).to.be.eql('{/:nope}');
    });
    it('should return empty path', () => {
      expect(addLeadingSlash('')).to.be.eql('');
      expect(addLeadingSlash(null!)).to.be.eql('');
      expect(addLeadingSlash(undefined)).to.be.eql('');
    });
  });
  describe('normalizePath', () => {
    it('should remove all trailing slashes at the end of the path', () => {
      expect(normalizePath('path/')).to.be.eql('/path');
      expect(normalizePath('path///')).to.be.eql('/path');
      expect(normalizePath('/path/path///')).to.be.eql('/path/path');
    });
    it('should replace all slashes with only one slash', () => {
      expect(normalizePath('////path/')).to.be.eql('/path');
      expect(normalizePath('///')).to.be.eql('/');
      expect(normalizePath('/path////path///')).to.be.eql('/path/path');
    });
    it('should return / for empty path', () => {
      expect(normalizePath('')).to.be.eql('/');
      expect(normalizePath(null!)).to.be.eql('/');
      expect(normalizePath(undefined)).to.be.eql('/');
    });
  });
  describe('isNil', () => {
    it('should return true when obj is undefined or null', () => {
      expect(isNil(undefined)).to.be.true;
      expect(isNil(null)).to.be.true;
    });
    it('should return false when object is not undefined and null', () => {
      expect(isNil('3')).to.be.false;
    });
  });
  describe('isEmpty', () => {
    it('should return true when array is empty or not exists', () => {
      expect(isEmpty([])).to.be.true;
      expect(isEmpty(null)).to.be.true;
      expect(isEmpty(undefined)).to.be.true;
    });
    it('should return false when array is not empty', () => {
      expect(isEmpty([1, 2])).to.be.false;
    });
  });
  describe('stripEndSlash', () => {
    it('should strip end slash if present', () => {
      expect(stripEndSlash('/cats/')).to.equal('/cats');
      expect(stripEndSlash('/cats')).to.equal('/cats');
    });
  });
});



================================================
FILE: packages/common/test/utils/validate-each.util.spec.ts
================================================
import { expect } from 'chai';
import { isFunction } from '../../utils/shared.utils';
import {
  validateEach,
  InvalidDecoratorItemException,
} from '../../utils/validate-each.util';

describe('validateEach', () => {
  describe('when any item will not pass predicate', () => {
    it('should throw exception', () => {
      expect(() =>
        validateEach({ name: 'test' } as any, ['test'], isFunction, '', ''),
      ).to.throws(InvalidDecoratorItemException);
    });
  });
  describe('when all items passed predicate', () => {
    it('should return true', () => {
      expect(validateEach({} as any, [() => null], isFunction, '', '')).to.be
        .true;
    });
  });
});



================================================
FILE: packages/common/utils/assign-custom-metadata.util.ts
================================================
import { CUSTOM_ROUTE_ARGS_METADATA } from '../constants';
import {
  ParamData,
  RouteParamMetadata,
} from '../decorators/http/route-params.decorator';
import { PipeTransform, Type } from '../interfaces';
import { CustomParamFactory } from '../interfaces/features/custom-route-param-factory.interface';

export function assignCustomParameterMetadata(
  args: Record<number, RouteParamMetadata>,
  paramtype: number | string,
  index: number,
  factory: CustomParamFactory,
  data?: ParamData,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
) {
  return {
    ...args,
    [`${paramtype}${CUSTOM_ROUTE_ARGS_METADATA}:${index}`]: {
      index,
      factory,
      data,
      pipes,
    },
  };
}



================================================
FILE: packages/common/utils/cli-colors.util.ts
================================================
type ColorTextFn = (text: string) => string;

const isColorAllowed = () => !process.env.NO_COLOR;
const colorIfAllowed = (colorFn: ColorTextFn) => (text: string) =>
  isColorAllowed() ? colorFn(text) : text;

export const clc = {
  bold: colorIfAllowed((text: string) => `\x1B[1m${text}\x1B[0m`),
  green: colorIfAllowed((text: string) => `\x1B[32m${text}\x1B[39m`),
  yellow: colorIfAllowed((text: string) => `\x1B[33m${text}\x1B[39m`),
  red: colorIfAllowed((text: string) => `\x1B[31m${text}\x1B[39m`),
  magentaBright: colorIfAllowed((text: string) => `\x1B[95m${text}\x1B[39m`),
  cyanBright: colorIfAllowed((text: string) => `\x1B[96m${text}\x1B[39m`),
};
export const yellow = colorIfAllowed(
  (text: string) => `\x1B[38;5;3m${text}\x1B[39m`,
);



================================================
FILE: packages/common/utils/extend-metadata.util.ts
================================================
export function extendArrayMetadata<T extends Array<unknown>>(
  key: string,
  metadata: T,
  target: Function,
) {
  const previousValue = Reflect.getMetadata(key, target) || [];
  const value = [...previousValue, ...metadata];
  Reflect.defineMetadata(key, value, target);
}



================================================
FILE: packages/common/utils/forward-ref.util.ts
================================================
import { ForwardReference } from '../interfaces/modules/forward-reference.interface';

/**
 * @publicApi
 */
export const forwardRef = (fn: () => any): ForwardReference => ({
  forwardRef: fn,
});



================================================
FILE: packages/common/utils/http-error-by-code.util.ts
================================================
import { HttpStatus } from '../enums';
import {
  BadGatewayException,
  BadRequestException,
  ConflictException,
  ForbiddenException,
  GatewayTimeoutException,
  GoneException,
  ImATeapotException,
  InternalServerErrorException,
  MethodNotAllowedException,
  NotAcceptableException,
  NotFoundException,
  NotImplementedException,
  PayloadTooLargeException,
  PreconditionFailedException,
  RequestTimeoutException,
  ServiceUnavailableException,
  UnauthorizedException,
  UnprocessableEntityException,
  UnsupportedMediaTypeException,
} from '../exceptions';
import { Type } from '../interfaces';

export type ErrorHttpStatusCode =
  | HttpStatus.BAD_GATEWAY
  | HttpStatus.BAD_REQUEST
  | HttpStatus.CONFLICT
  | HttpStatus.FORBIDDEN
  | HttpStatus.GATEWAY_TIMEOUT
  | HttpStatus.GONE
  | HttpStatus.I_AM_A_TEAPOT
  | HttpStatus.INTERNAL_SERVER_ERROR
  | HttpStatus.METHOD_NOT_ALLOWED
  | HttpStatus.NOT_ACCEPTABLE
  | HttpStatus.NOT_FOUND
  | HttpStatus.NOT_IMPLEMENTED
  | HttpStatus.PAYLOAD_TOO_LARGE
  | HttpStatus.PRECONDITION_FAILED
  | HttpStatus.REQUEST_TIMEOUT
  | HttpStatus.SERVICE_UNAVAILABLE
  | HttpStatus.UNAUTHORIZED
  | HttpStatus.UNPROCESSABLE_ENTITY
  | HttpStatus.UNSUPPORTED_MEDIA_TYPE;

export const HttpErrorByCode: Record<ErrorHttpStatusCode, Type<unknown>> = {
  [HttpStatus.BAD_GATEWAY]: BadGatewayException,
  [HttpStatus.BAD_REQUEST]: BadRequestException,
  [HttpStatus.CONFLICT]: ConflictException,
  [HttpStatus.FORBIDDEN]: ForbiddenException,
  [HttpStatus.GATEWAY_TIMEOUT]: GatewayTimeoutException,
  [HttpStatus.GONE]: GoneException,
  [HttpStatus.I_AM_A_TEAPOT]: ImATeapotException,
  [HttpStatus.INTERNAL_SERVER_ERROR]: InternalServerErrorException,
  [HttpStatus.METHOD_NOT_ALLOWED]: MethodNotAllowedException,
  [HttpStatus.NOT_ACCEPTABLE]: NotAcceptableException,
  [HttpStatus.NOT_FOUND]: NotFoundException,
  [HttpStatus.NOT_IMPLEMENTED]: NotImplementedException,
  [HttpStatus.PAYLOAD_TOO_LARGE]: PayloadTooLargeException,
  [HttpStatus.PRECONDITION_FAILED]: PreconditionFailedException,
  [HttpStatus.REQUEST_TIMEOUT]: RequestTimeoutException,
  [HttpStatus.SERVICE_UNAVAILABLE]: ServiceUnavailableException,
  [HttpStatus.UNAUTHORIZED]: UnauthorizedException,
  [HttpStatus.UNPROCESSABLE_ENTITY]: UnprocessableEntityException,
  [HttpStatus.UNSUPPORTED_MEDIA_TYPE]: UnsupportedMediaTypeException,
};



================================================
FILE: packages/common/utils/index.ts
================================================
export * from './forward-ref.util';



================================================
FILE: packages/common/utils/load-package.util.ts
================================================
import { Logger } from '../services/logger.service';

const MISSING_REQUIRED_DEPENDENCY = (name: string, reason: string) =>
  `The "${name}" package is missing. Please, make sure to install it to take advantage of ${reason}.`;

const logger = new Logger('PackageLoader');

export function loadPackage(
  packageName: string,
  context: string,
  loaderFn?: Function,
) {
  try {
    return loaderFn ? loaderFn() : require(packageName);
  } catch (e) {
    logger.error(MISSING_REQUIRED_DEPENDENCY(packageName, context));
    Logger.flush();
    process.exit(1);
  }
}



================================================
FILE: packages/common/utils/merge-with-values.util.ts
================================================
export type Constructor<T> = new (...args: any[]) => T;

/* eslint-disable @typescript-eslint/no-empty-object-type */
export const MergeWithValues = <T extends Constructor<{}>>(data: {
  [param: string]: any;
}) => {
  return (Metatype: T): any => {
    const Type = class extends Metatype {
      constructor(...args: any[]) {
        super(...args);
      }
    };
    const token = Metatype.name + JSON.stringify(data);
    Object.defineProperty(Type, 'name', { value: token });
    Object.assign(Type.prototype, data);
    return Type;
  };
};



================================================
FILE: packages/common/utils/random-string-generator.util.ts
================================================
import { uid } from 'uid';

export const randomStringGenerator = () => uid(21);



================================================
FILE: packages/common/utils/select-exception-filter-metadata.util.ts
================================================
import { ExceptionFilterMetadata } from '../interfaces/exceptions';

export const selectExceptionFilterMetadata = <T = any>(
  filters: ExceptionFilterMetadata[],
  exception: T,
): ExceptionFilterMetadata | undefined =>
  filters.find(
    ({ exceptionMetatypes }) =>
      !exceptionMetatypes.length ||
      exceptionMetatypes.some(
        ExceptionMetaType => exception instanceof ExceptionMetaType,
      ),
  );



================================================
FILE: packages/common/utils/shared.utils.ts
================================================
export const isUndefined = (obj: any): obj is undefined =>
  typeof obj === 'undefined';

export const isObject = (fn: any): fn is object =>
  !isNil(fn) && typeof fn === 'object';

export const isPlainObject = (fn: any): fn is object => {
  if (!isObject(fn)) {
    return false;
  }
  const proto = Object.getPrototypeOf(fn);
  if (proto === null) {
    return true;
  }
  const ctor =
    Object.prototype.hasOwnProperty.call(proto, 'constructor') &&
    proto.constructor;
  return (
    typeof ctor === 'function' &&
    ctor instanceof ctor &&
    Function.prototype.toString.call(ctor) ===
      Function.prototype.toString.call(Object)
  );
};

export const addLeadingSlash = (path?: string): string =>
  path && typeof path === 'string'
    ? path.charAt(0) !== '/' && path.substring(0, 2) !== '{/'
      ? '/' + path
      : path
    : '';

export const normalizePath = (path?: string): string =>
  path
    ? path.startsWith('/')
      ? ('/' + path.replace(/\/+$/, '')).replace(/\/+/g, '/')
      : '/' + path.replace(/\/+$/, '')
    : '/';

export const stripEndSlash = (path: string) =>
  path[path.length - 1] === '/' ? path.slice(0, path.length - 1) : path;

export const isFunction = (val: any): val is Function =>
  typeof val === 'function';
export const isString = (val: any): val is string => typeof val === 'string';
export const isNumber = (val: any): val is number => typeof val === 'number';
export const isConstructor = (val: any): boolean => val === 'constructor';
export const isNil = (val: any): val is null | undefined =>
  isUndefined(val) || val === null;
export const isEmpty = (array: any): boolean => !(array && array.length > 0);
export const isSymbol = (val: any): val is symbol => typeof val === 'symbol';



================================================
FILE: packages/common/utils/validate-each.util.ts
================================================
export class InvalidDecoratorItemException extends Error {
  private readonly msg: string;

  constructor(decorator: string, item: string, context: string) {
    const message = `Invalid ${item} passed to ${decorator}() decorator (${context}).`;
    super(message);

    this.msg = message;
  }

  public what(): string {
    return this.msg;
  }
}

export function validateEach(
  context: { name: string },
  arr: any[],
  predicate: Function,
  decorator: string,
  item: string,
): boolean {
  if (!context || !context.name) {
    return true;
  }
  const errors = arr.some(str => !predicate(str));
  if (errors) {
    throw new InvalidDecoratorItemException(decorator, item, context.name);
  }
  return true;
}



================================================
FILE: packages/common/utils/validate-module-keys.util.ts
================================================
import { MODULE_METADATA as metadataConstants } from '../constants';

export const INVALID_MODULE_CONFIG_MESSAGE = (
  text: TemplateStringsArray,
  property: string,
) => `Invalid property '${property}' passed into the @Module() decorator.`;

const metadataKeys = [
  metadataConstants.IMPORTS,
  metadataConstants.EXPORTS,
  metadataConstants.CONTROLLERS,
  metadataConstants.PROVIDERS,
];

export function validateModuleKeys(keys: string[]) {
  const validateKey = (key: string) => {
    if (metadataKeys.includes(key)) {
      return;
    }
    throw new Error(INVALID_MODULE_CONFIG_MESSAGE`${key}`);
  };
  keys.forEach(validateKey);
}



================================================
FILE: packages/core/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/core/application-config.ts
================================================
import {
  CanActivate,
  ExceptionFilter,
  NestInterceptor,
  PipeTransform,
  VersioningOptions,
  WebSocketAdapter,
} from '@nestjs/common';
import { GlobalPrefixOptions } from '@nestjs/common/interfaces';
import { InstanceWrapper } from './injector/instance-wrapper';
import { ExcludeRouteMetadata } from './router/interfaces/exclude-route-metadata.interface';

export class ApplicationConfig {
  private globalPrefix = '';
  private globalPrefixOptions: GlobalPrefixOptions<ExcludeRouteMetadata> = {};
  private globalPipes: Array<PipeTransform> = [];
  private globalFilters: Array<ExceptionFilter> = [];
  private globalInterceptors: Array<NestInterceptor> = [];
  private globalGuards: Array<CanActivate> = [];
  private versioningOptions: VersioningOptions;
  private readonly globalRequestPipes: InstanceWrapper<PipeTransform>[] = [];
  private readonly globalRequestFilters: InstanceWrapper<ExceptionFilter>[] =
    [];
  private readonly globalRequestInterceptors: InstanceWrapper<NestInterceptor>[] =
    [];
  private readonly globalRequestGuards: InstanceWrapper<CanActivate>[] = [];

  constructor(private ioAdapter: WebSocketAdapter | null = null) {}

  public setGlobalPrefix(prefix: string) {
    this.globalPrefix = prefix;
  }

  public getGlobalPrefix() {
    return this.globalPrefix;
  }

  public setGlobalPrefixOptions(
    options: GlobalPrefixOptions<ExcludeRouteMetadata>,
  ) {
    this.globalPrefixOptions = options;
  }

  public getGlobalPrefixOptions(): GlobalPrefixOptions<ExcludeRouteMetadata> {
    return this.globalPrefixOptions;
  }

  public setIoAdapter(ioAdapter: WebSocketAdapter) {
    this.ioAdapter = ioAdapter;
  }

  public getIoAdapter(): WebSocketAdapter {
    return this.ioAdapter!;
  }

  public addGlobalPipe(pipe: PipeTransform<any>) {
    this.globalPipes.push(pipe);
  }

  public useGlobalPipes(...pipes: PipeTransform<any>[]) {
    this.globalPipes = this.globalPipes.concat(pipes);
  }

  public getGlobalFilters(): ExceptionFilter[] {
    return this.globalFilters;
  }

  public addGlobalFilter(filter: ExceptionFilter) {
    this.globalFilters.push(filter);
  }

  public useGlobalFilters(...filters: ExceptionFilter[]) {
    this.globalFilters = this.globalFilters.concat(filters);
  }

  public getGlobalPipes(): PipeTransform<any>[] {
    return this.globalPipes;
  }

  public getGlobalInterceptors(): NestInterceptor[] {
    return this.globalInterceptors;
  }

  public addGlobalInterceptor(interceptor: NestInterceptor) {
    this.globalInterceptors.push(interceptor);
  }

  public useGlobalInterceptors(...interceptors: NestInterceptor[]) {
    this.globalInterceptors = this.globalInterceptors.concat(interceptors);
  }

  public getGlobalGuards(): CanActivate[] {
    return this.globalGuards;
  }

  public addGlobalGuard(guard: CanActivate) {
    this.globalGuards.push(guard);
  }

  public useGlobalGuards(...guards: CanActivate[]) {
    this.globalGuards = this.globalGuards.concat(guards);
  }

  public addGlobalRequestInterceptor(
    wrapper: InstanceWrapper<NestInterceptor>,
  ) {
    this.globalRequestInterceptors.push(wrapper);
  }

  public getGlobalRequestInterceptors(): InstanceWrapper<NestInterceptor>[] {
    return this.globalRequestInterceptors;
  }

  public addGlobalRequestPipe(wrapper: InstanceWrapper<PipeTransform>) {
    this.globalRequestPipes.push(wrapper);
  }

  public getGlobalRequestPipes(): InstanceWrapper<PipeTransform>[] {
    return this.globalRequestPipes;
  }

  public addGlobalRequestFilter(wrapper: InstanceWrapper<ExceptionFilter>) {
    this.globalRequestFilters.push(wrapper);
  }

  public getGlobalRequestFilters(): InstanceWrapper<ExceptionFilter>[] {
    return this.globalRequestFilters;
  }

  public addGlobalRequestGuard(wrapper: InstanceWrapper<CanActivate>) {
    this.globalRequestGuards.push(wrapper);
  }

  public getGlobalRequestGuards(): InstanceWrapper<CanActivate>[] {
    return this.globalRequestGuards;
  }

  public enableVersioning(options: VersioningOptions): void {
    if (Array.isArray(options.defaultVersion)) {
      // Drop duplicated versions
      options.defaultVersion = Array.from(new Set(options.defaultVersion));
    }

    this.versioningOptions = options;
  }

  public getVersioning(): VersioningOptions | undefined {
    return this.versioningOptions;
  }
}



================================================
FILE: packages/core/constants.ts
================================================
import { EnhancerSubtype } from '@nestjs/common/constants';

export const MESSAGES = {
  APPLICATION_START: `Starting Nest application...`,
  APPLICATION_READY: `Nest application successfully started`,
  MICROSERVICE_READY: `Nest microservice successfully started`,
  UNKNOWN_EXCEPTION_MESSAGE: 'Internal server error',
  ERROR_DURING_SHUTDOWN: 'Error happened during shutdown',
  CALL_LISTEN_FIRST:
    'app.listen() needs to be called before calling app.getUrl()',
};

export const APP_INTERCEPTOR = 'APP_INTERCEPTOR';
export const APP_PIPE = 'APP_PIPE';
export const APP_GUARD = 'APP_GUARD';
export const APP_FILTER = 'APP_FILTER';
export const ENHANCER_TOKEN_TO_SUBTYPE_MAP: Record<
  | typeof APP_GUARD
  | typeof APP_PIPE
  | typeof APP_FILTER
  | typeof APP_INTERCEPTOR,
  EnhancerSubtype
> = {
  [APP_GUARD]: 'guard',
  [APP_INTERCEPTOR]: 'interceptor',
  [APP_PIPE]: 'pipe',
  [APP_FILTER]: 'filter',
} as const;



================================================
FILE: packages/core/index.ts
================================================
/*
 * Nest @core
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */
import 'reflect-metadata';

export * from './adapters';
export * from './application-config';
export { APP_FILTER, APP_GUARD, APP_INTERCEPTOR, APP_PIPE } from './constants';
export * from './discovery';
export * from './exceptions';
export * from './helpers';
export * from './injector';
export * from './inspector';
export * from './metadata-scanner';
export * from './middleware';
export * from './nest-application';
export * from './nest-application-context';
export { NestFactory } from './nest-factory';
export * from './repl';
export * from './router';
export * from './services';



================================================
FILE: packages/core/metadata-scanner.ts
================================================
import { Injectable } from '@nestjs/common/interfaces/injectable.interface';
import {
  isConstructor,
  isFunction,
  isNil,
} from '@nestjs/common/utils/shared.utils';

export class MetadataScanner {
  private readonly cachedScannedPrototypes: Map<object, string[]> = new Map();

  /**
   * @deprecated
   * @see {@link getAllMethodNames}
   * @see getAllMethodNames
   */
  public scanFromPrototype<T extends Injectable, R = any>(
    instance: T,
    prototype: object | null,
    callback: (name: string) => R,
  ): R[] {
    if (!prototype) {
      return [];
    }

    const visitedNames = new Map<string, boolean>();
    const result: R[] = [];

    do {
      for (const property of Object.getOwnPropertyNames(prototype)) {
        if (visitedNames.has(property)) {
          continue;
        }

        visitedNames.set(property, true);

        // reason: https://github.com/nestjs/nest/pull/10821#issuecomment-1411916533
        const descriptor = Object.getOwnPropertyDescriptor(
          prototype,
          property,
        )!;

        if (
          descriptor.set ||
          descriptor.get ||
          isConstructor(property) ||
          !isFunction(prototype[property])
        ) {
          continue;
        }

        const value = callback(property);

        if (isNil(value)) {
          continue;
        }

        result.push(value);
      }
    } while (
      (prototype = Reflect.getPrototypeOf(prototype)) &&
      prototype !== Object.prototype
    );

    return result;
  }

  /**
   * @deprecated
   * @see {@link getAllMethodNames}
   * @see getAllMethodNames
   */
  public *getAllFilteredMethodNames(
    prototype: object,
  ): IterableIterator<string> {
    yield* this.getAllMethodNames(prototype);
  }

  public getAllMethodNames(prototype: object | null): string[] {
    if (!prototype) {
      return [];
    }

    if (this.cachedScannedPrototypes.has(prototype)) {
      return this.cachedScannedPrototypes.get(prototype)!;
    }

    const visitedNames = new Map<string, boolean>();
    const result: string[] = [];

    this.cachedScannedPrototypes.set(prototype, result);

    do {
      for (const property of Object.getOwnPropertyNames(prototype)) {
        if (visitedNames.has(property)) {
          continue;
        }

        visitedNames.set(property, true);

        // reason: https://github.com/nestjs/nest/pull/10821#issuecomment-1411916533
        const descriptor = Object.getOwnPropertyDescriptor(prototype, property);

        if (
          descriptor!.set ||
          descriptor!.get ||
          isConstructor(property) ||
          !isFunction(prototype[property])
        ) {
          continue;
        }

        result.push(property);
      }
    } while (
      (prototype = Reflect.getPrototypeOf(prototype)) &&
      prototype !== Object.prototype
    );

    return result;
  }
}



================================================
FILE: packages/core/nest-application-context.ts
================================================
import {
  INestApplicationContext,
  Logger,
  LoggerService,
  LogLevel,
  ShutdownSignal,
} from '@nestjs/common';
import {
  Abstract,
  DynamicModule,
  GetOrResolveOptions,
  SelectOptions,
  Type,
} from '@nestjs/common/interfaces';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { MESSAGES } from './constants';
import { UnknownModuleException } from './errors/exceptions';
import { createContextId } from './helpers/context-id-factory';
import {
  callAppShutdownHook,
  callBeforeAppShutdownHook,
  callModuleBootstrapHook,
  callModuleDestroyHook,
  callModuleInitHook,
} from './hooks';
import { AbstractInstanceResolver } from './injector/abstract-instance-resolver';
import { ModuleCompiler } from './injector/compiler';
import { NestContainer } from './injector/container';
import { Injector } from './injector/injector';
import { InstanceLinksHost } from './injector/instance-links-host';
import { ContextId } from './injector/instance-wrapper';
import { Module } from './injector/module';

/**
 * @publicApi
 */
export class NestApplicationContext<
    TOptions extends
      NestApplicationContextOptions = NestApplicationContextOptions,
  >
  extends AbstractInstanceResolver
  implements INestApplicationContext
{
  protected isInitialized = false;
  protected injector: Injector;
  protected readonly logger = new Logger(NestApplicationContext.name, {
    timestamp: true,
  });

  private shouldFlushLogsOnOverride = false;
  private readonly activeShutdownSignals = new Array<string>();
  private readonly moduleCompiler: ModuleCompiler;
  private shutdownCleanupRef?: (...args: unknown[]) => unknown;
  private _instanceLinksHost: InstanceLinksHost;
  private _moduleRefsForHooksByDistance?: Array<Module>;
  private initializationPromise?: Promise<void>;

  protected get instanceLinksHost() {
    if (!this._instanceLinksHost) {
      this._instanceLinksHost = new InstanceLinksHost(this.container);
    }
    return this._instanceLinksHost;
  }

  constructor(
    protected readonly container: NestContainer,
    protected readonly appOptions: TOptions = {} as TOptions,
    private contextModule: Module | null = null,
    private readonly scope = new Array<Type<any>>(),
  ) {
    super();
    this.injector = new Injector();
    this.moduleCompiler = container.getModuleCompiler();

    if (this.appOptions.preview) {
      this.printInPreviewModeWarning();
    }
  }

  public selectContextModule() {
    const modules = this.container.getModules().values();
    this.contextModule = modules.next().value!;
  }

  /**
   * Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.
   * @returns {INestApplicationContext}
   */
  public select<T>(
    moduleType: Type<T> | DynamicModule,
    selectOptions?: SelectOptions,
  ): INestApplicationContext {
    const modulesContainer = this.container.getModules();
    const contextModuleCtor = this.contextModule!.metatype;
    const scope = this.scope.concat(contextModuleCtor);

    const moduleTokenFactory = this.container.getModuleTokenFactory();
    const { type, dynamicMetadata } =
      this.moduleCompiler.extractMetadata(moduleType);
    const token = dynamicMetadata
      ? moduleTokenFactory.createForDynamic(
          type,
          dynamicMetadata,
          moduleType as DynamicModule,
        )
      : moduleTokenFactory.createForStatic(type, moduleType as Type);

    const selectedModule = modulesContainer.get(token);
    if (!selectedModule) {
      throw new UnknownModuleException(type.name);
    }

    const options =
      typeof selectOptions?.abortOnError !== 'undefined'
        ? {
            ...this.appOptions,
            ...selectOptions,
          }
        : this.appOptions;

    return new NestApplicationContext(
      this.container,
      options,
      selectedModule,
      scope,
    );
  }

  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  public get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): TResult;
  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  public get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: {
      strict?: boolean;
      each?: undefined | false;
    },
  ): TResult;
  /**
   * Retrieves a list of instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  public get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: {
      strict?: boolean;
      each: true;
    },
  ): Array<TResult>;
  /**
   * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {TResult | Array<TResult>}
   */
  public get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,
    options: GetOrResolveOptions = { strict: false },
  ): TResult | Array<TResult> {
    return !(options && options.strict)
      ? this.find<TInput, TResult>(typeOrToken, options)
      : this.find<TInput, TResult>(typeOrToken, {
          moduleId: this.contextModule?.id,
          each: options.each,
        });
  }

  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  public resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  public resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: {
      id: number;
    },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  public resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: {
      id: number;
    },
    options?: {
      strict?: boolean;
      each?: undefined | false;
    },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  public resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: {
      id: number;
    },
    options?: {
      strict?: boolean;
      each: true;
    },
  ): Promise<Array<TResult>>;
  /**
   * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {Promise<TResult | Array<TResult>>}
   */
  public resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,
    contextId = createContextId(),
    options: GetOrResolveOptions = { strict: false },
  ): Promise<TResult | Array<TResult>> {
    return this.resolvePerContext<TInput, TResult>(
      typeOrToken,
      this.contextModule!,
      contextId,
      options,
    );
  }

  /**
   * Registers the request/context object for a given context ID (DI container sub-tree).
   * @returns {void}
   */
  public registerRequestByContextId<T = any>(request: T, contextId: ContextId) {
    this.container.registerRequestProvider(request, contextId);
  }

  /**
   * Initializes the Nest application.
   * Calls the Nest lifecycle events.
   *
   * @returns {Promise<this>} The NestApplicationContext instance as Promise
   */
  public async init(): Promise<this> {
    if (this.isInitialized) {
      return this;
    }
    /* eslint-disable-next-line no-async-promise-executor */
    this.initializationPromise = new Promise(async (resolve, reject) => {
      try {
        await this.callInitHook();
        await this.callBootstrapHook();
        resolve();
      } catch (err) {
        reject(err);
      }
    });
    await this.initializationPromise;

    this.isInitialized = true;
    return this;
  }

  /**
   * Terminates the application
   * @returns {Promise<void>}
   */
  public async close(signal?: string): Promise<void> {
    await this.initializationPromise;
    await this.callDestroyHook();
    await this.callBeforeShutdownHook(signal);
    await this.dispose();
    await this.callShutdownHook(signal);
    this.unsubscribeFromProcessSignals();
  }

  /**
   * Sets custom logger service.
   * Flushes buffered logs if auto flush is on.
   * @returns {void}
   */
  public useLogger(logger: LoggerService | LogLevel[] | false) {
    Logger.overrideLogger(logger);

    if (this.shouldFlushLogsOnOverride) {
      this.flushLogs();
    }
  }

  /**
   * Prints buffered logs and detaches buffer.
   * @returns {void}
   */
  public flushLogs() {
    Logger.flush();
  }

  /**
   * Define that it must flush logs right after defining a custom logger.
   */
  public flushLogsOnOverride() {
    this.shouldFlushLogsOnOverride = true;
  }

  /**
   * Enables the usage of shutdown hooks. Will call the
   * `onApplicationShutdown` function of a provider if the
   * process receives a shutdown signal.
   *
   * @param {ShutdownSignal[]} [signals=[]] The system signals it should listen to
   *
   * @returns {this} The Nest application context instance
   */
  public enableShutdownHooks(signals: (ShutdownSignal | string)[] = []): this {
    if (isEmpty(signals)) {
      signals = Object.keys(ShutdownSignal).map(
        (key: string) => ShutdownSignal[key],
      );
    } else {
      // given signals array should be unique because
      // process shouldn't listen to the same signal more than once.
      signals = Array.from(new Set(signals));
    }

    signals = iterate(signals)
      .map((signal: string) => signal.toString().toUpperCase().trim())
      // filter out the signals which is already listening to
      .filter(signal => !this.activeShutdownSignals.includes(signal))
      .toArray();

    this.listenToShutdownSignals(signals);
    return this;
  }

  protected async dispose(): Promise<void> {
    // Nest application context has no server
    // to dispose, therefore just call a noop
    return Promise.resolve();
  }

  /**
   * Listens to shutdown signals by listening to
   * process events
   *
   * @param {string[]} signals The system signals it should listen to
   */
  protected listenToShutdownSignals(signals: string[]) {
    let receivedSignal = false;
    const cleanup = async (signal: string) => {
      try {
        if (receivedSignal) {
          // If we receive another signal while we're waiting
          // for the server to stop, just ignore it.
          return;
        }
        receivedSignal = true;
        await this.initializationPromise;
        await this.callDestroyHook();
        await this.callBeforeShutdownHook(signal);
        await this.dispose();
        await this.callShutdownHook(signal);
        signals.forEach(sig => process.removeListener(sig, cleanup));
        process.kill(process.pid, signal);
      } catch (err) {
        Logger.error(
          MESSAGES.ERROR_DURING_SHUTDOWN,
          (err as Error)?.stack,
          NestApplicationContext.name,
        );
        process.exit(1);
      }
    };
    this.shutdownCleanupRef = cleanup as (...args: unknown[]) => unknown;

    signals.forEach((signal: string) => {
      this.activeShutdownSignals.push(signal);
      process.on(signal as any, cleanup);
    });
  }

  /**
   * Unsubscribes from shutdown signals (process events)
   */
  protected unsubscribeFromProcessSignals() {
    if (!this.shutdownCleanupRef) {
      return;
    }
    this.activeShutdownSignals.forEach(signal => {
      process.removeListener(signal, this.shutdownCleanupRef!);
    });
  }

  /**
   * Calls the `onModuleInit` function on the registered
   * modules and its children.
   */
  protected async callInitHook(): Promise<void> {
    const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
    for (const module of modulesSortedByDistance) {
      await callModuleInitHook(module);
    }
  }

  /**
   * Calls the `onModuleDestroy` function on the registered
   * modules and its children.
   */
  protected async callDestroyHook(): Promise<void> {
    const modulesSortedByDistance = [
      ...this.getModulesToTriggerHooksOn(),
    ].reverse();

    for (const module of modulesSortedByDistance) {
      await callModuleDestroyHook(module);
    }
  }

  /**
   * Calls the `onApplicationBootstrap` function on the registered
   * modules and its children.
   */
  protected async callBootstrapHook(): Promise<void> {
    const modulesSortedByDistance = this.getModulesToTriggerHooksOn();
    for (const module of modulesSortedByDistance) {
      await callModuleBootstrapHook(module);
    }
  }

  /**
   * Calls the `onApplicationShutdown` function on the registered
   * modules and children.
   */
  protected async callShutdownHook(signal?: string): Promise<void> {
    const modulesSortedByDistance = [
      ...this.getModulesToTriggerHooksOn(),
    ].reverse();

    for (const module of modulesSortedByDistance) {
      await callAppShutdownHook(module, signal);
    }
  }

  /**
   * Calls the `beforeApplicationShutdown` function on the registered
   * modules and children.
   */
  protected async callBeforeShutdownHook(signal?: string): Promise<void> {
    const modulesSortedByDistance = [
      ...this.getModulesToTriggerHooksOn(),
    ].reverse();

    for (const module of modulesSortedByDistance) {
      await callBeforeAppShutdownHook(module, signal);
    }
  }

  protected assertNotInPreviewMode(methodName: string) {
    if (this.appOptions.preview) {
      const error = `Calling the "${methodName}" in the preview mode is not supported.`;
      this.logger.error(error);
      throw new Error(error);
    }
  }

  private getModulesToTriggerHooksOn(): Module[] {
    if (this._moduleRefsForHooksByDistance) {
      return this._moduleRefsForHooksByDistance;
    }
    const modulesContainer = this.container.getModules();
    const compareFn = (a: Module, b: Module) => b.distance - a.distance;
    const modulesSortedByDistance = Array.from(modulesContainer.values()).sort(
      compareFn,
    );

    this._moduleRefsForHooksByDistance = this.appOptions?.preview
      ? modulesSortedByDistance.filter(moduleRef => moduleRef.initOnPreview)
      : modulesSortedByDistance;
    return this._moduleRefsForHooksByDistance;
  }

  private printInPreviewModeWarning() {
    this.logger.warn('------------------------------------------------');
    this.logger.warn('Application is running in the PREVIEW mode!');
    this.logger.warn('Providers/controllers will not be instantiated.');
    this.logger.warn('------------------------------------------------');
  }
}



================================================
FILE: packages/core/nest-application.ts
================================================
import {
  CanActivate,
  ExceptionFilter,
  HttpServer,
  INestApplication,
  INestMicroservice,
  NestHybridApplicationOptions,
  NestInterceptor,
  PipeTransform,
  VersioningOptions,
  VersioningType,
  WebSocketAdapter,
} from '@nestjs/common';
import {
  GlobalPrefixOptions,
  NestApplicationOptions,
} from '@nestjs/common/interfaces';
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import {
  addLeadingSlash,
  isFunction,
  isObject,
  isString,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { platform } from 'os';
import { AbstractHttpAdapter } from './adapters';
import { ApplicationConfig } from './application-config';
import { MESSAGES } from './constants';
import { optionalRequire } from './helpers/optional-require';
import { NestContainer } from './injector/container';
import { Injector } from './injector/injector';
import { GraphInspector } from './inspector/graph-inspector';
import { MiddlewareContainer } from './middleware/container';
import { MiddlewareModule } from './middleware/middleware-module';
import { mapToExcludeRoute } from './middleware/utils';
import { NestApplicationContext } from './nest-application-context';
import { Resolver } from './router/interfaces/resolver.interface';
import { RoutesResolver } from './router/routes-resolver';

const { SocketModule } = optionalRequire(
  '@nestjs/websockets/socket-module',
  () => require('@nestjs/websockets/socket-module'),
);
const { MicroservicesModule } = optionalRequire(
  '@nestjs/microservices/microservices-module',
  () => require('@nestjs/microservices/microservices-module'),
);

/**
 * @publicApi
 */
export class NestApplication
  extends NestApplicationContext<NestApplicationOptions>
  implements INestApplication
{
  protected readonly logger = new Logger(NestApplication.name, {
    timestamp: true,
  });
  private readonly middlewareModule: MiddlewareModule;
  private readonly middlewareContainer = new MiddlewareContainer(
    this.container,
  );
  private readonly microservicesModule =
    MicroservicesModule && new MicroservicesModule();
  private readonly socketModule = SocketModule && new SocketModule();
  private readonly routesResolver: Resolver;
  private readonly microservices: any[] = [];
  private httpServer: any;
  private isListening = false;

  constructor(
    container: NestContainer,
    private readonly httpAdapter: HttpServer,
    private readonly config: ApplicationConfig,
    private readonly graphInspector: GraphInspector,
    appOptions: NestApplicationOptions = {},
  ) {
    super(container, appOptions);

    this.selectContextModule();
    this.registerHttpServer();
    this.injector = new Injector({ preview: this.appOptions.preview! });
    this.middlewareModule = new MiddlewareModule();
    this.routesResolver = new RoutesResolver(
      this.container,
      this.config,
      this.injector,
      this.graphInspector,
    );
  }

  protected async dispose(): Promise<void> {
    this.socketModule && (await this.socketModule.close());
    this.microservicesModule && (await this.microservicesModule.close());
    this.httpAdapter && (await this.httpAdapter.close());

    await Promise.all(
      iterate(this.microservices).map(async microservice => {
        microservice.setIsTerminated(true);
        await microservice.close();
      }),
    );
  }

  public getHttpAdapter(): AbstractHttpAdapter {
    return this.httpAdapter as AbstractHttpAdapter;
  }

  public registerHttpServer() {
    this.httpServer = this.createServer();
  }

  public getUnderlyingHttpServer<T>(): T {
    return this.httpAdapter.getHttpServer();
  }

  public applyOptions() {
    if (!this.appOptions || !this.appOptions.cors) {
      return undefined;
    }
    const passCustomOptions =
      isObject(this.appOptions.cors) || isFunction(this.appOptions.cors);
    if (!passCustomOptions) {
      return this.enableCors();
    }
    return this.enableCors(this.appOptions.cors);
  }

  public createServer<T = any>(): T {
    this.httpAdapter.initHttpServer(this.appOptions);
    return this.httpAdapter.getHttpServer() as T;
  }

  public async registerModules() {
    this.registerWsModule();

    if (this.microservicesModule) {
      this.microservicesModule.register(
        this.container,
        this.graphInspector,
        this.config,
        this.appOptions,
      );
      this.microservicesModule.setupClients(this.container);
    }

    await this.middlewareModule.register(
      this.middlewareContainer,
      this.container,
      this.config,
      this.injector,
      this.httpAdapter,
      this.graphInspector,
      this.appOptions,
    );
  }

  public registerWsModule() {
    if (!this.socketModule) {
      return;
    }
    this.socketModule.register(
      this.container,
      this.config,
      this.graphInspector,
      this.appOptions,
      this.httpServer,
    );
  }

  public async init(): Promise<this> {
    if (this.isInitialized) {
      return this;
    }

    this.applyOptions();
    await this.httpAdapter?.init?.();

    const useBodyParser =
      this.appOptions && this.appOptions.bodyParser !== false;
    useBodyParser && this.registerParserMiddleware();

    await this.registerModules();
    await this.registerRouter();
    await this.callInitHook();
    await this.registerRouterHooks();
    await this.callBootstrapHook();

    this.isInitialized = true;
    this.logger.log(MESSAGES.APPLICATION_READY);
    return this;
  }

  public registerParserMiddleware() {
    const prefix = this.config.getGlobalPrefix();
    const rawBody = !!this.appOptions?.rawBody;
    this.httpAdapter.registerParserMiddleware(prefix, rawBody);
  }

  public async registerRouter() {
    await this.registerMiddleware(this.httpAdapter);

    const prefix = this.config.getGlobalPrefix();
    const basePath = addLeadingSlash(prefix);
    this.routesResolver.resolve(this.httpAdapter, basePath);
  }

  public async registerRouterHooks() {
    this.routesResolver.registerNotFoundHandler();
    this.routesResolver.registerExceptionHandler();
  }

  public connectMicroservice<T extends object>(
    microserviceOptions: T,
    hybridAppOptions: NestHybridApplicationOptions = {},
  ): INestMicroservice {
    const { NestMicroservice } = loadPackage(
      '@nestjs/microservices',
      'NestFactory',
      () => require('@nestjs/microservices'),
    );
    const { inheritAppConfig } = hybridAppOptions;
    const applicationConfig = inheritAppConfig
      ? this.config
      : new ApplicationConfig();

    const instance = new NestMicroservice(
      this.container,
      microserviceOptions,
      this.graphInspector,
      applicationConfig,
    );
    instance.registerListeners();
    instance.setIsInitialized(true);
    instance.setIsInitHookCalled(true);

    this.microservices.push(instance);
    return instance;
  }

  public getMicroservices(): INestMicroservice[] {
    return this.microservices;
  }

  public getHttpServer() {
    return this.httpServer;
  }

  public async startAllMicroservices(): Promise<this> {
    this.assertNotInPreviewMode('startAllMicroservices');
    await Promise.all(this.microservices.map(msvc => msvc.listen()));
    return this;
  }

  public use(...args: [any, any?]): this {
    this.httpAdapter.use(...args);
    return this;
  }

  public useBodyParser(...args: [any, any?]): this {
    if (!('useBodyParser' in this.httpAdapter)) {
      this.logger.warn('Your HTTP Adapter does not support `.useBodyParser`.');
      return this;
    }

    const [parserType, ...otherArgs] = args;
    const rawBody = !!this.appOptions.rawBody;

    this.httpAdapter.useBodyParser?.(...[parserType, rawBody, ...otherArgs]);

    return this;
  }

  public enableCors(options?: any): void {
    this.httpAdapter.enableCors(options);
  }

  public enableVersioning(
    options: VersioningOptions = { type: VersioningType.URI },
  ): this {
    this.config.enableVersioning(options);
    return this;
  }

  public async listen(port: number | string): Promise<any>;
  public async listen(port: number | string, hostname: string): Promise<any>;
  public async listen(port: number | string, ...args: any[]): Promise<any> {
    this.assertNotInPreviewMode('listen');

    if (!this.isInitialized) {
      await this.init();
    }

    const httpAdapterHost = this.container.getHttpAdapterHostRef();
    return new Promise((resolve, reject) => {
      const errorHandler = (e: any) => {
        this.logger.error(e?.toString?.());
        reject(e);
      };
      this.httpServer.once('error', errorHandler);

      const isCallbackInOriginalArgs = isFunction(args[args.length - 1]);
      const listenFnArgs = isCallbackInOriginalArgs
        ? args.slice(0, args.length - 1)
        : args;

      this.httpAdapter.listen(
        port,
        ...listenFnArgs,
        (...originalCallbackArgs: unknown[]) => {
          if (this.appOptions?.autoFlushLogs ?? true) {
            this.flushLogs();
          }
          if (originalCallbackArgs[0] instanceof Error) {
            return reject(originalCallbackArgs[0]);
          }

          const address = this.httpServer.address();
          if (address) {
            this.httpServer.removeListener('error', errorHandler);
            this.isListening = true;

            httpAdapterHost.listening = true;
            resolve(this.httpServer);
          }
          if (isCallbackInOriginalArgs) {
            args[args.length - 1](...originalCallbackArgs);
          }
        },
      );
    });
  }

  public async getUrl(): Promise<string> {
    return new Promise((resolve, reject) => {
      if (!this.isListening) {
        this.logger.error(MESSAGES.CALL_LISTEN_FIRST);
        reject(MESSAGES.CALL_LISTEN_FIRST);
        return;
      }
      const address = this.httpServer.address();
      resolve(this.formatAddress(address));
    });
  }

  private formatAddress(address: any): string {
    if (isString(address)) {
      if (platform() === 'win32') {
        return address;
      }
      const basePath = encodeURIComponent(address);
      return `${this.getProtocol()}+unix://${basePath}`;
    }

    let host = this.host();
    if (address && address.family === 'IPv6') {
      if (host === '::') {
        host = '[::1]';
      } else {
        host = `[${host}]`;
      }
    } else if (host === '0.0.0.0') {
      host = '127.0.0.1';
    }

    return `${this.getProtocol()}://${host}:${address.port}`;
  }

  public setGlobalPrefix(prefix: string, options?: GlobalPrefixOptions): this {
    this.config.setGlobalPrefix(prefix);
    if (options) {
      const exclude = options?.exclude
        ? mapToExcludeRoute(options.exclude)
        : [];
      this.config.setGlobalPrefixOptions({
        ...options,
        exclude,
      });
    }
    return this;
  }

  public useWebSocketAdapter(adapter: WebSocketAdapter): this {
    this.config.setIoAdapter(adapter);
    return this;
  }

  public useGlobalFilters(...filters: ExceptionFilter[]): this {
    this.config.useGlobalFilters(...filters);
    filters.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'filter',
        ref: item,
      }),
    );
    return this;
  }

  public useGlobalPipes(...pipes: PipeTransform<any>[]): this {
    this.config.useGlobalPipes(...pipes);
    pipes.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'pipe',
        ref: item,
      }),
    );
    return this;
  }

  public useGlobalInterceptors(...interceptors: NestInterceptor[]): this {
    this.config.useGlobalInterceptors(...interceptors);
    interceptors.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'interceptor',
        ref: item,
      }),
    );
    return this;
  }

  public useGlobalGuards(...guards: CanActivate[]): this {
    this.config.useGlobalGuards(...guards);
    guards.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'guard',
        ref: item,
      }),
    );
    return this;
  }

  public useStaticAssets(options: any): this;
  public useStaticAssets(path: string, options?: any): this;
  public useStaticAssets(pathOrOptions: any, options?: any): this {
    this.httpAdapter.useStaticAssets &&
      this.httpAdapter.useStaticAssets(pathOrOptions, options);
    return this;
  }

  public setBaseViewsDir(path: string | string[]): this {
    this.httpAdapter.setBaseViewsDir && this.httpAdapter.setBaseViewsDir(path);
    return this;
  }

  public setViewEngine(engineOrOptions: any): this {
    this.httpAdapter.setViewEngine &&
      this.httpAdapter.setViewEngine(engineOrOptions);
    return this;
  }
  private host(): string | undefined {
    const address = this.httpServer.address();
    if (isString(address)) {
      return undefined;
    }
    return address && address.address;
  }

  private getProtocol(): 'http' | 'https' {
    return this.appOptions && this.appOptions.httpsOptions ? 'https' : 'http';
  }

  private async registerMiddleware(instance: any) {
    await this.middlewareModule.registerMiddleware(
      this.middlewareContainer,
      instance,
    );
  }
}



================================================
FILE: packages/core/nest-factory.ts
================================================
import {
  DynamicModule,
  ForwardReference,
  HttpServer,
  INestApplication,
  INestApplicationContext,
  INestMicroservice,
  Type,
} from '@nestjs/common';
import { NestMicroserviceOptions } from '@nestjs/common/interfaces/microservices/nest-microservice-options.interface';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { NestApplicationOptions } from '@nestjs/common/interfaces/nest-application-options.interface';
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { AbstractHttpAdapter } from './adapters/http-adapter';
import { ApplicationConfig } from './application-config';
import { MESSAGES } from './constants';
import { ExceptionsZone } from './errors/exceptions-zone';
import { loadAdapter } from './helpers/load-adapter';
import { rethrow } from './helpers/rethrow';
import { NestContainer } from './injector/container';
import { Injector } from './injector/injector';
import { InstanceLoader } from './injector/instance-loader';
import { GraphInspector } from './inspector/graph-inspector';
import { NoopGraphInspector } from './inspector/noop-graph-inspector';
import { UuidFactory, UuidFactoryMode } from './inspector/uuid-factory';
import { MetadataScanner } from './metadata-scanner';
import { NestApplication } from './nest-application';
import { NestApplicationContext } from './nest-application-context';
import { DependenciesScanner } from './scanner';

type IEntryNestModule =
  | Type<any>
  | DynamicModule
  | ForwardReference
  | Promise<IEntryNestModule>;

/**
 * @publicApi
 */
export class NestFactoryStatic {
  private readonly logger = new Logger('NestFactory', {
    timestamp: true,
  });
  private abortOnError = true;
  private autoFlushLogs = false;

  /**
   * Creates an instance of NestApplication.
   *
   * @param module Entry (root) application module class
   * @param options List of options to initialize NestApplication
   *
   * @returns A promise that, when resolved,
   * contains a reference to the NestApplication instance.
   */
  public async create<T extends INestApplication = INestApplication>(
    module: IEntryNestModule,
    options?: NestApplicationOptions,
  ): Promise<T>;
  /**
   * Creates an instance of NestApplication with the specified `httpAdapter`.
   *
   * @param module Entry (root) application module class
   * @param httpAdapter Adapter to proxy the request/response cycle to
   *    the underlying HTTP server
   * @param options List of options to initialize NestApplication
   *
   * @returns A promise that, when resolved,
   * contains a reference to the NestApplication instance.
   */
  public async create<T extends INestApplication = INestApplication>(
    module: IEntryNestModule,
    httpAdapter: AbstractHttpAdapter,
    options?: NestApplicationOptions,
  ): Promise<T>;
  public async create<T extends INestApplication = INestApplication>(
    moduleCls: IEntryNestModule,
    serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,
    options?: NestApplicationOptions,
  ): Promise<T> {
    const [httpServer, appOptions] = this.isHttpServer(serverOrOptions!)
      ? [serverOrOptions, options]
      : [this.createHttpAdapter(), serverOrOptions];

    const applicationConfig = new ApplicationConfig();
    const container = new NestContainer(applicationConfig, appOptions);
    const graphInspector = this.createGraphInspector(appOptions!, container);

    this.setAbortOnError(serverOrOptions, options);
    this.registerLoggerConfiguration(appOptions);

    await this.initialize(
      moduleCls,
      container,
      graphInspector,
      applicationConfig,
      appOptions,
      httpServer,
    );

    const instance = new NestApplication(
      container,
      httpServer,
      applicationConfig,
      graphInspector,
      appOptions,
    );
    const target = this.createNestInstance(instance);
    return this.createAdapterProxy<T>(target, httpServer);
  }

  /**
   * Creates an instance of NestMicroservice.
   *
   * @param moduleCls Entry (root) application module class
   * @param options Optional microservice configuration
   *
   * @returns A promise that, when resolved,
   * contains a reference to the NestMicroservice instance.
   */
  public async createMicroservice<T extends object>(
    moduleCls: IEntryNestModule,
    options?: NestMicroserviceOptions & T,
  ): Promise<INestMicroservice> {
    const { NestMicroservice } = loadPackage(
      '@nestjs/microservices',
      'NestFactory',
      () => require('@nestjs/microservices'),
    );
    const applicationConfig = new ApplicationConfig();
    const container = new NestContainer(applicationConfig, options);
    const graphInspector = this.createGraphInspector(options!, container);

    this.setAbortOnError(options);
    this.registerLoggerConfiguration(options);

    await this.initialize(
      moduleCls,
      container,
      graphInspector,
      applicationConfig,
      options,
    );
    return this.createNestInstance<INestMicroservice>(
      new NestMicroservice(
        container,
        options,
        graphInspector,
        applicationConfig,
      ),
    );
  }

  /**
   * Creates an instance of NestApplicationContext.
   *
   * @param moduleCls Entry (root) application module class
   * @param options Optional Nest application configuration
   *
   * @returns A promise that, when resolved,
   * contains a reference to the NestApplicationContext instance.
   */
  public async createApplicationContext(
    moduleCls: IEntryNestModule,
    options?: NestApplicationContextOptions,
  ): Promise<INestApplicationContext> {
    const applicationConfig = new ApplicationConfig();
    const container = new NestContainer(applicationConfig, options);
    const graphInspector = this.createGraphInspector(options!, container);

    this.setAbortOnError(options);
    this.registerLoggerConfiguration(options);

    await this.initialize(
      moduleCls,
      container,
      graphInspector,
      applicationConfig,
      options,
    );

    const modules = container.getModules().values();
    const root = modules.next().value;

    const context = this.createNestInstance<NestApplicationContext>(
      new NestApplicationContext(container, options, root),
    );
    if (this.autoFlushLogs) {
      context.flushLogsOnOverride();
    }
    return context.init();
  }

  private createNestInstance<T>(instance: T): T {
    return this.createProxy(instance);
  }

  private async initialize(
    module: any,
    container: NestContainer,
    graphInspector: GraphInspector,
    config = new ApplicationConfig(),
    options: NestApplicationContextOptions = {},
    httpServer: HttpServer | null = null,
  ) {
    UuidFactory.mode = options.snapshot
      ? UuidFactoryMode.Deterministic
      : UuidFactoryMode.Random;

    const injector = new Injector({ preview: options.preview! });
    const instanceLoader = new InstanceLoader(
      container,
      injector,
      graphInspector,
    );
    const metadataScanner = new MetadataScanner();
    const dependenciesScanner = new DependenciesScanner(
      container,
      metadataScanner,
      graphInspector,
      config,
    );
    container.setHttpAdapter(httpServer);

    const teardown = this.abortOnError === false ? rethrow : undefined;
    await httpServer?.init?.();
    try {
      this.logger.log(MESSAGES.APPLICATION_START);

      await ExceptionsZone.asyncRun(
        async () => {
          await dependenciesScanner.scan(module);
          await instanceLoader.createInstancesOfDependencies();
          dependenciesScanner.applyApplicationProviders();
        },
        teardown,
        this.autoFlushLogs,
      );
    } catch (e) {
      this.handleInitializationError(e);
    }
  }

  private handleInitializationError(err: unknown) {
    if (this.abortOnError) {
      process.abort();
    }
    rethrow(err);
  }

  private createProxy(target: any) {
    const proxy = this.createExceptionProxy();
    return new Proxy(target, {
      get: proxy,
      set: proxy,
    });
  }

  private createExceptionProxy() {
    return (receiver: Record<string, any>, prop: string) => {
      if (!(prop in receiver)) {
        return;
      }
      if (isFunction(receiver[prop])) {
        return this.createExceptionZone(receiver, prop);
      }
      return receiver[prop];
    };
  }

  private createExceptionZone(
    receiver: Record<string, any>,
    prop: string,
  ): Function {
    const teardown = this.abortOnError === false ? rethrow : undefined;

    return (...args: unknown[]) => {
      let result: unknown;
      ExceptionsZone.run(
        () => {
          result = receiver[prop](...args);
        },
        teardown,
        this.autoFlushLogs,
      );

      return result;
    };
  }

  private registerLoggerConfiguration(
    options: NestApplicationContextOptions | undefined,
  ) {
    if (!options) {
      return;
    }
    const { logger, bufferLogs, autoFlushLogs } = options;
    if ((logger as boolean) !== true && !isNil(logger)) {
      Logger.overrideLogger(logger);
    }
    if (bufferLogs) {
      Logger.attachBuffer();
    }
    this.autoFlushLogs = autoFlushLogs ?? true;
  }

  private createHttpAdapter<T = any>(httpServer?: T): AbstractHttpAdapter {
    const { ExpressAdapter } = loadAdapter(
      '@nestjs/platform-express',
      'HTTP',
      () => require('@nestjs/platform-express'),
    );
    return new ExpressAdapter(httpServer);
  }

  private isHttpServer(
    serverOrOptions: AbstractHttpAdapter | NestApplicationOptions,
  ): serverOrOptions is AbstractHttpAdapter {
    return !!(
      serverOrOptions && (serverOrOptions as AbstractHttpAdapter).patch
    );
  }

  private setAbortOnError(
    serverOrOptions?: AbstractHttpAdapter | NestApplicationOptions,
    options?: NestApplicationContextOptions | NestApplicationOptions,
  ) {
    this.abortOnError = this.isHttpServer(serverOrOptions!)
      ? !(options && options.abortOnError === false)
      : !(serverOrOptions && serverOrOptions.abortOnError === false);
  }

  private createAdapterProxy<T>(app: NestApplication, adapter: HttpServer): T {
    const proxy = new Proxy(app, {
      get: (receiver: Record<string, any>, prop: string) => {
        const mapToProxy = (result: unknown) => {
          return result instanceof Promise
            ? result.then(mapToProxy)
            : result instanceof NestApplication
              ? proxy
              : result;
        };

        if (!(prop in receiver) && prop in adapter) {
          return (...args: unknown[]) => {
            const result = this.createExceptionZone(adapter, prop)(...args);
            return mapToProxy(result);
          };
        }
        if (isFunction(receiver[prop])) {
          return (...args: unknown[]) => {
            const result = receiver[prop](...args);
            return mapToProxy(result);
          };
        }
        return receiver[prop];
      },
    });
    return proxy as unknown as T;
  }

  private createGraphInspector(
    appOptions: NestApplicationContextOptions,
    container: NestContainer,
  ) {
    return appOptions?.snapshot
      ? new GraphInspector(container)
      : NoopGraphInspector;
  }
}

/**
 * Use NestFactory to create an application instance.
 *
 * ### Specifying an entry module
 *
 * Pass the required *root module* for the application via the module parameter.
 * By convention, it is usually called `ApplicationModule`.  Starting with this
 * module, Nest assembles the dependency graph and begins the process of
 * Dependency Injection and instantiates the classes needed to launch your
 * application.
 *
 * @publicApi
 */
export const NestFactory = new NestFactoryStatic();



================================================
FILE: packages/core/package.json
================================================
{
  "name": "@nestjs/core",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@core)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "engines": {
    "node": ">= 20"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/core"
  },
  "publishConfig": {
    "access": "public"
  },
  "scripts": {
    "postinstall": "opencollective || exit 0"
  },
  "collective": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest",
    "donation": {
      "text": "Become a partner:"
    }
  },
  "dependencies": {
    "@nuxt/opencollective": "0.4.1",
    "fast-safe-stringify": "2.1.1",
    "iterare": "1.2.1",
    "path-to-regexp": "8.2.0",
    "tslib": "2.8.1",
    "uid": "2.0.2"
  },
  "devDependencies": {
    "@nestjs/common": "11.0.13"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/microservices": "^11.0.0",
    "@nestjs/platform-express": "^11.0.0",
    "@nestjs/websockets": "^11.0.0",
    "reflect-metadata": "^0.1.12 || ^0.2.0",
    "rxjs": "^7.1.0"
  },
  "peerDependenciesMeta": {
    "@nestjs/websockets": {
      "optional": true
    },
    "@nestjs/microservices": {
      "optional": true
    },
    "@nestjs/platform-express": {
      "optional": true
    }
  }
}



================================================
FILE: packages/core/PACKAGE.md
================================================
Implements Nest's core functionality, low-level services, and utilities.



================================================
FILE: packages/core/scanner.ts
================================================
import { DynamicModule, ForwardReference, Provider } from '@nestjs/common';
import {
  CATCH_WATERMARK,
  CONTROLLER_WATERMARK,
  ENHANCER_KEY_TO_SUBTYPE_MAP,
  EXCEPTION_FILTERS_METADATA,
  EnhancerSubtype,
  GUARDS_METADATA,
  INJECTABLE_WATERMARK,
  INTERCEPTORS_METADATA,
  MODULE_METADATA,
  PIPES_METADATA,
  ROUTE_ARGS_METADATA,
} from '@nestjs/common/constants';
import {
  CanActivate,
  ClassProvider,
  Controller,
  ExceptionFilter,
  ExistingProvider,
  FactoryProvider,
  Injectable,
  InjectionToken,
  NestInterceptor,
  PipeTransform,
  Scope,
  Type,
  ValueProvider,
} from '@nestjs/common/interfaces';
import {
  isFunction,
  isNil,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from './application-config';
import {
  APP_FILTER,
  APP_GUARD,
  APP_INTERCEPTOR,
  APP_PIPE,
  ENHANCER_TOKEN_TO_SUBTYPE_MAP,
} from './constants';
import { CircularDependencyException } from './errors/exceptions/circular-dependency.exception';
import { InvalidClassModuleException } from './errors/exceptions/invalid-class-module.exception';
import { InvalidModuleException } from './errors/exceptions/invalid-module.exception';
import { UndefinedModuleException } from './errors/exceptions/undefined-module.exception';
import { getClassScope } from './helpers/get-class-scope';
import { NestContainer } from './injector/container';
import { InstanceWrapper } from './injector/instance-wrapper';
import { InternalCoreModuleFactory } from './injector/internal-core-module/internal-core-module-factory';
import { Module } from './injector/module';
import { TopologyTree } from './injector/topology-tree/topology-tree';
import { GraphInspector } from './inspector/graph-inspector';
import { UuidFactory } from './inspector/uuid-factory';
import { ModuleDefinition } from './interfaces/module-definition.interface';
import { ModuleOverride } from './interfaces/module-override.interface';
import { MetadataScanner } from './metadata-scanner';

interface ApplicationProviderWrapper {
  moduleKey: string;
  providerKey: string;
  type: InjectionToken;
  scope?: Scope;
}

interface ModulesScanParameters {
  moduleDefinition: ModuleDefinition;
  scope?: Type<unknown>[];
  ctxRegistry?: (ForwardReference | DynamicModule | Type<unknown>)[];
  overrides?: ModuleOverride[];
  lazy?: boolean;
}

export class DependenciesScanner {
  private readonly applicationProvidersApplyMap: ApplicationProviderWrapper[] =
    [];

  constructor(
    private readonly container: NestContainer,
    private readonly metadataScanner: MetadataScanner,
    private readonly graphInspector: GraphInspector,
    private readonly applicationConfig = new ApplicationConfig(),
  ) {}

  public async scan(
    module: Type<any>,
    options?: { overrides?: ModuleOverride[] },
  ) {
    await this.registerCoreModule(options?.overrides);
    await this.scanForModules({
      moduleDefinition: module,
      overrides: options?.overrides,
    });
    await this.scanModulesForDependencies();
    this.addScopedEnhancersMetadata();

    // Modules distance calculation should be done after all modules are scanned
    // but before global modules are registered (linked to all modules).
    // Global modules have their distance set to MAX anyway.
    this.calculateModulesDistance();

    this.container.bindGlobalScope();
  }

  public async scanForModules({
    moduleDefinition,
    lazy,
    scope = [],
    ctxRegistry = [],
    overrides = [],
  }: ModulesScanParameters): Promise<Module[]> {
    const { moduleRef: moduleInstance, inserted: moduleInserted } =
      (await this.insertOrOverrideModule(moduleDefinition, overrides, scope)) ??
      {};

    moduleDefinition =
      this.getOverrideModuleByModule(moduleDefinition, overrides)?.newModule ??
      moduleDefinition;

    moduleDefinition =
      moduleDefinition instanceof Promise
        ? await moduleDefinition
        : moduleDefinition;

    ctxRegistry.push(moduleDefinition);

    if (this.isForwardReference(moduleDefinition)) {
      moduleDefinition = (moduleDefinition as ForwardReference).forwardRef();
    }
    const modules = !this.isDynamicModule(
      moduleDefinition as Type<any> | DynamicModule,
    )
      ? this.reflectMetadata(
          MODULE_METADATA.IMPORTS,
          moduleDefinition as Type<any>,
        )
      : [
          ...this.reflectMetadata(
            MODULE_METADATA.IMPORTS,
            (moduleDefinition as DynamicModule).module,
          ),
          ...((moduleDefinition as DynamicModule).imports || []),
        ];

    let registeredModuleRefs: Module[] = [];
    for (const [index, innerModule] of modules.entries()) {
      // In case of a circular dependency (ES module system), JavaScript will resolve the type to `undefined`.
      if (innerModule === undefined) {
        throw new UndefinedModuleException(moduleDefinition, index, scope);
      }
      if (!innerModule) {
        throw new InvalidModuleException(moduleDefinition, index, scope);
      }
      if (ctxRegistry.includes(innerModule)) {
        continue;
      }
      const moduleRefs = await this.scanForModules({
        moduleDefinition: innerModule,
        scope: ([] as Array<Type>).concat(scope, moduleDefinition as Type),
        ctxRegistry,
        overrides,
        lazy,
      });
      registeredModuleRefs = registeredModuleRefs.concat(moduleRefs);
    }
    if (!moduleInstance) {
      return registeredModuleRefs;
    }

    if (lazy && moduleInserted) {
      this.container.bindGlobalsToImports(moduleInstance);
    }
    return [moduleInstance].concat(registeredModuleRefs);
  }

  public async insertModule(
    moduleDefinition: any,
    scope: Type<unknown>[],
  ): Promise<
    | {
        moduleRef: Module;
        inserted: boolean;
      }
    | undefined
  > {
    const moduleToAdd = this.isForwardReference(moduleDefinition)
      ? moduleDefinition.forwardRef()
      : moduleDefinition;

    if (
      this.isInjectable(moduleToAdd) ||
      this.isController(moduleToAdd) ||
      this.isExceptionFilter(moduleToAdd)
    ) {
      throw new InvalidClassModuleException(moduleDefinition, scope);
    }

    return this.container.addModule(moduleToAdd, scope);
  }

  public async scanModulesForDependencies(
    modules: Map<string, Module> = this.container.getModules(),
  ) {
    for (const [token, { metatype }] of modules) {
      await this.reflectImports(metatype, token, metatype.name);
      this.reflectProviders(metatype, token);
      this.reflectControllers(metatype, token);
      this.reflectExports(metatype, token);
    }
  }

  public async reflectImports(
    module: Type<unknown>,
    token: string,
    context: string,
  ) {
    const modules = [
      ...this.reflectMetadata(MODULE_METADATA.IMPORTS, module),
      ...this.container.getDynamicMetadataByToken(
        token,
        MODULE_METADATA.IMPORTS as 'imports',
      )!,
    ];
    for (const related of modules) {
      await this.insertImport(related, token, context);
    }
  }

  public reflectProviders(module: Type<any>, token: string) {
    const providers = [
      ...this.reflectMetadata(MODULE_METADATA.PROVIDERS, module),
      ...this.container.getDynamicMetadataByToken(
        token,
        MODULE_METADATA.PROVIDERS as 'providers',
      )!,
    ];
    providers.forEach(provider => {
      this.insertProvider(provider, token);
      this.reflectDynamicMetadata(provider, token);
    });
  }

  public reflectControllers(module: Type<any>, token: string) {
    const controllers = [
      ...this.reflectMetadata(MODULE_METADATA.CONTROLLERS, module),
      ...this.container.getDynamicMetadataByToken(
        token,
        MODULE_METADATA.CONTROLLERS as 'controllers',
      )!,
    ];
    controllers.forEach(item => {
      this.insertController(item, token);
      this.reflectDynamicMetadata(item, token);
    });
  }

  public reflectDynamicMetadata(cls: Type<Injectable>, token: string) {
    if (!cls || !cls.prototype) {
      return;
    }
    this.reflectInjectables(cls, token, GUARDS_METADATA);
    this.reflectInjectables(cls, token, INTERCEPTORS_METADATA);
    this.reflectInjectables(cls, token, EXCEPTION_FILTERS_METADATA);
    this.reflectInjectables(cls, token, PIPES_METADATA);
    this.reflectParamInjectables(cls, token, ROUTE_ARGS_METADATA);
  }

  public reflectExports(module: Type<unknown>, token: string) {
    const exports = [
      ...this.reflectMetadata(MODULE_METADATA.EXPORTS, module),
      ...this.container.getDynamicMetadataByToken(
        token,
        MODULE_METADATA.EXPORTS as 'exports',
      )!,
    ];
    exports.forEach(exportedProvider =>
      this.insertExportedProviderOrModule(exportedProvider, token),
    );
  }

  public reflectInjectables(
    component: Type<Injectable>,
    token: string,
    metadataKey: string,
  ) {
    const controllerInjectables = this.reflectMetadata<Type<Injectable>>(
      metadataKey,
      component,
    );
    const methodInjectables = this.metadataScanner
      .getAllMethodNames(component.prototype)
      .reduce(
        (acc, method) => {
          const methodInjectable = this.reflectKeyMetadata(
            component,
            metadataKey,
            method,
          );

          if (methodInjectable) {
            acc.push(methodInjectable);
          }

          return acc;
        },
        [] as Array<{
          methodKey: string;
          metadata: Type<Injectable>[];
        }>,
      );

    controllerInjectables.forEach(injectable =>
      this.insertInjectable(
        injectable,
        token,
        component,
        ENHANCER_KEY_TO_SUBTYPE_MAP[metadataKey],
      ),
    );
    methodInjectables.forEach(methodInjectable => {
      methodInjectable.metadata.forEach(injectable =>
        this.insertInjectable(
          injectable,
          token,
          component,
          ENHANCER_KEY_TO_SUBTYPE_MAP[metadataKey],
          methodInjectable.methodKey,
        ),
      );
    });
  }

  public reflectParamInjectables(
    component: Type<Injectable>,
    token: string,
    metadataKey: string,
  ) {
    const paramsMethods = this.metadataScanner.getAllMethodNames(
      component.prototype,
    );

    paramsMethods.forEach(methodKey => {
      const metadata: Record<
        string,
        {
          index: number;
          data: unknown;
          pipes: Array<Type<PipeTransform> | PipeTransform>;
        }
      > = Reflect.getMetadata(metadataKey, component, methodKey);

      if (!metadata) {
        return;
      }

      const params = Object.values(metadata);
      params
        .map(item => item.pipes)
        .flat(1)
        .forEach(injectable =>
          this.insertInjectable(
            injectable,
            token,
            component,
            'pipe',
            methodKey,
          ),
        );
    });
  }

  public reflectKeyMetadata(
    component: Type<Injectable>,
    key: string,
    methodKey: string,
  ): { methodKey: string; metadata: any } | undefined {
    let prototype = component.prototype;
    do {
      const descriptor = Reflect.getOwnPropertyDescriptor(prototype, methodKey);
      if (!descriptor) {
        continue;
      }
      const metadata = Reflect.getMetadata(key, descriptor.value);
      if (!metadata) {
        return;
      }
      return { methodKey, metadata };
    } while (
      (prototype = Reflect.getPrototypeOf(prototype)) &&
      prototype !== Object.prototype &&
      prototype
    );
    return undefined;
  }

  public calculateModulesDistance() {
    const modulesGenerator = this.container.getModules().values();
    // Skip "InternalCoreModule"
    // The second element is the actual root module
    modulesGenerator.next();

    const rootModule = modulesGenerator.next().value!;
    if (!rootModule) {
      return;
    }

    // Convert modules to an acyclic connected graph
    const tree = new TopologyTree(rootModule);
    tree.walk((moduleRef, depth) => {
      if (moduleRef.isGlobal) {
        return;
      }
      moduleRef.distance = depth;
    });
  }

  public async insertImport(related: any, token: string, context: string) {
    if (isUndefined(related)) {
      throw new CircularDependencyException(context);
    }
    if (this.isForwardReference(related)) {
      return this.container.addImport(related.forwardRef(), token);
    }
    await this.container.addImport(related, token);
  }

  public isCustomProvider(
    provider: Provider,
  ): provider is
    | ClassProvider
    | ValueProvider
    | FactoryProvider
    | ExistingProvider {
    return provider && !isNil((provider as any).provide);
  }

  public insertProvider(provider: Provider, token: string) {
    const isCustomProvider = this.isCustomProvider(provider);
    if (!isCustomProvider) {
      return this.container.addProvider(provider, token);
    }
    const applyProvidersMap = this.getApplyProvidersMap();
    const providersKeys = Object.keys(applyProvidersMap);
    const type = provider.provide;

    if (!providersKeys.includes(type as string)) {
      return this.container.addProvider(provider as any, token);
    }
    const uuid = UuidFactory.get(type.toString());
    const providerToken = `${type as string} (UUID: ${uuid})`;

    let scope = (provider as ClassProvider | FactoryProvider).scope;
    if (isNil(scope) && (provider as ClassProvider).useClass) {
      scope = getClassScope((provider as ClassProvider).useClass);
    }
    this.applicationProvidersApplyMap.push({
      type,
      moduleKey: token,
      providerKey: providerToken,
      scope,
    });

    const newProvider = {
      ...provider,
      provide: providerToken,
      scope,
    } as Provider;

    const enhancerSubtype =
      ENHANCER_TOKEN_TO_SUBTYPE_MAP[
        type as
          | typeof APP_GUARD
          | typeof APP_PIPE
          | typeof APP_FILTER
          | typeof APP_INTERCEPTOR
      ];
    const factoryOrClassProvider = newProvider as
      | FactoryProvider
      | ClassProvider;
    if (this.isRequestOrTransient(factoryOrClassProvider.scope!)) {
      return this.container.addInjectable(newProvider, token, enhancerSubtype);
    }
    this.container.addProvider(newProvider, token, enhancerSubtype);
  }

  public insertInjectable(
    injectable: Type<Injectable> | object,
    token: string,
    host: Type<Injectable>,
    subtype: EnhancerSubtype,
    methodKey?: string,
  ) {
    if (isFunction(injectable)) {
      const instanceWrapper = this.container.addInjectable(
        injectable as Type,
        token,
        subtype,
        host,
      ) as InstanceWrapper;

      this.graphInspector.insertEnhancerMetadataCache({
        moduleToken: token,
        classRef: host,
        enhancerInstanceWrapper: instanceWrapper,
        targetNodeId: instanceWrapper.id,
        subtype,
        methodKey,
      });
      return instanceWrapper;
    } else {
      this.graphInspector.insertEnhancerMetadataCache({
        moduleToken: token,
        classRef: host,
        enhancerRef: injectable,
        methodKey,
        subtype,
      });
    }
  }

  public insertExportedProviderOrModule(
    toExport: ForwardReference | DynamicModule | Type<unknown>,
    token: string,
  ) {
    const fulfilledProvider = this.isForwardReference(toExport)
      ? toExport.forwardRef()
      : toExport;
    this.container.addExportedProviderOrModule(fulfilledProvider, token);
  }

  public insertController(controller: Type<Controller>, token: string) {
    this.container.addController(controller, token);
  }

  private insertOrOverrideModule(
    moduleDefinition: ModuleDefinition,
    overrides: ModuleOverride[],
    scope: Type<unknown>[],
  ): Promise<
    | {
        moduleRef: Module;
        inserted: boolean;
      }
    | undefined
  > {
    const overrideModule = this.getOverrideModuleByModule(
      moduleDefinition,
      overrides,
    );
    if (overrideModule !== undefined) {
      return this.overrideModule(
        moduleDefinition,
        overrideModule.newModule,
        scope,
      );
    }

    return this.insertModule(moduleDefinition, scope);
  }

  private getOverrideModuleByModule(
    module: ModuleDefinition,
    overrides: ModuleOverride[],
  ): ModuleOverride | undefined {
    if (this.isForwardReference(module)) {
      return overrides.find(moduleToOverride => {
        return (
          moduleToOverride.moduleToReplace === module.forwardRef() ||
          (
            moduleToOverride.moduleToReplace as ForwardReference
          ).forwardRef?.() === module.forwardRef()
        );
      });
    }

    return overrides.find(
      moduleToOverride => moduleToOverride.moduleToReplace === module,
    );
  }

  private async overrideModule(
    moduleToOverride: ModuleDefinition,
    newModule: ModuleDefinition,
    scope: Type<unknown>[],
  ): Promise<
    | {
        moduleRef: Module;
        inserted: boolean;
      }
    | undefined
  > {
    return this.container.replaceModule(
      this.isForwardReference(moduleToOverride)
        ? moduleToOverride.forwardRef()
        : moduleToOverride,
      this.isForwardReference(newModule) ? newModule.forwardRef() : newModule,
      scope,
    );
  }

  public reflectMetadata<T = any>(
    metadataKey: string,
    metatype: Type<any>,
  ): T[] {
    return Reflect.getMetadata(metadataKey, metatype) || [];
  }

  public async registerCoreModule(overrides?: ModuleOverride[]) {
    const moduleDefinition = InternalCoreModuleFactory.create(
      this.container,
      this,
      this.container.getModuleCompiler(),
      this.container.getHttpAdapterHostRef(),
      this.graphInspector,
      overrides,
    );
    const [instance] = await this.scanForModules({
      moduleDefinition,
      overrides,
    });
    this.container.registerCoreModuleRef(instance);
  }

  /**
   * Add either request or transient globally scoped enhancers
   * to all controllers metadata storage
   */
  public addScopedEnhancersMetadata() {
    iterate(this.applicationProvidersApplyMap)
      .filter(wrapper => this.isRequestOrTransient(wrapper.scope!))
      .forEach(({ moduleKey, providerKey }) => {
        const modulesContainer = this.container.getModules();
        const { injectables } = modulesContainer.get(moduleKey)!;
        const instanceWrapper = injectables.get(providerKey);

        const iterableIterator = modulesContainer.values();
        iterate(iterableIterator)
          .map(moduleRef =>
            Array.from<InstanceWrapper>(moduleRef.controllers.values()).concat(
              moduleRef.entryProviders,
            ),
          )
          .flatten()
          .forEach(controllerOrEntryProvider =>
            controllerOrEntryProvider.addEnhancerMetadata(instanceWrapper!),
          );
      });
  }

  public applyApplicationProviders() {
    const applyProvidersMap = this.getApplyProvidersMap();
    const applyRequestProvidersMap = this.getApplyRequestProvidersMap();

    const getInstanceWrapper = (
      moduleKey: string,
      providerKey: string,
      collectionKey: 'providers' | 'injectables',
    ) => {
      const modules = this.container.getModules();
      const collection = modules.get(moduleKey)![collectionKey];
      return collection.get(providerKey);
    };

    // Add global enhancers to the application config
    this.applicationProvidersApplyMap.forEach(
      ({ moduleKey, providerKey, type, scope }) => {
        let instanceWrapper: InstanceWrapper;
        if (this.isRequestOrTransient(scope!)) {
          instanceWrapper = getInstanceWrapper(
            moduleKey,
            providerKey,
            'injectables',
          )!;

          this.graphInspector.insertAttachedEnhancer(instanceWrapper);
          return applyRequestProvidersMap[type as string](instanceWrapper);
        }
        instanceWrapper = getInstanceWrapper(
          moduleKey,
          providerKey,
          'providers',
        )!;
        this.graphInspector.insertAttachedEnhancer(instanceWrapper);
        applyProvidersMap[type as string](instanceWrapper.instance);
      },
    );
  }

  public getApplyProvidersMap(): { [type: string]: Function } {
    return {
      [APP_INTERCEPTOR]: (interceptor: NestInterceptor) =>
        this.applicationConfig.addGlobalInterceptor(interceptor),
      [APP_PIPE]: (pipe: PipeTransform) =>
        this.applicationConfig.addGlobalPipe(pipe),
      [APP_GUARD]: (guard: CanActivate) =>
        this.applicationConfig.addGlobalGuard(guard),
      [APP_FILTER]: (filter: ExceptionFilter) =>
        this.applicationConfig.addGlobalFilter(filter),
    };
  }

  public getApplyRequestProvidersMap(): { [type: string]: Function } {
    return {
      [APP_INTERCEPTOR]: (interceptor: InstanceWrapper<NestInterceptor>) =>
        this.applicationConfig.addGlobalRequestInterceptor(interceptor),
      [APP_PIPE]: (pipe: InstanceWrapper<PipeTransform>) =>
        this.applicationConfig.addGlobalRequestPipe(pipe),
      [APP_GUARD]: (guard: InstanceWrapper<CanActivate>) =>
        this.applicationConfig.addGlobalRequestGuard(guard),
      [APP_FILTER]: (filter: InstanceWrapper<ExceptionFilter>) =>
        this.applicationConfig.addGlobalRequestFilter(filter),
    };
  }

  public isDynamicModule(
    module: Type<any> | DynamicModule,
  ): module is DynamicModule {
    return module && !!(module as DynamicModule).module;
  }

  /**
   * @param metatype
   * @returns `true` if `metatype` is annotated with the `@Injectable()` decorator.
   */
  private isInjectable(metatype: Type<any>): boolean {
    return !!Reflect.getMetadata(INJECTABLE_WATERMARK, metatype);
  }

  /**
   * @param metatype
   * @returns `true` if `metatype` is annotated with the `@Controller()` decorator.
   */
  private isController(metatype: Type<any>): boolean {
    return !!Reflect.getMetadata(CONTROLLER_WATERMARK, metatype);
  }

  /**
   * @param metatype
   * @returns `true` if `metatype` is annotated with the `@Catch()` decorator.
   */
  private isExceptionFilter(metatype: Type<any>): boolean {
    return !!Reflect.getMetadata(CATCH_WATERMARK, metatype);
  }

  private isForwardReference(
    module: ModuleDefinition,
  ): module is ForwardReference {
    return module && !!(module as ForwardReference).forwardRef;
  }

  private isRequestOrTransient(scope: Scope): boolean {
    return scope === Scope.REQUEST || scope === Scope.TRANSIENT;
  }
}



================================================
FILE: packages/core/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/microservices": ["../microservices"],
      "@nestjs/microservices/*": ["../microservices/*"],
      "@nestjs/websockets": ["../websockets"],
      "@nestjs/websockets/*": ["../websockets/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/core/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/core/adapters/http-adapter.ts
================================================
import { HttpServer, RequestMethod, VersioningOptions } from '@nestjs/common';
import { RequestHandler, VersionValue } from '@nestjs/common/interfaces';
import { NestApplicationOptions } from '@nestjs/common/interfaces/nest-application-options.interface';

/**
 * @publicApi
 */
export abstract class AbstractHttpAdapter<
  TServer = any,
  TRequest = any,
  TResponse = any,
> implements HttpServer<TRequest, TResponse>
{
  protected httpServer: TServer;

  constructor(protected instance?: any) {}

  public async init() {}

  public use(...args: any[]) {
    return this.instance.use(...args);
  }

  public get(handler: RequestHandler);
  public get(path: any, handler: RequestHandler);
  public get(...args: any[]) {
    return this.instance.get(...args);
  }

  public post(handler: RequestHandler);
  public post(path: any, handler: RequestHandler);
  public post(...args: any[]) {
    return this.instance.post(...args);
  }

  public head(handler: RequestHandler);
  public head(path: any, handler: RequestHandler);
  public head(...args: any[]) {
    return this.instance.head(...args);
  }

  public delete(handler: RequestHandler);
  public delete(path: any, handler: RequestHandler);
  public delete(...args: any[]) {
    return this.instance.delete(...args);
  }

  public put(handler: RequestHandler);
  public put(path: any, handler: RequestHandler);
  public put(...args: any[]) {
    return this.instance.put(...args);
  }

  public patch(handler: RequestHandler);
  public patch(path: any, handler: RequestHandler);
  public patch(...args: any[]) {
    return this.instance.patch(...args);
  }

  public propfind(handler: RequestHandler);
  public propfind(path: any, handler: RequestHandler);
  public propfind(...args: any[]) {
    return this.instance.propfind(...args);
  }

  public proppatch(handler: RequestHandler);
  public proppatch(path: any, handler: RequestHandler);
  public proppatch(...args: any[]) {
    return this.instance.proppatch(...args);
  }

  public mkcol(handler: RequestHandler);
  public mkcol(path: any, handler: RequestHandler);
  public mkcol(...args: any[]) {
    return this.instance.mkcol(...args);
  }

  public copy(handler: RequestHandler);
  public copy(path: any, handler: RequestHandler);
  public copy(...args: any[]) {
    return this.instance.copy(...args);
  }

  public move(handler: RequestHandler);
  public move(path: any, handler: RequestHandler);
  public move(...args: any[]) {
    return this.instance.move(...args);
  }

  public lock(handler: RequestHandler);
  public lock(path: any, handler: RequestHandler);
  public lock(...args: any[]) {
    return this.instance.lock(...args);
  }

  public unlock(handler: RequestHandler);
  public unlock(path: any, handler: RequestHandler);
  public unlock(...args: any[]) {
    return this.instance.unlock(...args);
  }

  public all(handler: RequestHandler);
  public all(path: any, handler: RequestHandler);
  public all(...args: any[]) {
    return this.instance.all(...args);
  }

  public search(handler: RequestHandler);
  public search(path: any, handler: RequestHandler);
  public search(...args: any[]) {
    return this.instance.search(...args);
  }

  public options(handler: RequestHandler);
  public options(path: any, handler: RequestHandler);
  public options(...args: any[]) {
    return this.instance.options(...args);
  }

  public listen(port: string | number, callback?: () => void);
  public listen(port: string | number, hostname: string, callback?: () => void);
  public listen(port: any, hostname?: any, callback?: any) {
    return this.instance.listen(port, hostname, callback);
  }

  public getHttpServer(): TServer {
    return this.httpServer;
  }

  public setHttpServer(httpServer: TServer) {
    this.httpServer = httpServer;
  }

  public setInstance<T = any>(instance: T) {
    this.instance = instance;
  }

  public getInstance<T = any>(): T {
    return this.instance as T;
  }

  public normalizePath(path: string): string {
    return path;
  }

  abstract close();
  abstract initHttpServer(options: NestApplicationOptions);
  abstract useStaticAssets(...args: any[]);
  abstract setViewEngine(engine: string);
  abstract getRequestHostname(request: any);
  abstract getRequestMethod(request: any);
  abstract getRequestUrl(request: any);
  abstract status(response: any, statusCode: number);
  abstract reply(response: any, body: any, statusCode?: number);
  abstract end(response: any, message?: string);
  abstract render(response: any, view: string, options: any);
  abstract redirect(response: any, statusCode: number, url: string);
  abstract setErrorHandler(handler: Function, prefix?: string);
  abstract setNotFoundHandler(handler: Function, prefix?: string);
  abstract isHeadersSent(response: any);
  abstract setHeader(response: any, name: string, value: string);
  abstract registerParserMiddleware(prefix?: string, rawBody?: boolean);
  abstract enableCors(options?: any, prefix?: string);
  abstract createMiddlewareFactory(
    requestMethod: RequestMethod,
  ):
    | ((path: string, callback: Function) => any)
    | Promise<(path: string, callback: Function) => any>;
  abstract getType(): string;
  abstract applyVersionFilter(
    handler: Function,
    version: VersionValue,
    versioningOptions: VersioningOptions,
  ): (req: TRequest, res: TResponse, next: () => void) => Function;
}



================================================
FILE: packages/core/adapters/index.ts
================================================
export * from './http-adapter';



================================================
FILE: packages/core/discovery/discoverable-meta-host-collection.ts
================================================
import { Type } from '@nestjs/common';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { ModulesContainer } from '../injector/modules-container';

export class DiscoverableMetaHostCollection {
  /**
   * A map of class references to metadata keys.
   */
  public static readonly metaHostLinks = new Map<Type | Function, string>();

  /**
   * A map of metadata keys to instance wrappers (providers) with the corresponding metadata key.
   * The map is weakly referenced by the modules container (unique per application).
   */
  private static readonly providersByMetaKey = new WeakMap<
    ModulesContainer,
    Map<string, Set<InstanceWrapper>>
  >();

  /**
   * A map of metadata keys to instance wrappers (controllers) with the corresponding metadata key.
   * The map is weakly referenced by the modules container (unique per application).
   */
  private static readonly controllersByMetaKey = new WeakMap<
    ModulesContainer,
    Map<string, Set<InstanceWrapper>>
  >();

  /**
   * Adds a link between a class reference and a metadata key.
   * @param target The class reference.
   * @param metadataKey The metadata key.
   */
  public static addClassMetaHostLink(
    target: Type | Function,
    metadataKey: string,
  ) {
    this.metaHostLinks.set(target, metadataKey);
  }

  /**
   * Inspects a provider instance wrapper and adds it to the collection of providers
   * if it has a metadata key.
   * @param hostContainerRef A reference to the modules container.
   * @param instanceWrapper A provider instance wrapper.
   * @returns void
   */
  public static inspectProvider(
    hostContainerRef: ModulesContainer,
    instanceWrapper: InstanceWrapper,
  ) {
    return this.inspectInstanceWrapper(
      hostContainerRef,
      instanceWrapper,
      this.providersByMetaKey,
    );
  }

  /**
   * Inspects a controller instance wrapper and adds it to the collection of controllers
   * if it has a metadata key.
   * @param hostContainerRef A reference to the modules container.
   * @param instanceWrapper A controller's instance wrapper.
   * @returns void
   */
  public static inspectController(
    hostContainerRef: ModulesContainer,
    instanceWrapper: InstanceWrapper,
  ) {
    return this.inspectInstanceWrapper(
      hostContainerRef,
      instanceWrapper,
      this.controllersByMetaKey,
    );
  }

  public static insertByMetaKey(
    metaKey: string,
    instanceWrapper: InstanceWrapper,
    collection: Map<string, Set<InstanceWrapper>>,
  ) {
    if (collection.has(metaKey)) {
      const wrappers = collection.get(metaKey)!;
      wrappers.add(instanceWrapper);
    } else {
      const wrappers = new Set<InstanceWrapper>();
      wrappers.add(instanceWrapper);
      collection.set(metaKey, wrappers);
    }
  }

  public static getProvidersByMetaKey(
    hostContainerRef: ModulesContainer,
    metaKey: string,
  ): Set<InstanceWrapper> {
    const wrappersByMetaKey = this.providersByMetaKey.get(hostContainerRef);
    return wrappersByMetaKey?.get(metaKey) ?? new Set<InstanceWrapper>();
  }

  public static getControllersByMetaKey(
    hostContainerRef: ModulesContainer,
    metaKey: string,
  ): Set<InstanceWrapper> {
    const wrappersByMetaKey = this.controllersByMetaKey.get(hostContainerRef);
    return wrappersByMetaKey?.get(metaKey) ?? new Set<InstanceWrapper>();
  }

  private static inspectInstanceWrapper(
    hostContainerRef: ModulesContainer,
    instanceWrapper: InstanceWrapper,
    wrapperByMetaKeyMap: WeakMap<
      ModulesContainer,
      Map<string, Set<InstanceWrapper>>
    >,
  ) {
    const metaKey =
      DiscoverableMetaHostCollection.getMetaKeyByInstanceWrapper(
        instanceWrapper,
      );
    if (!metaKey) {
      return;
    }

    let collection: Map<string, Set<InstanceWrapper>>;
    if (wrapperByMetaKeyMap.has(hostContainerRef)) {
      collection = wrapperByMetaKeyMap.get(hostContainerRef)!;
    } else {
      collection = new Map<string, Set<InstanceWrapper>>();
      wrapperByMetaKeyMap.set(hostContainerRef, collection);
    }
    this.insertByMetaKey(metaKey, instanceWrapper, collection);
  }

  private static getMetaKeyByInstanceWrapper(
    instanceWrapper: InstanceWrapper<any>,
  ) {
    return this.metaHostLinks.get(
      // NOTE: Regarding the ternary statement below,
      // - The condition `!wrapper.metatype` is needed because when we use `useValue`
      // the value of `wrapper.metatype` will be `null`.
      // - The condition `wrapper.inject` is needed here because when we use
      // `useFactory`, the value of `wrapper.metatype` will be the supplied
      // factory function.
      // For both cases, we should use `wrapper.instance.constructor` instead
      // of `wrapper.metatype` to resolve processor's class properly.
      // But since calling `wrapper.instance` could degrade overall performance
      // we must defer it as much we can.
      instanceWrapper.metatype || instanceWrapper.inject
        ? (instanceWrapper.instance?.constructor ?? instanceWrapper.metatype)
        : instanceWrapper.metatype,
    );
  }
}



================================================
FILE: packages/core/discovery/discovery-module.ts
================================================
import { Module } from '@nestjs/common';
import { MetadataScanner } from '../metadata-scanner';
import { DiscoveryService } from './discovery-service';

/**
 * @publicApi
 */
@Module({
  providers: [MetadataScanner, DiscoveryService],
  exports: [MetadataScanner, DiscoveryService],
})
export class DiscoveryModule {}



================================================
FILE: packages/core/discovery/discovery-service.ts
================================================
import {
  CustomDecorator,
  flatten,
  Injectable,
  SetMetadata,
} from '@nestjs/common';
import { uid } from 'uid';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';
import { ModulesContainer } from '../injector/modules-container';
import { DiscoverableMetaHostCollection } from './discoverable-meta-host-collection';

/**
 * @publicApi
 */
export interface FilterByInclude {
  /**
   * List of modules to include (whitelist) into the discovery process.
   */
  include?: Function[];
}

/**
 * @publicApi
 */
export interface FilterByMetadataKey {
  /**
   * A key to filter controllers and providers by.
   * Only instance wrappers with the specified metadata key will be returned.
   */
  metadataKey?: string;
}

/**
 * @publicApi
 */
export type DiscoveryOptions = FilterByInclude | FilterByMetadataKey;

/**
 * @publicApi
 */
export type DiscoverableDecorator<T> = ((opts?: T) => CustomDecorator) & {
  KEY: string;
};

/**
 * @publicApi
 */
@Injectable()
export class DiscoveryService {
  constructor(private readonly modulesContainer: ModulesContainer) {}

  /**
   * Creates a decorator that can be used to decorate classes and methods with metadata.
   * The decorator will also add the class to the collection of discoverable classes (by metadata key).
   * Decorated classes can be discovered using the `getProviders` and `getControllers` methods.
   * @returns A decorator function.
   */
  static createDecorator<T>(): DiscoverableDecorator<T> {
    const metadataKey = uid(21);
    const decoratorFn =
      (opts: T) =>
      (target: object | Function, key?: string | symbol, descriptor?: any) => {
        if (!descriptor) {
          DiscoverableMetaHostCollection.addClassMetaHostLink(
            target as Function,
            metadataKey,
          );
        }
        SetMetadata(metadataKey, opts ?? {})(target, key!, descriptor);
      };

    decoratorFn.KEY = metadataKey;
    return decoratorFn as DiscoverableDecorator<T>;
  }

  /**
   * Returns an array of instance wrappers (providers).
   * Depending on the options, the array will contain either all providers or only providers with the specified metadata key.
   * @param options Discovery options.
   * @param modules A list of modules to filter by.
   * @returns An array of instance wrappers (providers).
   */
  public getProviders(
    options: DiscoveryOptions = {},
    modules: Module[] = this.getModules(options),
  ): InstanceWrapper[] {
    if ('metadataKey' in options) {
      const providers = DiscoverableMetaHostCollection.getProvidersByMetaKey(
        this.modulesContainer,
        options.metadataKey!,
      );
      return Array.from(providers);
    }

    const providers = modules.map(item => [...item.providers.values()]);
    return flatten(providers);
  }

  /**
   * Returns an array of instance wrappers (controllers).
   * Depending on the options, the array will contain either all controllers or only controllers with the specified metadata key.
   * @param options Discovery options.
   * @param modules A list of modules to filter by.
   * @returns An array of instance wrappers (controllers).
   */
  public getControllers(
    options: DiscoveryOptions = {},
    modules: Module[] = this.getModules(options),
  ): InstanceWrapper[] {
    if ('metadataKey' in options) {
      const controllers =
        DiscoverableMetaHostCollection.getControllersByMetaKey(
          this.modulesContainer,
          options.metadataKey!,
        );
      return Array.from(controllers);
    }

    const controllers = modules.map(item => [...item.controllers.values()]);
    return flatten(controllers);
  }

  /**
   * Retrieves metadata from the specified instance wrapper.
   * @param decorator The decorator to retrieve metadata of.
   * @param instanceWrapper Reference to the instance wrapper.
   * @param methodKey An optional method key to retrieve metadata from.
   * @returns Discovered metadata.
   */
  public getMetadataByDecorator<T extends DiscoverableDecorator<any>>(
    decorator: T,
    instanceWrapper: InstanceWrapper,
    methodKey?: string,
  ): T extends DiscoverableDecorator<infer R> ? R | undefined : T | undefined {
    if (methodKey) {
      return Reflect.getMetadata(
        decorator.KEY,
        instanceWrapper.instance[methodKey],
      );
    }

    const clsRef =
      instanceWrapper.instance?.constructor ?? instanceWrapper.metatype;
    return Reflect.getMetadata(decorator.KEY, clsRef);
  }

  /**
   * Returns a list of modules to be used for discovery.
   */
  protected getModules(options: DiscoveryOptions = {}): Module[] {
    const includeInOpts = 'include' in options;
    if (!includeInOpts) {
      const moduleRefs = [...this.modulesContainer.values()];
      return moduleRefs;
    }
    const whitelisted = this.includeWhitelisted(options.include!);
    return whitelisted;
  }

  private includeWhitelisted(include: Function[]): Module[] {
    const moduleRefs = [...this.modulesContainer.values()];
    return moduleRefs.filter(({ metatype }) =>
      include.some(item => item === metatype),
    );
  }
}



================================================
FILE: packages/core/discovery/index.ts
================================================
export * from './discovery-module';
export * from './discovery-service';



================================================
FILE: packages/core/errors/exception-handler.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';

export class ExceptionHandler {
  private static readonly logger = new Logger(ExceptionHandler.name);

  public handle(exception: Error) {
    ExceptionHandler.logger.error(exception);
  }
}



================================================
FILE: packages/core/errors/exceptions-zone.ts
================================================
import { Logger } from '@nestjs/common';
import { ExceptionHandler } from './exception-handler';

const DEFAULT_TEARDOWN = () => process.exit(1);

export class ExceptionsZone {
  private static readonly exceptionHandler = new ExceptionHandler();

  public static run(
    callback: () => void,
    teardown: (err: any) => void = DEFAULT_TEARDOWN,
    autoFlushLogs: boolean,
  ) {
    try {
      callback();
    } catch (e) {
      this.exceptionHandler.handle(e);
      if (autoFlushLogs) {
        Logger.flush();
      }
      teardown(e);
    }
  }

  public static async asyncRun(
    callback: () => Promise<void>,
    teardown: (err: any) => void = DEFAULT_TEARDOWN,
    autoFlushLogs: boolean,
  ) {
    try {
      await callback();
    } catch (e) {
      this.exceptionHandler.handle(e);
      if (autoFlushLogs) {
        Logger.flush();
      }
      teardown(e);
    }
  }
}



================================================
FILE: packages/core/errors/messages.ts
================================================
import type { DynamicModule, ForwardReference, Type } from '@nestjs/common';
import { isNil, isSymbol } from '@nestjs/common/utils/shared.utils';
import {
  InjectorDependency,
  InjectorDependencyContext,
} from '../injector/injector';
import { Module } from '../injector/module';

/**
 * Returns the name of an instance or `undefined`
 * @param instance The instance which should get the name from
 */
const getInstanceName = (instance: unknown): string => {
  if ((instance as ForwardReference)?.forwardRef) {
    return (instance as ForwardReference).forwardRef()?.name;
  }

  if ((instance as DynamicModule)?.module) {
    return (instance as DynamicModule).module?.name;
  }

  return (instance as Type)?.name;
};

/**
 * Returns the name of the dependency.
 * Tries to get the class name, otherwise the string value
 * (= injection token). As fallback to any falsy value for `dependency`, it
 * returns `fallbackValue`
 * @param dependency The name of the dependency to be displayed
 * @param fallbackValue The fallback value if the dependency is falsy
 * @param disambiguated Whether dependency's name is disambiguated with double quotes
 */
const getDependencyName = (
  dependency: InjectorDependency | undefined,
  fallbackValue: string,
  disambiguated = true,
): string =>
  // use class name
  getInstanceName(dependency) ||
  // use injection token (symbol)
  (isSymbol(dependency) && dependency.toString()) ||
  // use string directly
  (dependency
    ? disambiguated
      ? `"${dependency as string}"`
      : (dependency as string)
    : undefined) ||
  // otherwise
  fallbackValue;

/**
 * Returns the name of the module
 * Tries to get the class name. As fallback it returns 'current'.
 * @param module The module which should get displayed
 */
const getModuleName = (module: Module | undefined) =>
  (module && getInstanceName(module.metatype)) || 'current';

const stringifyScope = (scope: any[]): string =>
  (scope || []).map(getInstanceName).join(' -> ');

export const UNKNOWN_DEPENDENCIES_MESSAGE = (
  type: string | symbol,
  unknownDependencyContext: InjectorDependencyContext,
  moduleRef: Module | undefined,
) => {
  const { index, name, dependencies, key } = unknownDependencyContext;
  const moduleName = getModuleName(moduleRef);
  const dependencyName = getDependencyName(name, 'dependency');

  const potentialSolutions =
    // If module's name is well defined
    moduleName !== 'current'
      ? `\n
Potential solutions:
- Is ${moduleName} a valid NestJS module?
- If ${dependencyName} is a provider, is it part of the current ${moduleName}?
- If ${dependencyName} is exported from a separate @Module, is that module imported within ${moduleName}?
  @Module({
    imports: [ /* the Module containing ${dependencyName} */ ]
  })
`
      : `\n
Potential solutions:
- If ${dependencyName} is a provider, is it part of the current Module?
- If ${dependencyName} is exported from a separate @Module, is that module imported within Module?
  @Module({
    imports: [ /* the Module containing ${dependencyName} */ ]
  })
`;

  let message = `Nest can't resolve dependencies of the ${type.toString()}`;

  if (isNil(index)) {
    message += `. Please make sure that the "${key!.toString()}" property is available in the current context.${potentialSolutions}`;
    return message;
  }
  const dependenciesName = (dependencies || []).map(dependencyName =>
    getDependencyName(dependencyName, '+', false),
  );
  dependenciesName[index] = '?';

  message += ` (`;
  message += dependenciesName.join(', ');
  message += `). Please make sure that the argument ${dependencyName} at index [${index}] is available in the ${moduleName} context.`;
  message += potentialSolutions;

  return message;
};

export const INVALID_MIDDLEWARE_MESSAGE = (
  text: TemplateStringsArray,
  name: string,
) => `The middleware doesn't provide the 'use' method (${name})`;

export const UNDEFINED_FORWARDREF_MESSAGE = (
  scope: Type<any>[],
) => `Nest cannot create the module instance. Often, this is because of a circular dependency between modules. Use forwardRef() to avoid it.

(Read more: https://docs.nestjs.com/fundamentals/circular-dependency)
Scope [${stringifyScope(scope)}]
`;

export const INVALID_MODULE_MESSAGE = (
  parentModule: any,
  index: number,
  scope: any[],
) => {
  const parentModuleName = parentModule?.name || 'module';

  return `Nest cannot create the ${parentModuleName} instance.
Received an unexpected value at index [${index}] of the ${parentModuleName} "imports" array.

Scope [${stringifyScope(scope)}]`;
};

export const USING_INVALID_CLASS_AS_A_MODULE_MESSAGE = (
  metatypeUsedAsAModule: Type | ForwardReference,
  scope: any[],
) => {
  const metatypeNameQuote = `"${getInstanceName(metatypeUsedAsAModule)}"`;

  return `Classes annotated with @Injectable(), @Catch(), and @Controller() decorators must not appear in the "imports" array of a module.
Please remove ${metatypeNameQuote} (including forwarded occurrences, if any) from all of the "imports" arrays.

Scope [${stringifyScope(scope)}]
`;
};

export const UNDEFINED_MODULE_MESSAGE = (
  parentModule: any,
  index: number,
  scope: any[],
) => {
  const parentModuleName = parentModule?.name || 'module';

  return `Nest cannot create the ${parentModuleName} instance.
The module at index [${index}] of the ${parentModuleName} "imports" array is undefined.

Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [${index}] is of type "undefined". Check your import statements and the type of the module.

Scope [${stringifyScope(scope)}]`;
};

export const UNKNOWN_EXPORT_MESSAGE = (
  token: string | symbol = 'item',
  module: string,
) => {
  token = isSymbol(token) ? token.toString() : token;

  return `Nest cannot export a provider/module that is not a part of the currently processed module (${module}). Please verify whether the exported ${token} is available in this particular context.

Possible Solutions:
- Is ${token} part of the relevant providers/imports within ${module}?
`;
};

export const INVALID_CLASS_MESSAGE = (text: TemplateStringsArray, value: any) =>
  `ModuleRef cannot instantiate class (${value} is not constructable).`;

export const INVALID_CLASS_SCOPE_MESSAGE = (
  text: TemplateStringsArray,
  name: string | undefined,
) =>
  `${
    name || 'This class'
  } is marked as a scoped provider. Request and transient-scoped providers can't be used in combination with "get()" method. Please, use "resolve()" instead.`;

export const UNKNOWN_REQUEST_MAPPING = (metatype: Type) => {
  const className = metatype.name;
  return className
    ? `An invalid controller has been detected. "${className}" does not have the @Controller() decorator but it is being listed in the "controllers" array of some module.`
    : `An invalid controller has been detected. Perhaps, one of your controllers is missing the @Controller() decorator.`;
};

export const INVALID_MIDDLEWARE_CONFIGURATION = `An invalid middleware configuration has been passed inside the module 'configure()' method.`;
export const UNHANDLED_RUNTIME_EXCEPTION = `Unhandled Runtime Exception.`;
export const INVALID_EXCEPTION_FILTER = `Invalid exception filters (@UseFilters()).`;
export const MICROSERVICES_PACKAGE_NOT_FOUND_EXCEPTION = `Unable to load @nestjs/microservices package. (Please make sure that it's already installed.)`;



================================================
FILE: packages/core/errors/exceptions/circular-dependency.exception.ts
================================================
import { RuntimeException } from './runtime.exception';

export class CircularDependencyException extends RuntimeException {
  constructor(context?: string) {
    const ctx = context ? ` inside ${context}` : ``;
    super(
      `A circular dependency has been detected${ctx}. Please, make sure that each side of a bidirectional relationships are decorated with "forwardRef()". Note that circular relationships between custom providers (e.g., factories) are not supported since functions cannot be called more than once.`,
    );
  }
}



================================================
FILE: packages/core/errors/exceptions/index.ts
================================================
export * from './circular-dependency.exception';
export * from './runtime.exception';
export * from './unknown-element.exception';
export * from './invalid-class-scope.exception';
export * from './invalid-class.exception';
export * from './unknown-export.exception';
export * from './unknown-module.exception';
export * from './undefined-forwardref.exception';



================================================
FILE: packages/core/errors/exceptions/invalid-class-module.exception.ts
================================================
import { USING_INVALID_CLASS_AS_A_MODULE_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class InvalidClassModuleException extends RuntimeException {
  constructor(metatypeUsedAsAModule: any, scope: any[]) {
    super(
      USING_INVALID_CLASS_AS_A_MODULE_MESSAGE(metatypeUsedAsAModule, scope),
    );
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-class-scope.exception.ts
================================================
import { Abstract, Type } from '@nestjs/common/interfaces';
import { isFunction } from '@nestjs/common/utils/shared.utils';
import { INVALID_CLASS_SCOPE_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class InvalidClassScopeException extends RuntimeException {
  constructor(metatypeOrToken: Type<any> | Abstract<any> | string | symbol) {
    let name = isFunction(metatypeOrToken)
      ? (metatypeOrToken as Function).name
      : metatypeOrToken;
    name = name && name.toString();

    super(INVALID_CLASS_SCOPE_MESSAGE`${name}`);
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-class.exception.ts
================================================
import { INVALID_CLASS_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class InvalidClassException extends RuntimeException {
  constructor(value: any) {
    super(INVALID_CLASS_MESSAGE`${value}`);
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-exception-filter.exception.ts
================================================
import { RuntimeException } from './runtime.exception';
import { INVALID_EXCEPTION_FILTER } from '../messages';

export class InvalidExceptionFilterException extends RuntimeException {
  constructor() {
    super(INVALID_EXCEPTION_FILTER);
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-middleware-configuration.exception.ts
================================================
import { RuntimeException } from './runtime.exception';
import { INVALID_MIDDLEWARE_CONFIGURATION } from '../messages';

export class InvalidMiddlewareConfigurationException extends RuntimeException {
  constructor() {
    super(INVALID_MIDDLEWARE_CONFIGURATION);
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-middleware.exception.ts
================================================
import { INVALID_MIDDLEWARE_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class InvalidMiddlewareException extends RuntimeException {
  constructor(name: string) {
    super(INVALID_MIDDLEWARE_MESSAGE`${name}`);
  }
}



================================================
FILE: packages/core/errors/exceptions/invalid-module.exception.ts
================================================
import { INVALID_MODULE_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class InvalidModuleException extends RuntimeException {
  constructor(parentModule: any, index: number, scope: any[]) {
    super(INVALID_MODULE_MESSAGE(parentModule, index, scope));
  }
}



================================================
FILE: packages/core/errors/exceptions/runtime.exception.ts
================================================
export class RuntimeException extends Error {
  constructor(message = ``) {
    super(message);
  }

  public what() {
    return this.message;
  }
}



================================================
FILE: packages/core/errors/exceptions/undefined-dependency.exception.ts
================================================
import { InjectorDependencyContext } from '../../injector/injector';
import { Module } from '../../injector/module';
import { UNKNOWN_DEPENDENCIES_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class UndefinedDependencyException extends RuntimeException {
  constructor(
    type: string,
    undefinedDependencyContext: InjectorDependencyContext,
    moduleRef?: Module,
  ) {
    super(
      UNKNOWN_DEPENDENCIES_MESSAGE(type, undefinedDependencyContext, moduleRef),
    );
  }
}



================================================
FILE: packages/core/errors/exceptions/undefined-forwardref.exception.ts
================================================
import { UNDEFINED_FORWARDREF_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';
import { Type } from '@nestjs/common';

export class UndefinedForwardRefException extends RuntimeException {
  constructor(scope: Type<any>[]) {
    super(UNDEFINED_FORWARDREF_MESSAGE(scope));
  }
}



================================================
FILE: packages/core/errors/exceptions/undefined-module.exception.ts
================================================
import { RuntimeException } from './runtime.exception';
import { UNDEFINED_MODULE_MESSAGE } from '../messages';

export class UndefinedModuleException extends RuntimeException {
  constructor(parentModule: any, index: number, scope: any[]) {
    super(UNDEFINED_MODULE_MESSAGE(parentModule, index, scope));
  }
}



================================================
FILE: packages/core/errors/exceptions/unknown-dependencies.exception.ts
================================================
import { InjectorDependencyContext } from '../../injector/injector';
import { Module } from '../../injector/module';
import { UNKNOWN_DEPENDENCIES_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class UnknownDependenciesException extends RuntimeException {
  public readonly moduleRef: { id: string } | undefined;

  constructor(
    public readonly type: string | symbol,
    public readonly context: InjectorDependencyContext,
    moduleRef?: Module,
    public readonly metadata?: { id: string },
  ) {
    super(UNKNOWN_DEPENDENCIES_MESSAGE(type, context, moduleRef));
    this.moduleRef = moduleRef && { id: moduleRef.id };
  }
}



================================================
FILE: packages/core/errors/exceptions/unknown-element.exception.ts
================================================
import { RuntimeException } from './runtime.exception';

export class UnknownElementException extends RuntimeException {
  constructor(name?: string | symbol) {
    name = name && name.toString();
    super(
      `Nest could not find ${
        name || 'given'
      } element (this provider does not exist in the current context)`,
    );
  }
}



================================================
FILE: packages/core/errors/exceptions/unknown-export.exception.ts
================================================
import { UNKNOWN_EXPORT_MESSAGE } from '../messages';
import { RuntimeException } from './runtime.exception';

export class UnknownExportException extends RuntimeException {
  constructor(token: string | symbol, moduleName: string) {
    super(UNKNOWN_EXPORT_MESSAGE(token, moduleName));
  }
}



================================================
FILE: packages/core/errors/exceptions/unknown-module.exception.ts
================================================
import { RuntimeException } from './runtime.exception';

export class UnknownModuleException extends RuntimeException {
  constructor(moduleName?: string) {
    super(
      `Nest could not select the given module (${
        moduleName ? `"${moduleName}"` : 'it'
      } does not exist in current context).`,
    );
  }
}



================================================
FILE: packages/core/errors/exceptions/unknown-request-mapping.exception.ts
================================================
import type { Type } from '@nestjs/common';
import { RuntimeException } from './runtime.exception';
import { UNKNOWN_REQUEST_MAPPING } from '../messages';

export class UnknownRequestMappingException extends RuntimeException {
  constructor(metatype: Type) {
    super(UNKNOWN_REQUEST_MAPPING(metatype));
  }
}



================================================
FILE: packages/core/exceptions/base-exception-filter-context.ts
================================================
import { FILTER_CATCH_EXCEPTIONS } from '@nestjs/common/constants';
import { Type } from '@nestjs/common/interfaces';
import { ExceptionFilter } from '@nestjs/common/interfaces/exceptions/exception-filter.interface';
import { isEmpty, isFunction } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ContextCreator } from '../helpers/context-creator';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';

export class BaseExceptionFilterContext extends ContextCreator {
  protected moduleContext: string;

  constructor(private readonly container: NestContainer) {
    super();
  }

  public createConcreteContext<T extends any[], R extends any[]>(
    metadata: T,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): R {
    if (isEmpty(metadata)) {
      return [] as any[] as R;
    }
    return iterate(metadata)
      .filter(
        instance => instance && (isFunction(instance.catch) || instance.name),
      )
      .map(filter => this.getFilterInstance(filter, contextId, inquirerId))
      .filter(item => !!item)
      .map(instance => ({
        func: instance!.catch.bind(instance),
        exceptionMetatypes: this.reflectCatchExceptions(instance!),
      }))
      .toArray() as R;
  }

  public getFilterInstance(
    filter: Function | ExceptionFilter,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): ExceptionFilter | null {
    const isObject = !!(filter as ExceptionFilter).catch;
    if (isObject) {
      return filter as ExceptionFilter;
    }
    const instanceWrapper = this.getInstanceByMetatype(filter as Type<unknown>);
    if (!instanceWrapper) {
      return null;
    }
    const instanceHost = instanceWrapper.getInstanceByContextId(
      this.getContextId(contextId, instanceWrapper),
      inquirerId,
    );
    return instanceHost && instanceHost.instance;
  }

  public getInstanceByMetatype(
    metatype: Type<unknown>,
  ): InstanceWrapper | undefined {
    if (!this.moduleContext) {
      return;
    }
    const collection = this.container.getModules();
    const moduleRef = collection.get(this.moduleContext);
    if (!moduleRef) {
      return;
    }
    return moduleRef.injectables.get(metatype);
  }

  public reflectCatchExceptions(instance: ExceptionFilter): Type<any>[] {
    const prototype = Object.getPrototypeOf(instance);
    return (
      Reflect.getMetadata(FILTER_CATCH_EXCEPTIONS, prototype.constructor) || []
    );
  }
}



================================================
FILE: packages/core/exceptions/base-exception-filter.ts
================================================
import {
  ArgumentsHost,
  ExceptionFilter,
  HttpException,
  HttpServer,
  HttpStatus,
  Inject,
  IntrinsicException,
  Logger,
  Optional,
} from '@nestjs/common';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { AbstractHttpAdapter } from '../adapters';
import { MESSAGES } from '../constants';
import { HttpAdapterHost } from '../helpers/http-adapter-host';

export class BaseExceptionFilter<T = any> implements ExceptionFilter<T> {
  private static readonly logger = new Logger('ExceptionsHandler');

  @Optional()
  @Inject()
  protected readonly httpAdapterHost?: HttpAdapterHost;

  constructor(protected readonly applicationRef?: HttpServer) {}

  catch(exception: T, host: ArgumentsHost) {
    const applicationRef =
      this.applicationRef ||
      (this.httpAdapterHost && this.httpAdapterHost.httpAdapter)!;

    if (!(exception instanceof HttpException)) {
      return this.handleUnknownError(exception, host, applicationRef);
    }
    const res = exception.getResponse();
    const message = isObject(res)
      ? res
      : {
          statusCode: exception.getStatus(),
          message: res,
        };

    const response = host.getArgByIndex(1);
    if (!applicationRef.isHeadersSent(response)) {
      applicationRef.reply(response, message, exception.getStatus());
    } else {
      applicationRef.end(response);
    }
  }

  public handleUnknownError(
    exception: T,
    host: ArgumentsHost,
    applicationRef: AbstractHttpAdapter | HttpServer,
  ) {
    const body = this.isHttpError(exception)
      ? {
          statusCode: exception.statusCode,
          message: exception.message,
        }
      : {
          statusCode: HttpStatus.INTERNAL_SERVER_ERROR,
          message: MESSAGES.UNKNOWN_EXCEPTION_MESSAGE,
        };

    const response = host.getArgByIndex(1);
    if (!applicationRef.isHeadersSent(response)) {
      applicationRef.reply(response, body, body.statusCode);
    } else {
      applicationRef.end(response);
    }

    if (!(exception instanceof IntrinsicException)) {
      BaseExceptionFilter.logger.error(exception);
    }
  }

  public isExceptionObject(err: any): err is Error {
    return isObject(err) && !!(err as Error).message;
  }

  /**
   * Checks if the thrown error comes from the "http-errors" library.
   * @param err error object
   */
  public isHttpError(err: any): err is { statusCode: number; message: string } {
    return err?.statusCode && err?.message;
  }
}



================================================
FILE: packages/core/exceptions/exceptions-handler.ts
================================================
import { HttpException } from '@nestjs/common';
import { ExceptionFilterMetadata } from '@nestjs/common/interfaces/exceptions/exception-filter-metadata.interface';
import { ArgumentsHost } from '@nestjs/common/interfaces/features/arguments-host.interface';
import { selectExceptionFilterMetadata } from '@nestjs/common/utils/select-exception-filter-metadata.util';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { InvalidExceptionFilterException } from '../errors/exceptions/invalid-exception-filter.exception';
import { BaseExceptionFilter } from './base-exception-filter';

export class ExceptionsHandler extends BaseExceptionFilter {
  private filters: ExceptionFilterMetadata[] = [];

  public next(exception: Error | HttpException, ctx: ArgumentsHost) {
    if (this.invokeCustomFilters(exception, ctx)) {
      return;
    }
    super.catch(exception, ctx);
  }

  public setCustomFilters(filters: ExceptionFilterMetadata[]) {
    if (!Array.isArray(filters)) {
      throw new InvalidExceptionFilterException();
    }
    this.filters = filters;
  }

  public invokeCustomFilters<T = any>(
    exception: T,
    ctx: ArgumentsHost,
  ): boolean {
    if (isEmpty(this.filters)) {
      return false;
    }

    const filter = selectExceptionFilterMetadata(this.filters, exception);
    filter && filter.func(exception, ctx);
    return !!filter;
  }
}



================================================
FILE: packages/core/exceptions/external-exception-filter-context.ts
================================================
import { EXCEPTION_FILTERS_METADATA } from '@nestjs/common/constants';
import { Controller } from '@nestjs/common/interfaces';
import { ExceptionFilterMetadata } from '@nestjs/common/interfaces/exceptions';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { RouterProxyCallback } from '../router/router-proxy';
import { BaseExceptionFilterContext } from './base-exception-filter-context';
import { ExternalExceptionsHandler } from './external-exceptions-handler';

export class ExternalExceptionFilterContext extends BaseExceptionFilterContext {
  constructor(
    container: NestContainer,
    private readonly config?: ApplicationConfig,
  ) {
    super(container);
  }

  public create(
    instance: Controller,
    callback: RouterProxyCallback,
    module: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): ExternalExceptionsHandler {
    this.moduleContext = module;

    const exceptionHandler = new ExternalExceptionsHandler();
    const filters = this.createContext<ExceptionFilterMetadata[]>(
      instance,
      callback,
      EXCEPTION_FILTERS_METADATA,
      contextId,
      inquirerId,
    );
    if (isEmpty(filters)) {
      return exceptionHandler;
    }
    exceptionHandler.setCustomFilters(filters.reverse());
    return exceptionHandler;
  }

  public getGlobalMetadata<T extends any[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    if (!this.config) {
      return [] as any[] as T;
    }
    const globalFilters = this.config.getGlobalFilters() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalFilters;
    }
    const scopedFilterWrappers =
      this.config.getGlobalRequestFilters() as InstanceWrapper[];
    const scopedFilters = iterate(scopedFilterWrappers)
      .map(wrapper => wrapper.getInstanceByContextId(contextId, inquirerId))
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalFilters.concat(scopedFilters) as T;
  }
}



================================================
FILE: packages/core/exceptions/external-exception-filter.ts
================================================
import { ArgumentsHost, IntrinsicException, Logger } from '@nestjs/common';

export class ExternalExceptionFilter<T = any, R = any> {
  private static readonly logger = new Logger('ExceptionsHandler');

  catch(exception: T, host: ArgumentsHost): R | Promise<R> {
    if (
      exception instanceof Error &&
      !(exception instanceof IntrinsicException)
    ) {
      ExternalExceptionFilter.logger.error(exception);
    }

    throw exception;
  }
}



================================================
FILE: packages/core/exceptions/external-exceptions-handler.ts
================================================
import { ExceptionFilterMetadata } from '@nestjs/common/interfaces/exceptions';
import { ArgumentsHost } from '@nestjs/common/interfaces/features/arguments-host.interface';
import { selectExceptionFilterMetadata } from '@nestjs/common/utils/select-exception-filter-metadata.util';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { InvalidExceptionFilterException } from '../errors/exceptions/invalid-exception-filter.exception';
import { ExternalExceptionFilter } from './external-exception-filter';

export class ExternalExceptionsHandler extends ExternalExceptionFilter {
  private filters: ExceptionFilterMetadata[] = [];

  public next(exception: Error, host: ArgumentsHost): Promise<any> {
    const result = this.invokeCustomFilters(exception, host);
    if (result) {
      return result;
    }
    return super.catch(exception, host);
  }

  public setCustomFilters(filters: ExceptionFilterMetadata[]) {
    if (!Array.isArray(filters)) {
      throw new InvalidExceptionFilterException();
    }
    this.filters = filters;
  }

  public invokeCustomFilters<T = any>(
    exception: T,
    host: ArgumentsHost,
  ): Promise<any> | null {
    if (isEmpty(this.filters)) {
      return null;
    }

    const filter = selectExceptionFilterMetadata(this.filters, exception);
    return filter ? filter.func(exception, host) : null;
  }
}



================================================
FILE: packages/core/exceptions/index.ts
================================================
export * from './base-exception-filter';



================================================
FILE: packages/core/guards/constants.ts
================================================
export const FORBIDDEN_MESSAGE = 'Forbidden resource';



================================================
FILE: packages/core/guards/guards-consumer.ts
================================================
import { CanActivate } from '@nestjs/common';
import { ContextType, Controller } from '@nestjs/common/interfaces';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { lastValueFrom, Observable } from 'rxjs';
import { ExecutionContextHost } from '../helpers/execution-context-host';

export class GuardsConsumer {
  public async tryActivate<TContext extends string = ContextType>(
    guards: CanActivate[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    type?: TContext,
  ): Promise<boolean> {
    if (!guards || isEmpty(guards)) {
      return true;
    }
    const context = this.createContext(args, instance, callback);
    context.setType<TContext>(type!);

    for (const guard of guards) {
      const result = guard.canActivate(context);
      if (await this.pickResult(result)) {
        continue;
      }
      return false;
    }
    return true;
  }

  public createContext(
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
  ): ExecutionContextHost {
    return new ExecutionContextHost(
      args,
      instance.constructor as any,
      callback,
    );
  }

  public async pickResult(
    result: boolean | Promise<boolean> | Observable<boolean>,
  ): Promise<boolean> {
    if (result instanceof Observable) {
      return lastValueFrom(result);
    }
    return result;
  }
}



================================================
FILE: packages/core/guards/guards-context-creator.ts
================================================
import { CanActivate } from '@nestjs/common';
import { GUARDS_METADATA } from '@nestjs/common/constants';
import { Controller, Type } from '@nestjs/common/interfaces';
import { isEmpty, isFunction } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import { ContextCreator } from '../helpers/context-creator';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';

export class GuardsContextCreator extends ContextCreator {
  private moduleContext: string;

  constructor(
    private readonly container: NestContainer,
    private readonly config?: ApplicationConfig,
  ) {
    super();
  }

  public create(
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    module: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): CanActivate[] {
    this.moduleContext = module;
    return this.createContext(
      instance,
      callback,
      GUARDS_METADATA,
      contextId,
      inquirerId,
    );
  }

  public createConcreteContext<T extends unknown[], R extends unknown[]>(
    metadata: T,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): R {
    if (isEmpty(metadata)) {
      return [] as unknown[] as R;
    }
    return iterate(metadata)
      .filter((guard: any) => guard && (guard.name || guard.canActivate))
      .map(guard =>
        this.getGuardInstance(guard as Function, contextId, inquirerId),
      )
      .filter(
        (guard: CanActivate | null) => !!guard && isFunction(guard.canActivate),
      )
      .toArray() as R;
  }

  public getGuardInstance(
    metatype: Function | CanActivate,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): CanActivate | null {
    const isObject = !!(metatype as CanActivate).canActivate;
    if (isObject) {
      return metatype as CanActivate;
    }
    const instanceWrapper = this.getInstanceByMetatype(
      metatype as Type<unknown>,
    );
    if (!instanceWrapper) {
      return null;
    }
    const instanceHost = instanceWrapper.getInstanceByContextId(
      this.getContextId(contextId, instanceWrapper),
      inquirerId,
    );
    return instanceHost && instanceHost.instance;
  }

  public getInstanceByMetatype(
    metatype: Type<unknown>,
  ): InstanceWrapper | undefined {
    if (!this.moduleContext) {
      return;
    }
    const collection = this.container.getModules();
    const moduleRef = collection.get(this.moduleContext);
    if (!moduleRef) {
      return;
    }
    const injectables = moduleRef.injectables;
    return injectables.get(metatype);
  }

  public getGlobalMetadata<T extends unknown[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    if (!this.config) {
      return [] as unknown[] as T;
    }
    const globalGuards = this.config.getGlobalGuards() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalGuards;
    }
    const scopedGuardWrappers =
      this.config.getGlobalRequestGuards() as InstanceWrapper[];
    const scopedGuards = iterate(scopedGuardWrappers)
      .map(wrapper =>
        wrapper.getInstanceByContextId(
          this.getContextId(contextId, wrapper),
          inquirerId,
        ),
      )
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalGuards.concat(scopedGuards) as T;
  }
}



================================================
FILE: packages/core/guards/index.ts
================================================
export * from './constants';
export * from './guards-consumer';
export * from './guards-context-creator';



================================================
FILE: packages/core/helpers/context-creator.ts
================================================
import { Controller } from '@nestjs/common/interfaces';
import { STATIC_CONTEXT } from '../injector/constants';
import { ContextId, InstanceWrapper } from '../injector/instance-wrapper';

export abstract class ContextCreator {
  public abstract createConcreteContext<T extends any[], R extends any[]>(
    metadata: T,
    contextId?: ContextId,
    inquirerId?: string,
  ): R;
  public getGlobalMetadata?<T extends any[]>(
    contextId?: ContextId,
    inquirerId?: string,
  ): T;

  public createContext<T extends unknown[] = any, R extends unknown[] = any>(
    instance: Controller,
    callback: (...args: any[]) => void,
    metadataKey: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): R {
    const globalMetadata =
      this.getGlobalMetadata &&
      this.getGlobalMetadata<T>(contextId, inquirerId);
    const classMetadata = this.reflectClassMetadata<T>(instance, metadataKey);
    const methodMetadata = this.reflectMethodMetadata<T>(callback, metadataKey);
    return [
      ...this.createConcreteContext<T, R>(
        globalMetadata || ([] as unknown[] as T),
        contextId,
        inquirerId,
      ),
      ...this.createConcreteContext<T, R>(classMetadata, contextId, inquirerId),
      ...this.createConcreteContext<T, R>(
        methodMetadata,
        contextId,
        inquirerId,
      ),
    ] as R;
  }

  public reflectClassMetadata<T>(instance: Controller, metadataKey: string): T {
    const prototype = Object.getPrototypeOf(instance);
    return Reflect.getMetadata(metadataKey, prototype.constructor);
  }

  public reflectMethodMetadata<T>(
    callback: (...args: unknown[]) => unknown,
    metadataKey: string,
  ): T {
    return Reflect.getMetadata(metadataKey, callback);
  }

  protected getContextId(
    contextId: ContextId,
    instanceWrapper: InstanceWrapper,
  ): ContextId {
    return contextId.getParent
      ? contextId.getParent({
          token: instanceWrapper.token,
          isTreeDurable: instanceWrapper.isDependencyTreeDurable(),
        })
      : contextId;
  }
}



================================================
FILE: packages/core/helpers/context-id-factory.ts
================================================
import { isObject } from '@nestjs/common/utils/shared.utils';
import { ContextId, HostComponentInfo } from '../injector/instance-wrapper';
import { REQUEST_CONTEXT_ID } from '../router/request/request-constants';

export function createContextId(): ContextId {
  /**
   * We are generating random identifier to track asynchronous
   * execution context. An identifier does not have to be neither unique
   * nor unpredictable because WeakMap uses objects as keys (reference comparison).
   * Thus, even though identifier number might be equal, WeakMap would properly
   * associate asynchronous context with its internal map values using object reference.
   * Object is automatically removed once request has been processed (closure).
   */
  return { id: Math.random() };
}

export type ContextIdResolverFn = (info: HostComponentInfo) => ContextId;

export interface ContextIdResolver {
  /**
   * Payload associated with the custom context id
   */
  payload: unknown;
  /**
   * A context id resolver function
   */
  resolve: ContextIdResolverFn;
}

export interface ContextIdStrategy<T = any> {
  /**
   * Allows to attach a parent context id to the existing child context id.
   * This lets you construct durable DI sub-trees that can be shared between contexts.
   * @param contextId auto-generated child context id
   * @param request request object
   */
  attach(
    contextId: ContextId,
    request: T,
  ): ContextIdResolverFn | ContextIdResolver | undefined;
}

export class ContextIdFactory {
  private static strategy?: ContextIdStrategy;

  /**
   * Generates a context identifier based on the request object.
   */
  public static create(): ContextId {
    return createContextId();
  }

  /**
   * Generates a random identifier to track asynchronous execution context.
   * @param request request object
   */
  public static getByRequest<T extends Record<any, any> = any>(
    request: T,
    propsToInspect: string[] = ['raw'],
  ): ContextId {
    if (!request) {
      return ContextIdFactory.create();
    }
    if (request[REQUEST_CONTEXT_ID as any]) {
      return request[REQUEST_CONTEXT_ID as any];
    }
    for (const key of propsToInspect) {
      if (request[key]?.[REQUEST_CONTEXT_ID]) {
        return request[key][REQUEST_CONTEXT_ID];
      }
    }
    if (!this.strategy) {
      return ContextIdFactory.create();
    }
    const contextId = createContextId();
    const resolverObjectOrFunction = this.strategy.attach(contextId, request);
    if (this.isContextIdResolverWithPayload(resolverObjectOrFunction!)) {
      contextId.getParent = resolverObjectOrFunction.resolve;
      contextId.payload = resolverObjectOrFunction.payload;
    } else {
      contextId.getParent = resolverObjectOrFunction;
    }
    return contextId;
  }

  /**
   * Registers a custom context id strategy that lets you attach
   * a parent context id to the existing context id object.
   * @param strategy strategy instance
   */
  public static apply(strategy: ContextIdStrategy) {
    this.strategy = strategy;
  }

  private static isContextIdResolverWithPayload(
    resolverOrResolverFn: ContextIdResolver | ContextIdResolverFn,
  ): resolverOrResolverFn is ContextIdResolver {
    return isObject(resolverOrResolverFn);
  }
}



================================================
FILE: packages/core/helpers/context-utils.ts
================================================
import { ParamData } from '@nestjs/common';
import {
  PARAMTYPES_METADATA,
  RESPONSE_PASSTHROUGH_METADATA,
} from '@nestjs/common/constants';
import {
  ContextType,
  Controller,
  PipeTransform,
  Type,
} from '@nestjs/common/interfaces';
import { isFunction } from '@nestjs/common/utils/shared.utils';
import { ExecutionContextHost } from './execution-context-host';

export interface ParamProperties<T = any, IExtractor extends Function = any> {
  index: number;
  type: T | string;
  data: ParamData;
  pipes: PipeTransform[];
  extractValue: IExtractor;
}

export class ContextUtils {
  public mapParamType(key: string): string {
    const keyPair = key.split(':');
    return keyPair[0];
  }

  public reflectCallbackParamtypes(
    instance: Controller,
    methodName: string,
  ): any[] {
    return Reflect.getMetadata(PARAMTYPES_METADATA, instance, methodName);
  }

  public reflectCallbackMetadata<T = any>(
    instance: Controller,
    methodName: string,
    metadataKey: string,
  ): T {
    return Reflect.getMetadata(metadataKey, instance.constructor, methodName);
  }

  public reflectPassthrough(instance: Controller, methodName: string): boolean {
    return Reflect.getMetadata(
      RESPONSE_PASSTHROUGH_METADATA,
      instance.constructor,
      methodName,
    );
  }

  public getArgumentsLength<T>(keys: string[], metadata: T): number {
    return keys.length
      ? Math.max(...keys.map(key => metadata[key].index)) + 1
      : 0;
  }

  public createNullArray(length: number): any[] {
    const a = new Array(length);
    for (let i = 0; i < length; ++i) a[i] = undefined;
    return a;
  }

  public mergeParamsMetatypes(
    paramsProperties: ParamProperties[],
    paramtypes: any[],
  ): (ParamProperties & { metatype?: any })[] {
    if (!paramtypes) {
      return paramsProperties;
    }
    return paramsProperties.map(param => ({
      ...param,
      metatype: paramtypes[param.index],
    }));
  }

  public getCustomFactory(
    factory: (...args: unknown[]) => void,
    data: unknown,
    contextFactory: (args: unknown[]) => ExecutionContextHost,
  ): (...args: unknown[]) => unknown {
    return isFunction(factory)
      ? (...args: unknown[]) => factory(data, contextFactory(args))
      : () => null;
  }

  public getContextFactory<TContext extends string = ContextType>(
    contextType: TContext,
    instance?: object,
    callback?: Function,
  ): (args: unknown[]) => ExecutionContextHost {
    const type = instance && (instance.constructor as Type<unknown>);
    return (args: unknown[]) => {
      const ctx = new ExecutionContextHost(args, type, callback);
      ctx.setType(contextType);
      return ctx;
    };
  }
}



================================================
FILE: packages/core/helpers/execution-context-host.ts
================================================
import { ExecutionContext } from '@nestjs/common';
import { Type } from '@nestjs/common/interfaces';
import {
  ContextType,
  HttpArgumentsHost,
  RpcArgumentsHost,
  WsArgumentsHost,
} from '@nestjs/common/interfaces/features/arguments-host.interface';

export class ExecutionContextHost implements ExecutionContext {
  private contextType = 'http';

  constructor(
    private readonly args: any[],
    private readonly constructorRef: Type<any> | null = null,
    private readonly handler: Function | null = null,
  ) {}

  setType<TContext extends string = ContextType>(type: TContext) {
    type && (this.contextType = type);
  }

  getType<TContext extends string = ContextType>(): TContext {
    return this.contextType as TContext;
  }

  getClass<T = any>(): Type<T> {
    return this.constructorRef!;
  }

  getHandler(): Function {
    return this.handler!;
  }

  getArgs<T extends Array<any> = any[]>(): T {
    return this.args as T;
  }

  getArgByIndex<T = any>(index: number): T {
    return this.args[index] as T;
  }

  switchToRpc(): RpcArgumentsHost {
    return Object.assign(this, {
      getData: () => this.getArgByIndex(0),
      getContext: () => this.getArgByIndex(1),
    });
  }

  switchToHttp(): HttpArgumentsHost {
    return Object.assign(this, {
      getRequest: () => this.getArgByIndex(0),
      getResponse: () => this.getArgByIndex(1),
      getNext: () => this.getArgByIndex(2),
    });
  }

  switchToWs(): WsArgumentsHost {
    return Object.assign(this, {
      getClient: () => this.getArgByIndex(0),
      getData: () => this.getArgByIndex(1),
      getPattern: () => this.getArgByIndex(this.getArgs().length - 1),
    });
  }
}



================================================
FILE: packages/core/helpers/external-context-creator.ts
================================================
import { ForbiddenException, ParamData } from '@nestjs/common';
import { CUSTOM_ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import {
  ContextType,
  Controller,
  PipeTransform,
} from '@nestjs/common/interfaces';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { isObservable, lastValueFrom } from 'rxjs';
import { ExternalExceptionFilterContext } from '../exceptions/external-exception-filter-context';
import { GuardsConsumer, GuardsContextCreator } from '../guards';
import { FORBIDDEN_MESSAGE } from '../guards/constants';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { ContextId } from '../injector/instance-wrapper';
import { ModulesContainer } from '../injector/modules-container';
import {
  InterceptorsConsumer,
  InterceptorsContextCreator,
} from '../interceptors';
import { PipesConsumer, PipesContextCreator } from '../pipes';
import { ContextUtils, ParamProperties } from './context-utils';
import { ExternalErrorProxy } from './external-proxy';
import { HandlerMetadataStorage } from './handler-metadata-storage';
import { ExternalHandlerMetadata } from './interfaces/external-handler-metadata.interface';
import { ParamsMetadata } from './interfaces/params-metadata.interface';

export interface ParamsFactory {
  exchangeKeyForValue(type: number, data: ParamData, args: any): any;
}

export interface ExternalContextOptions {
  guards?: boolean;
  interceptors?: boolean;
  filters?: boolean;
}

export class ExternalContextCreator {
  private readonly contextUtils = new ContextUtils();
  private readonly externalErrorProxy = new ExternalErrorProxy();
  private readonly handlerMetadataStorage =
    new HandlerMetadataStorage<ExternalHandlerMetadata>();
  private container: NestContainer;

  constructor(
    private readonly guardsContextCreator: GuardsContextCreator,
    private readonly guardsConsumer: GuardsConsumer,
    private readonly interceptorsContextCreator: InterceptorsContextCreator,
    private readonly interceptorsConsumer: InterceptorsConsumer,
    private readonly modulesContainer: ModulesContainer,
    private readonly pipesContextCreator: PipesContextCreator,
    private readonly pipesConsumer: PipesConsumer,
    private readonly filtersContextCreator: ExternalExceptionFilterContext,
  ) {}

  static fromContainer(container: NestContainer): ExternalContextCreator {
    const guardsContextCreator = new GuardsContextCreator(
      container,
      container.applicationConfig,
    );
    const guardsConsumer = new GuardsConsumer();
    const interceptorsContextCreator = new InterceptorsContextCreator(
      container,
      container.applicationConfig,
    );
    const interceptorsConsumer = new InterceptorsConsumer();
    const pipesContextCreator = new PipesContextCreator(
      container,
      container.applicationConfig,
    );
    const pipesConsumer = new PipesConsumer();
    const filtersContextCreator = new ExternalExceptionFilterContext(
      container,
      container.applicationConfig,
    );

    const externalContextCreator = new ExternalContextCreator(
      guardsContextCreator,
      guardsConsumer,
      interceptorsContextCreator,
      interceptorsConsumer,
      container.getModules(),
      pipesContextCreator,
      pipesConsumer,
      filtersContextCreator,
    );
    externalContextCreator.container = container;
    return externalContextCreator;
  }

  public create<
    TParamsMetadata extends ParamsMetadata = ParamsMetadata,
    TContext extends string = ContextType,
  >(
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    methodName: string,
    metadataKey?: string,
    paramsFactory?: ParamsFactory,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
    options: ExternalContextOptions = {
      interceptors: true,
      guards: true,
      filters: true,
    },
    contextType: TContext = 'http' as TContext,
  ) {
    const moduleKey = this.getContextModuleKey(instance.constructor);
    const { argsLength, paramtypes, getParamsMetadata } = this.getMetadata<
      TParamsMetadata,
      TContext
    >(instance, methodName, metadataKey, paramsFactory, contextType);
    const pipes = this.pipesContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const guards = this.guardsContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const exceptionFilter = this.filtersContextCreator.create(
      instance,
      callback as (...args: any[]) => any,
      moduleKey,
      contextId,
      inquirerId,
    );
    const interceptors = options.interceptors
      ? this.interceptorsContextCreator.create(
          instance,
          callback,
          moduleKey,
          contextId,
          inquirerId,
        )
      : [];

    const paramsMetadata = getParamsMetadata(moduleKey, contextId, inquirerId);
    const paramsOptions = paramsMetadata
      ? this.contextUtils.mergeParamsMetatypes(paramsMetadata, paramtypes)
      : [];

    const fnCanActivate = options.guards
      ? this.createGuardsFn(guards, instance, callback, contextType)
      : null;
    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);
    const handler =
      (initialArgs: unknown[], ...args: unknown[]) =>
      async () => {
        if (fnApplyPipes) {
          await fnApplyPipes(initialArgs, ...args);
          return callback.apply(instance, initialArgs);
        }
        return callback.apply(instance, args);
      };

    const target = async (...args: any[]) => {
      const initialArgs = this.contextUtils.createNullArray(argsLength);
      fnCanActivate && (await fnCanActivate(args));

      const result = await this.interceptorsConsumer.intercept(
        interceptors,
        args,
        instance,
        callback,
        handler(initialArgs, ...args),
        contextType,
      );
      return this.transformToResult(result);
    };
    return options.filters
      ? this.externalErrorProxy.createProxy(
          target,
          exceptionFilter,
          contextType,
        )
      : target;
  }

  public getMetadata<TMetadata, TContext extends string = ContextType>(
    instance: Controller,
    methodName: string,
    metadataKey?: string,
    paramsFactory?: ParamsFactory,
    contextType?: TContext,
  ): ExternalHandlerMetadata {
    const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
    if (cacheMetadata) {
      return cacheMetadata;
    }
    const metadata =
      this.contextUtils.reflectCallbackMetadata<TMetadata>(
        instance,
        methodName,
        metadataKey || '',
      ) || {};
    const keys = Object.keys(metadata);
    const argsLength = this.contextUtils.getArgumentsLength(keys, metadata);
    const paramtypes = this.contextUtils.reflectCallbackParamtypes(
      instance,
      methodName,
    );
    const contextFactory = this.contextUtils.getContextFactory<TContext>(
      contextType!,
      instance,
      instance[methodName],
    );
    const getParamsMetadata = (
      moduleKey: string,
      contextId = STATIC_CONTEXT,
      inquirerId?: string,
    ) =>
      paramsFactory
        ? this.exchangeKeysForValues(
            keys,
            metadata,
            moduleKey,
            paramsFactory,
            contextId,
            inquirerId,
            contextFactory,
          )
        : null;

    const handlerMetadata: ExternalHandlerMetadata = {
      argsLength,
      paramtypes,
      getParamsMetadata: getParamsMetadata as any,
    };
    this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
    return handlerMetadata;
  }

  public getContextModuleKey(moduleCtor: Function | undefined): string {
    const emptyModuleKey = '';
    if (!moduleCtor) {
      return emptyModuleKey;
    }
    const moduleContainerEntries = this.modulesContainer.entries();
    for (const [key, moduleRef] of moduleContainerEntries) {
      if (moduleRef.hasProvider(moduleCtor)) {
        return key;
      }
    }
    return emptyModuleKey;
  }

  public exchangeKeysForValues<TMetadata = any>(
    keys: string[],
    metadata: TMetadata,
    moduleContext: string,
    paramsFactory: ParamsFactory,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
    contextFactory = this.contextUtils.getContextFactory('http'),
  ): ParamProperties[] {
    this.pipesContextCreator.setModuleContext(moduleContext);

    return keys.map(key => {
      const { index, data, pipes: pipesCollection } = metadata[key];
      const pipes = this.pipesContextCreator.createConcreteContext(
        pipesCollection,
        contextId,
        inquirerId,
      );
      const type = this.contextUtils.mapParamType(key);

      if (key.includes(CUSTOM_ROUTE_ARGS_METADATA)) {
        const { factory } = metadata[key];
        const customExtractValue = this.contextUtils.getCustomFactory(
          factory,
          data,
          contextFactory,
        );
        return { index, extractValue: customExtractValue, type, data, pipes };
      }
      const numericType = Number(type);
      const extractValue = (...args: unknown[]) =>
        paramsFactory.exchangeKeyForValue(numericType, data, args);

      return { index, extractValue, type: numericType, data, pipes };
    });
  }

  public createPipesFn(
    pipes: PipeTransform[],
    paramsOptions: (ParamProperties & { metatype?: unknown })[],
  ) {
    const pipesFn = async (args: unknown[], ...params: unknown[]) => {
      const resolveParamValue = async (
        param: ParamProperties & { metatype?: unknown },
      ) => {
        const {
          index,
          extractValue,
          type,
          data,
          metatype,
          pipes: paramPipes,
        } = param;
        const value = extractValue(...params);

        args[index] = await this.getParamValue(
          value,
          { metatype, type, data },
          pipes.concat(paramPipes),
        );
      };
      await Promise.all(paramsOptions.map(resolveParamValue));
    };
    return paramsOptions.length ? pipesFn : null;
  }

  public async getParamValue<T>(
    value: T,
    { metatype, type, data }: { metatype: any; type: any; data: any },
    pipes: PipeTransform[],
  ): Promise<any> {
    return isEmpty(pipes)
      ? value
      : this.pipesConsumer.apply(value, { metatype, type, data }, pipes);
  }

  public async transformToResult(resultOrDeferred: any) {
    if (isObservable(resultOrDeferred)) {
      return lastValueFrom(resultOrDeferred);
    }
    return resultOrDeferred;
  }

  public createGuardsFn<TContext extends string = ContextType>(
    guards: any[],
    instance: Controller,
    callback: (...args: any[]) => any,
    contextType?: TContext,
  ): Function | null {
    const canActivateFn = async (args: any[]) => {
      const canActivate = await this.guardsConsumer.tryActivate<TContext>(
        guards,
        args,
        instance,
        callback,
        contextType,
      );
      if (!canActivate) {
        throw new ForbiddenException(FORBIDDEN_MESSAGE);
      }
    };
    return guards.length ? canActivateFn : null;
  }

  public registerRequestProvider<T = any>(request: T, contextId: ContextId) {
    this.container.registerRequestProvider<T>(request, contextId);
  }
}



================================================
FILE: packages/core/helpers/external-proxy.ts
================================================
import { ContextType } from '@nestjs/common/interfaces';
import { ExternalExceptionsHandler } from '../exceptions/external-exceptions-handler';
import { ExecutionContextHost } from '../helpers/execution-context-host';

export class ExternalErrorProxy {
  public createProxy<TContext extends string = ContextType>(
    targetCallback: (...args: any[]) => any,
    exceptionsHandler: ExternalExceptionsHandler,
    type?: TContext,
  ) {
    return async (...args: any[]) => {
      try {
        return await targetCallback(...args);
      } catch (e) {
        const host = new ExecutionContextHost(args);
        host.setType<TContext>(type!);
        return exceptionsHandler.next(e, host);
      }
    };
  }
}



================================================
FILE: packages/core/helpers/get-class-scope.ts
================================================
import { Scope } from '@nestjs/common';
import { SCOPE_OPTIONS_METADATA } from '@nestjs/common/constants';
import { Type } from '@nestjs/common/interfaces/type.interface';

export function getClassScope(provider: Type<unknown>): Scope {
  const metadata = Reflect.getMetadata(SCOPE_OPTIONS_METADATA, provider);
  return metadata && metadata.scope;
}



================================================
FILE: packages/core/helpers/handler-metadata-storage.ts
================================================
import { Controller, Type } from '@nestjs/common/interfaces';
import { IncomingMessage } from 'http';
import { Observable } from 'rxjs';
import { CONTROLLER_ID_KEY } from '../injector/constants';
import { ContextId } from '../injector/instance-wrapper';
import { HeaderStream } from '../router/sse-stream';
import { ParamProperties } from './context-utils';

export const HANDLER_METADATA_SYMBOL = Symbol.for('handler_metadata:cache');

export type HandleResponseFn = HandlerResponseBasicFn | HandleSseResponseFn;

export type HandlerResponseBasicFn = <TResult, TResponse>(
  result: TResult,
  res: TResponse,
  req?: any,
) => any;

export type HandleSseResponseFn = <
  TResult extends Observable<unknown> = any,
  TResponse extends HeaderStream = any,
  TRequest extends IncomingMessage = any,
>(
  result: TResult,
  res: TResponse,
  req: TRequest,
) => any;

export interface HandlerMetadata {
  argsLength: number;
  paramtypes: any[];
  httpStatusCode: number;
  responseHeaders: any[];
  hasCustomHeaders: boolean;
  getParamsMetadata: (
    moduleKey: string,
    contextId?: ContextId,
    inquirerId?: string,
  ) => (ParamProperties & { metatype?: any })[];
  fnHandleResponse: HandleResponseFn;
}

export class HandlerMetadataStorage<
  TValue = HandlerMetadata,
  TKey extends Type<unknown> = any,
> {
  private readonly [HANDLER_METADATA_SYMBOL] = new Map<string, TValue>();

  set(controller: TKey, methodName: string, metadata: TValue) {
    const metadataKey = this.getMetadataKey(controller, methodName);
    this[HANDLER_METADATA_SYMBOL].set(metadataKey, metadata);
  }

  get(controller: TKey, methodName: string): TValue | undefined {
    const metadataKey = this.getMetadataKey(controller, methodName);
    return this[HANDLER_METADATA_SYMBOL].get(metadataKey);
  }

  private getMetadataKey(controller: Controller, methodName: string): string {
    const ctor = controller.constructor;
    const controllerKey = ctor && (ctor[CONTROLLER_ID_KEY] || ctor.name);
    return controllerKey + methodName;
  }
}



================================================
FILE: packages/core/helpers/http-adapter-host.ts
================================================
import { Observable, Subject } from 'rxjs';
import { AbstractHttpAdapter } from '../adapters/http-adapter';

/**
 * Defines the `HttpAdapterHost` object.
 *
 * `HttpAdapterHost` wraps the underlying
 * platform-specific `HttpAdapter`.  The `HttpAdapter` is a wrapper around the underlying
 * native HTTP server library (e.g., Express).  The `HttpAdapterHost` object
 * provides methods to `get` and `set` the underlying HttpAdapter.
 *
 * @see [Http adapter](https://docs.nestjs.com/faq/http-adapter)
 *
 * @publicApi
 */
export class HttpAdapterHost<
  T extends AbstractHttpAdapter = AbstractHttpAdapter,
> {
  private _httpAdapter?: T;
  private _listen$ = new Subject<void>();
  private isListening = false;

  /**
   * Accessor for the underlying `HttpAdapter`
   *
   * @param httpAdapter reference to the `HttpAdapter` to be set
   */
  set httpAdapter(httpAdapter: T) {
    this._httpAdapter = httpAdapter;
  }

  /**
   * Accessor for the underlying `HttpAdapter`
   *
   * @example
   * `const httpAdapter = adapterHost.httpAdapter;`
   */
  get httpAdapter(): T {
    return this._httpAdapter as T;
  }

  /**
   * Observable that allows to subscribe to the `listen` event.
   * This event is emitted when the HTTP application is listening for incoming requests.
   */
  get listen$(): Observable<void> {
    return this._listen$.asObservable();
  }

  /**
   * Sets the listening state of the application.
   */
  set listening(listening: boolean) {
    this.isListening = listening;

    if (listening) {
      this._listen$.next();
      this._listen$.complete();
    }
  }

  /**
   * Returns a boolean indicating whether the application is listening for incoming requests.
   */
  get listening(): boolean {
    return this.isListening;
  }
}



================================================
FILE: packages/core/helpers/index.ts
================================================
export * from './context-id-factory';
export * from './external-context-creator';
export * from './http-adapter-host';



================================================
FILE: packages/core/helpers/is-durable.ts
================================================
import { SCOPE_OPTIONS_METADATA } from '@nestjs/common/constants';
import { Type } from '@nestjs/common/interfaces/type.interface';

export function isDurable(provider: Type<unknown>): boolean | undefined {
  const metadata = Reflect.getMetadata(SCOPE_OPTIONS_METADATA, provider);
  return metadata && metadata.durable;
}



================================================
FILE: packages/core/helpers/load-adapter.ts
================================================
import { Logger } from '@nestjs/common';

const MISSING_REQUIRED_DEPENDENCY = (
  defaultPlatform: string,
  transport: string,
) =>
  `No driver (${transport}) has been selected. In order to take advantage of the default driver, please, ensure to install the "${defaultPlatform}" package ($ npm install ${defaultPlatform}).`;

const logger = new Logger('PackageLoader');

export function loadAdapter(
  defaultPlatform: string,
  transport: string,
  loaderFn?: Function,
) {
  try {
    return loaderFn ? loaderFn() : require(defaultPlatform);
  } catch (e) {
    logger.error(MISSING_REQUIRED_DEPENDENCY(defaultPlatform, transport));
    process.exit(1);
  }
}



================================================
FILE: packages/core/helpers/messages.ts
================================================
import { RequestMethod } from '@nestjs/common/enums/request-method.enum';
import {
  VersionValue,
  VERSION_NEUTRAL,
} from '@nestjs/common/interfaces/version-options.interface';

export const MODULE_INIT_MESSAGE = (
  text: TemplateStringsArray,
  module: string,
) => `${module} dependencies initialized`;

export const ROUTE_MAPPED_MESSAGE = (path: string, method: string | number) =>
  `Mapped {${path}, ${RequestMethod[method]}} route`;

export const VERSIONED_ROUTE_MAPPED_MESSAGE = (
  path: string,
  method: string | number,
  version: VersionValue,
) => {
  const controllerVersions = Array.isArray(version) ? version : [version];
  const versions = controllerVersions
    .map(version => (version === VERSION_NEUTRAL ? 'Neutral' : version))
    .join(',');

  return `Mapped {${path}, ${RequestMethod[method]}} (version: ${versions}) route`;
};

export const CONTROLLER_MAPPING_MESSAGE = (name: string, path: string) =>
  `${name} {${path}}:`;

export const VERSIONED_CONTROLLER_MAPPING_MESSAGE = (
  name: string,
  path: string,
  version: VersionValue,
) => {
  const controllerVersions = Array.isArray(version) ? version : [version];
  const versions = controllerVersions
    .map(version => (version === VERSION_NEUTRAL ? 'Neutral' : version))
    .join(',');

  return `${name} {${path}} (version: ${versions}):`;
};

export const INVALID_EXECUTION_CONTEXT = (
  methodName: string,
  currentContext: string,
) =>
  `Calling ${methodName} is not allowed in this context. Your current execution context is "${currentContext}".`;



================================================
FILE: packages/core/helpers/optional-require.ts
================================================
export function optionalRequire(packageName: string, loaderFn?: Function) {
  try {
    return loaderFn ? loaderFn() : require(packageName);
  } catch (e) {
    return {};
  }
}



================================================
FILE: packages/core/helpers/rethrow.ts
================================================
export const rethrow = (err: unknown) => {
  throw err;
};



================================================
FILE: packages/core/helpers/router-method-factory.ts
================================================
import { HttpServer } from '@nestjs/common';
import { RequestMethod } from '@nestjs/common/enums/request-method.enum';

export const REQUEST_METHOD_MAP = {
  [RequestMethod.GET]: 'get',
  [RequestMethod.POST]: 'post',
  [RequestMethod.PUT]: 'put',
  [RequestMethod.DELETE]: 'delete',
  [RequestMethod.PATCH]: 'patch',
  [RequestMethod.ALL]: 'all',
  [RequestMethod.OPTIONS]: 'options',
  [RequestMethod.HEAD]: 'head',
  [RequestMethod.SEARCH]: 'search',
  [RequestMethod.PROPFIND]: 'propfind',
  [RequestMethod.PROPPATCH]: 'proppatch',
  [RequestMethod.MKCOL]: 'mkcol',
  [RequestMethod.COPY]: 'copy',
  [RequestMethod.MOVE]: 'move',
  [RequestMethod.LOCK]: 'lock',
  [RequestMethod.UNLOCK]: 'unlock',
} as const satisfies Record<RequestMethod, keyof HttpServer>;

export class RouterMethodFactory {
  public get(target: HttpServer, requestMethod: RequestMethod): Function {
    const methodName = REQUEST_METHOD_MAP[requestMethod];
    const method = target[methodName];
    if (!method) {
      return target.use;
    }
    return method;
  }
}



================================================
FILE: packages/core/helpers/interfaces/external-handler-metadata.interface.ts
================================================
import { ContextId } from '../../injector';
import { ParamProperties } from '../context-utils';

type ParamPropertiesWithMetatype<T = any> = ParamProperties & { metatype?: T };
export interface ExternalHandlerMetadata {
  argsLength: number;
  paramtypes: any[];
  getParamsMetadata: (
    moduleKey: string,
    contextId?: ContextId,
    inquirerId?: string,
  ) => ParamPropertiesWithMetatype[];
}



================================================
FILE: packages/core/helpers/interfaces/index.ts
================================================
export * from './external-handler-metadata.interface';
export * from './params-metadata.interface';



================================================
FILE: packages/core/helpers/interfaces/params-metadata.interface.ts
================================================
import { ParamData } from '@nestjs/common';

export type ParamsMetadata = Record<number, ParamMetadata>;
export interface ParamMetadata {
  index: number;
  data?: ParamData;
}



================================================
FILE: packages/core/hooks/before-app-shutdown.hook.ts
================================================
import { BeforeApplicationShutdown } from '@nestjs/common';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import {
  getNonTransientInstances,
  getTransientInstances,
} from '../injector/helpers/transient-instances';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';

/**
 * Checks if the given instance has the `beforeApplicationShutdown` function
 *
 * @param instance The instance which should be checked
 */
function hasBeforeApplicationShutdownHook(
  instance: unknown,
): instance is BeforeApplicationShutdown {
  return isFunction(
    (instance as BeforeApplicationShutdown).beforeApplicationShutdown,
  );
}

/**
 * Calls the given instances
 */
function callOperator(
  instances: InstanceWrapper[],
  signal?: string,
): Promise<any>[] {
  return iterate(instances)
    .filter(instance => !isNil(instance))
    .filter(hasBeforeApplicationShutdownHook)
    .map(async instance =>
      (instance as any as BeforeApplicationShutdown).beforeApplicationShutdown(
        signal,
      ),
    )
    .toArray();
}

/**
 * Calls the `beforeApplicationShutdown` function on the module and its children
 * (providers / controllers).
 *
 * @param module The module which will be initialized
 * @param signal The signal which caused the shutdown
 */
export async function callBeforeAppShutdownHook(
  module: Module,
  signal?: string,
): Promise<void> {
  const providers = module.getNonAliasProviders();
  const [_, moduleClassHost] = providers.shift()!;
  const instances = [
    ...module.controllers,
    ...providers,
    ...module.injectables,
    ...module.middlewares,
  ];

  const nonTransientInstances = getNonTransientInstances(instances);
  await Promise.all(callOperator(nonTransientInstances, signal));
  const transientInstances = getTransientInstances(instances);
  await Promise.all(callOperator(transientInstances, signal));

  const moduleClassInstance = moduleClassHost.instance;
  if (
    moduleClassInstance &&
    hasBeforeApplicationShutdownHook(moduleClassInstance) &&
    moduleClassHost.isDependencyTreeStatic()
  ) {
    await moduleClassInstance.beforeApplicationShutdown(signal);
  }
}



================================================
FILE: packages/core/hooks/index.ts
================================================
export * from './on-app-bootstrap.hook';
export * from './on-app-shutdown.hook';
export * from './on-module-destroy.hook';
export * from './on-module-init.hook';
export * from './before-app-shutdown.hook';



================================================
FILE: packages/core/hooks/on-app-bootstrap.hook.ts
================================================
import { OnApplicationBootstrap } from '@nestjs/common';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import {
  getNonTransientInstances,
  getTransientInstances,
} from '../injector/helpers/transient-instances';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';

/**
 * Checks if the given instance has the `onApplicationBootstrap` function
 *
 * @param instance The instance which should be checked
 */
function hasOnAppBootstrapHook(
  instance: unknown,
): instance is OnApplicationBootstrap {
  return isFunction(
    (instance as OnApplicationBootstrap).onApplicationBootstrap,
  );
}

/**
 * Calls the given instances
 */
function callOperator(instances: InstanceWrapper[]): Promise<any>[] {
  return iterate(instances)
    .filter(instance => !isNil(instance))
    .filter(hasOnAppBootstrapHook)
    .map(async instance =>
      (instance as any as OnApplicationBootstrap).onApplicationBootstrap(),
    )
    .toArray();
}

/**
 * Calls the `onApplicationBootstrap` function on the module and its children
 * (providers / controllers).
 *
 * @param module The module which will be initialized
 */
export async function callModuleBootstrapHook(module: Module): Promise<any> {
  const providers = module.getNonAliasProviders();
  // Module (class) instance is the first element of the providers array
  // Lifecycle hook has to be called once all classes are properly initialized
  const [_, moduleClassHost] = providers.shift()!;
  const instances = [
    ...module.controllers,
    ...providers,
    ...module.injectables,
    ...module.middlewares,
  ];

  const nonTransientInstances = getNonTransientInstances(instances);
  await Promise.all(callOperator(nonTransientInstances));
  const transientInstances = getTransientInstances(instances);
  await Promise.all(callOperator(transientInstances));

  // Call the instance itself
  const moduleClassInstance = moduleClassHost.instance;
  if (
    moduleClassInstance &&
    hasOnAppBootstrapHook(moduleClassInstance) &&
    moduleClassHost.isDependencyTreeStatic()
  ) {
    await moduleClassInstance.onApplicationBootstrap();
  }
}



================================================
FILE: packages/core/hooks/on-app-shutdown.hook.ts
================================================
import { OnApplicationShutdown } from '@nestjs/common';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import {
  getNonTransientInstances,
  getTransientInstances,
} from '../injector/helpers/transient-instances';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';

/**
 * Checks if the given instance has the `onApplicationShutdown` function
 *
 * @param instance The instance which should be checked
 */
function hasOnAppShutdownHook(
  instance: unknown,
): instance is OnApplicationShutdown {
  return isFunction((instance as OnApplicationShutdown).onApplicationShutdown);
}

/**
 * Calls the given instances
 */
function callOperator(
  instances: InstanceWrapper[],
  signal?: string,
): Promise<any>[] {
  return iterate(instances)
    .filter(instance => !isNil(instance))
    .filter(hasOnAppShutdownHook)
    .map(async instance =>
      (instance as any as OnApplicationShutdown).onApplicationShutdown(signal),
    )
    .toArray();
}

/**
 * Calls the `onApplicationShutdown` function on the module and its children
 * (providers / controllers).
 *
 * @param module The module which will be initialized
 * @param signal
 */
export async function callAppShutdownHook(
  module: Module,
  signal?: string,
): Promise<any> {
  const providers = module.getNonAliasProviders();
  // Module (class) instance is the first element of the providers array
  // Lifecycle hook has to be called once all classes are properly initialized
  const [_, moduleClassHost] = providers.shift()!;
  const instances = [
    ...module.controllers,
    ...providers,
    ...module.injectables,
    ...module.middlewares,
  ];

  const nonTransientInstances = getNonTransientInstances(instances);
  await Promise.all(callOperator(nonTransientInstances, signal));
  const transientInstances = getTransientInstances(instances);
  await Promise.all(callOperator(transientInstances, signal));

  // Call the instance itself
  const moduleClassInstance = moduleClassHost.instance;
  if (
    moduleClassInstance &&
    hasOnAppShutdownHook(moduleClassInstance) &&
    moduleClassHost.isDependencyTreeStatic()
  ) {
    await moduleClassInstance.onApplicationShutdown(signal);
  }
}



================================================
FILE: packages/core/hooks/on-module-destroy.hook.ts
================================================
import { OnModuleDestroy } from '@nestjs/common';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import {
  getNonTransientInstances,
  getTransientInstances,
} from '../injector/helpers/transient-instances';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';

/**
 * Returns true or false if the given instance has a `onModuleDestroy` function
 *
 * @param instance The instance which should be checked
 */
function hasOnModuleDestroyHook(
  instance: unknown,
): instance is OnModuleDestroy {
  return isFunction((instance as OnModuleDestroy).onModuleDestroy);
}

/**
 * Calls the given instances onModuleDestroy hook
 */
function callOperator(instances: InstanceWrapper[]): Promise<any>[] {
  return iterate(instances)
    .filter(instance => !isNil(instance))
    .filter(hasOnModuleDestroyHook)
    .map(async instance =>
      (instance as any as OnModuleDestroy).onModuleDestroy(),
    )
    .toArray();
}

/**
 * Calls the `onModuleDestroy` function on the module and its children
 * (providers / controllers).
 *
 * @param module The module which will be initialized
 */
export async function callModuleDestroyHook(module: Module): Promise<any> {
  const providers = module.getNonAliasProviders();
  // Module (class) instance is the first element of the providers array
  // Lifecycle hook has to be called once all classes are properly destroyed
  const [_, moduleClassHost] = providers.shift()!;
  const instances = [
    ...module.controllers,
    ...providers,
    ...module.injectables,
    ...module.middlewares,
  ];

  const nonTransientInstances = getNonTransientInstances(instances);
  await Promise.all(callOperator(nonTransientInstances));

  const transientInstances = getTransientInstances(instances);
  await Promise.all(callOperator(transientInstances));

  // Call the module instance itself
  const moduleClassInstance = moduleClassHost.instance;
  if (
    moduleClassInstance &&
    hasOnModuleDestroyHook(moduleClassInstance) &&
    moduleClassHost.isDependencyTreeStatic()
  ) {
    await moduleClassInstance.onModuleDestroy();
  }
}



================================================
FILE: packages/core/hooks/on-module-init.hook.ts
================================================
import { OnModuleInit } from '@nestjs/common';
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import {
  getNonTransientInstances,
  getTransientInstances,
} from '../injector/helpers/transient-instances';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';

/**
 * Returns true or false if the given instance has a `onModuleInit` function
 *
 * @param instance The instance which should be checked
 */
function hasOnModuleInitHook(instance: unknown): instance is OnModuleInit {
  return isFunction((instance as OnModuleInit).onModuleInit);
}

/**
 * Calls the given instances
 */
function callOperator(instances: InstanceWrapper[]): Promise<any>[] {
  return iterate(instances)
    .filter(instance => !isNil(instance))
    .filter(hasOnModuleInitHook)
    .map(async instance => (instance as any as OnModuleInit).onModuleInit())
    .toArray();
}

/**
 * Calls the `onModuleInit` function on the module and its children
 * (providers / controllers).
 *
 * @param module The module which will be initialized
 */
export async function callModuleInitHook(module: Module): Promise<void> {
  const providers = module.getNonAliasProviders();
  // Module (class) instance is the first element of the providers array
  // Lifecycle hook has to be called once all classes are properly initialized
  const [_, moduleClassHost] = providers.shift()!;
  const instances = [
    ...module.controllers,
    ...providers,
    ...module.injectables,
    ...module.middlewares,
  ];

  const nonTransientInstances = getNonTransientInstances(instances);
  await Promise.all(callOperator(nonTransientInstances));

  const transientInstances = getTransientInstances(instances);
  await Promise.all(callOperator(transientInstances));

  // Call the instance itself
  const moduleClassInstance = moduleClassHost.instance;
  if (
    moduleClassInstance &&
    hasOnModuleInitHook(moduleClassInstance) &&
    moduleClassHost.isDependencyTreeStatic()
  ) {
    await moduleClassInstance.onModuleInit();
  }
}



================================================
FILE: packages/core/injector/abstract-instance-resolver.ts
================================================
import { Abstract, Scope, Type } from '@nestjs/common';
import { GetOrResolveOptions } from '@nestjs/common/interfaces';
import {
  InvalidClassScopeException,
  UnknownElementException,
} from '../errors/exceptions';
import { Injector } from './injector';
import { InstanceLink, InstanceLinksHost } from './instance-links-host';
import { ContextId } from './instance-wrapper';
import { Module } from './module';

export abstract class AbstractInstanceResolver {
  protected abstract instanceLinksHost: InstanceLinksHost;
  protected abstract injector: Injector;

  protected abstract get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options?: GetOrResolveOptions,
  ): TResult | Array<TResult>;

  protected find<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,
    options: { moduleId?: string; each?: boolean },
  ): TResult | Array<TResult> {
    const instanceLinkOrArray = this.instanceLinksHost.get<TResult>(
      typeOrToken,
      options,
    );
    const pluckInstance = ({ wrapperRef }: InstanceLink) => {
      if (
        wrapperRef.scope === Scope.REQUEST ||
        wrapperRef.scope === Scope.TRANSIENT
      ) {
        throw new InvalidClassScopeException(typeOrToken);
      }
      return wrapperRef.instance;
    };
    if (Array.isArray(instanceLinkOrArray)) {
      return instanceLinkOrArray.map(pluckInstance);
    }
    return pluckInstance(instanceLinkOrArray);
  }

  protected async resolvePerContext<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Abstract<TInput> | string | symbol,
    contextModule: Module,
    contextId: ContextId,
    options?: GetOrResolveOptions,
  ): Promise<TResult | Array<TResult>> {
    const instanceLinkOrArray = options?.strict
      ? this.instanceLinksHost.get(typeOrToken, {
          moduleId: contextModule.id,
          each: options.each,
        })
      : this.instanceLinksHost.get(typeOrToken, {
          each: options?.each,
        });

    const pluckInstance = async (instanceLink: InstanceLink) => {
      const { wrapperRef, collection } = instanceLink;
      if (wrapperRef.isDependencyTreeStatic() && !wrapperRef.isTransient) {
        return this.get(typeOrToken, { strict: options?.strict });
      }

      const ctorHost = wrapperRef.instance || { constructor: typeOrToken };
      const instance = await this.injector.loadPerContext(
        ctorHost,
        wrapperRef.host!,
        collection,
        contextId,
        wrapperRef,
      );
      if (!instance) {
        throw new UnknownElementException();
      }
      return instance;
    };

    if (Array.isArray(instanceLinkOrArray)) {
      return Promise.all(
        instanceLinkOrArray.map(instanceLink => pluckInstance(instanceLink)),
      );
    }
    return pluckInstance(instanceLinkOrArray);
  }
}



================================================
FILE: packages/core/injector/compiler.ts
================================================
import {
  DynamicModule,
  ForwardReference,
  Type,
} from '@nestjs/common/interfaces';
import { ModuleOpaqueKeyFactory } from './opaque-key-factory/interfaces/module-opaque-key-factory.interface';

export interface ModuleFactory {
  type: Type<any>;
  token: string;
  dynamicMetadata?: Partial<DynamicModule>;
}

export class ModuleCompiler {
  constructor(
    private readonly _moduleOpaqueKeyFactory: ModuleOpaqueKeyFactory,
  ) {}

  get moduleOpaqueKeyFactory(): ModuleOpaqueKeyFactory {
    return this._moduleOpaqueKeyFactory;
  }

  public async compile(
    moduleClsOrDynamic:
      | Type
      | DynamicModule
      | ForwardReference
      | Promise<DynamicModule>,
  ): Promise<ModuleFactory> {
    moduleClsOrDynamic = await moduleClsOrDynamic;

    const { type, dynamicMetadata } = this.extractMetadata(moduleClsOrDynamic);
    const token = dynamicMetadata
      ? this._moduleOpaqueKeyFactory.createForDynamic(
          type,
          dynamicMetadata,
          moduleClsOrDynamic as DynamicModule | ForwardReference,
        )
      : this._moduleOpaqueKeyFactory.createForStatic(
          type,
          moduleClsOrDynamic as Type,
        );

    return { type, dynamicMetadata, token };
  }

  public extractMetadata(
    moduleClsOrDynamic: Type | ForwardReference | DynamicModule,
  ): {
    type: Type;
    dynamicMetadata: Omit<DynamicModule, 'module'> | undefined;
  } {
    if (!this.isDynamicModule(moduleClsOrDynamic)) {
      return {
        type: (moduleClsOrDynamic as ForwardReference)?.forwardRef
          ? (moduleClsOrDynamic as ForwardReference).forwardRef()
          : moduleClsOrDynamic,
        dynamicMetadata: undefined,
      };
    }
    const { module: type, ...dynamicMetadata } = moduleClsOrDynamic;
    return { type, dynamicMetadata };
  }

  public isDynamicModule(
    moduleClsOrDynamic: Type | DynamicModule | ForwardReference,
  ): moduleClsOrDynamic is DynamicModule {
    return !!(moduleClsOrDynamic as DynamicModule).module;
  }
}



================================================
FILE: packages/core/injector/constants.ts
================================================
import { ContextId } from './instance-wrapper';

export const CONTROLLER_ID_KEY = 'CONTROLLER_ID';

const STATIC_CONTEXT_ID = 1;
export const STATIC_CONTEXT: ContextId = Object.freeze({
  id: STATIC_CONTEXT_ID,
});



================================================
FILE: packages/core/injector/container.ts
================================================
import { DynamicModule, Provider } from '@nestjs/common';
import {
  EnhancerSubtype,
  GLOBAL_MODULE_METADATA,
} from '@nestjs/common/constants';
import { Injectable, Type } from '@nestjs/common/interfaces';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { ApplicationConfig } from '../application-config';
import { DiscoverableMetaHostCollection } from '../discovery/discoverable-meta-host-collection';
import {
  CircularDependencyException,
  UndefinedForwardRefException,
  UnknownModuleException,
} from '../errors/exceptions';
import { InitializeOnPreviewAllowlist } from '../inspector/initialize-on-preview.allowlist';
import { SerializedGraph } from '../inspector/serialized-graph';
import { REQUEST } from '../router/request/request-constants';
import { ModuleCompiler, ModuleFactory } from './compiler';
import { ContextId } from './instance-wrapper';
import { InternalCoreModule } from './internal-core-module/internal-core-module';
import { InternalProvidersStorage } from './internal-providers-storage';
import { Module } from './module';
import { ModulesContainer } from './modules-container';
import { ByReferenceModuleOpaqueKeyFactory } from './opaque-key-factory/by-reference-module-opaque-key-factory';
import { DeepHashedModuleOpaqueKeyFactory } from './opaque-key-factory/deep-hashed-module-opaque-key-factory';
import { ModuleOpaqueKeyFactory } from './opaque-key-factory/interfaces/module-opaque-key-factory.interface';

type ModuleMetatype = Type<any> | DynamicModule | Promise<DynamicModule>;
type ModuleScope = Type<any>[];

export class NestContainer {
  private readonly globalModules = new Set<Module>();
  private readonly modules = new ModulesContainer();
  private readonly dynamicModulesMetadata = new Map<
    string,
    Partial<DynamicModule>
  >();
  private readonly internalProvidersStorage = new InternalProvidersStorage();
  private readonly _serializedGraph = new SerializedGraph();
  private moduleCompiler: ModuleCompiler;
  private internalCoreModule: Module;

  constructor(
    private readonly _applicationConfig:
      | ApplicationConfig
      | undefined = undefined,
    private readonly _contextOptions:
      | NestApplicationContextOptions
      | undefined = undefined,
  ) {
    const moduleOpaqueKeyFactory =
      this._contextOptions?.moduleIdGeneratorAlgorithm === 'deep-hash'
        ? new DeepHashedModuleOpaqueKeyFactory()
        : new ByReferenceModuleOpaqueKeyFactory({
            keyGenerationStrategy: this._contextOptions?.snapshot
              ? 'shallow'
              : 'random',
          });
    this.moduleCompiler = new ModuleCompiler(moduleOpaqueKeyFactory);
  }

  get serializedGraph(): SerializedGraph {
    return this._serializedGraph;
  }

  get applicationConfig(): ApplicationConfig | undefined {
    return this._applicationConfig;
  }

  public setHttpAdapter(httpAdapter: any) {
    this.internalProvidersStorage.httpAdapter = httpAdapter;

    if (!this.internalProvidersStorage.httpAdapterHost) {
      return;
    }
    const host = this.internalProvidersStorage.httpAdapterHost;
    host.httpAdapter = httpAdapter;
  }

  public getHttpAdapterRef() {
    return this.internalProvidersStorage.httpAdapter;
  }

  public getHttpAdapterHostRef() {
    return this.internalProvidersStorage.httpAdapterHost;
  }

  public async addModule(
    metatype: ModuleMetatype,
    scope: ModuleScope,
  ): Promise<
    | {
        moduleRef: Module;
        inserted: boolean;
      }
    | undefined
  > {
    // In DependenciesScanner#scanForModules we already check for undefined or invalid modules
    // We still need to catch the edge-case of `forwardRef(() => undefined)`
    if (!metatype) {
      throw new UndefinedForwardRefException(scope);
    }
    const { type, dynamicMetadata, token } =
      await this.moduleCompiler.compile(metatype);
    if (this.modules.has(token)) {
      return {
        moduleRef: this.modules.get(token)!,
        inserted: true,
      };
    }

    return {
      moduleRef: await this.setModule(
        {
          token,
          type,
          dynamicMetadata,
        },
        scope,
      ),
      inserted: true,
    };
  }

  public async replaceModule(
    metatypeToReplace: ModuleMetatype,
    newMetatype: ModuleMetatype,
    scope: ModuleScope,
  ): Promise<
    | {
        moduleRef: Module;
        inserted: boolean;
      }
    | undefined
  > {
    // In DependenciesScanner#scanForModules we already check for undefined or invalid modules
    // We still need to catch the edge-case of `forwardRef(() => undefined)`
    if (!metatypeToReplace || !newMetatype) {
      throw new UndefinedForwardRefException(scope);
    }

    const { token } = await this.moduleCompiler.compile(metatypeToReplace);
    const { type, dynamicMetadata } =
      await this.moduleCompiler.compile(newMetatype);

    return {
      moduleRef: await this.setModule(
        {
          token,
          type,
          dynamicMetadata,
        },
        scope,
      ),
      inserted: false,
    };
  }

  private async setModule(
    { token, dynamicMetadata, type }: ModuleFactory,
    scope: ModuleScope,
  ): Promise<Module> {
    const moduleRef = new Module(type, this);
    moduleRef.token = token;
    moduleRef.initOnPreview = this.shouldInitOnPreview(type);
    this.modules.set(token, moduleRef);

    const updatedScope = ([] as ModuleScope).concat(scope, type);
    await this.addDynamicMetadata(token, dynamicMetadata!, updatedScope);

    if (this.isGlobalModule(type, dynamicMetadata)) {
      moduleRef.isGlobal = true;

      // Set global module distance to MAX_VALUE to ensure their lifecycle hooks
      // are always executed first (when initializing the application)
      moduleRef.distance = Number.MAX_VALUE;
      this.addGlobalModule(moduleRef);
    }

    return moduleRef;
  }

  public async addDynamicMetadata(
    token: string,
    dynamicModuleMetadata: Partial<DynamicModule>,
    scope: Type<any>[],
  ) {
    if (!dynamicModuleMetadata) {
      return;
    }
    this.dynamicModulesMetadata.set(token, dynamicModuleMetadata);

    const { imports } = dynamicModuleMetadata;
    await this.addDynamicModules(imports!, scope);
  }

  public async addDynamicModules(modules: any[], scope: Type<any>[]) {
    if (!modules) {
      return;
    }
    await Promise.all(modules.map(module => this.addModule(module, scope)));
  }

  public isGlobalModule(
    metatype: Type<any>,
    dynamicMetadata?: Partial<DynamicModule>,
  ): boolean {
    if (dynamicMetadata && dynamicMetadata.global) {
      return true;
    }
    return !!Reflect.getMetadata(GLOBAL_MODULE_METADATA, metatype);
  }

  public addGlobalModule(module: Module) {
    this.globalModules.add(module);
  }

  public getModules(): ModulesContainer {
    return this.modules;
  }

  public getModuleCompiler(): ModuleCompiler {
    return this.moduleCompiler;
  }

  public getModuleByKey(moduleKey: string): Module | undefined {
    return this.modules.get(moduleKey);
  }

  public getInternalCoreModuleRef(): Module | undefined {
    return this.internalCoreModule;
  }

  public async addImport(
    relatedModule: Type<any> | DynamicModule,
    token: string,
  ) {
    if (!this.modules.has(token)) {
      return;
    }
    const moduleRef = this.modules.get(token)!;
    const { token: relatedModuleToken } =
      await this.moduleCompiler.compile(relatedModule);
    const related = this.modules.get(relatedModuleToken)!;
    moduleRef.addImport(related);
  }

  public addProvider(
    provider: Provider,
    token: string,
    enhancerSubtype?: EnhancerSubtype,
  ): string | symbol | Function {
    const moduleRef = this.modules.get(token);
    if (!provider) {
      throw new CircularDependencyException(moduleRef?.metatype.name);
    }
    if (!moduleRef) {
      throw new UnknownModuleException();
    }
    const providerKey = moduleRef.addProvider(provider, enhancerSubtype!);
    const providerRef = moduleRef.getProviderByKey(providerKey);

    DiscoverableMetaHostCollection.inspectProvider(this.modules, providerRef);

    return providerKey as Function;
  }

  public addInjectable(
    injectable: Provider,
    token: string,
    enhancerSubtype: EnhancerSubtype,
    host?: Type<Injectable>,
  ) {
    if (!this.modules.has(token)) {
      throw new UnknownModuleException();
    }
    const moduleRef = this.modules.get(token)!;
    return moduleRef.addInjectable(injectable, enhancerSubtype, host);
  }

  public addExportedProviderOrModule(
    toExport: Type<any> | DynamicModule,
    token: string,
  ) {
    if (!this.modules.has(token)) {
      throw new UnknownModuleException();
    }
    const moduleRef = this.modules.get(token)!;
    moduleRef.addExportedProviderOrModule(toExport);
  }

  public addController(controller: Type<any>, token: string) {
    if (!this.modules.has(token)) {
      throw new UnknownModuleException();
    }
    const moduleRef = this.modules.get(token)!;
    moduleRef.addController(controller);

    const controllerRef = moduleRef.controllers.get(controller)!;
    DiscoverableMetaHostCollection.inspectController(
      this.modules,
      controllerRef,
    );
  }

  public clear() {
    this.modules.clear();
  }

  public replace(toReplace: any, options: { scope: any[] | null }) {
    this.modules.forEach(moduleRef => moduleRef.replace(toReplace, options));
  }

  public bindGlobalScope() {
    this.modules.forEach(moduleRef => this.bindGlobalsToImports(moduleRef));
  }

  public bindGlobalsToImports(moduleRef: Module) {
    this.globalModules.forEach(globalModule =>
      this.bindGlobalModuleToModule(moduleRef, globalModule),
    );
  }

  public bindGlobalModuleToModule(target: Module, globalModule: Module) {
    if (target === globalModule || target === this.internalCoreModule) {
      return;
    }
    target.addImport(globalModule);
  }

  public getDynamicMetadataByToken(token: string): Partial<DynamicModule>;
  public getDynamicMetadataByToken<
    K extends Exclude<keyof DynamicModule, 'global' | 'module'>,
  >(token: string, metadataKey: K): DynamicModule[K];
  public getDynamicMetadataByToken(
    token: string,
    metadataKey?: Exclude<keyof DynamicModule, 'global' | 'module'>,
  ) {
    const metadata = this.dynamicModulesMetadata.get(token);
    return metadataKey ? (metadata?.[metadataKey] ?? []) : metadata;
  }

  public registerCoreModuleRef(moduleRef: Module) {
    this.internalCoreModule = moduleRef;
    this.modules[InternalCoreModule.name] = moduleRef;
  }

  public getModuleTokenFactory(): ModuleOpaqueKeyFactory {
    return this.moduleCompiler.moduleOpaqueKeyFactory;
  }

  public registerRequestProvider<T = any>(request: T, contextId: ContextId) {
    const wrapper = this.internalCoreModule.getProviderByKey(REQUEST);
    wrapper.setInstanceByContextId(contextId, {
      instance: request,
      isResolved: true,
    });
  }

  private shouldInitOnPreview(type: Type) {
    return InitializeOnPreviewAllowlist.has(type);
  }
}



================================================
FILE: packages/core/injector/index.ts
================================================
export * from './container';
export * from './inquirer';
export { ContextId, HostComponentInfo } from './instance-wrapper';
export * from './lazy-module-loader/lazy-module-loader';
export * from './module-ref';
export * from './modules-container';



================================================
FILE: packages/core/injector/injector.ts
================================================
import {
  InjectionToken,
  Logger,
  LoggerService,
  OptionalFactoryDependency,
} from '@nestjs/common';
import {
  OPTIONAL_DEPS_METADATA,
  OPTIONAL_PROPERTY_DEPS_METADATA,
  PARAMTYPES_METADATA,
  PROPERTY_DEPS_METADATA,
  SELF_DECLARED_DEPS_METADATA,
} from '@nestjs/common/constants';
import {
  Controller,
  ForwardReference,
  Injectable,
  Type,
} from '@nestjs/common/interfaces';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import {
  isFunction,
  isNil,
  isObject,
  isString,
  isSymbol,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { performance } from 'perf_hooks';
import { CircularDependencyException } from '../errors/exceptions';
import { RuntimeException } from '../errors/exceptions/runtime.exception';
import { UndefinedDependencyException } from '../errors/exceptions/undefined-dependency.exception';
import { UnknownDependenciesException } from '../errors/exceptions/unknown-dependencies.exception';
import { STATIC_CONTEXT } from './constants';
import { INQUIRER } from './inquirer';
import {
  ContextId,
  InstancePerContext,
  InstanceWrapper,
  PropertyMetadata,
} from './instance-wrapper';
import { Module } from './module';
import { SettlementSignal } from './settlement-signal';

/**
 * The type of an injectable dependency
 */
export type InjectorDependency = InjectionToken;

/**
 * The property-based dependency
 */
export interface PropertyDependency {
  key: symbol | string;
  name: InjectorDependency;
  isOptional?: boolean;
  instance?: any;
}

/**
 * Context of a dependency which gets injected by
 * the injector
 */
export interface InjectorDependencyContext {
  /**
   * The name of the property key (property-based injection)
   */
  key?: string | symbol;
  /**
   * The function itself, the name of the function, or injection token.
   */
  name?: Function | string | symbol;
  /**
   * The index of the dependency which gets injected
   * from the dependencies array
   */
  index?: number;
  /**
   * The dependency array which gets injected
   */
  dependencies?: InjectorDependency[];
}

export class Injector {
  private logger: LoggerService = new Logger('InjectorLogger');

  constructor(private readonly options?: { preview: boolean }) {}

  public loadPrototype<T>(
    { token }: InstanceWrapper<T>,
    collection: Map<InjectionToken, InstanceWrapper<T>>,
    contextId = STATIC_CONTEXT,
  ) {
    if (!collection) {
      return;
    }
    const target = collection.get(token)!;
    const instance = target.createPrototype(contextId);
    if (instance) {
      const wrapper = new InstanceWrapper({
        ...target,
        instance,
      });
      collection.set(token, wrapper);
    }
  }

  public async loadInstance<T>(
    wrapper: InstanceWrapper<T>,
    collection: Map<InjectionToken, InstanceWrapper>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ) {
    const inquirerId = this.getInquirerId(inquirer);
    const instanceHost = wrapper.getInstanceByContextId(
      this.getContextId(contextId, wrapper),
      inquirerId,
    );

    if (instanceHost.isPending) {
      const settlementSignal = wrapper.settlementSignal;
      if (inquirer && settlementSignal?.isCycle(inquirer.id)) {
        throw new CircularDependencyException(`"${wrapper.name}"`);
      }

      return instanceHost.donePromise!.then((err?: unknown) => {
        if (err) {
          throw err;
        }
      });
    }

    const settlementSignal = this.applySettlementSignal(instanceHost, wrapper);
    const token = wrapper.token || wrapper.name;

    const { inject } = wrapper;
    const targetWrapper = collection.get(token);
    if (isUndefined(targetWrapper)) {
      throw new RuntimeException();
    }
    if (instanceHost.isResolved) {
      return settlementSignal.complete();
    }
    try {
      const t0 = this.getNowTimestamp();
      const callback = async (instances: unknown[]) => {
        const properties = await this.resolveProperties(
          wrapper,
          moduleRef,
          inject as InjectionToken[],
          contextId,
          wrapper,
          inquirer,
        );
        const instance = await this.instantiateClass(
          instances,
          wrapper,
          targetWrapper,
          contextId,
          inquirer,
        );
        this.applyProperties(instance, properties);
        wrapper.initTime = this.getNowTimestamp() - t0;
        settlementSignal.complete();
      };
      await this.resolveConstructorParams<T>(
        wrapper,
        moduleRef,
        inject as InjectionToken[],
        callback,
        contextId,
        wrapper,
        inquirer,
      );
    } catch (err) {
      wrapper.removeInstanceByContextId(
        this.getContextId(contextId, wrapper),
        inquirerId,
      );

      settlementSignal.error(err);
      throw err;
    }
  }

  public async loadMiddleware(
    wrapper: InstanceWrapper,
    collection: Map<InjectionToken, InstanceWrapper>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ) {
    const { metatype, token } = wrapper;
    const targetWrapper = collection.get(token)!;
    if (!isUndefined(targetWrapper.instance)) {
      return;
    }
    targetWrapper.instance = Object.create(metatype!.prototype);
    await this.loadInstance(
      wrapper,
      collection,
      moduleRef,
      contextId,
      inquirer || wrapper,
    );
  }

  public async loadController(
    wrapper: InstanceWrapper<Controller>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
  ) {
    const controllers = moduleRef.controllers;
    await this.loadInstance<Controller>(
      wrapper,
      controllers,
      moduleRef,
      contextId,
      wrapper,
    );
    await this.loadEnhancersPerContext(wrapper, contextId, wrapper);
  }

  public async loadInjectable<T = any>(
    wrapper: InstanceWrapper<T>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ) {
    const injectables = moduleRef.injectables;
    await this.loadInstance<T>(
      wrapper,
      injectables,
      moduleRef,
      contextId,
      inquirer,
    );
  }

  public async loadProvider(
    wrapper: InstanceWrapper<Injectable>,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ) {
    const providers = moduleRef.providers;
    await this.loadInstance<Injectable>(
      wrapper,
      providers,
      moduleRef,
      contextId,
      inquirer,
    );
    await this.loadEnhancersPerContext(wrapper, contextId, wrapper);
  }

  public applySettlementSignal<T>(
    instancePerContext: InstancePerContext<T>,
    host: InstanceWrapper<T>,
  ) {
    const settlementSignal = new SettlementSignal();
    instancePerContext.donePromise = settlementSignal.asPromise();
    instancePerContext.isPending = true;
    host.settlementSignal = settlementSignal;

    return settlementSignal;
  }

  public async resolveConstructorParams<T>(
    wrapper: InstanceWrapper<T>,
    moduleRef: Module,
    inject: InjectorDependency[] | undefined,
    callback: (args: unknown[]) => void | Promise<void>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    parentInquirer?: InstanceWrapper,
  ) {
    let inquirerId = this.getInquirerId(inquirer);
    const metadata = wrapper.getCtorMetadata();

    if (metadata && contextId !== STATIC_CONTEXT) {
      const deps = await this.loadCtorMetadata(
        metadata,
        contextId,
        inquirer,
        parentInquirer,
      );
      return callback(deps);
    }

    const isFactoryProvider = !isNil(inject);
    const [dependencies, optionalDependenciesIds] = isFactoryProvider
      ? this.getFactoryProviderDependencies(wrapper)
      : this.getClassDependencies(wrapper);

    let isResolved = true;
    const resolveParam = async (param: unknown, index: number) => {
      try {
        if (this.isInquirer(param, parentInquirer)) {
          return parentInquirer && parentInquirer.instance;
        }
        if (inquirer?.isTransient && parentInquirer) {
          inquirer = parentInquirer;
          inquirerId = this.getInquirerId(parentInquirer);
        }
        const paramWrapper = await this.resolveSingleParam<T>(
          wrapper,
          param as Type | string | symbol,
          { index, dependencies },
          moduleRef,
          contextId,
          inquirer,
          index,
        );
        const instanceHost = paramWrapper.getInstanceByContextId(
          this.getContextId(contextId, paramWrapper),
          inquirerId,
        );
        if (!instanceHost.isResolved && !paramWrapper.forwardRef) {
          isResolved = false;
        }
        return instanceHost?.instance;
      } catch (err) {
        const isOptional = optionalDependenciesIds.includes(index);
        if (!isOptional) {
          throw err;
        }
        return undefined;
      }
    };
    const instances = await Promise.all(dependencies.map(resolveParam));
    isResolved && (await callback(instances));
  }

  public getClassDependencies<T>(
    wrapper: InstanceWrapper<T>,
  ): [InjectorDependency[], number[]] {
    const ctorRef = wrapper.metatype as Type<any>;
    return [
      this.reflectConstructorParams(ctorRef),
      this.reflectOptionalParams(ctorRef),
    ];
  }

  public getFactoryProviderDependencies<T>(
    wrapper: InstanceWrapper<T>,
  ): [InjectorDependency[], number[]] {
    const optionalDependenciesIds: number[] = [];

    /**
     * Same as the internal utility function `isOptionalFactoryDependency` from `@nestjs/common`.
     * We are duplicating it here because that one is not supposed to be exported.
     */
    function isOptionalFactoryDependency(
      value: InjectionToken | OptionalFactoryDependency,
    ): value is OptionalFactoryDependency {
      return (
        !isUndefined((value as OptionalFactoryDependency).token) &&
        !isUndefined((value as OptionalFactoryDependency).optional) &&
        !(value as any).prototype
      );
    }

    const mapFactoryProviderInjectArray = (
      item: InjectionToken | OptionalFactoryDependency,
      index: number,
    ): InjectionToken => {
      if (typeof item !== 'object') {
        return item;
      }
      if (isOptionalFactoryDependency(item)) {
        if (item.optional) {
          optionalDependenciesIds.push(index);
        }
        return item?.token;
      }
      return item;
    };
    return [
      wrapper.inject?.map?.(mapFactoryProviderInjectArray) as any[],
      optionalDependenciesIds,
    ];
  }

  public reflectConstructorParams<T>(type: Type<T>): any[] {
    const paramtypes = [
      ...(Reflect.getMetadata(PARAMTYPES_METADATA, type) || []),
    ];
    const selfParams = this.reflectSelfParams<T>(type);

    selfParams.forEach(({ index, param }) => (paramtypes[index] = param));
    return paramtypes;
  }

  public reflectOptionalParams<T>(type: Type<T>): any[] {
    return Reflect.getMetadata(OPTIONAL_DEPS_METADATA, type) || [];
  }

  public reflectSelfParams<T>(type: Type<T>): any[] {
    return Reflect.getMetadata(SELF_DECLARED_DEPS_METADATA, type) || [];
  }

  public async resolveSingleParam<T>(
    wrapper: InstanceWrapper<T>,
    param: Type<any> | string | symbol,
    dependencyContext: InjectorDependencyContext,
    moduleRef: Module,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: symbol | string | number,
  ) {
    if (isUndefined(param)) {
      this.logger.log(
        'Nest encountered an undefined dependency. This may be due to a circular import or a missing dependency declaration.',
      );
      throw new UndefinedDependencyException(
        wrapper.name,
        dependencyContext,
        moduleRef,
      );
    }
    const token = this.resolveParamToken(wrapper, param);
    return this.resolveComponentInstance<T>(
      moduleRef,
      token,
      dependencyContext,
      wrapper,
      contextId,
      inquirer,
      keyOrIndex,
    );
  }

  public resolveParamToken<T>(
    wrapper: InstanceWrapper<T>,
    param: Type<any> | string | symbol | ForwardReference,
  ) {
    if (typeof param === 'object' && 'forwardRef' in param) {
      wrapper.forwardRef = true;
      return param.forwardRef();
    }
    return param;
  }

  public async resolveComponentInstance<T>(
    moduleRef: Module,
    token: InjectionToken,
    dependencyContext: InjectorDependencyContext,
    wrapper: InstanceWrapper<T>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: symbol | string | number,
  ): Promise<InstanceWrapper> {
    this.printResolvingDependenciesLog(token, inquirer);
    this.printLookingForProviderLog(token, moduleRef);
    const providers = moduleRef.providers;
    const instanceWrapper = await this.lookupComponent(
      providers,
      moduleRef,
      { ...dependencyContext, name: token },
      wrapper,
      contextId,
      inquirer,
      keyOrIndex,
    );

    return this.resolveComponentHost(
      moduleRef,
      instanceWrapper,
      contextId,
      inquirer,
    );
  }

  public async resolveComponentHost<T>(
    moduleRef: Module,
    instanceWrapper: InstanceWrapper<T | Promise<T>>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ): Promise<InstanceWrapper> {
    const inquirerId = this.getInquirerId(inquirer);
    const instanceHost = instanceWrapper.getInstanceByContextId(
      this.getContextId(contextId, instanceWrapper),
      inquirerId,
    );
    if (!instanceHost.isResolved && !instanceWrapper.forwardRef) {
      inquirer?.settlementSignal?.insertRef(instanceWrapper.id);

      await this.loadProvider(
        instanceWrapper,
        instanceWrapper.host ?? moduleRef,
        contextId,
        inquirer,
      );
    } else if (
      !instanceHost.isResolved &&
      instanceWrapper.forwardRef &&
      (contextId !== STATIC_CONTEXT || !!inquirerId)
    ) {
      /**
       * When circular dependency has been detected between
       * either request/transient providers, we have to asynchronously
       * resolve instance host for a specific contextId or inquirer, to ensure
       * that eventual lazily created instance will be merged with the prototype
       * instantiated beforehand.
       */
      instanceHost.donePromise &&
        void instanceHost.donePromise.then(() =>
          this.loadProvider(instanceWrapper, moduleRef, contextId, inquirer),
        );
    }
    if (instanceWrapper.async) {
      const host = instanceWrapper.getInstanceByContextId(
        this.getContextId(contextId, instanceWrapper),
        inquirerId,
      );
      host.instance = await host.instance;
      instanceWrapper.setInstanceByContextId(contextId, host, inquirerId);
    }
    return instanceWrapper;
  }

  public async lookupComponent<T = any>(
    providers: Map<Function | string | symbol, InstanceWrapper>,
    moduleRef: Module,
    dependencyContext: InjectorDependencyContext,
    wrapper: InstanceWrapper<T>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: symbol | string | number,
  ): Promise<InstanceWrapper<T>> {
    const token = wrapper.token || wrapper.name;
    const { name } = dependencyContext;
    if (wrapper && token === name) {
      throw new UnknownDependenciesException(
        wrapper.name,
        dependencyContext,
        moduleRef,
        { id: wrapper.id },
      );
    }
    if (name && providers.has(name)) {
      const instanceWrapper = providers.get(name)!;
      this.printFoundInModuleLog(name, moduleRef);
      this.addDependencyMetadata(keyOrIndex!, wrapper, instanceWrapper);
      return instanceWrapper;
    }
    return this.lookupComponentInParentModules(
      dependencyContext,
      moduleRef,
      wrapper,
      contextId,
      inquirer,
      keyOrIndex,
    );
  }

  public async lookupComponentInParentModules<T = any>(
    dependencyContext: InjectorDependencyContext,
    moduleRef: Module,
    wrapper: InstanceWrapper<T>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: symbol | string | number,
  ) {
    const instanceWrapper = await this.lookupComponentInImports(
      moduleRef,
      dependencyContext.name!,
      wrapper,
      [],
      contextId,
      inquirer,
      keyOrIndex,
    );
    if (isNil(instanceWrapper)) {
      throw new UnknownDependenciesException(
        wrapper.name,
        dependencyContext,
        moduleRef,
        { id: wrapper.id },
      );
    }
    return instanceWrapper;
  }

  public async lookupComponentInImports(
    moduleRef: Module,
    name: InjectionToken,
    wrapper: InstanceWrapper,
    moduleRegistry: any[] = [],
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: symbol | string | number,
    isTraversing?: boolean,
  ): Promise<any> {
    let instanceWrapperRef: InstanceWrapper | null = null;
    const imports = moduleRef.imports || new Set<Module>();
    const identity = (item: any) => item;

    let children = [...imports.values()].filter(identity);
    if (isTraversing) {
      const contextModuleExports = moduleRef.exports;
      children = children.filter(child =>
        contextModuleExports.has(child.metatype),
      );
    }
    for (const relatedModule of children) {
      if (moduleRegistry.includes(relatedModule.id)) {
        continue;
      }
      this.printLookingForProviderLog(name, relatedModule);
      moduleRegistry.push(relatedModule.id);

      const { providers, exports } = relatedModule;
      if (!exports.has(name) || !providers.has(name)) {
        const instanceRef = await this.lookupComponentInImports(
          relatedModule,
          name,
          wrapper,
          moduleRegistry,
          contextId,
          inquirer,
          keyOrIndex,
          true,
        );
        if (instanceRef) {
          this.addDependencyMetadata(keyOrIndex!, wrapper, instanceRef);
          return instanceRef;
        }
        continue;
      }
      this.printFoundInModuleLog(name, relatedModule);
      instanceWrapperRef = providers.get(name)!;
      this.addDependencyMetadata(keyOrIndex!, wrapper, instanceWrapperRef);

      const inquirerId = this.getInquirerId(inquirer);
      const instanceHost = instanceWrapperRef.getInstanceByContextId(
        this.getContextId(contextId, instanceWrapperRef),
        inquirerId,
      );
      if (!instanceHost.isResolved && !instanceWrapperRef.forwardRef) {
        wrapper.settlementSignal?.insertRef(instanceWrapperRef.id);

        await this.loadProvider(
          instanceWrapperRef,
          relatedModule,
          contextId,
          wrapper,
        );
        break;
      }
    }
    return instanceWrapperRef;
  }

  public async resolveProperties<T>(
    wrapper: InstanceWrapper<T>,
    moduleRef: Module,
    inject?: InjectorDependency[],
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    parentInquirer?: InstanceWrapper,
  ): Promise<PropertyDependency[]> {
    if (!isNil(inject)) {
      return [];
    }
    const metadata = wrapper.getPropertiesMetadata();
    if (metadata && contextId !== STATIC_CONTEXT) {
      return this.loadPropertiesMetadata(metadata, contextId, inquirer);
    }
    const properties = this.reflectProperties(wrapper.metatype as Type<any>);
    const instances = await Promise.all(
      properties.map(async (item: PropertyDependency) => {
        try {
          const dependencyContext = {
            key: item.key,
            name: item.name as Function | string | symbol,
          };
          if (this.isInquirer(item.name, parentInquirer)) {
            return parentInquirer && parentInquirer.instance;
          }
          const paramWrapper = await this.resolveSingleParam<T>(
            wrapper,
            item.name as string,
            dependencyContext,
            moduleRef,
            contextId,
            inquirer,
            item.key,
          );
          if (!paramWrapper) {
            return undefined;
          }
          const inquirerId = this.getInquirerId(inquirer);
          const instanceHost = paramWrapper.getInstanceByContextId(
            this.getContextId(contextId, paramWrapper),
            inquirerId,
          );
          return instanceHost.instance;
        } catch (err) {
          if (!item.isOptional) {
            throw err;
          }
          return undefined;
        }
      }),
    );
    return properties.map((item: PropertyDependency, index: number) => ({
      ...item,
      instance: instances[index],
    }));
  }

  public reflectProperties<T>(type: Type<T>): PropertyDependency[] {
    const properties = Reflect.getMetadata(PROPERTY_DEPS_METADATA, type) || [];
    const optionalKeys: string[] =
      Reflect.getMetadata(OPTIONAL_PROPERTY_DEPS_METADATA, type) || [];

    return properties.map((item: any) => ({
      ...item,
      name: item.type,
      isOptional: optionalKeys.includes(item.key),
    }));
  }

  public applyProperties<T = any>(
    instance: T,
    properties: PropertyDependency[],
  ): void {
    if (!isObject(instance)) {
      return undefined;
    }
    iterate(properties)
      .filter(item => !isNil(item.instance))
      .forEach(item => (instance[item.key] = item.instance));
  }

  public async instantiateClass<T = any>(
    instances: any[],
    wrapper: InstanceWrapper,
    targetMetatype: InstanceWrapper,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
  ): Promise<T> {
    const { metatype, inject } = wrapper;
    const inquirerId = this.getInquirerId(inquirer);
    const instanceHost = targetMetatype.getInstanceByContextId(
      this.getContextId(contextId, targetMetatype),
      inquirerId,
    );
    const isInContext =
      wrapper.isStatic(contextId, inquirer) ||
      wrapper.isInRequestScope(contextId, inquirer) ||
      wrapper.isLazyTransient(contextId, inquirer) ||
      wrapper.isExplicitlyRequested(contextId, inquirer);

    if (this.options?.preview && !wrapper.host?.initOnPreview) {
      instanceHost.isResolved = true;
      return instanceHost.instance;
    }

    if (isNil(inject) && isInContext) {
      instanceHost.instance = wrapper.forwardRef
        ? Object.assign(
            instanceHost.instance,
            new (metatype as Type<any>)(...instances),
          )
        : new (metatype as Type<any>)(...instances);
    } else if (isInContext) {
      const factoryReturnValue = (targetMetatype.metatype as any as Function)(
        ...instances,
      );
      instanceHost.instance = await factoryReturnValue;
    }
    instanceHost.isResolved = true;
    return instanceHost.instance;
  }

  public async loadPerContext<T = any>(
    instance: T,
    moduleRef: Module,
    collection: Map<InjectionToken, InstanceWrapper>,
    ctx: ContextId,
    wrapper?: InstanceWrapper,
  ): Promise<T> {
    if (!wrapper) {
      const injectionToken = (instance as any).constructor!;
      wrapper = collection.get(injectionToken);
    }
    await this.loadInstance(wrapper!, collection, moduleRef, ctx, wrapper);
    await this.loadEnhancersPerContext(wrapper!, ctx, wrapper);

    const host = wrapper!.getInstanceByContextId(
      this.getContextId(ctx, wrapper!),
      wrapper!.id,
    );
    return host && (host.instance as T);
  }

  public async loadEnhancersPerContext(
    wrapper: InstanceWrapper,
    ctx: ContextId,
    inquirer?: InstanceWrapper,
  ) {
    const enhancers = wrapper.getEnhancersMetadata() || [];
    const loadEnhancer = (item: InstanceWrapper) => {
      const hostModule = item.host!;
      return this.loadInstance(
        item,
        hostModule.injectables,
        hostModule,
        ctx,
        inquirer,
      );
    };
    await Promise.all(enhancers.map(loadEnhancer));
  }

  public async loadCtorMetadata(
    metadata: InstanceWrapper<any>[],
    contextId: ContextId,
    inquirer?: InstanceWrapper,
    parentInquirer?: InstanceWrapper,
  ): Promise<any[]> {
    const hosts: Array<InstanceWrapper<any> | undefined> = await Promise.all(
      metadata.map(async item =>
        this.resolveScopedComponentHost(
          item,
          contextId,
          inquirer,
          parentInquirer,
        ),
      ),
    );
    const inquirerId = this.getInquirerId(inquirer);
    return hosts.map(
      item =>
        item?.getInstanceByContextId(
          this.getContextId(contextId, item),
          inquirerId,
        ).instance,
    );
  }

  public async loadPropertiesMetadata(
    metadata: PropertyMetadata[],
    contextId: ContextId,
    inquirer?: InstanceWrapper,
  ): Promise<PropertyDependency[]> {
    const dependenciesHosts = await Promise.all(
      metadata.map(async ({ wrapper: item, key }) => ({
        key,
        host: await this.resolveComponentHost(
          item.host!,
          item,
          contextId,
          inquirer,
        ),
      })),
    );
    const inquirerId = this.getInquirerId(inquirer);
    return dependenciesHosts.map(({ key, host }) => ({
      key,
      name: key,
      instance: host.getInstanceByContextId(
        this.getContextId(contextId, host),
        inquirerId,
      ).instance,
    }));
  }

  private getInquirerId(
    inquirer: InstanceWrapper | undefined,
  ): string | undefined {
    return inquirer ? inquirer.id : undefined;
  }

  private resolveScopedComponentHost(
    item: InstanceWrapper,
    contextId: ContextId,
    inquirer?: InstanceWrapper,
    parentInquirer?: InstanceWrapper,
  ) {
    return this.isInquirerRequest(item, parentInquirer)
      ? parentInquirer
      : this.resolveComponentHost(item.host!, item, contextId, inquirer);
  }

  private isInquirerRequest(
    item: InstanceWrapper,
    parentInquirer: InstanceWrapper | undefined,
  ) {
    return item.isTransient && item.name === INQUIRER && parentInquirer;
  }

  private isInquirer(
    param: unknown,
    parentInquirer: InstanceWrapper | undefined,
  ) {
    return param === INQUIRER && parentInquirer;
  }

  protected addDependencyMetadata(
    keyOrIndex: symbol | string | number,
    hostWrapper: InstanceWrapper,
    instanceWrapper: InstanceWrapper,
  ) {
    if (isSymbol(keyOrIndex) || isString(keyOrIndex)) {
      hostWrapper.addPropertiesMetadata(keyOrIndex, instanceWrapper);
    } else {
      hostWrapper.addCtorMetadata(keyOrIndex, instanceWrapper);
    }
  }

  private getTokenName(token: InjectionToken): string {
    return isFunction(token) ? (token as Function).name : token.toString();
  }

  private printResolvingDependenciesLog(
    token: InjectionToken,
    inquirer?: InstanceWrapper,
  ): void {
    if (!this.isDebugMode()) {
      return;
    }
    const tokenName = this.getTokenName(token);
    const dependentName =
      (inquirer?.name && inquirer.name.toString?.()) ?? 'unknown';
    const isAlias = dependentName === tokenName;

    const messageToPrint = `Resolving dependency ${clc.cyanBright(
      tokenName,
    )}${clc.green(' in the ')}${clc.yellow(dependentName)}${clc.green(
      ` provider ${isAlias ? '(alias)' : ''}`,
    )}`;

    this.logger.log(messageToPrint);
  }

  private printLookingForProviderLog(
    token: InjectionToken,
    moduleRef: Module,
  ): void {
    if (!this.isDebugMode()) {
      return;
    }
    const tokenName = this.getTokenName(token);
    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';
    this.logger.log(
      `Looking for ${clc.cyanBright(tokenName)}${clc.green(
        ' in ',
      )}${clc.magentaBright(moduleRefName)}`,
    );
  }

  private printFoundInModuleLog(
    token: InjectionToken,
    moduleRef: Module,
  ): void {
    if (!this.isDebugMode()) {
      return;
    }
    const tokenName = this.getTokenName(token);
    const moduleRefName = moduleRef?.metatype?.name ?? 'unknown';
    this.logger.log(
      `Found ${clc.cyanBright(tokenName)}${clc.green(
        ' in ',
      )}${clc.magentaBright(moduleRefName)}`,
    );
  }

  private isDebugMode(): boolean {
    return !!process.env.NEST_DEBUG;
  }

  private getContextId(
    contextId: ContextId,
    instanceWrapper: InstanceWrapper,
  ): ContextId {
    return contextId.getParent
      ? contextId.getParent({
          token: instanceWrapper.token,
          isTreeDurable: instanceWrapper.isDependencyTreeDurable(),
        })
      : contextId;
  }

  private getNowTimestamp() {
    return performance.now();
  }
}



================================================
FILE: packages/core/injector/instance-links-host.ts
================================================
import { InjectionToken } from '@nestjs/common';
import { isFunction } from '@nestjs/common/utils/shared.utils';
import { UnknownElementException } from '../errors/exceptions/unknown-element.exception';
import { NestContainer } from './container';
import { InstanceWrapper } from './instance-wrapper';
import { Module } from './module';

type HostCollection = 'providers' | 'controllers' | 'injectables';

export interface InstanceLink<T = any> {
  token: InjectionToken;
  wrapperRef: InstanceWrapper<T>;
  collection: Map<any, InstanceWrapper>;
  moduleId: string;
}

export class InstanceLinksHost {
  private readonly instanceLinks = new Map<InjectionToken, InstanceLink[]>();

  constructor(private readonly container: NestContainer) {
    this.initialize();
  }

  get<T = any>(token: InjectionToken): InstanceLink<T>;
  get<T = any>(
    token: InjectionToken,
    options?: { moduleId?: string; each?: boolean },
  ): InstanceLink<T> | Array<InstanceLink<T>>;
  get<T = any>(
    token: InjectionToken,
    options: { moduleId?: string; each?: boolean } = {},
  ): InstanceLink<T> | Array<InstanceLink<T>> {
    const instanceLinksForGivenToken = this.instanceLinks.get(token);

    if (!instanceLinksForGivenToken) {
      throw new UnknownElementException(this.getInstanceNameByToken(token));
    }

    if (options.each) {
      return instanceLinksForGivenToken;
    }

    const instanceLink = options.moduleId
      ? instanceLinksForGivenToken.find(
          item => item.moduleId === options.moduleId,
        )
      : instanceLinksForGivenToken[instanceLinksForGivenToken.length - 1];

    if (!instanceLink) {
      throw new UnknownElementException(this.getInstanceNameByToken(token));
    }
    return instanceLink;
  }

  private initialize() {
    const modules = this.container.getModules();
    modules.forEach(moduleRef => {
      const { providers, injectables, controllers } = moduleRef;
      providers.forEach((wrapper, token) =>
        this.addLink(wrapper, token, moduleRef, 'providers'),
      );
      injectables.forEach((wrapper, token) =>
        this.addLink(wrapper, token, moduleRef, 'injectables'),
      );
      controllers.forEach((wrapper, token) =>
        this.addLink(wrapper, token, moduleRef, 'controllers'),
      );
    });
  }

  private addLink(
    wrapper: InstanceWrapper,
    token: InjectionToken,
    moduleRef: Module,
    collectionName: HostCollection,
  ) {
    const instanceLink: InstanceLink = {
      moduleId: moduleRef.id,
      wrapperRef: wrapper,
      collection: moduleRef[collectionName],
      token,
    };
    const existingLinks = this.instanceLinks.get(token);
    if (!existingLinks) {
      this.instanceLinks.set(token, [instanceLink]);
    } else {
      existingLinks.push(instanceLink);
    }
  }

  private getInstanceNameByToken(token: InjectionToken): string {
    return isFunction(token) ? (token as Function)?.name : (token as string);
  }
}



================================================
FILE: packages/core/injector/instance-loader.ts
================================================
import { Logger, LoggerService } from '@nestjs/common';
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { Injectable } from '@nestjs/common/interfaces/injectable.interface';
import { MODULE_INIT_MESSAGE } from '../helpers/messages';
import { GraphInspector } from '../inspector/graph-inspector';
import { NestContainer } from './container';
import { Injector } from './injector';
import { InternalCoreModule } from './internal-core-module/internal-core-module';
import { Module } from './module';

export class InstanceLoader<TInjector extends Injector = Injector> {
  constructor(
    protected readonly container: NestContainer,
    protected readonly injector: TInjector,
    protected readonly graphInspector: GraphInspector,
    private logger: LoggerService = new Logger(InstanceLoader.name, {
      timestamp: true,
    }),
  ) {}

  public setLogger(logger: Logger) {
    this.logger = logger;
  }

  public async createInstancesOfDependencies(
    modules: Map<string, Module> = this.container.getModules(),
  ) {
    this.createPrototypes(modules);

    try {
      await this.createInstances(modules);
    } catch (err) {
      this.graphInspector.inspectModules(modules);
      this.graphInspector.registerPartial(err);
      throw err;
    }
    this.graphInspector.inspectModules(modules);
  }

  private createPrototypes(modules: Map<string, Module>) {
    modules.forEach(moduleRef => {
      this.createPrototypesOfProviders(moduleRef);
      this.createPrototypesOfInjectables(moduleRef);
      this.createPrototypesOfControllers(moduleRef);
    });
  }

  private async createInstances(modules: Map<string, Module>) {
    await Promise.all(
      [...modules.values()].map(async moduleRef => {
        await this.createInstancesOfProviders(moduleRef);
        await this.createInstancesOfInjectables(moduleRef);
        await this.createInstancesOfControllers(moduleRef);

        const { name } = moduleRef;
        this.isModuleWhitelisted(name) &&
          this.logger.log(MODULE_INIT_MESSAGE`${name}`);
      }),
    );
  }

  private createPrototypesOfProviders(moduleRef: Module) {
    const { providers } = moduleRef;
    providers.forEach(wrapper =>
      this.injector.loadPrototype<Injectable>(wrapper, providers),
    );
  }

  private async createInstancesOfProviders(moduleRef: Module) {
    const { providers } = moduleRef;
    const wrappers = [...providers.values()];
    await Promise.all(
      wrappers.map(async item => {
        await this.injector.loadProvider(item, moduleRef);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef);
      }),
    );
  }

  private createPrototypesOfControllers(moduleRef: Module) {
    const { controllers } = moduleRef;
    controllers.forEach(wrapper =>
      this.injector.loadPrototype<Controller>(wrapper, controllers),
    );
  }

  private async createInstancesOfControllers(moduleRef: Module) {
    const { controllers } = moduleRef;
    const wrappers = [...controllers.values()];
    await Promise.all(
      wrappers.map(async item => {
        await this.injector.loadController(item, moduleRef);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef);
      }),
    );
  }

  private createPrototypesOfInjectables(moduleRef: Module) {
    const { injectables } = moduleRef;
    injectables.forEach(wrapper =>
      this.injector.loadPrototype(wrapper, injectables),
    );
  }

  private async createInstancesOfInjectables(moduleRef: Module) {
    const { injectables } = moduleRef;
    const wrappers = [...injectables.values()];
    await Promise.all(
      wrappers.map(async item => {
        await this.injector.loadInjectable(item, moduleRef);
        this.graphInspector.inspectInstanceWrapper(item, moduleRef);
      }),
    );
  }

  private isModuleWhitelisted(name: string): boolean {
    return name !== InternalCoreModule.name;
  }
}



================================================
FILE: packages/core/injector/instance-wrapper.ts
================================================
import { Logger, LoggerService, Provider, Scope, Type } from '@nestjs/common';
import { EnhancerSubtype } from '@nestjs/common/constants';
import { FactoryProvider, InjectionToken } from '@nestjs/common/interfaces';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import {
  isNil,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { UuidFactory } from '../inspector/uuid-factory';
import { STATIC_CONTEXT } from './constants';
import {
  isClassProvider,
  isFactoryProvider,
  isValueProvider,
} from './helpers/provider-classifier';
import { Module } from './module';
import { SettlementSignal } from './settlement-signal';

export const INSTANCE_METADATA_SYMBOL = Symbol.for('instance_metadata:cache');
export const INSTANCE_ID_SYMBOL = Symbol.for('instance_metadata:id');

export interface HostComponentInfo {
  /**
   * Injection token (or class reference)
   */
  token: InjectionToken;
  /**
   * Flag that indicates whether DI subtree is durable
   */
  isTreeDurable: boolean;
}

export interface ContextId {
  readonly id: number;
  payload?: unknown;
  getParent?(info: HostComponentInfo): ContextId;
}

export interface InstancePerContext<T> {
  instance: T;
  isResolved?: boolean;
  isPending?: boolean;
  donePromise?: Promise<unknown>;
}

export interface PropertyMetadata {
  key: symbol | string;
  wrapper: InstanceWrapper;
}

interface InstanceMetadataStore {
  dependencies?: InstanceWrapper[];
  properties?: PropertyMetadata[];
  enhancers?: InstanceWrapper[];
}

export class InstanceWrapper<T = any> {
  public readonly name: any;
  public readonly token: InjectionToken;
  public readonly async?: boolean;
  public readonly host?: Module;
  public readonly isAlias: boolean = false;
  public readonly subtype?: EnhancerSubtype;
  public scope?: Scope = Scope.DEFAULT;
  public metatype: Type<T> | Function | null;
  public inject?: FactoryProvider['inject'] | null;
  public forwardRef?: boolean;
  public durable?: boolean;
  public initTime?: number;
  public settlementSignal?: SettlementSignal;

  private static logger: LoggerService = new Logger(InstanceWrapper.name);

  private readonly values = new WeakMap<ContextId, InstancePerContext<T>>();
  private readonly [INSTANCE_METADATA_SYMBOL]: InstanceMetadataStore = {};
  private readonly [INSTANCE_ID_SYMBOL]: string;
  private transientMap?:
    | Map<string, WeakMap<ContextId, InstancePerContext<T>>>
    | undefined;
  private isTreeStatic: boolean | undefined;
  private isTreeDurable: boolean | undefined;

  constructor(
    metadata: Partial<InstanceWrapper<T>> & Partial<InstancePerContext<T>> = {},
  ) {
    this.initialize(metadata);
    this[INSTANCE_ID_SYMBOL] =
      metadata[INSTANCE_ID_SYMBOL] ?? this.generateUuid();
  }

  get id(): string {
    return this[INSTANCE_ID_SYMBOL];
  }

  set instance(value: T) {
    this.values.set(STATIC_CONTEXT, { instance: value });
  }

  get instance(): T {
    const instancePerContext = this.getInstanceByContextId(STATIC_CONTEXT);
    return instancePerContext.instance;
  }

  get isNotMetatype(): boolean {
    return !this.metatype || this.isFactory;
  }

  get isFactory(): boolean {
    return !!this.metatype && !isNil(this.inject);
  }

  get isTransient(): boolean {
    return this.scope === Scope.TRANSIENT;
  }

  public getInstanceByContextId(
    contextId: ContextId,
    inquirerId?: string,
  ): InstancePerContext<T> {
    if (this.scope === Scope.TRANSIENT && inquirerId) {
      return this.getInstanceByInquirerId(contextId, inquirerId);
    }
    const instancePerContext = this.values.get(contextId);
    return instancePerContext
      ? instancePerContext
      : contextId !== STATIC_CONTEXT
        ? this.cloneStaticInstance(contextId)
        : {
            instance: null as T,
            isResolved: true,
            isPending: false,
          };
  }

  public getInstanceByInquirerId(
    contextId: ContextId,
    inquirerId: string,
  ): InstancePerContext<T> {
    let collectionPerContext = this.transientMap!.get(inquirerId);
    if (!collectionPerContext) {
      collectionPerContext = new WeakMap();
      this.transientMap!.set(inquirerId, collectionPerContext);
    }
    const instancePerContext = collectionPerContext.get(contextId);
    return instancePerContext
      ? instancePerContext
      : this.cloneTransientInstance(contextId, inquirerId);
  }

  public setInstanceByContextId(
    contextId: ContextId,
    value: InstancePerContext<T>,
    inquirerId?: string,
  ) {
    if (this.scope === Scope.TRANSIENT && inquirerId) {
      return this.setInstanceByInquirerId(contextId, inquirerId, value);
    }
    this.values.set(contextId, value);
  }

  public setInstanceByInquirerId(
    contextId: ContextId,
    inquirerId: string,
    value: InstancePerContext<T>,
  ) {
    let collection = this.transientMap!.get(inquirerId);
    if (!collection) {
      collection = new WeakMap();
      this.transientMap!.set(inquirerId, collection);
    }
    collection.set(contextId, value);
  }

  public removeInstanceByContextId(contextId: ContextId, inquirerId?: string) {
    if (this.scope === Scope.TRANSIENT && inquirerId) {
      return this.removeInstanceByInquirerId(contextId, inquirerId);
    }
    this.values.delete(contextId);
  }

  public removeInstanceByInquirerId(contextId: ContextId, inquirerId: string) {
    const collection = this.transientMap!.get(inquirerId);
    if (!collection) {
      return;
    }
    collection.delete(contextId);
  }

  public addCtorMetadata(index: number, wrapper: InstanceWrapper) {
    if (!this[INSTANCE_METADATA_SYMBOL].dependencies) {
      this[INSTANCE_METADATA_SYMBOL].dependencies = [];
    }
    this[INSTANCE_METADATA_SYMBOL].dependencies[index] = wrapper;
  }

  public getCtorMetadata(): InstanceWrapper[] {
    return this[INSTANCE_METADATA_SYMBOL].dependencies!;
  }

  public addPropertiesMetadata(key: symbol | string, wrapper: InstanceWrapper) {
    if (!this[INSTANCE_METADATA_SYMBOL].properties) {
      this[INSTANCE_METADATA_SYMBOL].properties = [];
    }
    this[INSTANCE_METADATA_SYMBOL].properties.push({
      key,
      wrapper,
    });
  }

  public getPropertiesMetadata(): PropertyMetadata[] {
    return this[INSTANCE_METADATA_SYMBOL].properties!;
  }

  public addEnhancerMetadata(wrapper: InstanceWrapper) {
    if (!this[INSTANCE_METADATA_SYMBOL].enhancers) {
      this[INSTANCE_METADATA_SYMBOL].enhancers = [];
    }
    this[INSTANCE_METADATA_SYMBOL].enhancers.push(wrapper);
  }

  public getEnhancersMetadata(): InstanceWrapper[] {
    return this[INSTANCE_METADATA_SYMBOL].enhancers!;
  }

  public isDependencyTreeDurable(lookupRegistry: string[] = []): boolean {
    if (!isUndefined(this.isTreeDurable)) {
      return this.isTreeDurable;
    }
    if (this.scope === Scope.REQUEST) {
      this.isTreeDurable = this.durable === undefined ? false : this.durable;
      if (this.isTreeDurable) {
        this.printIntrospectedAsDurable();
      }
      return this.isTreeDurable;
    }
    const isStatic = this.isDependencyTreeStatic();
    if (isStatic) {
      return false;
    }

    const isTreeNonDurable = this.introspectDepsAttribute(
      (collection, registry) =>
        collection.some(
          (item: InstanceWrapper) =>
            !item.isDependencyTreeStatic() &&
            !item.isDependencyTreeDurable(registry),
        ),
      lookupRegistry,
    );
    this.isTreeDurable = !isTreeNonDurable;
    if (this.isTreeDurable) {
      this.printIntrospectedAsDurable();
    }
    return this.isTreeDurable;
  }

  public introspectDepsAttribute(
    callback: (
      collection: InstanceWrapper[],
      lookupRegistry: string[],
    ) => boolean,
    lookupRegistry: string[] = [],
  ): boolean {
    if (lookupRegistry.includes(this[INSTANCE_ID_SYMBOL])) {
      return false;
    }
    lookupRegistry = lookupRegistry.concat(this[INSTANCE_ID_SYMBOL]);

    const { dependencies, properties, enhancers } =
      this[INSTANCE_METADATA_SYMBOL];

    let introspectionResult = dependencies
      ? callback(dependencies, lookupRegistry)
      : false;

    if (introspectionResult || !(properties || enhancers)) {
      return introspectionResult;
    }
    introspectionResult = properties
      ? callback(
          properties.map(item => item.wrapper),
          lookupRegistry,
        )
      : false;
    if (introspectionResult || !enhancers) {
      return introspectionResult;
    }
    return enhancers ? callback(enhancers, lookupRegistry) : false;
  }

  public isDependencyTreeStatic(lookupRegistry: string[] = []): boolean {
    if (!isUndefined(this.isTreeStatic)) {
      return this.isTreeStatic;
    }
    if (this.scope === Scope.REQUEST) {
      this.isTreeStatic = false;
      this.printIntrospectedAsRequestScoped();
      return this.isTreeStatic;
    }
    this.isTreeStatic = !this.introspectDepsAttribute(
      (collection, registry) =>
        collection.some(
          (item: InstanceWrapper) => !item.isDependencyTreeStatic(registry),
        ),
      lookupRegistry,
    );
    if (!this.isTreeStatic) {
      this.printIntrospectedAsRequestScoped();
    }
    return this.isTreeStatic;
  }

  public cloneStaticInstance(contextId: ContextId): InstancePerContext<T> {
    const staticInstance = this.getInstanceByContextId(STATIC_CONTEXT);
    if (this.isDependencyTreeStatic()) {
      return staticInstance;
    }
    const instancePerContext: InstancePerContext<T> = {
      ...staticInstance,
      instance: undefined!,
      isResolved: false,
      isPending: false,
    };
    if (this.isNewable()) {
      instancePerContext.instance = Object.create(this.metatype!.prototype);
    }
    this.setInstanceByContextId(contextId, instancePerContext);
    return instancePerContext;
  }

  public cloneTransientInstance(
    contextId: ContextId,
    inquirerId: string,
  ): InstancePerContext<T> {
    const staticInstance = this.getInstanceByContextId(STATIC_CONTEXT);
    const instancePerContext: InstancePerContext<T> = {
      ...staticInstance,
      instance: undefined!,
      isResolved: false,
      isPending: false,
    };
    if (this.isNewable()) {
      instancePerContext.instance = Object.create(this.metatype!.prototype);
    }
    this.setInstanceByInquirerId(contextId, inquirerId, instancePerContext);
    return instancePerContext;
  }

  public createPrototype(contextId: ContextId) {
    const host = this.getInstanceByContextId(contextId);
    if (!this.isNewable() || host.isResolved) {
      return;
    }
    return Object.create(this.metatype!.prototype);
  }

  public isInRequestScope(
    contextId: ContextId,
    inquirer?: InstanceWrapper,
  ): boolean {
    const isDependencyTreeStatic = this.isDependencyTreeStatic();

    return (
      !isDependencyTreeStatic &&
      contextId !== STATIC_CONTEXT &&
      (!this.isTransient || (this.isTransient && !!inquirer))
    );
  }

  public isLazyTransient(
    contextId: ContextId,
    inquirer: InstanceWrapper | undefined,
  ): boolean {
    const isInquirerRequestScoped = !!(
      inquirer && !inquirer.isDependencyTreeStatic()
    );

    return (
      this.isDependencyTreeStatic() &&
      contextId !== STATIC_CONTEXT &&
      this.isTransient &&
      isInquirerRequestScoped
    );
  }

  public isExplicitlyRequested(
    contextId: ContextId,
    inquirer?: InstanceWrapper,
  ): boolean {
    const isSelfRequested = inquirer === this;
    return (
      this.isDependencyTreeStatic() &&
      contextId !== STATIC_CONTEXT &&
      (isSelfRequested || !!(inquirer && inquirer.scope === Scope.TRANSIENT))
    );
  }

  public isStatic(
    contextId: ContextId,
    inquirer: InstanceWrapper | undefined,
  ): boolean {
    const isInquirerRequestScoped =
      inquirer && !inquirer.isDependencyTreeStatic();
    const isStaticTransient = this.isTransient && !isInquirerRequestScoped;

    return (
      this.isDependencyTreeStatic() &&
      contextId === STATIC_CONTEXT &&
      (!this.isTransient ||
        (isStaticTransient && !!inquirer && !inquirer.isTransient))
    );
  }

  public getStaticTransientInstances() {
    if (!this.transientMap) {
      return [];
    }
    const instances = [...this.transientMap.values()];
    return iterate(instances)
      .map(item => item.get(STATIC_CONTEXT))
      .filter(item => !!item)
      .toArray();
  }

  public mergeWith(provider: Provider) {
    if (isValueProvider(provider)) {
      this.metatype = null;
      this.inject = null;

      this.scope = Scope.DEFAULT;

      this.setInstanceByContextId(STATIC_CONTEXT, {
        instance: provider.useValue,
        isResolved: true,
        isPending: false,
      });
    } else if (isClassProvider(provider)) {
      this.inject = null;
      this.metatype = provider.useClass;
    } else if (isFactoryProvider(provider)) {
      this.metatype = provider.useFactory;
      this.inject = provider.inject || [];
    }
  }

  private isNewable(): boolean {
    return isNil(this.inject) && this.metatype && this.metatype.prototype;
  }

  private initialize(
    metadata: Partial<InstanceWrapper<T>> & Partial<InstancePerContext<T>>,
  ) {
    const { instance, isResolved, ...wrapperPartial } = metadata;
    Object.assign(this, wrapperPartial);

    this.setInstanceByContextId(STATIC_CONTEXT, {
      instance: instance as T,
      isResolved,
    });
    this.scope === Scope.TRANSIENT && (this.transientMap = new Map());
  }

  private printIntrospectedAsRequestScoped() {
    if (!this.isDebugMode() || this.name === 'REQUEST') {
      return;
    }
    if (isString(this.name)) {
      InstanceWrapper.logger.log(
        `${clc.cyanBright(this.name)}${clc.green(
          ' introspected as ',
        )}${clc.magentaBright('request-scoped')}`,
      );
    }
  }

  private printIntrospectedAsDurable() {
    if (!this.isDebugMode()) {
      return;
    }
    if (isString(this.name)) {
      InstanceWrapper.logger.log(
        `${clc.cyanBright(this.name)}${clc.green(
          ' introspected as ',
        )}${clc.magentaBright('durable')}`,
      );
    }
  }

  private isDebugMode(): boolean {
    return !!process.env.NEST_DEBUG;
  }

  private generateUuid(): string {
    let key = this.name?.toString() ?? this.token?.toString();
    key += this.host?.name ?? '';

    return key ? UuidFactory.get(key) : randomStringGenerator();
  }
}



================================================
FILE: packages/core/injector/internal-providers-storage.ts
================================================
import { AbstractHttpAdapter } from '../adapters';
import { HttpAdapterHost } from '../helpers/http-adapter-host';

export class InternalProvidersStorage {
  private readonly _httpAdapterHost = new HttpAdapterHost();
  private _httpAdapter: AbstractHttpAdapter;

  get httpAdapterHost(): HttpAdapterHost {
    return this._httpAdapterHost;
  }

  get httpAdapter(): AbstractHttpAdapter {
    return this._httpAdapter;
  }

  set httpAdapter(httpAdapter: AbstractHttpAdapter) {
    this._httpAdapter = httpAdapter;
  }
}



================================================
FILE: packages/core/injector/module-ref.ts
================================================
import { IntrospectionResult, Scope, Type } from '@nestjs/common';
import { getClassScope } from '../helpers/get-class-scope';
import { isDurable } from '../helpers/is-durable';
import { AbstractInstanceResolver } from './abstract-instance-resolver';
import { NestContainer } from './container';
import { Injector } from './injector';
import { InstanceLinksHost } from './instance-links-host';
import { ContextId, InstanceWrapper } from './instance-wrapper';
import { Module } from './module';

export interface ModuleRefGetOrResolveOpts {
  /**
   * If enabled, lookup will only be performed in the host module.
   * @default true
   */
  strict?: boolean;
  /**
   * If enabled, instead of returning a first instance registered under a given token,
   * a list of instances will be returned.
   * @default false
   */
  each?: boolean;
}

export abstract class ModuleRef extends AbstractInstanceResolver {
  protected readonly injector = new Injector();
  private _instanceLinksHost: InstanceLinksHost;

  protected get instanceLinksHost() {
    if (!this._instanceLinksHost) {
      this._instanceLinksHost = new InstanceLinksHost(this.container);
    }
    return this._instanceLinksHost;
  }

  constructor(protected readonly container: NestContainer) {
    super();
  }

  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  abstract get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): TResult;
  /**
   * Retrieves an instance of either injectable or controller, otherwise, throws exception.
   * @returns {TResult}
   */
  abstract get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: {
      /**
       * If enabled, lookup will only be performed in the host module.
       * @default true
       */
      strict?: boolean;
      /** This indicates that only the first instance registered will be returned. */
      each?: undefined | false;
    },
  ): TResult;
  /**
   * Retrieves a list of instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  abstract get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options: {
      /**
       * If enabled, lookup will only be performed in the host module.
       * @default true
       */
      strict?: boolean;
      /** This indicates that a list of instances will be returned. */
      each: true;
    },
  ): Array<TResult>;
  /**
   * Retrieves an instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {TResult | Array<TResult>}
   */
  abstract get<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    options?: ModuleRefGetOrResolveOpts,
  ): TResult | Array<TResult>;

  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  abstract resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  abstract resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  abstract resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: { strict?: boolean; each?: undefined | false },
  ): Promise<TResult>;
  /**
   * Resolves transient or request-scoped instances of either injectables or controllers, otherwise, throws exception.
   * @returns {Array<TResult>}
   */
  abstract resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: { strict?: boolean; each: true },
  ): Promise<Array<TResult>>;
  /**
   * Resolves transient or request-scoped instance (or a list of instances) of either injectable or controller, otherwise, throws exception.
   * @returns {Promise<TResult | Array<TResult>>}
   */
  abstract resolve<TInput = any, TResult = TInput>(
    typeOrToken: Type<TInput> | Function | string | symbol,
    contextId?: { id: number },
    options?: ModuleRefGetOrResolveOpts,
  ): Promise<TResult | Array<TResult>>;

  public abstract create<T = any>(
    type: Type<T>,
    contextId?: ContextId,
  ): Promise<T>;

  public introspect<T = any>(
    token: Type<T> | string | symbol,
  ): IntrospectionResult {
    const { wrapperRef } = this.instanceLinksHost.get(token);

    let scope = Scope.DEFAULT;
    if (!wrapperRef.isDependencyTreeStatic()) {
      scope = Scope.REQUEST;
    } else if (wrapperRef.isTransient) {
      scope = Scope.TRANSIENT;
    }
    return { scope };
  }

  public registerRequestByContextId<T = any>(request: T, contextId: ContextId) {
    this.container.registerRequestProvider(request, contextId);
  }

  protected async instantiateClass<T = any>(
    type: Type<T>,
    moduleRef: Module,
    contextId?: ContextId,
  ): Promise<T> {
    const wrapper = new InstanceWrapper({
      name: type && type.name,
      metatype: type,
      isResolved: false,
      scope: getClassScope(type),
      durable: isDurable(type),
      host: moduleRef,
    });

    /* eslint-disable-next-line no-async-promise-executor */
    return new Promise<T>(async (resolve, reject) => {
      try {
        const callback = async (instances: any[]) => {
          const properties = await this.injector.resolveProperties(
            wrapper,
            moduleRef,
            undefined,
            contextId,
          );
          const instance = new type(...instances);
          this.injector.applyProperties(instance, properties);
          resolve(instance);
        };
        await this.injector.resolveConstructorParams<T>(
          wrapper,
          moduleRef,
          undefined,
          callback,
          contextId,
        );
      } catch (err) {
        reject(err);
      }
    });
  }
}



================================================
FILE: packages/core/injector/module.ts
================================================
import {
  EnhancerSubtype,
  ENTRY_PROVIDER_WATERMARK,
} from '@nestjs/common/constants';
import {
  ClassProvider,
  Controller,
  DynamicModule,
  ExistingProvider,
  FactoryProvider,
  Injectable,
  InjectionToken,
  NestModule,
  Provider,
  Scope,
  Type,
  ValueProvider,
} from '@nestjs/common/interfaces';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import {
  isFunction,
  isNil,
  isObject,
  isString,
  isSymbol,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import {
  InvalidClassException,
  RuntimeException,
  UnknownExportException,
} from '../errors/exceptions';
import { createContextId } from '../helpers/context-id-factory';
import { getClassScope } from '../helpers/get-class-scope';
import { isDurable } from '../helpers/is-durable';
import { UuidFactory } from '../inspector/uuid-factory';
import { CONTROLLER_ID_KEY } from './constants';
import { NestContainer } from './container';
import { ContextId, InstanceWrapper } from './instance-wrapper';
import { ModuleRef, ModuleRefGetOrResolveOpts } from './module-ref';

export class Module {
  private readonly _id: string;
  private readonly _imports = new Set<Module>();
  private readonly _providers = new Map<
    InjectionToken,
    InstanceWrapper<Injectable>
  >();
  private readonly _injectables = new Map<
    InjectionToken,
    InstanceWrapper<Injectable>
  >();
  private readonly _middlewares = new Map<
    InjectionToken,
    InstanceWrapper<Injectable>
  >();
  private readonly _controllers = new Map<
    InjectionToken,
    InstanceWrapper<Controller>
  >();
  private readonly _entryProviderKeys = new Set<InjectionToken>();
  private readonly _exports = new Set<InjectionToken>();

  private _distance = 0;
  private _initOnPreview = false;
  private _isGlobal = false;
  private _token: string;

  constructor(
    private readonly _metatype: Type<any>,
    private readonly container: NestContainer,
  ) {
    this.addCoreProviders();
    this._id = this.generateUuid();
  }

  get id(): string {
    return this._id;
  }

  get token(): string {
    return this._token;
  }

  set token(token: string) {
    this._token = token;
  }

  get name() {
    return this.metatype.name;
  }

  get isGlobal() {
    return this._isGlobal;
  }

  set isGlobal(global: boolean) {
    this._isGlobal = global;
  }

  get initOnPreview() {
    return this._initOnPreview;
  }

  set initOnPreview(initOnPreview: boolean) {
    this._initOnPreview = initOnPreview;
  }

  get providers(): Map<InjectionToken, InstanceWrapper<Injectable>> {
    return this._providers;
  }

  get middlewares(): Map<InjectionToken, InstanceWrapper<Injectable>> {
    return this._middlewares;
  }

  get imports(): Set<Module> {
    return this._imports;
  }

  get injectables(): Map<InjectionToken, InstanceWrapper<Injectable>> {
    return this._injectables;
  }

  get controllers(): Map<InjectionToken, InstanceWrapper<Controller>> {
    return this._controllers;
  }

  get entryProviders(): Array<InstanceWrapper<Injectable>> {
    return Array.from(this._entryProviderKeys).map(
      token => this.providers.get(token)!,
    );
  }

  get exports(): Set<InjectionToken> {
    return this._exports;
  }

  get instance(): NestModule {
    if (!this._providers.has(this._metatype)) {
      throw new RuntimeException();
    }
    const moduleRef = this._providers.get(this._metatype);
    return moduleRef!.instance as NestModule;
  }

  get metatype(): Type<any> {
    return this._metatype;
  }

  get distance(): number {
    return this._distance;
  }

  set distance(value: number) {
    this._distance = value;
  }

  public addCoreProviders() {
    this.addModuleAsProvider();
    this.addModuleRef();
    this.addApplicationConfig();
  }

  public addModuleRef() {
    const moduleRef = this.createModuleReferenceType();
    this._providers.set(
      ModuleRef,
      new InstanceWrapper({
        token: ModuleRef,
        name: ModuleRef.name,
        metatype: ModuleRef as any,
        isResolved: true,
        instance: new moduleRef(),
        host: this,
      }),
    );
  }

  public addModuleAsProvider() {
    this._providers.set(
      this._metatype,
      new InstanceWrapper({
        token: this._metatype,
        name: this._metatype.name,
        metatype: this._metatype,
        isResolved: false,
        instance: null,
        host: this,
      }),
    );
  }

  public addApplicationConfig() {
    this._providers.set(
      ApplicationConfig,
      new InstanceWrapper({
        token: ApplicationConfig,
        name: ApplicationConfig.name,
        isResolved: true,
        instance: this.container.applicationConfig,
        host: this,
      }),
    );
  }

  public addInjectable<T extends Injectable>(
    injectable: Provider,
    enhancerSubtype: EnhancerSubtype,
    host?: Type<T>,
  ) {
    if (this.isCustomProvider(injectable)) {
      return this.addCustomProvider(
        injectable,
        this._injectables,
        enhancerSubtype,
      );
    }
    let instanceWrapper = this.injectables.get(injectable);
    if (!instanceWrapper) {
      instanceWrapper = new InstanceWrapper({
        token: injectable,
        name: injectable.name,
        metatype: injectable,
        instance: null,
        isResolved: false,
        scope: getClassScope(injectable),
        durable: isDurable(injectable),
        subtype: enhancerSubtype,
        host: this,
      });
      this._injectables.set(injectable, instanceWrapper);
    }
    if (host) {
      const hostWrapper =
        this._controllers.get(host) || this._providers.get(host);
      hostWrapper && hostWrapper.addEnhancerMetadata(instanceWrapper);
    }
    return instanceWrapper;
  }

  public addProvider(provider: Provider): InjectionToken;
  public addProvider(
    provider: Provider,
    enhancerSubtype: EnhancerSubtype,
  ): InjectionToken;
  public addProvider(provider: Provider, enhancerSubtype?: EnhancerSubtype) {
    if (this.isCustomProvider(provider)) {
      if (this.isEntryProvider(provider.provide)) {
        this._entryProviderKeys.add(provider.provide);
      }
      return this.addCustomProvider(provider, this._providers, enhancerSubtype);
    }

    const isAlreadyDeclared = this._providers.has(provider);
    if (
      (this.isTransientProvider(provider) ||
        this.isRequestScopeProvider(provider)) &&
      isAlreadyDeclared
    ) {
      return provider;
    }

    this._providers.set(
      provider,
      new InstanceWrapper({
        token: provider,
        name: (provider as Type<Injectable>).name,
        metatype: provider as Type<Injectable>,
        instance: null,
        isResolved: false,
        scope: getClassScope(provider),
        durable: isDurable(provider),
        host: this,
      }),
    );

    if (this.isEntryProvider(provider)) {
      this._entryProviderKeys.add(provider);
    }

    return provider as Type<Injectable>;
  }

  public isCustomProvider(
    provider: Provider,
  ): provider is
    | ClassProvider
    | FactoryProvider
    | ValueProvider
    | ExistingProvider {
    return !isNil(
      (
        provider as
          | ClassProvider
          | FactoryProvider
          | ValueProvider
          | ExistingProvider
      ).provide,
    );
  }

  public addCustomProvider(
    provider:
      | ClassProvider
      | FactoryProvider
      | ValueProvider
      | ExistingProvider,
    collection: Map<Function | string | symbol, any>,
    enhancerSubtype?: EnhancerSubtype,
  ) {
    if (this.isCustomClass(provider)) {
      this.addCustomClass(provider, collection, enhancerSubtype);
    } else if (this.isCustomValue(provider)) {
      this.addCustomValue(provider, collection, enhancerSubtype);
    } else if (this.isCustomFactory(provider)) {
      this.addCustomFactory(provider, collection, enhancerSubtype);
    } else if (this.isCustomUseExisting(provider)) {
      this.addCustomUseExisting(provider, collection, enhancerSubtype);
    }
    return provider.provide;
  }

  public isCustomClass(provider: any): provider is ClassProvider {
    return !isUndefined((provider as ClassProvider).useClass);
  }

  public isCustomValue(provider: any): provider is ValueProvider {
    return (
      isObject(provider) &&
      Object.prototype.hasOwnProperty.call(provider, 'useValue')
    );
  }

  public isCustomFactory(provider: any): provider is FactoryProvider {
    return !isUndefined((provider as FactoryProvider).useFactory);
  }

  public isCustomUseExisting(provider: any): provider is ExistingProvider {
    return !isUndefined((provider as ExistingProvider).useExisting);
  }

  public isDynamicModule(exported: any): exported is DynamicModule {
    return exported && exported.module;
  }

  public addCustomClass(
    provider: ClassProvider,
    collection: Map<InjectionToken, InstanceWrapper>,
    enhancerSubtype?: EnhancerSubtype,
  ) {
    let { scope, durable } = provider;

    const { useClass } = provider;
    if (isUndefined(scope)) {
      scope = getClassScope(useClass);
    }
    if (isUndefined(durable)) {
      durable = isDurable(useClass);
    }

    const token = provider.provide;
    collection.set(
      token,
      new InstanceWrapper({
        token,
        name: useClass?.name || useClass,
        metatype: useClass,
        instance: null,
        isResolved: false,
        scope,
        durable,
        host: this,
        subtype: enhancerSubtype,
      }),
    );
  }

  public addCustomValue(
    provider: ValueProvider,
    collection: Map<Function | string | symbol, InstanceWrapper>,
    enhancerSubtype?: EnhancerSubtype,
  ) {
    const { useValue: value, provide: providerToken } = provider;
    collection.set(
      providerToken,
      new InstanceWrapper({
        token: providerToken,
        name: (providerToken as Function)?.name || providerToken,
        metatype: null!,
        instance: value,
        isResolved: true,
        async: value instanceof Promise,
        host: this,
        subtype: enhancerSubtype,
      }),
    );
  }

  public addCustomFactory(
    provider: FactoryProvider,
    collection: Map<Function | string | symbol, InstanceWrapper>,
    enhancerSubtype?: EnhancerSubtype,
  ) {
    const {
      useFactory: factory,
      inject,
      scope,
      durable,
      provide: providerToken,
    } = provider;

    collection.set(
      providerToken,
      new InstanceWrapper({
        token: providerToken,
        name: (providerToken as Function)?.name || providerToken,
        metatype: factory as any,
        instance: null,
        isResolved: false,
        inject: inject || [],
        scope,
        durable,
        host: this,
        subtype: enhancerSubtype,
      }),
    );
  }

  public addCustomUseExisting(
    provider: ExistingProvider,
    collection: Map<Function | string | symbol, InstanceWrapper>,
    enhancerSubtype?: EnhancerSubtype,
  ) {
    const { useExisting, provide: providerToken } = provider;
    collection.set(
      providerToken,
      new InstanceWrapper({
        token: providerToken,
        name: (providerToken as Function)?.name || providerToken,
        metatype: (instance => instance) as any,
        instance: null,
        isResolved: false,
        inject: [useExisting],
        host: this,
        isAlias: true,
        subtype: enhancerSubtype,
      }),
    );
  }

  public addExportedProviderOrModule(
    toExport: Provider | string | symbol | DynamicModule,
  ) {
    const addExportedUnit = (token: InjectionToken) =>
      this._exports.add(this.validateExportedProvider(token));

    if (this.isCustomProvider(toExport as any)) {
      return this.addCustomExportedProvider(toExport as any);
    } else if (isString(toExport) || isSymbol(toExport)) {
      return addExportedUnit(toExport);
    } else if (this.isDynamicModule(toExport)) {
      const { module: moduleClassRef } = toExport;
      return addExportedUnit(moduleClassRef);
    }
    addExportedUnit(toExport as Type<any>);
  }

  public addCustomExportedProvider(
    provider:
      | FactoryProvider
      | ValueProvider
      | ClassProvider
      | ExistingProvider,
  ) {
    const provide = provider.provide;
    if (isString(provide) || isSymbol(provide)) {
      return this._exports.add(this.validateExportedProvider(provide));
    }
    this._exports.add(this.validateExportedProvider(provide));
  }

  public validateExportedProvider(token: InjectionToken) {
    if (this._providers.has(token)) {
      return token;
    }
    const imports = iterate(this._imports.values())
      .filter(item => !!item)
      .map(({ metatype }) => metatype)
      .filter(metatype => !!metatype)
      .toArray();

    if (!imports.includes(token as Type<unknown>)) {
      const { name } = this.metatype;
      const providerName = isFunction(token) ? (token as Function).name : token;
      throw new UnknownExportException(providerName as string, name);
    }
    return token;
  }

  public addController(controller: Type<Controller>) {
    this._controllers.set(
      controller,
      new InstanceWrapper({
        token: controller,
        name: controller.name,
        metatype: controller,
        instance: null!,
        isResolved: false,
        scope: getClassScope(controller),
        durable: isDurable(controller),
        host: this,
      }),
    );

    this.assignControllerUniqueId(controller);
  }

  public assignControllerUniqueId(controller: Type<Controller>) {
    Object.defineProperty(controller, CONTROLLER_ID_KEY, {
      enumerable: false,
      writable: false,
      configurable: true,
      value: randomStringGenerator(),
    });
  }

  public addImport(moduleRef: Module) {
    this._imports.add(moduleRef);
  }

  public replace(toReplace: InjectionToken, options: any) {
    if (options.isProvider && this.hasProvider(toReplace)) {
      const originalProvider = this._providers.get(toReplace);

      return originalProvider!.mergeWith({ provide: toReplace, ...options });
    } else if (!options.isProvider && this.hasInjectable(toReplace)) {
      const originalInjectable = this._injectables.get(toReplace);

      return originalInjectable!.mergeWith({
        provide: toReplace,
        ...options,
      });
    }
  }

  public hasProvider(token: InjectionToken): boolean {
    return this._providers.has(token);
  }

  public hasInjectable(token: InjectionToken): boolean {
    return this._injectables.has(token);
  }

  public getProviderByKey<T = any>(name: InjectionToken): InstanceWrapper<T> {
    return this._providers.get(name) as InstanceWrapper<T>;
  }

  public getProviderById<T = any>(id: string): InstanceWrapper<T> | undefined {
    return Array.from(this._providers.values()).find(
      item => item.id === id,
    ) as InstanceWrapper<T>;
  }

  public getControllerById<T = any>(
    id: string,
  ): InstanceWrapper<T> | undefined {
    return Array.from(this._controllers.values()).find(
      item => item.id === id,
    ) as InstanceWrapper<T>;
  }

  public getInjectableById<T = any>(
    id: string,
  ): InstanceWrapper<T> | undefined {
    return Array.from(this._injectables.values()).find(
      item => item.id === id,
    ) as InstanceWrapper<T>;
  }

  public getMiddlewareById<T = any>(
    id: string,
  ): InstanceWrapper<T> | undefined {
    return Array.from(this._middlewares.values()).find(
      item => item.id === id,
    ) as InstanceWrapper<T>;
  }

  public getNonAliasProviders(): Array<
    [InjectionToken, InstanceWrapper<Injectable>]
  > {
    return [...this._providers].filter(([_, wrapper]) => !wrapper.isAlias);
  }

  public createModuleReferenceType(): Type<ModuleRef> {
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    const self = this;
    return class extends ModuleRef {
      constructor() {
        super(self.container);
      }

      public get<TInput = any, TResult = TInput>(
        typeOrToken: Type<TInput> | string | symbol,
        options: ModuleRefGetOrResolveOpts = {},
      ): TResult | Array<TResult> {
        options.strict ??= true;
        options.each ??= false;

        return this.find<TInput, TResult>(
          typeOrToken,
          options.strict
            ? {
                moduleId: self.id,
                each: options.each,
              }
            : options,
        );
      }

      public resolve<TInput = any, TResult = TInput>(
        typeOrToken: Type<TInput> | string | symbol,
        contextId = createContextId(),
        options: ModuleRefGetOrResolveOpts = {},
      ): Promise<TResult | Array<TResult>> {
        options.strict ??= true;
        options.each ??= false;

        return this.resolvePerContext<TInput, TResult>(
          typeOrToken,
          self,
          contextId,
          options,
        );
      }

      public async create<T = any>(
        type: Type<T>,
        contextId?: ContextId,
      ): Promise<T> {
        if (!(type && isFunction(type) && type.prototype)) {
          throw new InvalidClassException(type);
        }
        return this.instantiateClass<T>(type, self, contextId);
      }
    };
  }

  private isEntryProvider(metatype: InjectionToken): boolean {
    return typeof metatype === 'function'
      ? !!Reflect.getMetadata(ENTRY_PROVIDER_WATERMARK, metatype)
      : false;
  }

  private generateUuid(): string {
    const prefix = 'M_';
    const key = this.token
      ? this.token.includes(':')
        ? this.token.split(':')[1]
        : this.token
      : this.name;

    return key ? UuidFactory.get(`${prefix}_${key}`) : randomStringGenerator();
  }

  private isTransientProvider(provider: Type<any>): boolean {
    return getClassScope(provider) === Scope.TRANSIENT;
  }

  private isRequestScopeProvider(provider: Type<any>): boolean {
    return getClassScope(provider) === Scope.REQUEST;
  }
}



================================================
FILE: packages/core/injector/modules-container.ts
================================================
import { uid } from 'uid';
import { Module } from './module';

export class ModulesContainer extends Map<string, Module> {
  private readonly _applicationId = uid(21);

  get applicationId(): string {
    return this._applicationId;
  }

  public getById(id: string): Module | undefined {
    return Array.from(this.values()).find(moduleRef => moduleRef.id === id);
  }
}



================================================
FILE: packages/core/injector/settlement-signal.ts
================================================
/**
 * SettlementSignal is used to signal the resolution of a provider/instance.
 * Calling `complete` or `error` will resolve the promise returned by `asPromise`.
 * Can be used to detect circular dependencies.
 */
export class SettlementSignal {
  private readonly _refs = new Set();
  private readonly settledPromise: Promise<unknown>;
  private settleFn!: (err?: unknown) => void;
  private completed = false;

  constructor() {
    this.settledPromise = new Promise<unknown>(resolve => {
      this.settleFn = resolve;
    });
  }

  /**
   * Resolves the promise returned by `asPromise`.
   */
  public complete() {
    this.completed = true;
    this.settleFn();
  }

  /**
   * Rejects the promise returned by `asPromise` with the given error.
   * @param err Error to reject the promise returned by `asPromise` with.
   */
  public error(err: unknown) {
    this.completed = true;
    this.settleFn(err);
  }

  /**
   * Returns a promise that will be resolved when `complete` or `error` is called.
   * @returns Promise that will be resolved when `complete` or `error` is called.
   */
  public asPromise() {
    return this.settledPromise;
  }

  /**
   * Inserts a wrapper id that the host of this signal depends on.
   * @param wrapperId Wrapper id to insert.
   */
  public insertRef(wrapperId: string) {
    this._refs.add(wrapperId);
  }

  /**
   * Check if relationship is circular.
   * @param wrapperId Wrapper id to check.
   * @returns True if relationship is circular, false otherwise.
   */
  public isCycle(wrapperId: string) {
    return !this.completed && this._refs.has(wrapperId);
  }
}



================================================
FILE: packages/core/injector/helpers/provider-classifier.ts
================================================
import {
  ClassProvider,
  FactoryProvider,
  Provider,
  ValueProvider,
} from '@nestjs/common';
import { isUndefined } from '@nestjs/common/utils/shared.utils';

export function isClassProvider<T = any>(
  provider: Provider,
): provider is ClassProvider<T> {
  return Boolean((provider as ClassProvider<T>)?.useClass);
}

export function isValueProvider<T = any>(
  provider: Provider,
): provider is ValueProvider<T> {
  const providerValue = (provider as ValueProvider)?.useValue;
  return !isUndefined(providerValue);
}

export function isFactoryProvider<T = any>(
  provider: Provider,
): provider is FactoryProvider<T> {
  return Boolean((provider as FactoryProvider).useFactory);
}



================================================
FILE: packages/core/injector/helpers/silent-logger.ts
================================================
import { Logger } from '@nestjs/common';

const noop = () => {};
export class SilentLogger extends Logger {
  log = noop;
  error = noop;
  warn = noop;
  debug = noop;
  verbose = noop;
  fatal = noop;
  setLogLevels = noop;
}



================================================
FILE: packages/core/injector/helpers/transient-instances.ts
================================================
import { InjectionToken } from '@nestjs/common';
import { iterate } from 'iterare';
import { InstanceWrapper } from '../instance-wrapper';

/**
 * Returns the instances which are transient
 * @param instances The instances which should be checked whether they are transient
 */
export function getTransientInstances(
  instances: [InjectionToken, InstanceWrapper][],
): InstanceWrapper[] {
  return iterate(instances)
    .filter(([_, wrapper]) => wrapper.isDependencyTreeStatic())
    .map(([_, wrapper]) => wrapper.getStaticTransientInstances())
    .flatten()
    .filter(item => !!item)
    .map(({ instance }: any) => instance)
    .toArray() as InstanceWrapper[];
}

/**
 * Returns the instances which are not transient
 * @param instances The instances which should be checked whether they are transient
 */
export function getNonTransientInstances(
  instances: [InjectionToken, InstanceWrapper][],
): InstanceWrapper[] {
  return iterate(instances)
    .filter(
      ([key, wrapper]) =>
        wrapper.isDependencyTreeStatic() && !wrapper.isTransient,
    )
    .map(([key, { instance }]) => instance)
    .toArray() as InstanceWrapper[];
}



================================================
FILE: packages/core/injector/inquirer/index.ts
================================================
export * from './inquirer-constants';



================================================
FILE: packages/core/injector/inquirer/inquirer-constants.ts
================================================
export const INQUIRER = 'INQUIRER';



================================================
FILE: packages/core/injector/inquirer/inquirer-providers.ts
================================================
import { Provider, Scope } from '@nestjs/common';
import { INQUIRER } from './inquirer-constants';

const noop = () => {};
export const inquirerProvider: Provider = {
  provide: INQUIRER,
  scope: Scope.TRANSIENT,
  useFactory: noop,
};



================================================
FILE: packages/core/injector/internal-core-module/index.ts
================================================
export * from './internal-core-module';



================================================
FILE: packages/core/injector/internal-core-module/internal-core-module-factory.ts
================================================
import { Logger } from '@nestjs/common';
import { ExternalContextCreator } from '../../helpers/external-context-creator';
import { HttpAdapterHost } from '../../helpers/http-adapter-host';
import { GraphInspector } from '../../inspector/graph-inspector';
import { InitializeOnPreviewAllowlist } from '../../inspector/initialize-on-preview.allowlist';
import { SerializedGraph } from '../../inspector/serialized-graph';
import { ModuleOverride } from '../../interfaces/module-override.interface';
import { DependenciesScanner } from '../../scanner';
import { ModuleCompiler } from '../compiler';
import { NestContainer } from '../container';
import { Injector } from '../injector';
import { InstanceLoader } from '../instance-loader';
import { LazyModuleLoader } from '../lazy-module-loader/lazy-module-loader';
import { ModulesContainer } from '../modules-container';
import { InternalCoreModule } from './internal-core-module';

export class InternalCoreModuleFactory {
  static create(
    container: NestContainer,
    scanner: DependenciesScanner,
    moduleCompiler: ModuleCompiler,
    httpAdapterHost: HttpAdapterHost,
    graphInspector: GraphInspector,
    moduleOverrides?: ModuleOverride[],
  ) {
    const lazyModuleLoaderFactory = () => {
      const logger = new Logger(LazyModuleLoader.name, {
        timestamp: false,
      });
      const injector = new Injector();
      const instanceLoader = new InstanceLoader(
        container,
        injector,
        graphInspector,
        logger,
      );
      return new LazyModuleLoader(
        scanner,
        instanceLoader,
        moduleCompiler,
        container.getModules(),
        moduleOverrides,
      );
    };

    InitializeOnPreviewAllowlist.add(InternalCoreModule);

    return InternalCoreModule.register([
      {
        provide: ExternalContextCreator,
        useFactory: () => ExternalContextCreator.fromContainer(container),
      },
      {
        provide: ModulesContainer,
        useFactory: () => container.getModules(),
      },
      {
        provide: HttpAdapterHost,
        useFactory: () => httpAdapterHost,
      },
      {
        provide: LazyModuleLoader,
        useFactory: lazyModuleLoaderFactory,
      },
      {
        provide: SerializedGraph,
        useFactory: () => container.serializedGraph,
      },
    ]);
  }
}



================================================
FILE: packages/core/injector/internal-core-module/internal-core-module.ts
================================================
import { DynamicModule, Global, Module } from '@nestjs/common';
import {
  ExistingProvider,
  FactoryProvider,
  ValueProvider,
} from '@nestjs/common/interfaces';
import { requestProvider } from '../../router/request/request-providers';
import { Reflector } from '../../services';
import { inquirerProvider } from '../inquirer/inquirer-providers';

const ReflectorAliasProvider = {
  provide: Reflector.name,
  useExisting: Reflector,
};

@Global()
@Module({
  providers: [
    Reflector,
    ReflectorAliasProvider,
    requestProvider,
    inquirerProvider,
  ],
  exports: [
    Reflector,
    ReflectorAliasProvider,
    requestProvider,
    inquirerProvider,
  ],
})
export class InternalCoreModule {
  static register(
    providers: Array<ValueProvider | FactoryProvider | ExistingProvider>,
  ): DynamicModule {
    return {
      module: InternalCoreModule,
      providers: [...providers],
      exports: [...providers.map(item => item.provide)],
    };
  }
}



================================================
FILE: packages/core/injector/lazy-module-loader/lazy-module-loader-options.interface.ts
================================================
export interface LazyModuleLoaderLoadOptions {
  /**
   * If `false`, no logs will be generated when loading some module lazily.
   */
  logger?: boolean;
}



================================================
FILE: packages/core/injector/lazy-module-loader/lazy-module-loader.ts
================================================
import { DynamicModule, Type } from '@nestjs/common';
import { ModuleOverride } from '../../interfaces/module-override.interface';
import { DependenciesScanner } from '../../scanner';
import { ModuleCompiler } from '../compiler';
import { SilentLogger } from '../helpers/silent-logger';
import { InstanceLoader } from '../instance-loader';
import { Module } from '../module';
import { ModuleRef } from '../module-ref';
import { ModulesContainer } from '../modules-container';
import { LazyModuleLoaderLoadOptions } from './lazy-module-loader-options.interface';

export class LazyModuleLoader {
  constructor(
    private readonly dependenciesScanner: DependenciesScanner,
    private readonly instanceLoader: InstanceLoader,
    private readonly moduleCompiler: ModuleCompiler,
    private readonly modulesContainer: ModulesContainer,
    private readonly moduleOverrides?: ModuleOverride[],
  ) {}

  public async load(
    loaderFn: () =>
      | Promise<Type<unknown> | DynamicModule>
      | Type<unknown>
      | DynamicModule,
    loadOpts?: LazyModuleLoaderLoadOptions,
  ): Promise<ModuleRef> {
    this.registerLoggerConfiguration(loadOpts);

    const moduleClassOrDynamicDefinition = await loaderFn();
    const moduleInstances = await this.dependenciesScanner.scanForModules({
      moduleDefinition: moduleClassOrDynamicDefinition,
      overrides: this.moduleOverrides,
      lazy: true,
    });
    if (moduleInstances.length === 0) {
      // The module has been loaded already. In this case, we must
      // retrieve a module reference from the existing container.
      const { token } = await this.moduleCompiler.compile(
        moduleClassOrDynamicDefinition,
      );
      const moduleInstance = this.modulesContainer.get(token)!;
      return moduleInstance && this.getTargetModuleRef(moduleInstance);
    }
    const lazyModulesContainer =
      this.createLazyModulesContainer(moduleInstances);
    await this.dependenciesScanner.scanModulesForDependencies(
      lazyModulesContainer,
    );
    await this.instanceLoader.createInstancesOfDependencies(
      lazyModulesContainer,
    );
    const [targetModule] = moduleInstances;
    return this.getTargetModuleRef(targetModule);
  }

  private registerLoggerConfiguration(loadOpts?: LazyModuleLoaderLoadOptions) {
    if (loadOpts?.logger === false) {
      this.instanceLoader.setLogger(new SilentLogger());
    }
  }

  private createLazyModulesContainer(
    moduleInstances: Module[],
  ): Map<string, Module> {
    moduleInstances = Array.from(new Set(moduleInstances));
    return new Map(moduleInstances.map(ref => [ref.token, ref]));
  }

  private getTargetModuleRef(moduleInstance: Module): ModuleRef {
    const moduleRefInstanceWrapper = moduleInstance.getProviderByKey(ModuleRef);
    return moduleRefInstanceWrapper.instance;
  }
}



================================================
FILE: packages/core/injector/opaque-key-factory/by-reference-module-opaque-key-factory.ts
================================================
import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { createHash } from 'crypto';
import { ModuleOpaqueKeyFactory } from './interfaces/module-opaque-key-factory.interface';

const K_MODULE_ID = Symbol('K_MODULE_ID');

export class ByReferenceModuleOpaqueKeyFactory
  implements ModuleOpaqueKeyFactory
{
  private readonly keyGenerationStrategy: 'random' | 'shallow';

  constructor(options?: { keyGenerationStrategy: 'random' | 'shallow' }) {
    this.keyGenerationStrategy = options?.keyGenerationStrategy ?? 'random';
  }

  public createForStatic(
    moduleCls: Type,
    originalRef: Type | ForwardReference = moduleCls,
  ): string {
    return this.getOrCreateModuleId(moduleCls, undefined, originalRef);
  }

  public createForDynamic(
    moduleCls: Type<unknown>,
    dynamicMetadata: Omit<DynamicModule, 'module'>,
    originalRef: DynamicModule | ForwardReference,
  ): string {
    return this.getOrCreateModuleId(moduleCls, dynamicMetadata, originalRef);
  }

  private getOrCreateModuleId(
    moduleCls: Type<unknown>,
    dynamicMetadata: Partial<DynamicModule> | undefined,
    originalRef: Type | DynamicModule | ForwardReference,
  ): string {
    if (originalRef[K_MODULE_ID]) {
      return originalRef[K_MODULE_ID];
    }

    let moduleId: string;
    if (this.keyGenerationStrategy === 'random') {
      moduleId = this.generateRandomString();
    } else {
      const delimiter = ':';
      moduleId = dynamicMetadata
        ? `${this.generateRandomString()}${delimiter}${this.hashString(moduleCls.name + JSON.stringify(dynamicMetadata))}`
        : `${this.generateRandomString()}${delimiter}${this.hashString(moduleCls.toString())}`;
    }

    originalRef[K_MODULE_ID] = moduleId;
    return moduleId;
  }

  private hashString(value: string): string {
    return createHash('sha256').update(value).digest('hex');
  }

  private generateRandomString(): string {
    return randomStringGenerator();
  }
}



================================================
FILE: packages/core/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.ts
================================================
import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { Logger } from '@nestjs/common/services/logger.service';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { isFunction, isSymbol } from '@nestjs/common/utils/shared.utils';
import { createHash } from 'crypto';
import stringify from 'fast-safe-stringify';
import { ModuleOpaqueKeyFactory } from './interfaces/module-opaque-key-factory.interface';

const CLASS_STR = 'class ';
const CLASS_STR_LEN = CLASS_STR.length;

export class DeepHashedModuleOpaqueKeyFactory
  implements ModuleOpaqueKeyFactory
{
  private readonly moduleIdsCache = new WeakMap<Type<unknown>, string>();
  private readonly moduleTokenCache = new Map<string, string>();
  private readonly logger = new Logger(DeepHashedModuleOpaqueKeyFactory.name, {
    timestamp: true,
  });

  public createForStatic(moduleCls: Type): string {
    const moduleId = this.getModuleId(moduleCls);
    const moduleName = this.getModuleName(moduleCls);

    const key = `${moduleId}_${moduleName}`;
    if (this.moduleTokenCache.has(key)) {
      return this.moduleTokenCache.get(key)!;
    }

    const hash = this.hashString(key);
    this.moduleTokenCache.set(key, hash);
    return hash;
  }

  public createForDynamic(
    moduleCls: Type<unknown>,
    dynamicMetadata: Omit<DynamicModule, 'module'>,
  ): string {
    const moduleId = this.getModuleId(moduleCls);
    const moduleName = this.getModuleName(moduleCls);
    const opaqueToken = {
      id: moduleId,
      module: moduleName,
      dynamic: dynamicMetadata,
    };
    const start = performance.now();
    const opaqueTokenString = this.getStringifiedOpaqueToken(opaqueToken);
    const timeSpentInMs = performance.now() - start;

    if (timeSpentInMs > 10) {
      const formattedTimeSpent = timeSpentInMs.toFixed(2);
      this.logger.warn(
        `The module "${opaqueToken.module}" is taking ${formattedTimeSpent}ms to serialize, this may be caused by larger objects statically assigned to the module. Consider changing the "moduleIdGeneratorAlgorithm" option to "reference" to improve the performance.`,
      );
    }

    return this.hashString(opaqueTokenString);
  }

  public getStringifiedOpaqueToken(opaqueToken: object | undefined): string {
    // Uses safeStringify instead of JSON.stringify to support circular dynamic modules
    // The replacer function is also required in order to obtain real class names
    // instead of the unified "Function" key
    return opaqueToken ? stringify(opaqueToken, this.replacer) : '';
  }

  public getModuleId(metatype: Type<unknown>): string {
    let moduleId = this.moduleIdsCache.get(metatype);
    if (moduleId) {
      return moduleId;
    }
    moduleId = randomStringGenerator();
    this.moduleIdsCache.set(metatype, moduleId);
    return moduleId;
  }

  public getModuleName(metatype: Type<any>): string {
    return metatype.name;
  }

  private hashString(value: string): string {
    return createHash('sha256').update(value).digest('hex');
  }

  private replacer(key: string, value: any) {
    if (isFunction(value)) {
      const funcAsString = value.toString();
      const isClass = funcAsString.slice(0, CLASS_STR_LEN) === CLASS_STR;
      if (isClass) {
        return value.name;
      }
      return funcAsString;
    }
    if (isSymbol(value)) {
      return value.toString();
    }
    return value;
  }
}



================================================
FILE: packages/core/injector/opaque-key-factory/interfaces/module-opaque-key-factory.interface.ts
================================================
import { DynamicModule } from '@nestjs/common/interfaces/modules/dynamic-module.interface';
import { ForwardReference } from '@nestjs/common/interfaces/modules/forward-reference.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';

export interface ModuleOpaqueKeyFactory {
  /**
   * Creates a unique opaque key for the given static module.
   * @param moduleCls A static module class.
   * @param originalRef Original object reference. In most cases, it's the same as `moduleCls`.
   */
  createForStatic(
    moduleCls: Type,
    originalRef: Type | ForwardReference,
  ): string;
  /**
   * Creates a unique opaque key for the given dynamic module.
   * @param moduleCls  A dynamic module class reference.
   * @param dynamicMetadata Dynamic module metadata.
   * @param originalRef Original object reference.
   */
  createForDynamic(
    moduleCls: Type<unknown>,
    dynamicMetadata: Omit<DynamicModule, 'module'>,
    originalRef: DynamicModule | ForwardReference,
  ): string;
}



================================================
FILE: packages/core/injector/topology-tree/topology-tree.ts
================================================
import { Module } from '../module';
import { TreeNode } from './tree-node';

export class TopologyTree {
  private root: TreeNode<Module>;
  private links: Map<Module, TreeNode<Module>> = new Map();

  constructor(moduleRef: Module) {
    this.root = new TreeNode<Module>({
      value: moduleRef,
      parent: null,
    });
    this.links.set(moduleRef, this.root);
    this.traverseAndMapToTree(this.root);
  }

  public walk(callback: (value: Module, depth: number) => void) {
    function walkNode(node: TreeNode<Module>, depth = 1) {
      callback(node.value, depth);
      node.children.forEach(child => walkNode(child, depth + 1));
    }
    walkNode(this.root);
  }

  private traverseAndMapToTree(node: TreeNode<Module>, depth = 1) {
    if (!node.value.imports) {
      return;
    }
    node.value.imports.forEach(child => {
      if (!child) {
        return;
      }
      if (this.links.has(child)) {
        const existingSubtree = this.links.get(child)!;

        if (node.hasCycleWith(child)) {
          return;
        }
        const existingDepth = existingSubtree.getDepth();
        if (existingDepth < depth) {
          existingSubtree.relink(node);
        }
        return;
      }

      const childNode = new TreeNode<Module>({
        value: child,
        parent: node,
      });
      node.addChild(childNode);

      this.links.set(child, childNode);

      this.traverseAndMapToTree(childNode, depth + 1);
    });
  }
}



================================================
FILE: packages/core/injector/topology-tree/tree-node.ts
================================================
export class TreeNode<T> {
  public readonly value: T;
  public readonly children = new Set<TreeNode<T>>();
  private parent: TreeNode<T> | null;

  constructor({ value, parent }: { value: T; parent: TreeNode<T> | null }) {
    this.value = value;
    this.parent = parent;
  }

  addChild(child: TreeNode<T>) {
    this.children.add(child);
  }

  removeChild(child: TreeNode<T>) {
    this.children.delete(child);
  }

  relink(parent: TreeNode<T>) {
    this.parent?.removeChild(this);

    this.parent = parent;
    this.parent.addChild(this);
  }

  getDepth() {
    const visited = new Set<TreeNode<T>>();

    let depth = 0;
    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let current: TreeNode<T> | null = this;

    while (current) {
      depth++;
      current = current.parent;

      // Stop on cycle
      if (visited.has(current!)) {
        return -1;
      }
      visited.add(current!);
    }
    return depth;
  }

  hasCycleWith(target: T) {
    const visited = new Set<TreeNode<T>>();

    // eslint-disable-next-line @typescript-eslint/no-this-alias
    let current: TreeNode<T> | null = this;

    while (current) {
      if (current.value === target) {
        return true;
      }
      current = current.parent;

      if (visited.has(current!)) {
        return false;
      }
      visited.add(current!);
    }
    return false;
  }
}



================================================
FILE: packages/core/inspector/deterministic-uuid-registry.ts
================================================
export class DeterministicUuidRegistry {
  private static readonly registry = new Map<string, boolean>();

  static get(str: string, inc = 0) {
    const id = inc ? this.hashCode(`${str}_${inc}`) : this.hashCode(str);
    if (this.registry.has(id)) {
      return this.get(str, inc + 1);
    }
    this.registry.set(id, true);
    return id;
  }

  static clear() {
    this.registry.clear();
  }

  private static hashCode(s: string) {
    let h = 0;
    for (let i = 0; i < s.length; i++)
      h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
    return h.toString();
  }
}



================================================
FILE: packages/core/inspector/graph-inspector.ts
================================================
import { UnknownDependenciesException } from '../errors/exceptions/unknown-dependencies.exception';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';
import { DeterministicUuidRegistry } from './deterministic-uuid-registry';
import { EnhancerMetadataCacheEntry } from './interfaces/enhancer-metadata-cache-entry.interface';
import { Entrypoint } from './interfaces/entrypoint.interface';
import { OrphanedEnhancerDefinition } from './interfaces/extras.interface';
import { ClassNode, Node } from './interfaces/node.interface';
import { PartialGraphHost } from './partial-graph.host';
import { SerializedGraph } from './serialized-graph';

export class GraphInspector {
  private readonly graph: SerializedGraph;
  private readonly enhancersMetadataCache =
    new Array<EnhancerMetadataCacheEntry>();

  constructor(private readonly container: NestContainer) {
    this.graph = container.serializedGraph;
  }

  public inspectModules(
    modules: Map<string, Module> = this.container.getModules(),
  ) {
    for (const moduleRef of modules.values()) {
      this.insertModuleNode(moduleRef);
      this.insertClassNodes(moduleRef);
      this.insertModuleToModuleEdges(moduleRef);
    }

    this.enhancersMetadataCache.forEach(entry =>
      this.insertEnhancerEdge(entry),
    );

    DeterministicUuidRegistry.clear();
  }

  public registerPartial(error: unknown) {
    this.graph.status = 'partial';

    if (error instanceof UnknownDependenciesException) {
      this.graph.metadata = {
        cause: {
          type: 'unknown-dependencies',
          context: error.context,
          moduleId: error.moduleRef?.id,
          nodeId: error.metadata?.id,
        },
      };
    } else {
      this.graph.metadata = {
        cause: {
          type: 'unknown',
          error,
        },
      };
    }
    PartialGraphHost.register(this.graph);
  }

  public inspectInstanceWrapper<T = any>(
    source: InstanceWrapper<T>,
    moduleRef: Module,
  ) {
    const ctorMetadata = source.getCtorMetadata();
    ctorMetadata?.forEach((target, index) =>
      this.insertClassToClassEdge(
        source,
        target,
        moduleRef,
        index,
        'constructor',
      ),
    );

    const propertiesMetadata = source.getPropertiesMetadata();
    propertiesMetadata?.forEach(({ key, wrapper: target }) =>
      this.insertClassToClassEdge(source, target, moduleRef, key, 'property'),
    );
  }

  public insertEnhancerMetadataCache(entry: EnhancerMetadataCacheEntry) {
    this.enhancersMetadataCache.push(entry);
  }

  public insertOrphanedEnhancer(entry: OrphanedEnhancerDefinition) {
    this.graph.insertOrphanedEnhancer({
      ...entry,
      ref: entry.ref?.constructor?.name ?? 'Object',
    });
  }

  public insertAttachedEnhancer(wrapper: InstanceWrapper) {
    const existingNode = this.graph.getNodeById(wrapper.id)!;
    existingNode.metadata.global = true;

    this.graph.insertAttachedEnhancer(existingNode.id);
  }

  public insertEntrypointDefinition<T>(
    definition: Entrypoint<T>,
    parentId: string,
  ) {
    definition = {
      ...definition,
      id: `${definition.classNodeId}_${definition.methodName}`,
    };
    this.graph.insertEntrypoint(definition, parentId);
  }

  public insertClassNode(
    moduleRef: Module,
    wrapper: InstanceWrapper,
    type: Exclude<Node['metadata']['type'], 'module'>,
  ) {
    this.graph.insertNode({
      id: wrapper.id,
      label: wrapper.name,
      parent: moduleRef.id,
      metadata: {
        type,
        internal: wrapper.metatype === moduleRef.metatype,
        sourceModuleName: moduleRef.name,
        durable: wrapper.isDependencyTreeDurable(),
        static: wrapper.isDependencyTreeStatic(),
        scope: wrapper.scope!,
        transient: wrapper.isTransient,
        exported: moduleRef.exports.has(wrapper.token),
        token: wrapper.token,
        subtype: wrapper.subtype,
        initTime: wrapper.initTime!,
      },
    });
  }

  private insertModuleNode(moduleRef: Module) {
    const dynamicMetadata = this.container.getDynamicMetadataByToken(
      moduleRef.token,
    );
    const node: Node = {
      id: moduleRef.id,
      label: moduleRef.name,
      metadata: {
        type: 'module',
        global: moduleRef.isGlobal,
        dynamic: !!dynamicMetadata,
        internal: moduleRef.name === 'InternalCoreModule',
      },
    };
    this.graph.insertNode(node);
  }

  private insertModuleToModuleEdges(moduleRef: Module) {
    for (const targetModuleRef of moduleRef.imports) {
      this.graph.insertEdge({
        source: moduleRef.id,
        target: targetModuleRef.id,
        metadata: {
          type: 'module-to-module',
          sourceModuleName: moduleRef.name,
          targetModuleName: targetModuleRef.name,
        },
      });
    }
  }

  private insertEnhancerEdge(entry: EnhancerMetadataCacheEntry) {
    const moduleRef = this.container.getModuleByKey(entry.moduleToken)!;
    const sourceInstanceWrapper =
      moduleRef.controllers.get(entry.classRef) ??
      moduleRef.providers.get(entry.classRef)!;
    const existingSourceNode = this.graph.getNodeById(
      sourceInstanceWrapper.id,
    ) as ClassNode;
    const enhancers = existingSourceNode.metadata.enhancers ?? [];

    if (entry.enhancerInstanceWrapper) {
      this.insertClassToClassEdge(
        sourceInstanceWrapper,
        entry.enhancerInstanceWrapper,
        moduleRef,
        undefined,
        'decorator',
      );

      enhancers.push({
        id: entry.enhancerInstanceWrapper.id,
        methodKey: entry.methodKey,
        subtype: entry.subtype,
      });
    } else {
      const name =
        entry.enhancerRef!.constructor?.name ??
        (entry.enhancerRef as Function).name;

      enhancers.push({
        name,
        methodKey: entry.methodKey,
        subtype: entry.subtype,
      });
    }
    existingSourceNode.metadata.enhancers = enhancers;
  }

  private insertClassToClassEdge<T>(
    source: InstanceWrapper<T>,
    target: InstanceWrapper,
    moduleRef: Module,
    keyOrIndex: number | string | symbol | undefined,
    injectionType: 'constructor' | 'property' | 'decorator',
  ) {
    this.graph.insertEdge({
      source: source.id,
      target: target.id,
      metadata: {
        type: 'class-to-class',
        sourceModuleName: moduleRef.name,
        sourceClassName: source.name,
        targetClassName: target.name,
        sourceClassToken: source.token,
        targetClassToken: target.token,
        targetModuleName: target.host?.name as string,
        keyOrIndex,
        injectionType,
      },
    });
  }

  private insertClassNodes(moduleRef: Module) {
    moduleRef.providers.forEach(value =>
      this.insertClassNode(moduleRef, value, 'provider'),
    );
    moduleRef.injectables.forEach(value =>
      this.insertClassNode(moduleRef, value, 'injectable'),
    );
    moduleRef.controllers.forEach(value =>
      this.insertClassNode(moduleRef, value, 'controller'),
    );
  }
}



================================================
FILE: packages/core/inspector/index.ts
================================================
export * from './graph-inspector';
export * from './initialize-on-preview.allowlist';
export * from './partial-graph.host';
export * from './serialized-graph';



================================================
FILE: packages/core/inspector/initialize-on-preview.allowlist.ts
================================================
import { Type } from '@nestjs/common';

export class InitializeOnPreviewAllowlist {
  private static readonly allowlist = new WeakMap<Type, boolean>();

  public static add(type: Type) {
    this.allowlist.set(type, true);
  }

  public static has(type: Type) {
    return this.allowlist.has(type);
  }
}



================================================
FILE: packages/core/inspector/noop-graph-inspector.ts
================================================
import { GraphInspector } from './graph-inspector';

const noop = () => {};
export const NoopGraphInspector: GraphInspector = new Proxy(
  GraphInspector.prototype,
  {
    get: () => noop,
  },
);



================================================
FILE: packages/core/inspector/partial-graph.host.ts
================================================
import { SerializedGraph } from './serialized-graph';

export class PartialGraphHost {
  private static partialGraph: SerializedGraph;

  static toJSON() {
    return this.partialGraph?.toJSON();
  }

  static toString() {
    return this.partialGraph?.toString();
  }

  static register(partialGraph: SerializedGraph) {
    this.partialGraph = partialGraph;
  }
}



================================================
FILE: packages/core/inspector/serialized-graph.ts
================================================
import { InjectionToken } from '@nestjs/common';
import { ApplicationConfig } from '../application-config';
import { ExternalContextCreator } from '../helpers/external-context-creator';
import { HttpAdapterHost } from '../helpers/http-adapter-host';
import { INQUIRER } from '../injector/inquirer/inquirer-constants';
import { LazyModuleLoader } from '../injector/lazy-module-loader/lazy-module-loader';
import { ModuleRef } from '../injector/module-ref';
import { ModulesContainer } from '../injector/modules-container';
import { REQUEST } from '../router/request/request-constants';
import { Reflector } from '../services/reflector.service';
import { DeterministicUuidRegistry } from './deterministic-uuid-registry';
import { Edge } from './interfaces/edge.interface';
import { Entrypoint } from './interfaces/entrypoint.interface';
import {
  Extras,
  OrphanedEnhancerDefinition,
} from './interfaces/extras.interface';
import { Node } from './interfaces/node.interface';
import { SerializedGraphJson } from './interfaces/serialized-graph-json.interface';
import { SerializedGraphMetadata } from './interfaces/serialized-graph-metadata.interface';

export type SerializedGraphStatus = 'partial' | 'complete';
type WithOptionalId<T extends Record<'id', string>> = Omit<T, 'id'> &
  Partial<Pick<T, 'id'>>;

export class SerializedGraph {
  private readonly nodes = new Map<string, Node>();
  private readonly edges = new Map<string, Edge>();
  private readonly entrypoints = new Map<string, Entrypoint<unknown>[]>();
  private readonly extras: Extras = {
    orphanedEnhancers: [],
    attachedEnhancers: [],
  };
  private _status: SerializedGraphStatus = 'complete';
  private _metadata?: SerializedGraphMetadata;

  private static readonly INTERNAL_PROVIDERS: Array<InjectionToken> = [
    ApplicationConfig,
    ModuleRef,
    HttpAdapterHost,
    LazyModuleLoader,
    ExternalContextCreator,
    ModulesContainer,
    Reflector,
    SerializedGraph,
    HttpAdapterHost.name,
    Reflector.name,
    REQUEST,
    INQUIRER,
  ];

  set status(status: SerializedGraphStatus) {
    this._status = status;
  }

  set metadata(metadata: SerializedGraphMetadata) {
    this._metadata = metadata;
  }

  public insertNode(nodeDefinition: Node) {
    if (
      nodeDefinition.metadata.type === 'provider' &&
      SerializedGraph.INTERNAL_PROVIDERS.includes(nodeDefinition.metadata.token)
    ) {
      nodeDefinition.metadata = {
        ...nodeDefinition.metadata,
        internal: true,
      };
    }
    if (this.nodes.has(nodeDefinition.id)) {
      return this.nodes.get(nodeDefinition.id);
    }
    this.nodes.set(nodeDefinition.id, nodeDefinition);
    return nodeDefinition;
  }

  public insertEdge(edgeDefinition: WithOptionalId<Edge>) {
    if (
      edgeDefinition.metadata.type === 'class-to-class' &&
      (SerializedGraph.INTERNAL_PROVIDERS.includes(
        edgeDefinition.metadata.sourceClassToken,
      ) ||
        SerializedGraph.INTERNAL_PROVIDERS.includes(
          edgeDefinition.metadata.targetClassToken,
        ))
    ) {
      edgeDefinition.metadata = {
        ...edgeDefinition.metadata,
        internal: true,
      };
    }
    const id =
      edgeDefinition.id ?? this.generateUuidByEdgeDefinition(edgeDefinition);
    const edge = {
      ...edgeDefinition,
      id,
    };
    this.edges.set(id, edge);
    return edge;
  }

  public insertEntrypoint<T>(definition: Entrypoint<T>, parentId: string) {
    if (this.entrypoints.has(parentId)) {
      const existingCollection = this.entrypoints.get(parentId)!;
      existingCollection.push(definition);
    } else {
      this.entrypoints.set(parentId, [definition]);
    }
  }

  public insertOrphanedEnhancer(entry: OrphanedEnhancerDefinition) {
    this.extras.orphanedEnhancers.push(entry);
  }

  public insertAttachedEnhancer(nodeId: string) {
    this.extras.attachedEnhancers.push({
      nodeId,
    });
  }

  public getNodeById(id: string) {
    return this.nodes.get(id);
  }

  public toJSON(): SerializedGraphJson {
    const json: SerializedGraphJson = {
      nodes: Object.fromEntries(this.nodes),
      edges: Object.fromEntries(this.edges),
      entrypoints: Object.fromEntries(this.entrypoints),
      extras: this.extras,
    };

    if (this._status) {
      json['status'] = this._status;
    }
    if (this._metadata) {
      json['metadata'] = this._metadata;
    }
    return json;
  }

  public toString() {
    const replacer = (key: string, value: unknown) => {
      if (typeof value === 'symbol') {
        return value.toString();
      }
      return typeof value === 'function' ? (value.name ?? 'Function') : value;
    };
    return JSON.stringify(this.toJSON(), replacer, 2);
  }

  private generateUuidByEdgeDefinition(
    edgeDefinition: WithOptionalId<Edge>,
  ): string {
    return DeterministicUuidRegistry.get(JSON.stringify(edgeDefinition));
  }
}



================================================
FILE: packages/core/inspector/uuid-factory.ts
================================================
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { DeterministicUuidRegistry } from './deterministic-uuid-registry';

export enum UuidFactoryMode {
  Random = 'random',
  Deterministic = 'deterministic',
}

export class UuidFactory {
  private static _mode = UuidFactoryMode.Random;

  static set mode(value: UuidFactoryMode) {
    this._mode = value;
  }

  static get(key = '') {
    return this._mode === UuidFactoryMode.Deterministic
      ? DeterministicUuidRegistry.get(key)
      : randomStringGenerator();
  }
}



================================================
FILE: packages/core/inspector/interfaces/edge.interface.ts
================================================
import { InjectionToken } from '@nestjs/common';

type CommonEdgeMetadata = {
  sourceModuleName: string;
  targetModuleName: string;
};

type ModuleToModuleEdgeMetadata = {
  type: 'module-to-module';
} & CommonEdgeMetadata;

type ClassToClassEdgeMetadata = {
  type: 'class-to-class';
  sourceClassName: string;
  targetClassName: string;
  sourceClassToken: InjectionToken;
  targetClassToken: InjectionToken;
  injectionType: 'constructor' | 'property' | 'decorator';
  keyOrIndex?: string | number | symbol;
  /**
   * If true, indicates that this edge represents an internal providers connection
   */
  internal?: boolean;
} & CommonEdgeMetadata;

export interface Edge {
  id: string;
  source: string;
  target: string;
  metadata: ModuleToModuleEdgeMetadata | ClassToClassEdgeMetadata;
}



================================================
FILE: packages/core/inspector/interfaces/enhancer-metadata-cache-entry.interface.ts
================================================
import { Type } from '@nestjs/common';
import { EnhancerSubtype } from '@nestjs/common/constants';
import { InstanceWrapper } from '../../injector/instance-wrapper';

export interface EnhancerMetadataCacheEntry {
  targetNodeId?: string;
  moduleToken: string;
  classRef: Type;
  methodKey: string | undefined;
  enhancerRef?: unknown;
  enhancerInstanceWrapper?: InstanceWrapper;
  subtype: EnhancerSubtype;
}



================================================
FILE: packages/core/inspector/interfaces/entrypoint.interface.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';

export type HttpEntrypointMetadata = {
  path: string;
  requestMethod: keyof typeof RequestMethod;
  methodVersion?: VersionValue;
  controllerVersion?: VersionValue;
};

export type MiddlewareEntrypointMetadata = {
  path: string;
  requestMethod: keyof typeof RequestMethod;
  version?: VersionValue;
};

export type Entrypoint<T> = {
  id?: string;
  type: string;
  methodName: string;
  className: string;
  classNodeId: string;
  metadata: { key: string } & T;
};



================================================
FILE: packages/core/inspector/interfaces/extras.interface.ts
================================================
import { EnhancerSubtype } from '@nestjs/common/constants';

/**
 * Enhancers attached through APP_PIPE, APP_GUARD, APP_INTERCEPTOR, and APP_FILTER tokens.
 */
export interface AttachedEnhancerDefinition {
  nodeId: string;
}

/**
 * Enhancers registered through "app.useGlobalPipes()", "app.useGlobalGuards()", "app.useGlobalInterceptors()", and "app.useGlobalFilters()" methods.
 */
export interface OrphanedEnhancerDefinition {
  subtype: EnhancerSubtype;
  ref: unknown;
}

export interface Extras {
  orphanedEnhancers: Array<OrphanedEnhancerDefinition>;
  attachedEnhancers: Array<AttachedEnhancerDefinition>;
}



================================================
FILE: packages/core/inspector/interfaces/node.interface.ts
================================================
import { InjectionToken, Scope } from '@nestjs/common';
import { EnhancerSubtype } from '@nestjs/common/constants';

export type ModuleNode = {
  metadata: {
    type: 'module';
    global: boolean;
    dynamic: boolean;
    internal: boolean;
  };
};

export type ClassNode = {
  parent: string;
  metadata: {
    type: 'provider' | 'controller' | 'middleware' | 'injectable';
    subtype?: EnhancerSubtype;
    sourceModuleName: string;
    durable: boolean;
    static: boolean;
    transient: boolean;
    exported: boolean;
    scope: Scope;
    token: InjectionToken;
    initTime: number;
    /**
     * Enhancers metadata collection
     */
    enhancers?: Array<
      | { id: string; subtype: EnhancerSubtype }
      | { name: string; methodKey?: string; subtype: EnhancerSubtype }
    >;
    /**
     * If true, node is a globally registered enhancer
     */
    global?: boolean;
    /**
     * If true, indicates that this node represents an internal provider
     */
    internal?: boolean;
  };
};

export type Node = {
  id: string;
  label: string;
} & (ClassNode | ModuleNode);



================================================
FILE: packages/core/inspector/interfaces/serialized-graph-json.interface.ts
================================================
import { SerializedGraphStatus } from '../serialized-graph';
import { Edge } from './edge.interface';
import { Entrypoint } from './entrypoint.interface';
import { Extras } from './extras.interface';
import { Node } from './node.interface';
import { SerializedGraphMetadata } from './serialized-graph-metadata.interface';

export interface SerializedGraphJson {
  nodes: Record<string, Node>;
  edges: Record<string, Edge>;
  entrypoints: Record<string, Entrypoint<unknown>[]>;
  extras: Extras;
  status?: SerializedGraphStatus;
  metadata?: SerializedGraphMetadata;
}



================================================
FILE: packages/core/inspector/interfaces/serialized-graph-metadata.interface.ts
================================================
import { InjectorDependencyContext } from '../../injector/injector';

export interface SerializedGraphMetadata {
  cause: {
    type: 'unknown-dependencies' | 'unknown';
    context?: InjectorDependencyContext;
    moduleId?: string;
    nodeId?: string;
    error?: any;
  };
}



================================================
FILE: packages/core/interceptors/index.ts
================================================
export * from './interceptors-consumer';
export * from './interceptors-context-creator';



================================================
FILE: packages/core/interceptors/interceptors-consumer.ts
================================================
import { NestInterceptor, Type } from '@nestjs/common';
import {
  CallHandler,
  ContextType,
  Controller,
} from '@nestjs/common/interfaces';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { AsyncResource } from 'async_hooks';
import { Observable, defer, from as fromPromise } from 'rxjs';
import { mergeAll, switchMap } from 'rxjs/operators';
import { ExecutionContextHost } from '../helpers/execution-context-host';

export class InterceptorsConsumer {
  public async intercept<TContext extends string = ContextType>(
    interceptors: NestInterceptor[],
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    next: () => Promise<unknown>,
    type?: TContext,
  ): Promise<unknown> {
    if (isEmpty(interceptors)) {
      return next();
    }
    const context = this.createContext(args, instance, callback);
    context.setType<TContext>(type!);

    const nextFn = async (i = 0) => {
      if (i >= interceptors.length) {
        return defer(AsyncResource.bind(() => this.transformDeferred(next)));
      }
      const handler: CallHandler = {
        handle: () =>
          defer(AsyncResource.bind(() => nextFn(i + 1))).pipe(mergeAll()),
      };
      return interceptors[i].intercept(context, handler);
    };
    return defer(() => nextFn()).pipe(mergeAll());
  }

  public createContext(
    args: unknown[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
  ): ExecutionContextHost {
    return new ExecutionContextHost(
      args,
      instance.constructor as Type<unknown>,
      callback,
    );
  }

  public transformDeferred(next: () => Promise<any>): Observable<any> {
    return fromPromise(next()).pipe(
      switchMap(res => {
        const isDeferred = res instanceof Promise || res instanceof Observable;
        return isDeferred ? res : Promise.resolve(res);
      }),
    );
  }
}



================================================
FILE: packages/core/interceptors/interceptors-context-creator.ts
================================================
import { INTERCEPTORS_METADATA } from '@nestjs/common/constants';
import { Controller, NestInterceptor, Type } from '@nestjs/common/interfaces';
import { isEmpty, isFunction } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import { ContextCreator } from '../helpers/context-creator';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';

export class InterceptorsContextCreator extends ContextCreator {
  private moduleContext: string;

  constructor(
    private readonly container: NestContainer,
    private readonly config?: ApplicationConfig,
  ) {
    super();
  }

  public create(
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    module: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): NestInterceptor[] {
    this.moduleContext = module;
    return this.createContext(
      instance,
      callback,
      INTERCEPTORS_METADATA,
      contextId,
      inquirerId,
    );
  }

  public createConcreteContext<T extends any[], R extends any[]>(
    metadata: T,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): R {
    if (isEmpty(metadata)) {
      return [] as any[] as R;
    }
    return iterate(metadata)
      .filter(
        interceptor =>
          interceptor && (interceptor.name || interceptor.intercept),
      )
      .map(
        interceptor =>
          this.getInterceptorInstance(interceptor, contextId, inquirerId)!,
      )
      .filter((interceptor: NestInterceptor) =>
        interceptor ? isFunction(interceptor.intercept) : false,
      )
      .toArray() as R;
  }

  public getInterceptorInstance(
    metatype: Function | NestInterceptor,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): NestInterceptor | null {
    const isObject = !!(metatype as NestInterceptor).intercept;
    if (isObject) {
      return metatype as NestInterceptor;
    }
    const instanceWrapper = this.getInstanceByMetatype(
      metatype as Type<unknown>,
    );
    if (!instanceWrapper) {
      return null;
    }
    const instanceHost = instanceWrapper.getInstanceByContextId(
      this.getContextId(contextId, instanceWrapper),
      inquirerId,
    );
    return instanceHost && instanceHost.instance;
  }

  public getInstanceByMetatype(
    metatype: Type<unknown>,
  ): InstanceWrapper | undefined {
    if (!this.moduleContext) {
      return;
    }
    const collection = this.container.getModules();
    const moduleRef = collection.get(this.moduleContext);
    if (!moduleRef) {
      return;
    }
    return moduleRef.injectables.get(metatype);
  }

  public getGlobalMetadata<T extends unknown[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    if (!this.config) {
      return [] as unknown[] as T;
    }
    const globalInterceptors = this.config.getGlobalInterceptors() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalInterceptors;
    }
    const scopedInterceptorWrappers =
      this.config.getGlobalRequestInterceptors() as InstanceWrapper[];
    const scopedInterceptors = iterate(scopedInterceptorWrappers)
      .map(wrapper =>
        wrapper.getInstanceByContextId(
          this.getContextId(contextId, wrapper),
          inquirerId,
        ),
      )
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalInterceptors.concat(scopedInterceptors) as T;
  }
}



================================================
FILE: packages/core/interfaces/module-definition.interface.ts
================================================
import { DynamicModule, ForwardReference } from '@nestjs/common';
import { Type } from '@nestjs/common/interfaces';

export type ModuleDefinition =
  | ForwardReference
  | Type<unknown>
  | DynamicModule
  | Promise<DynamicModule>;



================================================
FILE: packages/core/interfaces/module-override.interface.ts
================================================
import { ModuleDefinition } from './module-definition.interface';

export interface ModuleOverride {
  moduleToReplace: ModuleDefinition;
  newModule: ModuleDefinition;
}



================================================
FILE: packages/core/middleware/builder.ts
================================================
import {
  HttpServer,
  MiddlewareConsumer,
  Type,
} from '@nestjs/common/interfaces';
import {
  MiddlewareConfigProxy,
  MiddlewareConfiguration,
  RouteInfo,
} from '@nestjs/common/interfaces/middleware';
import { stripEndSlash } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { RouteInfoPathExtractor } from './route-info-path-extractor';
import { RoutesMapper } from './routes-mapper';
import { filterMiddleware } from './utils';

export class MiddlewareBuilder implements MiddlewareConsumer {
  private readonly middlewareCollection = new Set<MiddlewareConfiguration>();

  constructor(
    private readonly routesMapper: RoutesMapper,
    private readonly httpAdapter: HttpServer,
    private readonly routeInfoPathExtractor: RouteInfoPathExtractor,
  ) {}

  public apply(
    ...middleware: Array<Type<any> | Function | Array<Type<any> | Function>>
  ): MiddlewareConfigProxy {
    return new MiddlewareBuilder.ConfigProxy(
      this,
      middleware.flat(),
      this.routeInfoPathExtractor,
    );
  }

  public build(): MiddlewareConfiguration[] {
    return [...this.middlewareCollection];
  }

  public getHttpAdapter(): HttpServer {
    return this.httpAdapter;
  }

  private static readonly ConfigProxy = class implements MiddlewareConfigProxy {
    private excludedRoutes: RouteInfo[] = [];

    constructor(
      private readonly builder: MiddlewareBuilder,
      private readonly middleware: Array<Type<any> | Function>,
      private routeInfoPathExtractor: RouteInfoPathExtractor,
    ) {}

    public getExcludedRoutes(): RouteInfo[] {
      return this.excludedRoutes;
    }

    public exclude(
      ...routes: Array<string | RouteInfo>
    ): MiddlewareConfigProxy {
      this.excludedRoutes = [
        ...this.excludedRoutes,
        ...this.getRoutesFlatList(routes).reduce((excludedRoutes, route) => {
          for (const routePath of this.routeInfoPathExtractor.extractPathFrom(
            route,
          )) {
            excludedRoutes.push({
              ...route,
              path: routePath,
            });
          }

          return excludedRoutes;
        }, [] as RouteInfo[]),
      ];

      return this;
    }

    public forRoutes(
      ...routes: Array<string | Type<any> | RouteInfo>
    ): MiddlewareConsumer {
      const { middlewareCollection } = this.builder;

      const flattedRoutes = this.getRoutesFlatList(routes);
      const forRoutes = this.removeOverlappedRoutes(flattedRoutes);
      const configuration = {
        middleware: filterMiddleware(
          this.middleware,
          this.excludedRoutes,
          this.builder.getHttpAdapter(),
        ),
        forRoutes,
      };
      middlewareCollection.add(configuration);
      return this.builder;
    }

    private getRoutesFlatList(
      routes: Array<string | Type<any> | RouteInfo>,
    ): RouteInfo[] {
      const { routesMapper } = this.builder;

      return iterate(routes)
        .map(route => routesMapper.mapRouteToRouteInfo(route))
        .flatten()
        .toArray();
    }

    private removeOverlappedRoutes(routes: RouteInfo[]) {
      const regexMatchParams = /(:[^/]*)/g;
      const wildcard = '([^/]*)';
      const routesWithRegex = routes
        .filter(route => route.path.includes(':'))
        .map(route => ({
          method: route.method,
          path: route.path,
          regex: new RegExp(
            '^(' + route.path.replace(regexMatchParams, wildcard) + ')$',
            'g',
          ),
        }));

      return routes.filter(route => {
        const isOverlapped = (item: { regex: RegExp } & RouteInfo): boolean => {
          if (route.method !== item.method) {
            return false;
          }
          const normalizedRoutePath = stripEndSlash(route.path);
          return (
            normalizedRoutePath !== item.path &&
            item.regex.test(normalizedRoutePath)
          );
        };
        const routeMatch = routesWithRegex.find(isOverlapped);
        return routeMatch === undefined;
      });
    }
  };
}



================================================
FILE: packages/core/middleware/container.ts
================================================
import { InjectionToken, Type } from '@nestjs/common';
import { MiddlewareConfiguration } from '@nestjs/common/interfaces/middleware/middleware-configuration.interface';
import { getClassScope } from '../helpers/get-class-scope';
import { isDurable } from '../helpers/is-durable';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';

export class MiddlewareContainer {
  private readonly middleware = new Map<
    string,
    Map<InjectionToken, InstanceWrapper>
  >();
  private readonly configurationSets = new Map<
    string,
    Set<MiddlewareConfiguration>
  >();

  constructor(private readonly container: NestContainer) {}

  public getMiddlewareCollection(
    moduleKey: string,
  ): Map<InjectionToken, InstanceWrapper> {
    if (!this.middleware.has(moduleKey)) {
      const moduleRef = this.container.getModuleByKey(moduleKey)!;
      this.middleware.set(moduleKey, moduleRef.middlewares);
    }
    return this.middleware.get(moduleKey)!;
  }

  public getConfigurations(): Map<string, Set<MiddlewareConfiguration>> {
    return this.configurationSets;
  }

  public insertConfig(
    configList: MiddlewareConfiguration[],
    moduleKey: string,
  ) {
    const middleware = this.getMiddlewareCollection(moduleKey);
    const targetConfig = this.getTargetConfig(moduleKey)!;

    const configurations = configList || [];
    const insertMiddleware = <T extends Type<unknown>>(metatype: T) => {
      const token = metatype;
      middleware.set(
        token,
        new InstanceWrapper({
          scope: getClassScope(metatype),
          durable: isDurable(metatype),
          name: token?.name ?? token,
          metatype,
          token,
        }),
      );
    };
    configurations.forEach(config => {
      [].concat(config.middleware).map(insertMiddleware);
      targetConfig.add(config);
    });
  }

  private getTargetConfig(moduleName: string) {
    if (!this.configurationSets.has(moduleName)) {
      this.configurationSets.set(
        moduleName,
        new Set<MiddlewareConfiguration>(),
      );
    }
    return this.configurationSets.get(moduleName);
  }
}



================================================
FILE: packages/core/middleware/index.ts
================================================
export * from './builder';



================================================
FILE: packages/core/middleware/middleware-module.ts
================================================
import { HttpServer, InjectionToken, Logger } from '@nestjs/common';
import { RequestMethod } from '@nestjs/common/enums/request-method.enum';
import {
  MiddlewareConfiguration,
  NestMiddleware,
  RouteInfo,
} from '@nestjs/common/interfaces/middleware';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '../application-config';
import { InvalidMiddlewareException } from '../errors/exceptions/invalid-middleware.exception';
import { RuntimeException } from '../errors/exceptions/runtime.exception';
import { ContextIdFactory } from '../helpers/context-id-factory';
import { ExecutionContextHost } from '../helpers/execution-context-host';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { Injector } from '../injector/injector';
import { ContextId, InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';
import { GraphInspector } from '../inspector/graph-inspector';
import {
  Entrypoint,
  MiddlewareEntrypointMetadata,
} from '../inspector/interfaces/entrypoint.interface';
import { REQUEST_CONTEXT_ID } from '../router/request/request-constants';
import { RouterExceptionFilters } from '../router/router-exception-filters';
import { RouterProxy } from '../router/router-proxy';
import { isRequestMethodAll } from '../router/utils';
import { MiddlewareBuilder } from './builder';
import { MiddlewareContainer } from './container';
import { MiddlewareResolver } from './resolver';
import { RouteInfoPathExtractor } from './route-info-path-extractor';
import { RoutesMapper } from './routes-mapper';

export class MiddlewareModule<
  TAppOptions extends
    NestApplicationContextOptions = NestApplicationContextOptions,
> {
  private readonly routerProxy = new RouterProxy();
  private readonly exceptionFiltersCache = new WeakMap();
  private readonly logger = new Logger(MiddlewareModule.name);

  private injector: Injector;
  private routerExceptionFilter: RouterExceptionFilters;
  private routesMapper: RoutesMapper;
  private resolver: MiddlewareResolver;
  private container: NestContainer;
  private httpAdapter: HttpServer;
  private graphInspector: GraphInspector;
  private appOptions: TAppOptions;
  private routeInfoPathExtractor: RouteInfoPathExtractor;

  public async register(
    middlewareContainer: MiddlewareContainer,
    container: NestContainer,
    config: ApplicationConfig,
    injector: Injector,
    httpAdapter: HttpServer,
    graphInspector: GraphInspector,
    options: TAppOptions,
  ) {
    this.appOptions = options;

    const appRef = container.getHttpAdapterRef();
    this.routerExceptionFilter = new RouterExceptionFilters(
      container,
      config,
      appRef,
    );
    this.routesMapper = new RoutesMapper(container, config);
    this.resolver = new MiddlewareResolver(middlewareContainer, injector);
    this.routeInfoPathExtractor = new RouteInfoPathExtractor(config);
    this.injector = injector;
    this.container = container;
    this.httpAdapter = httpAdapter;
    this.graphInspector = graphInspector;

    const modules = container.getModules();
    await this.resolveMiddleware(middlewareContainer, modules);
  }

  public async resolveMiddleware(
    middlewareContainer: MiddlewareContainer,
    modules: Map<string, Module>,
  ) {
    const moduleEntries = [...modules.entries()];
    const loadMiddlewareConfiguration = async ([moduleName, moduleRef]: [
      string,
      Module,
    ]) => {
      await this.loadConfiguration(middlewareContainer, moduleRef, moduleName);
      await this.resolver.resolveInstances(moduleRef, moduleName);
    };
    await Promise.all(moduleEntries.map(loadMiddlewareConfiguration));
  }

  public async loadConfiguration(
    middlewareContainer: MiddlewareContainer,
    moduleRef: Module,
    moduleKey: string,
  ) {
    const { instance } = moduleRef;
    if (!instance.configure) {
      return;
    }
    const middlewareBuilder = new MiddlewareBuilder(
      this.routesMapper,
      this.httpAdapter,
      this.routeInfoPathExtractor,
    );
    try {
      await instance.configure(middlewareBuilder);
    } catch (err) {
      if (!this.appOptions.preview) {
        throw err;
      }
      const warningMessage =
        `Warning! "${moduleRef.name}" module exposes a "configure" method that throws an exception in the preview mode` +
        ` (possibly due to missing dependencies). Note: you can ignore this message, just be aware that some of those conditional middlewares will not be reflected in your graph.`;
      this.logger.warn(warningMessage);
    }

    if (!(middlewareBuilder instanceof MiddlewareBuilder)) {
      return;
    }
    const config = middlewareBuilder.build();
    middlewareContainer.insertConfig(config, moduleKey);
  }

  public async registerMiddleware(
    middlewareContainer: MiddlewareContainer,
    applicationRef: any,
  ) {
    const configs = middlewareContainer.getConfigurations();
    const registerAllConfigs = async (
      moduleKey: string,
      middlewareConfig: MiddlewareConfiguration[],
    ) => {
      for (const config of middlewareConfig) {
        await this.registerMiddlewareConfig(
          middlewareContainer,
          config,
          moduleKey,
          applicationRef,
        );
      }
    };

    const entriesSortedByDistance = [...configs.entries()].sort(
      ([moduleA], [moduleB]) => {
        const moduleARef = this.container.getModuleByKey(moduleA)!;
        const moduleBRef = this.container.getModuleByKey(moduleB)!;
        const isModuleAGlobal = moduleARef.distance === Number.MAX_VALUE;
        const isModuleBGlobal = moduleBRef.distance === Number.MAX_VALUE;
        if (isModuleAGlobal && isModuleBGlobal) {
          return 0;
        }
        if (isModuleAGlobal) {
          return -1;
        }
        if (isModuleBGlobal) {
          return 1;
        }
        return moduleARef.distance - moduleBRef.distance;
      },
    );
    for (const [moduleRef, moduleConfigurations] of entriesSortedByDistance) {
      await registerAllConfigs(moduleRef, [...moduleConfigurations]);
    }
  }

  public async registerMiddlewareConfig(
    middlewareContainer: MiddlewareContainer,
    config: MiddlewareConfiguration,
    moduleKey: string,
    applicationRef: any,
  ) {
    const { forRoutes } = config;
    for (const routeInfo of forRoutes) {
      await this.registerRouteMiddleware(
        middlewareContainer,
        routeInfo as RouteInfo,
        config,
        moduleKey,
        applicationRef,
      );
    }
  }

  public async registerRouteMiddleware(
    middlewareContainer: MiddlewareContainer,
    routeInfo: RouteInfo,
    config: MiddlewareConfiguration,
    moduleKey: string,
    applicationRef: any,
  ) {
    const middlewareCollection = [].concat(config.middleware);
    const moduleRef = this.container.getModuleByKey(moduleKey)!;

    for (const metatype of middlewareCollection) {
      const collection = middlewareContainer.getMiddlewareCollection(moduleKey);
      const instanceWrapper = collection.get(metatype);

      if (isUndefined(instanceWrapper)) {
        throw new RuntimeException();
      }
      if (instanceWrapper.isTransient) {
        return;
      }

      this.graphInspector.insertClassNode(
        moduleRef,
        instanceWrapper,
        'middleware',
      );
      const middlewareDefinition: Entrypoint<MiddlewareEntrypointMetadata> = {
        type: 'middleware',
        methodName: 'use',
        className: instanceWrapper.name,
        classNodeId: instanceWrapper.id,
        metadata: {
          key: routeInfo.path,
          path: routeInfo.path,
          requestMethod:
            (RequestMethod[routeInfo.method] as keyof typeof RequestMethod) ??
            'ALL',
          version: routeInfo.version,
        },
      };
      this.graphInspector.insertEntrypointDefinition(
        middlewareDefinition,
        instanceWrapper.id,
      );

      await this.bindHandler(
        instanceWrapper,
        applicationRef,
        routeInfo,
        moduleRef,
        collection,
      );
    }
  }

  private async bindHandler(
    wrapper: InstanceWrapper<NestMiddleware>,
    applicationRef: HttpServer,
    routeInfo: RouteInfo,
    moduleRef: Module,
    collection: Map<InjectionToken, InstanceWrapper>,
  ) {
    const { instance, metatype } = wrapper;

    if (isUndefined(instance?.use)) {
      throw new InvalidMiddlewareException(metatype!.name);
    }
    const isStatic = wrapper.isDependencyTreeStatic();
    if (isStatic) {
      const proxy = await this.createProxy(instance);
      return this.registerHandler(applicationRef, routeInfo, proxy);
    }

    const isTreeDurable = wrapper.isDependencyTreeDurable();

    await this.registerHandler(
      applicationRef,
      routeInfo,
      async <TRequest, TResponse>(
        req: TRequest,
        res: TResponse,
        next: () => void,
      ) => {
        try {
          const contextId = this.getContextId(req, isTreeDurable);
          const contextInstance = await this.injector.loadPerContext(
            instance,
            moduleRef,
            collection,
            contextId,
          );
          const proxy = await this.createProxy<TRequest, TResponse>(
            contextInstance,
            contextId,
          );
          return proxy(req, res, next);
        } catch (err) {
          let exceptionsHandler = this.exceptionFiltersCache.get(instance.use);
          if (!exceptionsHandler) {
            exceptionsHandler = this.routerExceptionFilter.create(
              instance,
              instance.use,
              undefined,
            );
            this.exceptionFiltersCache.set(instance.use, exceptionsHandler);
          }
          const host = new ExecutionContextHost([req, res, next]);
          exceptionsHandler.next(err, host);
        }
      },
    );
  }

  private async createProxy<TRequest = unknown, TResponse = unknown>(
    instance: NestMiddleware,
    contextId = STATIC_CONTEXT,
  ): Promise<(req: TRequest, res: TResponse, next: () => void) => void> {
    const exceptionsHandler = this.routerExceptionFilter.create(
      instance,
      instance.use,
      undefined,
      contextId,
    );
    const middleware = instance.use.bind(instance);
    return this.routerProxy.createProxy(middleware, exceptionsHandler);
  }

  private async registerHandler(
    applicationRef: HttpServer,
    routeInfo: RouteInfo,
    proxy: <TRequest, TResponse>(
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => void,
  ) {
    const { method } = routeInfo;
    const paths = this.routeInfoPathExtractor.extractPathsFrom(routeInfo);
    const isMethodAll = isRequestMethodAll(method);
    const requestMethod = RequestMethod[method];
    const router = await applicationRef.createMiddlewareFactory(method);
    const middlewareFunction = isMethodAll
      ? proxy
      : <TRequest, TResponse>(
          req: TRequest,
          res: TResponse,
          next: () => void,
        ) => {
          if (applicationRef.getRequestMethod?.(req) === requestMethod) {
            return proxy(req, res, next);
          }
          return next();
        };
    const pathsToApplyMiddleware = [] as string[];
    paths.some(path => path.match(/^\/?$/))
      ? pathsToApplyMiddleware.push('/')
      : pathsToApplyMiddleware.push(...paths);
    pathsToApplyMiddleware.forEach(path => router(path, middlewareFunction));
  }

  private getContextId(request: unknown, isTreeDurable: boolean): ContextId {
    const contextId = ContextIdFactory.getByRequest(request as object);
    if (!request![REQUEST_CONTEXT_ID]) {
      Object.defineProperty(request, REQUEST_CONTEXT_ID, {
        value: contextId,
        enumerable: false,
        writable: false,
        configurable: false,
      });

      const requestProviderValue = isTreeDurable
        ? contextId.payload
        : Object.assign(request as object, contextId.payload);
      this.container.registerRequestProvider(requestProviderValue, contextId);
    }
    return contextId;
  }
}



================================================
FILE: packages/core/middleware/resolver.ts
================================================
import { InjectionToken } from '@nestjs/common';
import { Injector } from '../injector/injector';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';
import { MiddlewareContainer } from './container';

export class MiddlewareResolver {
  constructor(
    private readonly middlewareContainer: MiddlewareContainer,
    private readonly injector: Injector,
  ) {}

  public async resolveInstances(moduleRef: Module, moduleName: string) {
    const middlewareMap =
      this.middlewareContainer.getMiddlewareCollection(moduleName);
    const resolveInstance = async (wrapper: InstanceWrapper) =>
      this.resolveMiddlewareInstance(wrapper, middlewareMap, moduleRef);
    await Promise.all([...middlewareMap.values()].map(resolveInstance));
  }

  private async resolveMiddlewareInstance(
    wrapper: InstanceWrapper,
    middlewareMap: Map<InjectionToken, InstanceWrapper>,
    moduleRef: Module,
  ) {
    await this.injector.loadMiddleware(wrapper, middlewareMap, moduleRef);
  }
}



================================================
FILE: packages/core/middleware/route-info-path-extractor.ts
================================================
import { VersioningType } from '@nestjs/common';
import {
  RouteInfo,
  VersioningOptions,
  VersionValue,
} from '@nestjs/common/interfaces';
import {
  addLeadingSlash,
  stripEndSlash,
} from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '../application-config';
import { ExcludeRouteMetadata } from '../router/interfaces/exclude-route-metadata.interface';
import { isRouteExcluded } from '../router/utils';
import { RoutePathFactory } from './../router/route-path-factory';

export class RouteInfoPathExtractor {
  private readonly routePathFactory: RoutePathFactory;
  private readonly prefixPath: string;
  private readonly excludedGlobalPrefixRoutes: ExcludeRouteMetadata[];
  private readonly versioningConfig?: VersioningOptions;

  constructor(private readonly applicationConfig: ApplicationConfig) {
    this.routePathFactory = new RoutePathFactory(applicationConfig);
    this.prefixPath = stripEndSlash(
      addLeadingSlash(this.applicationConfig.getGlobalPrefix()),
    );
    this.excludedGlobalPrefixRoutes =
      this.applicationConfig.getGlobalPrefixOptions().exclude!;
    this.versioningConfig = this.applicationConfig.getVersioning();
  }

  public extractPathsFrom({ path, method, version }: RouteInfo): string[] {
    const versionPaths = this.extractVersionPathFrom(version);

    if (this.isAWildcard(path)) {
      const entries =
        versionPaths.length > 0
          ? versionPaths
              .map(versionPath => [
                this.prefixPath + versionPath + '$',
                this.prefixPath + versionPath + addLeadingSlash(path),
              ])
              .flat()
          : this.prefixPath
            ? [this.prefixPath + '$', this.prefixPath + addLeadingSlash(path)]
            : [addLeadingSlash(path)];

      return Array.isArray(this.excludedGlobalPrefixRoutes)
        ? [
            ...entries,
            ...this.excludedGlobalPrefixRoutes
              .map(route =>
                Array.isArray(versionPaths) && versionPaths.length > 0
                  ? versionPaths.map(v => v + addLeadingSlash(route.path))
                  : addLeadingSlash(route.path),
              )
              .flat(),
          ]
        : entries;
    }

    return this.extractNonWildcardPathsFrom({ path, method, version });
  }

  public extractPathFrom(route: RouteInfo): string[] {
    if (this.isAWildcard(route.path) && !route.version) {
      return [addLeadingSlash(route.path)];
    }

    return this.extractNonWildcardPathsFrom(route);
  }

  private isAWildcard(path: string): boolean {
    const isSimpleWildcard = ['*', '/*', '/*/', '(.*)', '/(.*)'];
    if (isSimpleWildcard.includes(path)) {
      return true;
    }

    const wildcardRegexp = /^\/\{.*\}.*|^\/\*.*$/;
    return wildcardRegexp.test(path);
  }

  private extractNonWildcardPathsFrom({
    path,
    method,
    version,
  }: RouteInfo): string[] {
    const versionPaths = this.extractVersionPathFrom(version);

    if (
      Array.isArray(this.excludedGlobalPrefixRoutes) &&
      isRouteExcluded(this.excludedGlobalPrefixRoutes, path, method)
    ) {
      if (!versionPaths.length) {
        return [addLeadingSlash(path)];
      }

      return versionPaths.map(
        versionPath => versionPath + addLeadingSlash(path),
      );
    }

    if (!versionPaths.length) {
      return [this.prefixPath + addLeadingSlash(path)];
    }
    return versionPaths.map(
      versionPath => this.prefixPath + versionPath + addLeadingSlash(path),
    );
  }

  private extractVersionPathFrom(versionValue?: VersionValue): string[] {
    if (!versionValue || this.versioningConfig?.type !== VersioningType.URI)
      return [];

    const versionPrefix = this.routePathFactory.getVersionPrefix(
      this.versioningConfig,
    );

    if (Array.isArray(versionValue)) {
      return versionValue.map(version =>
        addLeadingSlash(versionPrefix + version.toString()),
      );
    }
    return [addLeadingSlash(versionPrefix + versionValue.toString())];
  }
}



================================================
FILE: packages/core/middleware/routes-mapper.ts
================================================
import {
  MODULE_PATH,
  PATH_METADATA,
  VERSION_METADATA,
} from '@nestjs/common/constants';
import {
  RouteInfo,
  Type,
  VERSION_NEUTRAL,
  VersionValue,
} from '@nestjs/common/interfaces';
import {
  addLeadingSlash,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '../application-config';
import { NestContainer } from '../injector/container';
import { Module } from '../injector/module';
import { MetadataScanner } from '../metadata-scanner';
import { PathsExplorer, RouteDefinition } from '../router/paths-explorer';
import { targetModulesByContainer } from '../router/router-module';

export class RoutesMapper {
  private readonly pathsExplorer: PathsExplorer;

  constructor(
    private readonly container: NestContainer,
    private readonly applicationConfig: ApplicationConfig,
  ) {
    this.pathsExplorer = new PathsExplorer(new MetadataScanner());
  }

  public mapRouteToRouteInfo(
    controllerOrRoute: Type<any> | RouteInfo | string,
  ): RouteInfo[] {
    if (isString(controllerOrRoute)) {
      return this.getRouteInfoFromPath(controllerOrRoute);
    }
    const routePathOrPaths = this.getRoutePath(controllerOrRoute);
    if (this.isRouteInfo(routePathOrPaths, controllerOrRoute)) {
      return this.getRouteInfoFromObject(controllerOrRoute);
    }

    return this.getRouteInfoFromController(
      controllerOrRoute,
      routePathOrPaths!,
    );
  }

  private getRouteInfoFromPath(routePath: string): RouteInfo[] {
    const defaultRequestMethod = -1;
    return [
      {
        path: addLeadingSlash(routePath),
        method: defaultRequestMethod as any,
      },
    ];
  }

  private getRouteInfoFromObject(routeInfoObject: RouteInfo): RouteInfo[] {
    const routeInfo: RouteInfo = {
      path: addLeadingSlash(routeInfoObject.path),
      method: routeInfoObject.method,
    };

    if (routeInfoObject.version) {
      routeInfo.version = routeInfoObject.version;
    }
    return [routeInfo];
  }

  private getRouteInfoFromController(
    controller: Type<any>,
    routePath: string,
  ): RouteInfo[] {
    const controllerPaths = this.pathsExplorer.scanForPaths(
      Object.create(controller),
      controller.prototype,
    );
    const controllerVersion = this.getVersionMetadata(controller);
    const versioningConfig = this.applicationConfig.getVersioning();
    const moduleRef = this.getHostModuleOfController(controller);
    const modulePath = this.getModulePath(moduleRef?.metatype);

    const concatPaths = <T>(acc: T[], currentValue: T[]) =>
      acc.concat(currentValue);

    const toUndefinedIfNeural = (version: VersionValue) =>
      version === VERSION_NEUTRAL ? undefined : version;

    const toRouteInfo = (item: RouteDefinition, prefix: string) =>
      item.path?.flatMap(p => {
        let endpointPath = modulePath ?? '';
        endpointPath += this.normalizeGlobalPath(prefix) + addLeadingSlash(p);

        const routeInfo: RouteInfo = {
          path: endpointPath,
          method: item.requestMethod,
        };
        const version = item.version ?? controllerVersion;
        if (version && versioningConfig) {
          if (typeof version !== 'string' && Array.isArray(version)) {
            return version.map(v => ({
              ...routeInfo,
              version: toUndefinedIfNeural(v),
            }));
          }
          routeInfo.version = toUndefinedIfNeural(version);
        }

        return routeInfo;
      });

    return ([] as string[])
      .concat(routePath)
      .map(routePath =>
        controllerPaths
          .map(item => toRouteInfo(item, routePath))
          .reduce(concatPaths, []),
      )
      .reduce(concatPaths, []);
  }

  private isRouteInfo(
    path: string | string[] | undefined,
    objectOrClass: Function | RouteInfo,
  ): objectOrClass is RouteInfo {
    return isUndefined(path);
  }

  private normalizeGlobalPath(path: string): string {
    const prefix = addLeadingSlash(path);
    return prefix === '/' ? '' : prefix;
  }

  private getRoutePath(route: Type<any> | RouteInfo): string | undefined {
    return Reflect.getMetadata(PATH_METADATA, route);
  }

  private getHostModuleOfController(
    metatype: Type<unknown>,
  ): Module | undefined {
    if (!metatype) {
      return;
    }
    const modulesContainer = this.container.getModules();
    const moduleRefsSet = targetModulesByContainer.get(modulesContainer);
    if (!moduleRefsSet) {
      return;
    }

    const modules = Array.from(modulesContainer.values()).filter(moduleRef =>
      moduleRefsSet.has(moduleRef),
    );
    return modules.find(({ controllers }) => controllers.has(metatype));
  }

  private getModulePath(
    metatype: Type<unknown> | undefined,
  ): string | undefined {
    if (!metatype) {
      return;
    }
    const modulesContainer = this.container.getModules();
    const modulePath = Reflect.getMetadata(
      MODULE_PATH + modulesContainer.applicationId,
      metatype,
    );
    return modulePath ?? Reflect.getMetadata(MODULE_PATH, metatype);
  }

  private getVersionMetadata(
    metatype: Type<unknown> | Function,
  ): VersionValue | undefined {
    const versioningConfig = this.applicationConfig.getVersioning();
    if (versioningConfig) {
      return (
        Reflect.getMetadata(VERSION_METADATA, metatype) ??
        versioningConfig.defaultVersion
      );
    }
  }
}



================================================
FILE: packages/core/middleware/utils.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { HttpServer, RouteInfo, Type } from '@nestjs/common/interfaces';
import {
  addLeadingSlash,
  isFunction,
  isString,
} from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { pathToRegexp } from 'path-to-regexp';
import { uid } from 'uid';
import { ExcludeRouteMetadata } from '../router/interfaces/exclude-route-metadata.interface';
import { LegacyRouteConverter } from '../router/legacy-route-converter';
import { isRouteExcluded } from '../router/utils';

export const mapToExcludeRoute = (
  routes: (string | RouteInfo)[],
): ExcludeRouteMetadata[] => {
  return routes.map(route => {
    const originalPath = isString(route) ? route : route.path;
    const path = LegacyRouteConverter.tryConvert(originalPath);

    try {
      if (isString(route)) {
        return {
          path,
          requestMethod: RequestMethod.ALL,
          pathRegex: pathToRegexp(addLeadingSlash(path)).regexp,
        };
      }
      return {
        path,
        requestMethod: route.method,
        pathRegex: pathToRegexp(addLeadingSlash(path)).regexp,
      };
    } catch (e) {
      if (e instanceof TypeError) {
        LegacyRouteConverter.printError(originalPath);
      }
      throw e;
    }
  });
};

export const filterMiddleware = <T extends Function | Type<any> = any>(
  middleware: T[],
  routes: RouteInfo[],
  httpAdapter: HttpServer,
) => {
  const excludedRoutes = mapToExcludeRoute(routes);
  return iterate([])
    .concat(middleware)
    .filter(isFunction)
    .map((item: T) => mapToClass(item, excludedRoutes, httpAdapter))
    .toArray();
};

export const mapToClass = <T extends Function | Type<any>>(
  middleware: T,
  excludedRoutes: ExcludeRouteMetadata[],
  httpAdapter: HttpServer,
) => {
  if (isMiddlewareClass(middleware)) {
    if (excludedRoutes.length <= 0) {
      return middleware;
    }
    const MiddlewareHost = class extends middleware {
      use(...params: unknown[]) {
        const [req, _, next] = params as [Record<string, any>, any, Function];
        const isExcluded = isMiddlewareRouteExcluded(
          req,
          excludedRoutes,
          httpAdapter,
        );
        if (isExcluded) {
          return next();
        }
        return super.use(...params);
      }
    };
    return assignToken(MiddlewareHost, middleware.name);
  }
  return assignToken(
    class {
      use = (...params: unknown[]) => {
        const [req, _, next] = params as [Record<string, any>, any, Function];
        const isExcluded = isMiddlewareRouteExcluded(
          req,
          excludedRoutes,
          httpAdapter,
        );
        if (isExcluded) {
          return next();
        }
        return (middleware as Function)(...params);
      };
    },
  );
};

export function isMiddlewareClass(middleware: any): middleware is Type<any> {
  const middlewareStr = middleware.toString();
  if (middlewareStr.substring(0, 5) === 'class') {
    return true;
  }
  const middlewareArr = middlewareStr.split(' ');
  return (
    middlewareArr[0] === 'function' &&
    /[A-Z]/.test(middlewareArr[1]?.[0]) &&
    isFunction(middleware.prototype?.use)
  );
}

export function assignToken(metatype: Type<any>, token = uid(21)): Type<any> {
  Object.defineProperty(metatype, 'name', { value: token });
  return metatype;
}

export function isMiddlewareRouteExcluded(
  req: Record<string, any>,
  excludedRoutes: ExcludeRouteMetadata[],
  httpAdapter: HttpServer,
): boolean {
  if (excludedRoutes.length <= 0) {
    return false;
  }
  const reqMethod = httpAdapter.getRequestMethod!(req);
  const originalUrl = httpAdapter.getRequestUrl!(req);
  const queryParamsIndex = originalUrl ? originalUrl.indexOf('?') : -1;
  const pathname =
    queryParamsIndex >= 0
      ? originalUrl.slice(0, queryParamsIndex)
      : originalUrl;

  return isRouteExcluded(excludedRoutes, pathname, RequestMethod[reqMethod]);
}



================================================
FILE: packages/core/pipes/index.ts
================================================
export * from './params-token-factory';
export * from './pipes-consumer';
export * from './pipes-context-creator';



================================================
FILE: packages/core/pipes/params-token-factory.ts
================================================
import { Paramtype } from '@nestjs/common';
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';

export class ParamsTokenFactory {
  public exchangeEnumForString(type: RouteParamtypes): Paramtype {
    switch (type) {
      case RouteParamtypes.BODY:
        return 'body';
      case RouteParamtypes.PARAM:
        return 'param';
      case RouteParamtypes.QUERY:
        return 'query';
      default:
        return 'custom';
    }
  }
}



================================================
FILE: packages/core/pipes/pipes-consumer.ts
================================================
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';
import { ArgumentMetadata, PipeTransform } from '@nestjs/common/interfaces';
import { ParamsTokenFactory } from './params-token-factory';

export class PipesConsumer {
  private readonly paramsTokenFactory = new ParamsTokenFactory();

  public async apply<TInput = unknown>(
    value: TInput,
    { metatype, type, data }: ArgumentMetadata,
    pipes: PipeTransform[],
  ) {
    const token = this.paramsTokenFactory.exchangeEnumForString(
      type as any as RouteParamtypes,
    );
    return this.applyPipes(value, { metatype, type: token, data }, pipes);
  }

  public async applyPipes<TInput = unknown>(
    value: TInput,
    { metatype, type, data }: { metatype: any; type?: any; data?: any },
    transforms: PipeTransform[],
  ) {
    return transforms.reduce(async (deferredValue, pipe) => {
      const val = await deferredValue;
      const result = pipe.transform(val, { metatype, type, data });
      return result;
    }, Promise.resolve(value));
  }
}



================================================
FILE: packages/core/pipes/pipes-context-creator.ts
================================================
import { PIPES_METADATA } from '@nestjs/common/constants';
import { Controller, PipeTransform, Type } from '@nestjs/common/interfaces';
import { isEmpty, isFunction } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import { ContextCreator } from '../helpers/context-creator';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';

export class PipesContextCreator extends ContextCreator {
  private moduleContext: string;

  constructor(
    private readonly container: NestContainer,
    private readonly config?: ApplicationConfig,
  ) {
    super();
  }

  public create(
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    moduleKey: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): PipeTransform[] {
    this.moduleContext = moduleKey;
    return this.createContext(
      instance,
      callback,
      PIPES_METADATA,
      contextId,
      inquirerId,
    );
  }

  public createConcreteContext<T extends any[], R extends any[]>(
    metadata: T,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): R {
    if (isEmpty(metadata)) {
      return [] as any[] as R;
    }
    return iterate(metadata)
      .filter((pipe: any) => pipe && (pipe.name || pipe.transform))
      .map(pipe => this.getPipeInstance(pipe, contextId, inquirerId))
      .filter(pipe => !!pipe && pipe.transform && isFunction(pipe.transform))
      .toArray() as R;
  }

  public getPipeInstance(
    pipe: Function | PipeTransform,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): PipeTransform | null {
    const isObject = !!(pipe as PipeTransform).transform;
    if (isObject) {
      return pipe as PipeTransform;
    }
    const instanceWrapper = this.getInstanceByMetatype(pipe as Type<unknown>);
    if (!instanceWrapper) {
      return null;
    }
    const instanceHost = instanceWrapper.getInstanceByContextId(
      this.getContextId(contextId, instanceWrapper),
      inquirerId,
    );
    return instanceHost && instanceHost.instance;
  }

  public getInstanceByMetatype(
    metatype: Type<unknown>,
  ): InstanceWrapper | undefined {
    if (!this.moduleContext) {
      return;
    }
    const collection = this.container.getModules();
    const moduleRef = collection.get(this.moduleContext);
    if (!moduleRef) {
      return;
    }
    return moduleRef.injectables.get(metatype);
  }

  public getGlobalMetadata<T extends unknown[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    if (!this.config) {
      return [] as unknown[] as T;
    }
    const globalPipes = this.config.getGlobalPipes() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalPipes;
    }
    const scopedPipeWrappers =
      this.config.getGlobalRequestPipes() as InstanceWrapper[];
    const scopedPipes = iterate(scopedPipeWrappers)
      .map(wrapper =>
        wrapper.getInstanceByContextId(
          this.getContextId(contextId, wrapper),
          inquirerId,
        ),
      )
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalPipes.concat(scopedPipes) as T;
  }

  public setModuleContext(context: string) {
    this.moduleContext = context;
  }
}



================================================
FILE: packages/core/repl/assign-to-object.util.ts
================================================
/**
 * Similar to `Object.assign` but copying properties descriptors from `source`
 * as well.
 */
export function assignToObject<T, U extends object>(
  target: T,
  source: U,
): T & U {
  Object.defineProperties(
    target,
    Object.keys(source).reduce((descriptors, key) => {
      descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
      return descriptors;
    }, Object.create(null)),
  );
  return target as T & U;
}



================================================
FILE: packages/core/repl/constants.ts
================================================
export const REPL_INITIALIZED_MESSAGE = 'REPL initialized';



================================================
FILE: packages/core/repl/index.ts
================================================
export * from './repl';



================================================
FILE: packages/core/repl/repl-context.ts
================================================
import {
  INestApplicationContext,
  InjectionToken,
  Logger,
} from '@nestjs/common';
import { ApplicationConfig } from '../application-config';
import { ModuleRef, NestContainer } from '../injector';
import { InternalCoreModule } from '../injector/internal-core-module/internal-core-module';
import { Module } from '../injector/module';
import {
  DebugReplFn,
  GetReplFn,
  HelpReplFn,
  MethodsReplFn,
  ResolveReplFn,
  SelectReplFn,
} from './native-functions';
import { ReplFunction } from './repl-function';
import type { ReplFunctionClass } from './repl.interfaces';

type ModuleKey = string;
export type ModuleDebugEntry = {
  controllers: Record<string, InjectionToken>;
  providers: Record<string, InjectionToken>;
};

type ReplScope = Record<string, any>;

export class ReplContext {
  public readonly logger = new Logger(ReplContext.name);
  public debugRegistry: Record<ModuleKey, ModuleDebugEntry> = {};
  public readonly globalScope: ReplScope = Object.create(null);
  public readonly nativeFunctions = new Map<
    string,
    InstanceType<ReplFunctionClass>
  >();
  private readonly container: NestContainer;

  constructor(
    public readonly app: INestApplicationContext,
    nativeFunctionsClassRefs?: ReplFunctionClass[],
  ) {
    this.container = (app as any).container; // Using `any` because `app.container` is not public.

    this.initializeContext();
    this.initializeNativeFunctions(nativeFunctionsClassRefs || []);
  }

  public writeToStdout(text: string) {
    process.stdout.write(text);
  }

  private initializeContext() {
    const modules = this.container.getModules();

    modules.forEach(moduleRef => {
      let moduleName = moduleRef.metatype.name;
      if (moduleName === InternalCoreModule.name) {
        return;
      }
      if (this.globalScope[moduleName]) {
        moduleName += ` (${moduleRef.token})`;
      }

      this.introspectCollection(moduleRef, moduleName, 'providers');
      this.introspectCollection(moduleRef, moduleName, 'controllers');

      // For in REPL auto-complete functionality
      Object.defineProperty(this.globalScope, moduleName, {
        value: moduleRef.metatype,
        configurable: false,
        enumerable: true,
      });
    });
  }

  private introspectCollection(
    moduleRef: Module,
    moduleKey: ModuleKey,
    collection: keyof ModuleDebugEntry,
  ) {
    const moduleDebugEntry = {};
    moduleRef[collection].forEach(({ token }) => {
      const stringifiedToken = this.stringifyToken(token);
      if (
        stringifiedToken === ApplicationConfig.name ||
        stringifiedToken === moduleRef.metatype.name
      ) {
        return;
      }

      if (!this.globalScope[stringifiedToken]) {
        // For in REPL auto-complete functionality
        Object.defineProperty(this.globalScope, stringifiedToken, {
          value: token,
          configurable: false,
          enumerable: true,
        });
      }

      if (stringifiedToken === ModuleRef.name) {
        return;
      }

      moduleDebugEntry[stringifiedToken] = token;
    });

    this.debugRegistry[moduleKey] = {
      ...this.debugRegistry?.[moduleKey],
      [collection]: moduleDebugEntry,
    };
  }

  private stringifyToken(token: unknown): string {
    return typeof token !== 'string'
      ? typeof token === 'function'
        ? token.name
        : (token?.toString() as string)
      : `"${token}"`;
  }

  private addNativeFunction(
    NativeFunctionRef: ReplFunctionClass,
  ): InstanceType<ReplFunctionClass>[] {
    const nativeFunction = new NativeFunctionRef(this);
    const nativeFunctions = [nativeFunction];

    this.nativeFunctions.set(nativeFunction.fnDefinition.name, nativeFunction);

    nativeFunction.fnDefinition.aliases?.forEach(aliasName => {
      const aliasNativeFunction: InstanceType<ReplFunctionClass> =
        Object.create(nativeFunction);
      aliasNativeFunction.fnDefinition = {
        name: aliasName,
        description: aliasNativeFunction.fnDefinition.description,
        signature: aliasNativeFunction.fnDefinition.signature,
      };
      this.nativeFunctions.set(aliasName, aliasNativeFunction);
      nativeFunctions.push(aliasNativeFunction);
    });

    return nativeFunctions;
  }

  private registerFunctionIntoGlobalScope(
    nativeFunction: InstanceType<ReplFunctionClass>,
  ) {
    // Bind the method to REPL's context:
    this.globalScope[nativeFunction.fnDefinition.name] =
      nativeFunction.action.bind(nativeFunction);

    // Load the help trigger as a `help` getter on each native function:
    const functionBoundRef: ReplFunction['action'] =
      this.globalScope[nativeFunction.fnDefinition.name];
    Object.defineProperty(functionBoundRef, 'help', {
      enumerable: false,
      configurable: false,
      get: () =>
        // Dynamically builds the help message as will unlikely to be called
        // several times.
        this.writeToStdout(nativeFunction.makeHelpMessage()),
    });
  }

  private initializeNativeFunctions(
    nativeFunctionsClassRefs: ReplFunctionClass[],
  ): void {
    const builtInFunctionsClassRefs: ReplFunctionClass[] = [
      HelpReplFn,
      GetReplFn,
      ResolveReplFn,
      SelectReplFn,
      DebugReplFn,
      MethodsReplFn,
    ];

    builtInFunctionsClassRefs
      .concat(nativeFunctionsClassRefs)
      .forEach(NativeFunction => {
        const nativeFunctions = this.addNativeFunction(NativeFunction);
        nativeFunctions.forEach(nativeFunction => {
          this.registerFunctionIntoGlobalScope(nativeFunction);
        });
      });
  }
}



================================================
FILE: packages/core/repl/repl-function.ts
================================================
import { Logger } from '@nestjs/common';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { ReplContext } from './repl-context';
import type { ReplFnDefinition } from './repl.interfaces';

export abstract class ReplFunction<
  ActionParams extends Array<unknown> = Array<unknown>,
  ActionReturn = any,
> {
  /** Metadata that describes the built-in function itself. */
  public abstract fnDefinition: ReplFnDefinition;

  protected readonly logger: Logger;

  constructor(protected readonly ctx: ReplContext) {
    this.logger = ctx.logger;
  }

  /**
   * Method called when the function is invoked from the REPL by the user.
   */
  abstract action(...args: ActionParams): ActionReturn;

  /**
   * @returns A message displayed by calling `<fnName>.help`
   */
  public makeHelpMessage(): string {
    const { description, name, signature } = this.fnDefinition;

    const fnSignatureWithName = `${name}${signature}`;

    return `${clc.yellow(description)}\n${clc.magentaBright(
      'Interface:',
    )} ${clc.bold(fnSignatureWithName)}\n`;
  }
}



================================================
FILE: packages/core/repl/repl-logger.ts
================================================
import { ConsoleLogger } from '@nestjs/common';
import { NestApplication } from '../nest-application';
import { RouterExplorer } from '../router/router-explorer';
import { RoutesResolver } from '../router/routes-resolver';

export class ReplLogger extends ConsoleLogger {
  private static readonly ignoredContexts = [
    RoutesResolver.name,
    RouterExplorer.name,
    NestApplication.name,
  ];

  log(_message: any, context?: string) {
    if (ReplLogger.ignoredContexts.includes(context!)) {
      return;
    }
    // eslint-disable-next-line
    return super.log.apply(this, Array.from(arguments) as [any, string?]);
  }
}



================================================
FILE: packages/core/repl/repl-native-commands.ts
================================================
import type { REPLServer } from 'repl';

/**
 * Displays a list of available commands in the REPL alongside with their
 * descriptions.
 * (c) This code was inspired by the 'help' command from Node.js core:
 * {@link https://github.com/nodejs/node/blob/58b60c1393dd65cd228a8b0084a19acd2c1d16aa/lib/repl.js#L1741-L1759}
 */
function listAllCommands(replServer: REPLServer) {
  Object.keys(replServer.commands)
    .sort()
    .forEach(name => {
      const cmd = replServer.commands[name];
      if (cmd) {
        replServer.output.write(`${name}\t${cmd.help || ''}\n`);
      }
    });
}

export function defineDefaultCommandsOnRepl(replServer: REPLServer): void {
  replServer.defineCommand('help', {
    help: 'Show REPL options',
    action(name?: string) {
      this.clearBufferedCommand();

      if (name) {
        // Considering native commands before native nestjs injected functions.
        const nativeCommandOrFunction =
          this.commands[name] || this.context[name];
        // NOTE: If the command was retrieve from the context, it will have a `help`
        // getter property that outputs the helper message and returns undefined.
        // But if the command was retrieve from the `commands` object, it will
        // have a `help` property that returns the helper message.
        const helpMessage = nativeCommandOrFunction?.help;
        if (helpMessage) {
          this.output.write(`${helpMessage}\n`);
        }
      } else {
        listAllCommands(this);
        this.output.write('\n\n');
        this.context.help();
        this.output.write(
          '\nPress Ctrl+C to abort current expression, Ctrl+D to exit the REPL\n',
        );
      }

      this.displayPrompt();
    },
  });
}



================================================
FILE: packages/core/repl/repl.interfaces.ts
================================================
import type { ReplContext } from './repl-context';
import type { ReplFunction } from './repl-function';

export type ReplFnDefinition = {
  /** Function's name. Note that this should be a valid JavaScript function name. */
  name: string;

  /** Alternative names to the function. */
  aliases?: ReplFnDefinition['name'][];

  /** Function's description to display when `<function>.help` is entered. */
  description: string;

  /**
   * Function's signature following TypeScript _function type expression_ syntax.
   * @example '(token: InjectionToken) => any'
   */
  signature: string;
};

export type ReplFunctionClass = new (replContext: ReplContext) => ReplFunction;



================================================
FILE: packages/core/repl/repl.ts
================================================
import { DynamicModule, Logger, Type } from '@nestjs/common';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { NestFactory } from '../nest-factory';
import { assignToObject } from './assign-to-object.util';
import { REPL_INITIALIZED_MESSAGE } from './constants';
import { ReplContext } from './repl-context';
import { ReplLogger } from './repl-logger';
import { defineDefaultCommandsOnRepl } from './repl-native-commands';

import type { ReplOptions } from 'repl';

export async function repl(
  module: Type | DynamicModule,
  replOptions: ReplOptions = {},
) {
  const app = await NestFactory.createApplicationContext(module, {
    abortOnError: false,
    logger: new ReplLogger(),
  });
  await app.init();

  const replContext = new ReplContext(app);
  Logger.log(REPL_INITIALIZED_MESSAGE);

  const _repl = await import('repl');
  const replServer = _repl.start({
    prompt: clc.green('> '),
    ignoreUndefined: true,
    ...replOptions,
  });
  assignToObject(replServer.context, replContext.globalScope);

  defineDefaultCommandsOnRepl(replServer);

  return replServer;
}



================================================
FILE: packages/core/repl/native-functions/debug-repl-fn.ts
================================================
import type { Type, InjectionToken } from '@nestjs/common';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { ReplFunction } from '../repl-function';
import type { ModuleDebugEntry } from '../repl-context';
import type { ReplFnDefinition } from '../repl.interfaces';

export class DebugReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'debug',
    description:
      'Print all registered modules as a list together with their controllers and providers.\nIf the argument is passed in, for example, "debug(MyModule)" then it will only print components of this specific module.',
    signature: '(moduleCls?: ClassRef | string) => void',
  };

  action(moduleCls?: Type<unknown> | string): void {
    this.ctx.writeToStdout('\n');

    if (moduleCls) {
      const token =
        typeof moduleCls === 'function' ? moduleCls.name : moduleCls;
      const moduleEntry = this.ctx.debugRegistry[token];
      if (!moduleEntry) {
        return this.logger.error(
          `"${token}" has not been found in the modules registry`,
        );
      }
      this.printCtrlsAndProviders(token, moduleEntry);
    } else {
      Object.keys(this.ctx.debugRegistry).forEach(moduleKey => {
        this.printCtrlsAndProviders(
          moduleKey,
          this.ctx.debugRegistry[moduleKey],
        );
      });
    }
    this.ctx.writeToStdout('\n');
  }

  private printCtrlsAndProviders(
    moduleName: string,
    moduleDebugEntry: ModuleDebugEntry,
  ) {
    this.ctx.writeToStdout(`${clc.green(moduleName)}:\n`);
    this.printCollection('controllers', moduleDebugEntry['controllers']);
    this.printCollection('providers', moduleDebugEntry['providers']);
  }

  private printCollection(
    title: string,
    collectionValue: Record<string, InjectionToken>,
  ) {
    const collectionEntries = Object.keys(collectionValue);
    if (collectionEntries.length <= 0) {
      return;
    }

    this.ctx.writeToStdout(` ${clc.yellow(`- ${title}`)}:\n`);
    collectionEntries.forEach(provider =>
      this.ctx.writeToStdout(`  ${clc.green('◻')} ${provider}\n`),
    );
  }
}



================================================
FILE: packages/core/repl/native-functions/get-relp-fn.ts
================================================
import type { Type } from '@nestjs/common';
import { ReplFunction } from '../repl-function';
import type { ReplFnDefinition } from '../repl.interfaces';

export class GetReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'get',
    signature: '(token: InjectionToken) => any',
    description:
      'Retrieves an instance of either injectable or controller, otherwise, throws exception.',
    aliases: ['$'],
  };

  action(token: string | symbol | Function | Type<any>): any {
    return this.ctx.app.get(token);
  }
}



================================================
FILE: packages/core/repl/native-functions/help-repl-fn.ts
================================================
import { iterate } from 'iterare';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { ReplFunction } from '../repl-function';
import type { ReplFnDefinition } from '../repl.interfaces';

export class HelpReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'help',
    signature: '() => void',
    description: 'Display all available REPL native functions.',
  };

  static buildHelpMessage = ({ name, description }: ReplFnDefinition) =>
    clc.cyanBright(name) +
    (description ? ` ${clc.bold('-')} ${description}` : '');

  action(): void {
    const sortedNativeFunctions = iterate(this.ctx.nativeFunctions)
      .map(([, nativeFunction]) => nativeFunction.fnDefinition)
      .toArray()
      .sort((a, b) => (a.name < b.name ? -1 : 1));

    this.ctx.writeToStdout(
      `You can call ${clc.bold(
        '.help',
      )} on any function listed below (e.g.: ${clc.bold('help.help')}):\n\n` +
        sortedNativeFunctions.map(HelpReplFn.buildHelpMessage).join('\n') +
        // Without the following LF the last item won't be displayed
        '\n',
    );
  }
}



================================================
FILE: packages/core/repl/native-functions/index.ts
================================================
export * from './help-repl-fn';
export * from './get-relp-fn';
export * from './resolve-repl-fn';
export * from './select-relp-fn';
export * from './debug-repl-fn';
export * from './methods-repl-fn';



================================================
FILE: packages/core/repl/native-functions/methods-repl-fn.ts
================================================
import type { Type } from '@nestjs/common';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { MetadataScanner } from '../../metadata-scanner';
import { ReplFunction } from '../repl-function';
import type { ReplFnDefinition } from '../repl.interfaces';

export class MethodsReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'methods',
    description:
      'Display all public methods available on a given provider or controller.',
    signature: '(token: ClassRef | string) => void',
  };

  private readonly metadataScanner = new MetadataScanner();

  action(token: Type<unknown> | string): void {
    const proto =
      typeof token !== 'function'
        ? Object.getPrototypeOf(this.ctx.app.get(token))
        : token?.prototype;

    const methods = this.metadataScanner.getAllMethodNames(proto);

    this.ctx.writeToStdout('\n');
    this.ctx.writeToStdout(`${clc.green('Methods')}:\n`);
    methods.forEach(methodName =>
      this.ctx.writeToStdout(` ${clc.yellow('◻')} ${methodName}\n`),
    );
    this.ctx.writeToStdout('\n');
  }
}



================================================
FILE: packages/core/repl/native-functions/resolve-repl-fn.ts
================================================
import type { Type } from '@nestjs/common';
import { ReplFunction } from '../repl-function';
import type { ReplFnDefinition } from '../repl.interfaces';

export class ResolveReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'resolve',
    description:
      'Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.',
    signature: '(token: InjectionToken, contextId: any) => Promise<any>',
  };

  action(
    token: string | symbol | Function | Type<any>,
    contextId: any,
  ): Promise<any> {
    return this.ctx.app.resolve(token, contextId);
  }
}



================================================
FILE: packages/core/repl/native-functions/select-relp-fn.ts
================================================
import type {
  DynamicModule,
  INestApplicationContext,
  Type,
} from '@nestjs/common';
import { ReplFunction } from '../repl-function';
import type { ReplFnDefinition } from '../repl.interfaces';

export class SelectReplFn extends ReplFunction {
  public fnDefinition: ReplFnDefinition = {
    name: 'select',
    description:
      'Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.',
    signature: '(token: DynamicModule | ClassRef) => INestApplicationContext',
  };

  action(token: DynamicModule | Type<unknown>): INestApplicationContext {
    return this.ctx.app.select(token);
  }
}



================================================
FILE: packages/core/router/index.ts
================================================
export * from './interfaces';
export * from './request';
export { RouterModule } from './router-module';



================================================
FILE: packages/core/router/legacy-route-converter.ts
================================================
import { Logger } from '@nestjs/common';

const UNSUPPORTED_PATH_MESSAGE = (text: TemplateStringsArray, route: string) =>
  `Unsupported route path: "${route}". In previous versions, the symbols ?, *, and + were used to denote optional or repeating path parameters. The latest version of "path-to-regexp" now requires the use of named parameters. For example, instead of using a route like /users/* to capture all routes starting with "/users", you should use /users/*path. For more details, refer to the migration guide.`;

export class LegacyRouteConverter {
  private static readonly logger = new Logger(LegacyRouteConverter.name);

  /**
   * Convert legacy routes to the new format (syntax).
   * path-to-regexp used by Express>=v5 and @fastify/middie>=v9 no longer support unnamed wildcards.
   * This method attempts to convert the old syntax to the new one, and logs an error if it fails.
   * @param route The route to convert.
   * @param options Options object.
   * @returns The converted route, or the original route if it cannot be converted.
   */
  static tryConvert(
    route: string,
    options?: {
      logs?: boolean;
    },
  ): string {
    // Normalize path to eliminate additional if statements.
    const routeWithLeadingSlash = route.startsWith('/') ? route : `/${route}`;
    const normalizedRoute = route.endsWith('/')
      ? routeWithLeadingSlash
      : `${routeWithLeadingSlash}/`;

    const loggingEnabled = options?.logs ?? true;
    const printWarning = loggingEnabled
      ? this.printWarning.bind(this)
      : () => {};

    if (normalizedRoute.endsWith('/(.*)/')) {
      // Skip printing warning for the "all" wildcard.
      if (normalizedRoute !== '/(.*)/') {
        printWarning(route);
      }
      return route.replace('(.*)', '{*path}');
    }

    if (normalizedRoute.endsWith('/*/')) {
      // Skip printing warning for the "all" wildcard.
      if (normalizedRoute !== '/*/') {
        printWarning(route);
      }
      return route.replace('*', '{*path}');
    }

    if (normalizedRoute.endsWith('/+/')) {
      printWarning(route);
      return route.replace('/+', '/*path');
    }

    // When route includes any wildcard segments in the middle.
    if (normalizedRoute.includes('/*/')) {
      printWarning(route);
      // Replace each /*/ segment with a named parameter using different name for each segment.
      return route.replaceAll('/*/', (match, offset) => {
        return `/*path${offset}/`;
      });
    }

    return route;
  }

  static printError(route: string): void {
    this.logger.error(UNSUPPORTED_PATH_MESSAGE`${route}`);
  }

  static printWarning(route: string): void {
    this.logger.warn(
      UNSUPPORTED_PATH_MESSAGE`${route}` + ' Attempting to auto-convert...',
    );
  }
}



================================================
FILE: packages/core/router/paths-explorer.ts
================================================
import {
  METHOD_METADATA,
  PATH_METADATA,
  VERSION_METADATA,
} from '@nestjs/common/constants';
import { RequestMethod } from '@nestjs/common/enums';
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { VersionValue } from '@nestjs/common/interfaces/version-options.interface';
import {
  addLeadingSlash,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { MetadataScanner } from '../metadata-scanner';
import { RouterProxyCallback } from './router-proxy';

export interface RouteDefinition {
  path: string[];
  requestMethod: RequestMethod;
  targetCallback: RouterProxyCallback;
  methodName: string;
  version?: VersionValue;
}

export class PathsExplorer {
  constructor(private readonly metadataScanner: MetadataScanner) {}

  public scanForPaths(
    instance: Controller,
    prototype?: object,
  ): RouteDefinition[] {
    const instancePrototype = isUndefined(prototype)
      ? Object.getPrototypeOf(instance)
      : prototype;

    return this.metadataScanner
      .getAllMethodNames(instancePrototype)
      .reduce((acc, method) => {
        const route = this.exploreMethodMetadata(
          instance,
          instancePrototype,
          method,
        );

        if (route) {
          acc.push(route);
        }

        return acc;
      }, [] as RouteDefinition[]);
  }

  public exploreMethodMetadata(
    instance: Controller,
    prototype: object,
    methodName: string,
  ): RouteDefinition | null {
    const instanceCallback = instance[methodName];
    const prototypeCallback = prototype[methodName];
    const routePath = Reflect.getMetadata(PATH_METADATA, prototypeCallback);
    if (isUndefined(routePath)) {
      return null;
    }
    const requestMethod: RequestMethod = Reflect.getMetadata(
      METHOD_METADATA,
      prototypeCallback,
    );
    const version: VersionValue | undefined = Reflect.getMetadata(
      VERSION_METADATA,
      prototypeCallback,
    );
    const path = isString(routePath)
      ? [addLeadingSlash(routePath)]
      : routePath.map((p: string) => addLeadingSlash(p));

    return {
      path,
      requestMethod,
      targetCallback: instanceCallback,
      methodName,
      version,
    };
  }
}



================================================
FILE: packages/core/router/route-params-factory.ts
================================================
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';
import { IRouteParamsFactory } from './interfaces/route-params-factory.interface';

export class RouteParamsFactory implements IRouteParamsFactory {
  public exchangeKeyForValue<
    TRequest extends Record<string, any> = any,
    TResponse = any,
    TResult = any,
  >(
    key: RouteParamtypes | string,
    data: string,
    { req, res, next }: { req: TRequest; res: TResponse; next: Function },
  ): TResult | null {
    switch (key) {
      case RouteParamtypes.NEXT:
        return next as any;
      case RouteParamtypes.REQUEST:
        return req as any;
      case RouteParamtypes.RESPONSE:
        return res as any;
      case RouteParamtypes.BODY:
        return data && req.body ? req.body[data] : req.body;
      case RouteParamtypes.RAW_BODY:
        return req.rawBody;
      case RouteParamtypes.PARAM:
        return data ? req.params[data] : req.params;
      case RouteParamtypes.HOST:
        /* eslint-disable-next-line no-case-declarations */
        const hosts = req.hosts || {};
        return data ? hosts[data] : hosts;
      case RouteParamtypes.QUERY:
        return data ? req.query[data] : req.query;
      case RouteParamtypes.HEADERS:
        return data ? req.headers[data.toLowerCase()] : req.headers;
      case RouteParamtypes.SESSION:
        return req.session;
      case RouteParamtypes.FILE:
        return req[data || 'file'];
      case RouteParamtypes.FILES:
        return req.files;
      case RouteParamtypes.IP:
        return req.ip;
      default:
        return null;
    }
  }
}



================================================
FILE: packages/core/router/route-path-factory.ts
================================================
import {
  RequestMethod,
  VERSION_NEUTRAL,
  VersioningOptions,
  VersioningType,
  flatten,
} from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';
import {
  addLeadingSlash,
  isUndefined,
  stripEndSlash,
} from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '../application-config';
import { RoutePathMetadata } from './interfaces/route-path-metadata.interface';
import { isRouteExcluded } from './utils';

export class RoutePathFactory {
  constructor(private readonly applicationConfig: ApplicationConfig) {}

  public create(
    metadata: RoutePathMetadata,
    requestMethod?: RequestMethod,
  ): string[] {
    let paths = [''];

    const versionOrVersions = this.getVersion(metadata);
    if (
      versionOrVersions &&
      metadata.versioningOptions?.type === VersioningType.URI
    ) {
      const versionPrefix = this.getVersionPrefix(metadata.versioningOptions);

      if (Array.isArray(versionOrVersions)) {
        paths = flatten(
          paths.map(path =>
            versionOrVersions.map(version =>
              // Version Neutral - Do not include version in URL
              version === VERSION_NEUTRAL
                ? path
                : `${path}/${versionPrefix}${version}`,
            ),
          ),
        );
      } else {
        // Version Neutral - Do not include version in URL
        if (versionOrVersions !== VERSION_NEUTRAL) {
          paths = paths.map(
            path => `${path}/${versionPrefix}${versionOrVersions}`,
          );
        }
      }
    }

    paths = this.appendToAllIfDefined(paths, metadata.modulePath);
    paths = this.appendToAllIfDefined(paths, metadata.ctrlPath);
    paths = this.appendToAllIfDefined(paths, metadata.methodPath);

    if (metadata.globalPrefix) {
      paths = paths.map(path => {
        if (
          this.isExcludedFromGlobalPrefix(
            path,
            requestMethod,
            versionOrVersions,
            metadata.versioningOptions,
          )
        ) {
          return path;
        }
        return stripEndSlash(metadata.globalPrefix || '') + path;
      });
    }

    return paths
      .map(path => addLeadingSlash(path || '/'))
      .map(path => (path !== '/' ? stripEndSlash(path) : path));
  }

  public getVersion(metadata: RoutePathMetadata) {
    // The version will be either the path version or the controller version,
    // with the pathVersion taking priority.
    return metadata.methodVersion || metadata.controllerVersion;
  }

  public getVersionPrefix(versioningOptions: VersioningOptions): string {
    const defaultPrefix = 'v';
    if (versioningOptions.type === VersioningType.URI) {
      if (versioningOptions.prefix === false) {
        return '';
      } else if (versioningOptions.prefix !== undefined) {
        return versioningOptions.prefix;
      }
    }
    return defaultPrefix;
  }

  public appendToAllIfDefined(
    paths: string[],
    fragmentToAppend: string | string[] | undefined,
  ): string[] {
    if (!fragmentToAppend) {
      return paths;
    }
    const concatPaths = (a: string, b: string) =>
      stripEndSlash(a) + addLeadingSlash(b);

    if (Array.isArray(fragmentToAppend)) {
      const paths2dArray = paths.map(path =>
        fragmentToAppend.map(fragment => concatPaths(path, fragment)),
      );
      return flatten(paths2dArray);
    }
    return paths.map(path => concatPaths(path, fragmentToAppend));
  }

  public isExcludedFromGlobalPrefix(
    path: string,
    requestMethod?: RequestMethod,
    versionOrVersions?: VersionValue,
    versioningOptions?: VersioningOptions,
  ) {
    if (isUndefined(requestMethod)) {
      return false;
    }
    const options = this.applicationConfig.getGlobalPrefixOptions();
    const excludedRoutes = options.exclude;

    if (
      versionOrVersions &&
      versionOrVersions !== VERSION_NEUTRAL &&
      versioningOptions?.type === VersioningType.URI
    ) {
      path = this.truncateVersionPrefixFromPath(
        path,
        versionOrVersions,
        versioningOptions,
      );
    }
    return (
      Array.isArray(excludedRoutes) &&
      isRouteExcluded(excludedRoutes, path, requestMethod)
    );
  }

  private truncateVersionPrefixFromPath(
    path: string,
    versionValue: Exclude<VersionValue, typeof VERSION_NEUTRAL>,
    versioningOptions: VersioningOptions,
  ) {
    if (typeof versionValue !== 'string') {
      versionValue.forEach(version => {
        if (typeof version === 'string') {
          path = this.truncateVersionPrefixFromPath(
            path,
            version,
            versioningOptions,
          );
        }
      });
      return path;
    }

    const prefix = `/${this.getVersionPrefix(
      versioningOptions,
    )}${versionValue}`;

    return path.startsWith(prefix) ? path.replace(prefix, '') : path;
  }
}



================================================
FILE: packages/core/router/router-exception-filters.ts
================================================
import { HttpServer } from '@nestjs/common';
import { EXCEPTION_FILTERS_METADATA } from '@nestjs/common/constants';
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { iterate } from 'iterare';
import { ApplicationConfig } from '../application-config';
import { BaseExceptionFilterContext } from '../exceptions/base-exception-filter-context';
import { ExceptionsHandler } from '../exceptions/exceptions-handler';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { RouterProxyCallback } from './router-proxy';

export class RouterExceptionFilters extends BaseExceptionFilterContext {
  constructor(
    container: NestContainer,
    private readonly config: ApplicationConfig,
    private readonly applicationRef: HttpServer,
  ) {
    super(container);
  }

  public create(
    instance: Controller,
    callback: RouterProxyCallback,
    moduleKey: string | undefined,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): ExceptionsHandler {
    this.moduleContext = moduleKey!;

    const exceptionHandler = new ExceptionsHandler(this.applicationRef);
    const filters = this.createContext(
      instance,
      callback,
      EXCEPTION_FILTERS_METADATA,
      contextId,
      inquirerId,
    );
    if (isEmpty(filters)) {
      return exceptionHandler;
    }
    exceptionHandler.setCustomFilters(filters.reverse());
    return exceptionHandler;
  }

  public getGlobalMetadata<T extends unknown[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    const globalFilters = this.config.getGlobalFilters() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalFilters;
    }
    const scopedFilterWrappers =
      this.config.getGlobalRequestFilters() as InstanceWrapper[];
    const scopedFilters = iterate(scopedFilterWrappers)
      .map(wrapper => wrapper.getInstanceByContextId(contextId, inquirerId))
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalFilters.concat(scopedFilters) as T;
  }
}



================================================
FILE: packages/core/router/router-execution-context.ts
================================================
import {
  CanActivate,
  ForbiddenException,
  HttpServer,
  ParamData,
  PipeTransform,
  RequestMethod,
} from '@nestjs/common';
import {
  CUSTOM_ROUTE_ARGS_METADATA,
  HEADERS_METADATA,
  HTTP_CODE_METADATA,
  REDIRECT_METADATA,
  RENDER_METADATA,
  ROUTE_ARGS_METADATA,
  SSE_METADATA,
} from '@nestjs/common/constants';
import { RouteParamMetadata } from '@nestjs/common/decorators';
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';
import { ContextType, Controller } from '@nestjs/common/interfaces';
import { isEmpty, isString } from '@nestjs/common/utils/shared.utils';
import { IncomingMessage } from 'http';
import { Observable } from 'rxjs';
import {
  FORBIDDEN_MESSAGE,
  GuardsConsumer,
  GuardsContextCreator,
} from '../guards';
import { ContextUtils } from '../helpers/context-utils';
import { ExecutionContextHost } from '../helpers/execution-context-host';
import {
  HandleResponseFn,
  HandlerMetadata,
  HandlerMetadataStorage,
  HandlerResponseBasicFn,
} from '../helpers/handler-metadata-storage';
import { STATIC_CONTEXT } from '../injector/constants';
import { InterceptorsConsumer } from '../interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '../interceptors/interceptors-context-creator';
import { PipesConsumer } from '../pipes/pipes-consumer';
import { PipesContextCreator } from '../pipes/pipes-context-creator';
import { IRouteParamsFactory } from './interfaces/route-params-factory.interface';
import {
  CustomHeader,
  RedirectResponse,
  RouterResponseController,
} from './router-response-controller';
import { HeaderStream } from './sse-stream';

export interface ParamProperties {
  index: number;
  type: RouteParamtypes | string;
  data: ParamData;
  pipes: PipeTransform[];
  extractValue: <TRequest, TResponse>(
    req: TRequest,
    res: TResponse,
    next: Function,
  ) => any;
}

export class RouterExecutionContext {
  private readonly handlerMetadataStorage = new HandlerMetadataStorage();
  private readonly contextUtils = new ContextUtils();
  private readonly responseController: RouterResponseController;

  constructor(
    private readonly paramsFactory: IRouteParamsFactory,
    private readonly pipesContextCreator: PipesContextCreator,
    private readonly pipesConsumer: PipesConsumer,
    private readonly guardsContextCreator: GuardsContextCreator,
    private readonly guardsConsumer: GuardsConsumer,
    private readonly interceptorsContextCreator: InterceptorsContextCreator,
    private readonly interceptorsConsumer: InterceptorsConsumer,
    readonly applicationRef: HttpServer,
  ) {
    this.responseController = new RouterResponseController(applicationRef);
  }

  public create(
    instance: Controller,
    callback: (...args: any[]) => unknown,
    methodName: string,
    moduleKey: string,
    requestMethod: RequestMethod,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ) {
    const contextType: ContextType = 'http';
    const {
      argsLength,
      fnHandleResponse,
      paramtypes,
      getParamsMetadata,
      httpStatusCode,
      responseHeaders,
      hasCustomHeaders,
    } = this.getMetadata(
      instance,
      callback,
      methodName,
      moduleKey,
      requestMethod,
      contextType,
    );

    const paramsOptions = this.contextUtils.mergeParamsMetatypes(
      getParamsMetadata(moduleKey, contextId, inquirerId),
      paramtypes,
    );
    const pipes = this.pipesContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const guards = this.guardsContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const interceptors = this.interceptorsContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );

    const fnCanActivate = this.createGuardsFn(
      guards,
      instance,
      callback,
      contextType,
    );
    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);

    const handler =
      <TRequest, TResponse>(
        args: any[],
        req: TRequest,
        res: TResponse,
        next: Function,
      ) =>
      async () => {
        fnApplyPipes && (await fnApplyPipes(args, req, res, next));
        return callback.apply(instance, args);
      };

    return async <TRequest, TResponse>(
      req: TRequest,
      res: TResponse,
      next: Function,
    ) => {
      const args = this.contextUtils.createNullArray(argsLength);
      fnCanActivate && (await fnCanActivate([req, res, next]));

      this.responseController.setStatus(res, httpStatusCode);
      hasCustomHeaders &&
        this.responseController.setHeaders(res, responseHeaders);

      const result = await this.interceptorsConsumer.intercept(
        interceptors,
        [req, res, next],
        instance,
        callback,
        handler(args, req, res, next),
        contextType,
      );
      await (fnHandleResponse as HandlerResponseBasicFn)(result, res, req);
    };
  }

  public getMetadata<TContext extends ContextType = ContextType>(
    instance: Controller,
    callback: (...args: any[]) => any,
    methodName: string,
    moduleKey: string,
    requestMethod: RequestMethod,
    contextType: TContext,
  ): HandlerMetadata {
    const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
    if (cacheMetadata) {
      return cacheMetadata;
    }
    const metadata =
      this.contextUtils.reflectCallbackMetadata(
        instance,
        methodName,
        ROUTE_ARGS_METADATA,
      ) || {};
    const keys = Object.keys(metadata);
    const argsLength = this.contextUtils.getArgumentsLength(keys, metadata);
    const paramtypes = this.contextUtils.reflectCallbackParamtypes(
      instance,
      methodName,
    );

    const contextFactory = this.contextUtils.getContextFactory(
      contextType,
      instance,
      callback,
    );
    const getParamsMetadata = (
      moduleKey: string,
      contextId = STATIC_CONTEXT,
      inquirerId?: string,
    ) =>
      this.exchangeKeysForValues(
        keys,
        metadata,
        moduleKey,
        contextId,
        inquirerId,
        contextFactory,
      );

    const paramsMetadata = getParamsMetadata(moduleKey);
    const isResponseHandled = this.isResponseHandled(
      instance,
      methodName,
      paramsMetadata,
    );

    const httpRedirectResponse = this.reflectRedirect(callback);
    const fnHandleResponse = this.createHandleResponseFn(
      callback,
      isResponseHandled,
      httpRedirectResponse,
    );

    const httpCode = this.reflectHttpStatusCode(callback);
    const httpStatusCode = httpCode
      ? httpCode
      : this.responseController.getStatusByMethod(requestMethod);

    const responseHeaders = this.reflectResponseHeaders(callback);
    const hasCustomHeaders = !isEmpty(responseHeaders);
    const handlerMetadata: HandlerMetadata = {
      argsLength,
      fnHandleResponse,
      paramtypes,
      getParamsMetadata,
      httpStatusCode,
      hasCustomHeaders,
      responseHeaders,
    };
    this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
    return handlerMetadata;
  }

  public reflectRedirect(
    callback: (...args: unknown[]) => unknown,
  ): RedirectResponse {
    return Reflect.getMetadata(REDIRECT_METADATA, callback);
  }

  public reflectHttpStatusCode(
    callback: (...args: unknown[]) => unknown,
  ): number {
    return Reflect.getMetadata(HTTP_CODE_METADATA, callback);
  }

  public reflectRenderTemplate(
    callback: (...args: unknown[]) => unknown,
  ): string {
    return Reflect.getMetadata(RENDER_METADATA, callback);
  }

  public reflectResponseHeaders(
    callback: (...args: unknown[]) => unknown,
  ): CustomHeader[] {
    return Reflect.getMetadata(HEADERS_METADATA, callback) || [];
  }

  public reflectSse(callback: (...args: unknown[]) => unknown): string {
    return Reflect.getMetadata(SSE_METADATA, callback);
  }

  public exchangeKeysForValues(
    keys: string[],
    metadata: Record<number, RouteParamMetadata>,
    moduleContext: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
    contextFactory?: (args: unknown[]) => ExecutionContextHost,
  ): ParamProperties[] {
    this.pipesContextCreator.setModuleContext(moduleContext);

    return keys.map(key => {
      const { index, data, pipes: pipesCollection } = metadata[key];
      const pipes = this.pipesContextCreator.createConcreteContext(
        pipesCollection,
        contextId,
        inquirerId,
      );
      const type = this.contextUtils.mapParamType(key);

      if (key.includes(CUSTOM_ROUTE_ARGS_METADATA)) {
        const { factory } = metadata[key];
        const customExtractValue = this.contextUtils.getCustomFactory(
          factory,
          data,
          contextFactory!,
        );
        return { index, extractValue: customExtractValue, type, data, pipes };
      }
      const numericType = Number(type);
      const extractValue = <TRequest, TResponse>(
        req: TRequest,
        res: TResponse,
        next: Function,
      ) =>
        this.paramsFactory.exchangeKeyForValue(numericType, data, {
          req: req as Record<string, any>,
          res,
          next,
        });
      return { index, extractValue, type: numericType, data, pipes };
    });
  }

  public async getParamValue<T>(
    value: T,
    {
      metatype,
      type,
      data,
    }: { metatype: unknown; type: RouteParamtypes; data: unknown },
    pipes: PipeTransform[],
  ): Promise<unknown> {
    if (!isEmpty(pipes)) {
      return this.pipesConsumer.apply(
        value,
        { metatype, type, data } as any,
        pipes,
      );
    }
    return value;
  }

  public isPipeable(type: number | string): boolean {
    return (
      type === RouteParamtypes.BODY ||
      type === RouteParamtypes.RAW_BODY ||
      type === RouteParamtypes.QUERY ||
      type === RouteParamtypes.PARAM ||
      type === RouteParamtypes.FILE ||
      type === RouteParamtypes.FILES ||
      isString(type)
    );
  }

  public createGuardsFn<TContext extends string = ContextType>(
    guards: CanActivate[],
    instance: Controller,
    callback: (...args: any[]) => any,
    contextType?: TContext,
  ): ((args: any[]) => Promise<void>) | null {
    const canActivateFn = async (args: any[]) => {
      const canActivate = await this.guardsConsumer.tryActivate<TContext>(
        guards,
        args,
        instance,
        callback,
        contextType,
      );
      if (!canActivate) {
        throw new ForbiddenException(FORBIDDEN_MESSAGE);
      }
    };
    return guards.length ? canActivateFn : null;
  }

  public createPipesFn(
    pipes: PipeTransform[],
    paramsOptions: (ParamProperties & { metatype?: any })[],
  ) {
    const pipesFn = async <TRequest, TResponse>(
      args: any[],
      req: TRequest,
      res: TResponse,
      next: Function,
    ) => {
      const resolveParamValue = async (
        param: ParamProperties & { metatype?: any },
      ) => {
        const {
          index,
          extractValue,
          type,
          data,
          metatype,
          pipes: paramPipes,
        } = param;
        const value = extractValue(req, res, next);

        args[index] = this.isPipeable(type)
          ? await this.getParamValue(
              value,
              { metatype, type, data } as any,
              pipes.concat(paramPipes),
            )
          : value;
      };
      await Promise.all(paramsOptions.map(resolveParamValue));
    };
    return paramsOptions.length ? pipesFn : null;
  }

  public createHandleResponseFn(
    callback: (...args: unknown[]) => unknown,
    isResponseHandled: boolean,
    redirectResponse?: RedirectResponse,
    httpStatusCode?: number,
  ): HandleResponseFn {
    const renderTemplate = this.reflectRenderTemplate(callback);
    if (renderTemplate) {
      return async <TResult, TResponse>(result: TResult, res: TResponse) => {
        return await this.responseController.render(
          result,
          res,
          renderTemplate,
        );
      };
    }
    if (redirectResponse && isString(redirectResponse.url)) {
      return async <TResult, TResponse>(result: TResult, res: TResponse) => {
        await this.responseController.redirect(result, res, redirectResponse);
      };
    }
    const isSseHandler = !!this.reflectSse(callback);
    if (isSseHandler) {
      return <
        TResult extends Observable<unknown> = any,
        TResponse extends HeaderStream = any,
        TRequest extends IncomingMessage = any,
      >(
        result: TResult,
        res: TResponse,
        req: TRequest,
      ) => {
        this.responseController.sse(
          result,
          (res as any).raw || res,
          (req as any).raw || req,
          { additionalHeaders: res.getHeaders?.() as any },
        );
      };
    }
    return async <TResult, TResponse>(result: TResult, res: TResponse) => {
      result = await this.responseController.transformToResult(result);
      !isResponseHandled &&
        (await this.responseController.apply(result, res, httpStatusCode));
      return res;
    };
  }

  private isResponseHandled(
    instance: Controller,
    methodName: string,
    paramsMetadata: ParamProperties[],
  ): boolean {
    const hasResponseOrNextDecorator = paramsMetadata.some(
      ({ type }) =>
        type === RouteParamtypes.RESPONSE || type === RouteParamtypes.NEXT,
    );
    const isPassthroughEnabled = this.contextUtils.reflectPassthrough(
      instance,
      methodName,
    );
    return hasResponseOrNextDecorator && !isPassthroughEnabled;
  }
}



================================================
FILE: packages/core/router/router-explorer.ts
================================================
import { HttpServer } from '@nestjs/common';
import { PATH_METADATA } from '@nestjs/common/constants';
import { RequestMethod, VersioningType } from '@nestjs/common/enums';
import { InternalServerErrorException } from '@nestjs/common/exceptions';
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { VersionValue } from '@nestjs/common/interfaces/version-options.interface';
import { Logger } from '@nestjs/common/services/logger.service';
import {
  addLeadingSlash,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { pathToRegexp } from 'path-to-regexp';
import { ApplicationConfig } from '../application-config';
import { UnknownRequestMappingException } from '../errors/exceptions/unknown-request-mapping.exception';
import { GuardsConsumer, GuardsContextCreator } from '../guards';
import { ContextIdFactory } from '../helpers/context-id-factory';
import { ExecutionContextHost } from '../helpers/execution-context-host';
import {
  ROUTE_MAPPED_MESSAGE,
  VERSIONED_ROUTE_MAPPED_MESSAGE,
} from '../helpers/messages';
import { RouterMethodFactory } from '../helpers/router-method-factory';
import { STATIC_CONTEXT } from '../injector/constants';
import { NestContainer } from '../injector/container';
import { Injector } from '../injector/injector';
import { ContextId, InstanceWrapper } from '../injector/instance-wrapper';
import { Module } from '../injector/module';
import { GraphInspector } from '../inspector/graph-inspector';
import {
  Entrypoint,
  HttpEntrypointMetadata,
} from '../inspector/interfaces/entrypoint.interface';
import {
  InterceptorsConsumer,
  InterceptorsContextCreator,
} from '../interceptors';
import { MetadataScanner } from '../metadata-scanner';
import { PipesConsumer, PipesContextCreator } from '../pipes';
import { ExceptionsFilter } from './interfaces/exceptions-filter.interface';
import { RoutePathMetadata } from './interfaces/route-path-metadata.interface';
import { PathsExplorer } from './paths-explorer';
import { REQUEST_CONTEXT_ID } from './request/request-constants';
import { RouteParamsFactory } from './route-params-factory';
import { RoutePathFactory } from './route-path-factory';
import { RouterExecutionContext } from './router-execution-context';
import { RouterProxy, RouterProxyCallback } from './router-proxy';

export interface RouteDefinition {
  path: string[];
  requestMethod: RequestMethod;
  targetCallback: RouterProxyCallback;
  methodName: string;
  version?: VersionValue;
}

export class RouterExplorer {
  private readonly executionContextCreator: RouterExecutionContext;
  private readonly pathsExplorer: PathsExplorer;
  private readonly routerMethodFactory = new RouterMethodFactory();
  private readonly logger = new Logger(RouterExplorer.name, {
    timestamp: true,
  });
  private readonly exceptionFiltersCache = new WeakMap();

  constructor(
    metadataScanner: MetadataScanner,
    private readonly container: NestContainer,
    private readonly injector: Injector,
    private readonly routerProxy: RouterProxy,
    private readonly exceptionsFilter: ExceptionsFilter,
    config: ApplicationConfig,
    private readonly routePathFactory: RoutePathFactory,
    private readonly graphInspector: GraphInspector,
  ) {
    this.pathsExplorer = new PathsExplorer(metadataScanner);

    const routeParamsFactory = new RouteParamsFactory();
    const pipesContextCreator = new PipesContextCreator(container, config);
    const pipesConsumer = new PipesConsumer();
    const guardsContextCreator = new GuardsContextCreator(container, config);
    const guardsConsumer = new GuardsConsumer();
    const interceptorsContextCreator = new InterceptorsContextCreator(
      container,
      config,
    );
    const interceptorsConsumer = new InterceptorsConsumer();

    this.executionContextCreator = new RouterExecutionContext(
      routeParamsFactory,
      pipesContextCreator,
      pipesConsumer,
      guardsContextCreator,
      guardsConsumer,
      interceptorsContextCreator,
      interceptorsConsumer,
      container.getHttpAdapterRef(),
    );
  }

  public explore<T extends HttpServer = any>(
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    applicationRef: T,
    host: string | RegExp | Array<string | RegExp>,
    routePathMetadata: RoutePathMetadata,
  ) {
    const { instance } = instanceWrapper;
    const routerPaths = this.pathsExplorer.scanForPaths(instance);
    this.applyPathsToRouterProxy(
      applicationRef,
      routerPaths,
      instanceWrapper,
      moduleKey,
      routePathMetadata,
      host,
    );
  }

  public extractRouterPath(metatype: Type<Controller>): string[] {
    const path = Reflect.getMetadata(PATH_METADATA, metatype);

    if (isUndefined(path)) {
      throw new UnknownRequestMappingException(metatype);
    }
    if (Array.isArray(path)) {
      return path.map(p => addLeadingSlash(p));
    }
    return [addLeadingSlash(path)];
  }

  public applyPathsToRouterProxy<T extends HttpServer>(
    router: T,
    routeDefinitions: RouteDefinition[],
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    (routeDefinitions || []).forEach(routeDefinition => {
      const { version: methodVersion } = routeDefinition;
      routePathMetadata.methodVersion = methodVersion;

      this.applyCallbackToRouter(
        router,
        routeDefinition,
        instanceWrapper,
        moduleKey,
        routePathMetadata,
        host,
      );
    });
  }

  private applyCallbackToRouter<T extends HttpServer>(
    router: T,
    routeDefinition: RouteDefinition,
    instanceWrapper: InstanceWrapper,
    moduleKey: string,
    routePathMetadata: RoutePathMetadata,
    host: string | RegExp | Array<string | RegExp>,
  ) {
    const {
      path: paths,
      requestMethod,
      targetCallback,
      methodName,
    } = routeDefinition;

    const { instance } = instanceWrapper;
    const routerMethodRef = this.routerMethodFactory
      .get(router, requestMethod)
      .bind(router);

    const isRequestScoped = !instanceWrapper.isDependencyTreeStatic();
    const proxy = isRequestScoped
      ? this.createRequestScopedHandler(
          instanceWrapper,
          requestMethod,
          this.container.getModuleByKey(moduleKey)!,
          moduleKey,
          methodName,
        )
      : this.createCallbackProxy(
          instance,
          targetCallback,
          methodName,
          moduleKey,
          requestMethod,
        );

    const isVersioned =
      (routePathMetadata.methodVersion ||
        routePathMetadata.controllerVersion) &&
      routePathMetadata.versioningOptions;
    let routeHandler = this.applyHostFilter(host, proxy);

    paths.forEach(path => {
      if (
        isVersioned &&
        routePathMetadata.versioningOptions!.type !== VersioningType.URI
      ) {
        // All versioning (except for URI Versioning) is done via the "Version Filter"
        routeHandler = this.applyVersionFilter(
          router,
          routePathMetadata,
          routeHandler,
        );
      }

      routePathMetadata.methodPath = path;
      const pathsToRegister = this.routePathFactory.create(
        routePathMetadata,
        requestMethod,
      );
      pathsToRegister.forEach(path => {
        const entrypointDefinition: Entrypoint<HttpEntrypointMetadata> = {
          type: 'http-endpoint',
          methodName,
          className: instanceWrapper.name,
          classNodeId: instanceWrapper.id,
          metadata: {
            key: path,
            path,
            requestMethod: RequestMethod[
              requestMethod
            ] as keyof typeof RequestMethod,
            methodVersion: routePathMetadata.methodVersion,
            controllerVersion: routePathMetadata.controllerVersion,
          },
        };

        this.copyMetadataToCallback(targetCallback, routeHandler);
        const normalizedPath = router.normalizePath
          ? router.normalizePath(path)
          : path;
        routerMethodRef(normalizedPath, routeHandler);

        this.graphInspector.insertEntrypointDefinition<HttpEntrypointMetadata>(
          entrypointDefinition,
          instanceWrapper.id,
        );
      });

      const pathsToLog = this.routePathFactory.create(
        {
          ...routePathMetadata,
          versioningOptions: undefined,
        },
        requestMethod,
      );
      pathsToLog.forEach(path => {
        if (isVersioned) {
          const version = this.routePathFactory.getVersion(routePathMetadata);
          this.logger.log(
            VERSIONED_ROUTE_MAPPED_MESSAGE(path, requestMethod, version!),
          );
        } else {
          this.logger.log(ROUTE_MAPPED_MESSAGE(path, requestMethod));
        }
      });
    });
  }

  private applyHostFilter(
    host: string | RegExp | Array<string | RegExp>,
    handler: Function,
  ) {
    if (!host) {
      return handler;
    }

    const httpAdapterRef = this.container.getHttpAdapterRef();
    const hosts = Array.isArray(host) ? host : [host];
    const hostRegExps = hosts.map((host: string | RegExp) => {
      if (typeof host === 'string') {
        try {
          return pathToRegexp(host);
        } catch (e) {
          if (e instanceof TypeError) {
            this.logger.error(
              `Unsupported host "${host}" syntax. In past releases, ?, *, and + were used to denote optional or repeating path parameters. The latest version of "path-to-regexp" now requires the use of named parameters. For example, instead of using a route like /users/* to capture all routes starting with "/users", you should use /users/*path. Please see the migration guide for more information.`,
            );
          }
          throw e;
        }
      }
      return { regexp: host, keys: [] };
    });

    const unsupportedFilteringErrorMessage = Array.isArray(host)
      ? `HTTP adapter does not support filtering on hosts: ["${host.join(
          '", "',
        )}"]`
      : `HTTP adapter does not support filtering on host: "${host}"`;

    return <TRequest extends Record<string, any> = any, TResponse = any>(
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => {
      (req as Record<string, any>).hosts = {};
      const hostname = httpAdapterRef.getRequestHostname(req) || '';

      for (const exp of hostRegExps) {
        const match = hostname.match(exp.regexp);
        if (match) {
          if (exp.keys.length > 0) {
            exp.keys.forEach((key, i) => (req.hosts[key.name] = match[i + 1]));
          } else if (exp.regexp && match.groups) {
            for (const groupName in match.groups) {
              req.hosts[groupName] = match.groups[groupName];
            }
          }
          return handler(req, res, next);
        }
      }
      if (!next) {
        throw new InternalServerErrorException(
          unsupportedFilteringErrorMessage,
        );
      }
      return next();
    };
  }

  private applyVersionFilter<T extends HttpServer>(
    router: T,
    routePathMetadata: RoutePathMetadata,
    handler: Function,
  ) {
    const version = this.routePathFactory.getVersion(routePathMetadata)!;
    return router.applyVersionFilter(
      handler,
      version,
      routePathMetadata.versioningOptions!,
    );
  }

  private createCallbackProxy(
    instance: Controller,
    callback: RouterProxyCallback,
    methodName: string,
    moduleRef: string,
    requestMethod: RequestMethod,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ) {
    const executionContext = this.executionContextCreator.create(
      instance,
      callback,
      methodName,
      moduleRef,
      requestMethod,
      contextId,
      inquirerId,
    );
    const exceptionFilter = this.exceptionsFilter.create(
      instance,
      callback,
      moduleRef,
      contextId,
      inquirerId,
    );
    return this.routerProxy.createProxy(executionContext, exceptionFilter);
  }

  public createRequestScopedHandler(
    instanceWrapper: InstanceWrapper,
    requestMethod: RequestMethod,
    moduleRef: Module,
    moduleKey: string,
    methodName: string,
  ) {
    const { instance } = instanceWrapper;
    const collection = moduleRef.controllers;

    const isTreeDurable = instanceWrapper.isDependencyTreeDurable();

    return async <TRequest extends Record<any, any>, TResponse>(
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => {
      try {
        const contextId = this.getContextId(req, isTreeDurable);
        const contextInstance = await this.injector.loadPerContext(
          instance,
          moduleRef,
          collection,
          contextId,
        );
        await this.createCallbackProxy(
          contextInstance,
          contextInstance[methodName],
          methodName,
          moduleKey,
          requestMethod,
          contextId,
          instanceWrapper.id,
        )(req, res, next);
      } catch (err) {
        let exceptionFilter = this.exceptionFiltersCache.get(
          instance[methodName],
        );
        if (!exceptionFilter) {
          exceptionFilter = this.exceptionsFilter.create(
            instance,
            instance[methodName],
            moduleKey,
          );
          this.exceptionFiltersCache.set(instance[methodName], exceptionFilter);
        }
        const host = new ExecutionContextHost([req, res, next]);
        exceptionFilter.next(err, host);
      }
    };
  }

  private getContextId<T extends Record<any, unknown> = any>(
    request: T,
    isTreeDurable: boolean,
  ): ContextId {
    const contextId = ContextIdFactory.getByRequest(request);
    if (!request[REQUEST_CONTEXT_ID as any]) {
      Object.defineProperty(request, REQUEST_CONTEXT_ID, {
        value: contextId,
        enumerable: false,
        writable: false,
        configurable: false,
      });

      const requestProviderValue = isTreeDurable
        ? contextId.payload
        : Object.assign(request, contextId.payload);
      this.container.registerRequestProvider(requestProviderValue, contextId);
    }
    return contextId;
  }

  private copyMetadataToCallback(
    originalCallback: RouterProxyCallback,
    targetCallback: Function,
  ) {
    for (const key of Reflect.getMetadataKeys(originalCallback)) {
      Reflect.defineMetadata(
        key,
        Reflect.getMetadata(key, originalCallback),
        targetCallback,
      );
    }
  }
}



================================================
FILE: packages/core/router/router-module.ts
================================================
import { DynamicModule, Inject, Module, Type } from '@nestjs/common';
import { MODULE_PATH } from '@nestjs/common/constants';
import { normalizePath } from '@nestjs/common/utils/shared.utils';
import { Module as ModuleClass } from '../injector/module';
import { ModulesContainer } from '../injector/modules-container';
import { Routes, RouteTree } from './interfaces';
import { flattenRoutePaths } from './utils';

export const ROUTES = Symbol('ROUTES');

export const targetModulesByContainer = new WeakMap<
  ModulesContainer,
  WeakSet<ModuleClass>
>();

/**
 * @publicApi
 */
@Module({})
export class RouterModule {
  constructor(
    private readonly modulesContainer: ModulesContainer,
    @Inject(ROUTES) private readonly routes: Routes,
  ) {
    this.routes = this.deepCloneRoutes(routes) as Routes;
    this.initialize();
  }

  static register(routes: Routes): DynamicModule {
    return {
      module: RouterModule,
      providers: [
        {
          provide: ROUTES,
          useValue: routes,
        },
      ],
    };
  }

  private deepCloneRoutes(
    routes: (RouteTree | Type<any>)[],
  ): (RouteTree | Type<any>)[] {
    return routes.map((routeOrType: Type<any> | RouteTree) => {
      if (typeof routeOrType === 'function') {
        return routeOrType;
      }
      if (routeOrType.children) {
        return {
          ...routeOrType,
          children: this.deepCloneRoutes(routeOrType.children),
        };
      }
      return { ...routeOrType };
    });
  }

  private initialize() {
    const flattenedRoutes = flattenRoutePaths(this.routes);
    flattenedRoutes.forEach(route => {
      const modulePath = normalizePath(route.path);
      this.registerModulePathMetadata(route.module, modulePath);
      this.updateTargetModulesCache(route.module);
    });
  }

  private registerModulePathMetadata(
    moduleCtor: Type<unknown>,
    modulePath: string,
  ) {
    Reflect.defineMetadata(
      MODULE_PATH + this.modulesContainer.applicationId,
      modulePath,
      moduleCtor,
    );
  }

  private updateTargetModulesCache(moduleCtor: Type<unknown>) {
    let moduleClassSet: WeakSet<ModuleClass>;
    if (targetModulesByContainer.has(this.modulesContainer)) {
      moduleClassSet = targetModulesByContainer.get(this.modulesContainer)!;
    } else {
      moduleClassSet = new WeakSet<ModuleClass>();
      targetModulesByContainer.set(this.modulesContainer, moduleClassSet);
    }
    const moduleRef = Array.from(this.modulesContainer.values()).find(
      item => item?.metatype === moduleCtor,
    );
    if (!moduleRef) {
      return;
    }
    moduleClassSet.add(moduleRef);
  }
}



================================================
FILE: packages/core/router/router-proxy.ts
================================================
import { ExceptionsHandler } from '../exceptions/exceptions-handler';
import { ExecutionContextHost } from '../helpers/execution-context-host';

export type RouterProxyCallback = <TRequest, TResponse>(
  req: TRequest,
  res: TResponse,
  next: () => void,
) => void | Promise<void>;

export class RouterProxy {
  public createProxy(
    targetCallback: RouterProxyCallback,
    exceptionsHandler: ExceptionsHandler,
  ) {
    return async <TRequest, TResponse>(
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => {
      try {
        await targetCallback(req, res, next);
      } catch (e) {
        const host = new ExecutionContextHost([req, res, next]);
        exceptionsHandler.next(e, host);
        return res;
      }
    };
  }

  public createExceptionLayerProxy(
    targetCallback: <TError, TRequest, TResponse>(
      err: TError,
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => void | Promise<void>,
    exceptionsHandler: ExceptionsHandler,
  ) {
    return async <TError, TRequest, TResponse>(
      err: TError,
      req: TRequest,
      res: TResponse,
      next: () => void,
    ) => {
      try {
        await targetCallback(err, req, res, next);
      } catch (e) {
        const host = new ExecutionContextHost([req, res, next]);
        exceptionsHandler.next(e, host);
        return res;
      }
    };
  }
}



================================================
FILE: packages/core/router/router-response-controller.ts
================================================
import {
  HttpServer,
  HttpStatus,
  Logger,
  RequestMethod,
  MessageEvent,
} from '@nestjs/common';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { IncomingMessage } from 'http';
import { EMPTY, lastValueFrom, Observable, isObservable } from 'rxjs';
import { catchError, concatMap, map } from 'rxjs/operators';
import {
  AdditionalHeaders,
  WritableHeaderStream,
  SseStream,
} from './sse-stream';

export interface CustomHeader {
  name: string;
  value: string | (() => string);
}

export interface RedirectResponse {
  url: string;
  statusCode?: number;
}

export class RouterResponseController {
  private readonly logger = new Logger(RouterResponseController.name);

  constructor(private readonly applicationRef: HttpServer) {}

  public async apply<TInput = any, TResponse = any>(
    result: TInput,
    response: TResponse,
    httpStatusCode?: number,
  ) {
    return this.applicationRef.reply(response, result, httpStatusCode);
  }

  public async redirect<TInput = any, TResponse = any>(
    resultOrDeferred: TInput,
    response: TResponse,
    redirectResponse: RedirectResponse,
  ) {
    const result = await this.transformToResult(resultOrDeferred);
    const statusCode =
      result && result.statusCode
        ? result.statusCode
        : redirectResponse.statusCode
          ? redirectResponse.statusCode
          : HttpStatus.FOUND;
    const url = result && result.url ? result.url : redirectResponse.url;
    this.applicationRef.redirect(response, statusCode, url);
  }

  public async render<TInput = unknown, TResponse = unknown>(
    resultOrDeferred: TInput,
    response: TResponse,
    template: string,
  ) {
    const result = await this.transformToResult(resultOrDeferred);
    return this.applicationRef.render(response, template, result);
  }

  public async transformToResult(resultOrDeferred: any) {
    if (isObservable(resultOrDeferred)) {
      return lastValueFrom(resultOrDeferred);
    }
    return resultOrDeferred;
  }

  public getStatusByMethod(requestMethod: RequestMethod): number {
    switch (requestMethod) {
      case RequestMethod.POST:
        return HttpStatus.CREATED;
      default:
        return HttpStatus.OK;
    }
  }

  public setHeaders<TResponse = unknown>(
    response: TResponse,
    headers: CustomHeader[],
  ) {
    headers.forEach(({ name, value }) =>
      this.applicationRef.setHeader(
        response,
        name,
        typeof value === 'function' ? value() : value,
      ),
    );
  }

  public setStatus<TResponse = unknown>(
    response: TResponse,
    statusCode: number,
  ) {
    this.applicationRef.status(response, statusCode);
  }

  public sse<
    TInput extends Observable<unknown> = any,
    TResponse extends WritableHeaderStream = any,
    TRequest extends IncomingMessage = any,
  >(
    result: TInput,
    response: TResponse,
    request: TRequest,
    options?: { additionalHeaders: AdditionalHeaders },
  ) {
    // It's possible that we sent headers already so don't use a stream
    if (response.writableEnded) {
      return;
    }

    this.assertObservable(result);

    const stream = new SseStream(request);
    stream.pipe(response, options);

    const subscription = result
      .pipe(
        map((message): MessageEvent => {
          if (isObject(message)) {
            return message as MessageEvent;
          }

          return { data: message as object | string };
        }),
        concatMap(
          message =>
            new Promise<void>(resolve =>
              stream.writeMessage(message, () => resolve()),
            ),
        ),
        catchError(err => {
          const data = err instanceof Error ? err.message : err;
          stream.writeMessage({ type: 'error', data }, writeError => {
            if (writeError) {
              this.logger.error(writeError);
            }
          });

          return EMPTY;
        }),
      )
      .subscribe({
        complete: () => {
          response.end();
        },
      });

    request.on('close', () => {
      subscription.unsubscribe();
      if (!stream.writableEnded) {
        stream.end();
      }
    });
  }

  private assertObservable(value: any) {
    if (!isObservable(value)) {
      throw new ReferenceError(
        'You must return an Observable stream to use Server-Sent Events (SSE).',
      );
    }
  }
}



================================================
FILE: packages/core/router/routes-resolver.ts
================================================
import { BadRequestException, NotFoundException } from '@nestjs/common';
import {
  HOST_METADATA,
  MODULE_PATH,
  VERSION_METADATA,
} from '@nestjs/common/constants';
import {
  Controller,
  HttpServer,
  Type,
  VersionValue,
} from '@nestjs/common/interfaces';
import { Logger } from '@nestjs/common/services/logger.service';
import { ApplicationConfig } from '../application-config';
import {
  CONTROLLER_MAPPING_MESSAGE,
  VERSIONED_CONTROLLER_MAPPING_MESSAGE,
} from '../helpers/messages';
import { NestContainer } from '../injector/container';
import { Injector } from '../injector/injector';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { GraphInspector } from '../inspector/graph-inspector';
import { MetadataScanner } from '../metadata-scanner';
import { Resolver } from './interfaces/resolver.interface';
import { RoutePathMetadata } from './interfaces/route-path-metadata.interface';
import { RoutePathFactory } from './route-path-factory';
import { RouterExceptionFilters } from './router-exception-filters';
import { RouterExplorer } from './router-explorer';
import { RouterProxy } from './router-proxy';

export class RoutesResolver implements Resolver {
  private readonly logger = new Logger(RoutesResolver.name, {
    timestamp: true,
  });
  private readonly routerProxy = new RouterProxy();
  private readonly routePathFactory: RoutePathFactory;
  private readonly routerExceptionsFilter: RouterExceptionFilters;
  private readonly routerExplorer: RouterExplorer;

  constructor(
    private readonly container: NestContainer,
    private readonly applicationConfig: ApplicationConfig,
    private readonly injector: Injector,
    graphInspector: GraphInspector,
  ) {
    const httpAdapterRef = container.getHttpAdapterRef();
    this.routerExceptionsFilter = new RouterExceptionFilters(
      container,
      applicationConfig,
      httpAdapterRef,
    );
    this.routePathFactory = new RoutePathFactory(this.applicationConfig);

    const metadataScanner = new MetadataScanner();
    this.routerExplorer = new RouterExplorer(
      metadataScanner,
      this.container,
      this.injector,
      this.routerProxy,
      this.routerExceptionsFilter,
      this.applicationConfig,
      this.routePathFactory,
      graphInspector,
    );
  }

  public resolve<T extends HttpServer>(
    applicationRef: T,
    globalPrefix: string,
  ) {
    const modules = this.container.getModules();
    modules.forEach(({ controllers, metatype }, moduleName) => {
      const modulePath = this.getModulePathMetadata(metatype)!;
      this.registerRouters(
        controllers,
        moduleName,
        globalPrefix,
        modulePath,
        applicationRef,
      );
    });
  }

  public registerRouters(
    routes: Map<string | symbol | Function, InstanceWrapper<Controller>>,
    moduleName: string,
    globalPrefix: string,
    modulePath: string,
    applicationRef: HttpServer,
  ) {
    routes.forEach(instanceWrapper => {
      const { metatype } = instanceWrapper;

      const host = this.getHostMetadata(metatype!);
      const routerPaths = this.routerExplorer.extractRouterPath(
        metatype as Type<any>,
      );
      const controllerVersion = this.getVersionMetadata(metatype!);
      const controllerName = metatype!.name;

      routerPaths.forEach(path => {
        const pathsToLog = this.routePathFactory.create({
          ctrlPath: path,
          modulePath,
          globalPrefix,
        });
        if (!controllerVersion) {
          pathsToLog.forEach(path => {
            const logMessage = CONTROLLER_MAPPING_MESSAGE(controllerName, path);
            this.logger.log(logMessage);
          });
        } else {
          pathsToLog.forEach(path => {
            const logMessage = VERSIONED_CONTROLLER_MAPPING_MESSAGE(
              controllerName,
              path,
              controllerVersion,
            );
            this.logger.log(logMessage);
          });
        }

        const versioningOptions = this.applicationConfig.getVersioning();
        const routePathMetadata: RoutePathMetadata = {
          ctrlPath: path,
          modulePath,
          globalPrefix,
          controllerVersion,
          versioningOptions,
        };
        this.routerExplorer.explore(
          instanceWrapper,
          moduleName,
          applicationRef,
          host!,
          routePathMetadata,
        );
      });
    });
  }

  public registerNotFoundHandler() {
    const applicationRef = this.container.getHttpAdapterRef();
    const callback = <TRequest, TResponse>(req: TRequest, res: TResponse) => {
      const method = applicationRef.getRequestMethod(req);
      const url = applicationRef.getRequestUrl(req);
      throw new NotFoundException(`Cannot ${method} ${url}`);
    };
    const handler = this.routerExceptionsFilter.create({}, callback, undefined);
    const proxy = this.routerProxy.createProxy(callback, handler);
    applicationRef.setNotFoundHandler &&
      applicationRef.setNotFoundHandler(
        proxy,
        this.applicationConfig.getGlobalPrefix(),
      );
  }

  public registerExceptionHandler() {
    const callback = <TError, TRequest, TResponse>(
      err: TError,
      req: TRequest,
      res: TResponse,
      next: Function,
    ) => {
      throw this.mapExternalException(err);
    };
    const handler = this.routerExceptionsFilter.create(
      {},
      callback as any,
      undefined,
    );
    const proxy = this.routerProxy.createExceptionLayerProxy(callback, handler);
    const applicationRef = this.container.getHttpAdapterRef();
    applicationRef.setErrorHandler &&
      applicationRef.setErrorHandler(
        proxy,
        this.applicationConfig.getGlobalPrefix(),
      );
  }

  public mapExternalException(err: any) {
    switch (true) {
      // SyntaxError is thrown by Express body-parser when given invalid JSON (#422, #430)
      // URIError is thrown by Express when given a path parameter with an invalid percentage
      // encoding, e.g. '%FF' (#8915)
      case err instanceof SyntaxError || err instanceof URIError:
        return new BadRequestException(err.message);
      default:
        return err;
    }
  }

  private getModulePathMetadata(metatype: Type<unknown>): string | undefined {
    const modulesContainer = this.container.getModules();
    const modulePath = Reflect.getMetadata(
      MODULE_PATH + modulesContainer.applicationId,
      metatype,
    );
    return modulePath ?? Reflect.getMetadata(MODULE_PATH, metatype);
  }

  private getHostMetadata(
    metatype: Type<unknown> | Function,
  ): string | string[] | undefined {
    return Reflect.getMetadata(HOST_METADATA, metatype);
  }

  private getVersionMetadata(
    metatype: Type<unknown> | Function,
  ): VersionValue | undefined {
    const versioningConfig = this.applicationConfig.getVersioning();
    if (versioningConfig) {
      return (
        Reflect.getMetadata(VERSION_METADATA, metatype) ??
        versioningConfig.defaultVersion
      );
    }
  }
}



================================================
FILE: packages/core/router/sse-stream.ts
================================================
import { MessageEvent } from '@nestjs/common/interfaces';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { IncomingMessage, OutgoingHttpHeaders } from 'http';
import { Transform } from 'stream';

function toDataString(data: string | object): string {
  if (isObject(data)) {
    return toDataString(JSON.stringify(data));
  }

  return data
    .split(/\r\n|\r|\n/)
    .map(line => `data: ${line}\n`)
    .join('');
}

export type AdditionalHeaders = Record<
  string,
  string[] | string | number | undefined
>;

interface ReadHeaders {
  getHeaders?(): AdditionalHeaders;
}

interface WriteHeaders {
  writableEnded?: boolean;
  writeHead?(
    statusCode: number,
    reasonPhrase?: string,
    headers?: OutgoingHttpHeaders,
  ): void;
  writeHead?(statusCode: number, headers?: OutgoingHttpHeaders): void;
  flushHeaders?(): void;
}

export type WritableHeaderStream = NodeJS.WritableStream & WriteHeaders;
export type HeaderStream = WritableHeaderStream & ReadHeaders;

/**
 * Adapted from https://raw.githubusercontent.com/EventSource/node-ssestream
 * Transforms "messages" to W3C event stream content.
 * See https://html.spec.whatwg.org/multipage/server-sent-events.html
 * A message is an object with one or more of the following properties:
 * - data (String or object, which gets turned into JSON)
 * - type
 * - id
 * - retry
 *
 * If constructed with a HTTP Request, it will optimise the socket for streaming.
 * If this stream is piped to an HTTP Response, it will set appropriate headers.
 */
export class SseStream extends Transform {
  private lastEventId: number | null = null;

  constructor(req?: IncomingMessage) {
    super({ objectMode: true });
    if (req && req.socket) {
      req.socket.setKeepAlive(true);
      req.socket.setNoDelay(true);
      req.socket.setTimeout(0);
    }
  }

  pipe<T extends WritableHeaderStream>(
    destination: T,
    options?: {
      additionalHeaders?: AdditionalHeaders;
      end?: boolean;
    },
  ): T {
    if (destination.writeHead) {
      destination.writeHead(200, {
        ...options?.additionalHeaders,
        // See https://github.com/dunglas/mercure/blob/master/hub/subscribe.go#L124-L130
        'Content-Type': 'text/event-stream',
        Connection: 'keep-alive',
        // Disable cache, even for old browsers and proxies
        'Cache-Control':
          'private, no-cache, no-store, must-revalidate, max-age=0, no-transform',
        Pragma: 'no-cache',
        Expire: '0',
        // NGINX support https://www.nginx.com/resources/wiki/start/topics/examples/x-accel/#x-accel-buffering
        'X-Accel-Buffering': 'no',
      });
      destination.flushHeaders?.();
    }

    destination.write('\n');
    return super.pipe(destination, options);
  }

  _transform(
    message: MessageEvent,
    encoding: string,
    callback: (error?: Error | null, data?: any) => void,
  ) {
    let data = message.type ? `event: ${message.type}\n` : '';
    data += message.id ? `id: ${message.id}\n` : '';
    data += message.retry ? `retry: ${message.retry}\n` : '';
    data += message.data ? toDataString(message.data) : '';
    data += '\n';
    this.push(data);
    callback();
  }

  /**
   * Calls `.write` but handles the drain if needed
   */
  writeMessage(
    message: MessageEvent,
    cb: (error: Error | null | undefined) => void,
  ) {
    if (!message.id) {
      this.lastEventId!++;
      message.id = this.lastEventId!.toString();
    }

    if (!this.write(message, 'utf-8')) {
      this.once('drain', cb);
    } else {
      process.nextTick(cb);
    }
  }
}



================================================
FILE: packages/core/router/interfaces/exceptions-filter.interface.ts
================================================
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { ExceptionsHandler } from '../../exceptions/exceptions-handler';
import { ContextId } from '../../injector/instance-wrapper';

export interface ExceptionsFilter {
  create(
    instance: Controller,
    callback: Function,
    module: string,
    contextId?: ContextId,
    inquirerId?: string,
  ): ExceptionsHandler;
}



================================================
FILE: packages/core/router/interfaces/exclude-route-metadata.interface.ts
================================================
import { RequestMethod } from '@nestjs/common';

export interface ExcludeRouteMetadata {
  /**
   * Route path.
   */
  path: string;

  /**
   * Regular expression representing the route path.
   */
  pathRegex: RegExp;

  /**
   * HTTP request method (e.g., GET, POST).
   */
  requestMethod: RequestMethod;
}



================================================
FILE: packages/core/router/interfaces/index.ts
================================================
export * from './routes.interface';



================================================
FILE: packages/core/router/interfaces/resolver.interface.ts
================================================
export interface Resolver {
  resolve(instance: any, basePath: string): void;
  registerNotFoundHandler(): void;
  registerExceptionHandler(): void;
}



================================================
FILE: packages/core/router/interfaces/route-params-factory.interface.ts
================================================
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';

export interface IRouteParamsFactory {
  exchangeKeyForValue<
    TRequest extends Record<string, any> = any,
    TResponse = any,
    TResult = any,
  >(
    key: RouteParamtypes | string,
    data: any,
    { req, res, next }: { req: TRequest; res: TResponse; next: Function },
  ): TResult | null;
}



================================================
FILE: packages/core/router/interfaces/route-path-metadata.interface.ts
================================================
import { VersioningOptions } from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';

export interface RoutePathMetadata {
  /**
   * Controller-level path (e.g., @Controller('resource') = "resource").
   */
  ctrlPath?: string;

  /**
   * Method-level path (e.g., @Get('resource') = "resource").
   */
  methodPath?: string;

  /**
   * Global route prefix specified with the "NestApplication#setGlobalPrefix" method.
   */
  globalPrefix?: string;

  /**
   * Module-level path registered through the "RouterModule".
   */
  modulePath?: string;

  /**
   * Controller-level version (e.g., @Controller({ version: '1.0' }) = "1.0").
   */
  controllerVersion?: VersionValue;

  /**
   * Method-level version (e.g., @Version('1.0') = "1.0").
   */
  methodVersion?: VersionValue;

  /**
   * API versioning options object.
   */
  versioningOptions?: VersioningOptions;
}



================================================
FILE: packages/core/router/interfaces/routes.interface.ts
================================================
import { Type } from '@nestjs/common';

export interface RouteTree {
  path: string;
  module?: Type<any>;
  children?: (RouteTree | Type<any>)[];
}

export type Routes = RouteTree[];



================================================
FILE: packages/core/router/request/index.ts
================================================
export { REQUEST } from './request-constants';



================================================
FILE: packages/core/router/request/request-constants.ts
================================================
export const REQUEST = 'REQUEST';
export const REQUEST_CONTEXT_ID = Symbol('REQUEST_CONTEXT_ID');



================================================
FILE: packages/core/router/request/request-providers.ts
================================================
import { Provider, Scope } from '@nestjs/common';
import { REQUEST } from './request-constants';

const noop = () => {};
export const requestProvider: Provider = {
  provide: REQUEST,
  scope: Scope.REQUEST,
  useFactory: noop,
};



================================================
FILE: packages/core/router/utils/exclude-route.util.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { addLeadingSlash } from '@nestjs/common/utils/shared.utils';
import { ExcludeRouteMetadata } from '../interfaces/exclude-route-metadata.interface';

export const isRequestMethodAll = (method: RequestMethod) => {
  return RequestMethod.ALL === method || (method as number) === -1;
};

export function isRouteExcluded(
  excludedRoutes: ExcludeRouteMetadata[],
  path: string,
  requestMethod?: RequestMethod,
) {
  return excludedRoutes.some(route => {
    if (
      isRequestMethodAll(route.requestMethod) ||
      route.requestMethod === requestMethod
    ) {
      return route.pathRegex.exec(addLeadingSlash(path));
    }
    return false;
  });
}



================================================
FILE: packages/core/router/utils/flatten-route-paths.util.ts
================================================
import { Type } from '@nestjs/common';
import { isString, normalizePath } from '@nestjs/common/utils/shared.utils';
import { Routes } from '../interfaces/routes.interface';

export function flattenRoutePaths(routes: Routes) {
  const result: Array<{
    module: Type;
    path: string;
  }> = [];
  routes.forEach(item => {
    if (item.module && item.path) {
      result.push({ module: item.module, path: item.path });
    }
    if (item.children) {
      const childrenRef = item.children as Routes;
      childrenRef.forEach(child => {
        if (!isString(child) && child.path) {
          child.path = normalizePath(
            normalizePath(item.path) + normalizePath(child.path),
          );
        } else {
          result.push({ path: item.path, module: child as any as Type });
        }
      });
      result.push(...flattenRoutePaths(childrenRef));
    }
  });
  return result;
}



================================================
FILE: packages/core/router/utils/index.ts
================================================
export * from './exclude-route.util';
export * from './flatten-route-paths.util';



================================================
FILE: packages/core/services/index.ts
================================================
export * from './reflector.service';



================================================
FILE: packages/core/services/reflector.service.ts
================================================
import { CustomDecorator, SetMetadata, Type } from '@nestjs/common';
import { isEmpty, isObject } from '@nestjs/common/utils/shared.utils';
import { uid } from 'uid';

/**
 * @publicApi
 */
export interface CreateDecoratorOptions<TParam = any, TTransformed = TParam> {
  /**
   * The key for the metadata.
   * @default uid(21)
   */
  key?: string;

  /**
   * The transform function to apply to the metadata value.
   * @default value => value
   */
  transform?: (value: TParam) => TTransformed;
}

type CreateDecoratorWithTransformOptions<
  TParam,
  TTransformed = TParam,
> = CreateDecoratorOptions<TParam, TTransformed> &
  Required<Pick<CreateDecoratorOptions<TParam, TTransformed>, 'transform'>>;

/**
 * @publicApi
 */
export type ReflectableDecorator<TParam, TTransformed = TParam> = ((
  opts?: TParam,
) => CustomDecorator) & {
  KEY: string;
};

/**
 * Helper class providing Nest reflection capabilities.
 *
 * @see [Reflection](https://docs.nestjs.com/guards#putting-it-all-together)
 *
 * @publicApi
 */
export class Reflector {
  /**
   * Creates a decorator that can be used to decorate classes and methods with metadata.
   * Can be used as a strongly-typed alternative to `@SetMetadata`.
   * @param options Decorator options.
   * @returns A decorator function.
   */
  static createDecorator<TParam>(
    options?: CreateDecoratorOptions<TParam>,
  ): ReflectableDecorator<TParam>;
  static createDecorator<TParam, TTransformed>(
    options: CreateDecoratorWithTransformOptions<TParam, TTransformed>,
  ): ReflectableDecorator<TParam, TTransformed>;
  static createDecorator<TParam, TTransformed = TParam>(
    options: CreateDecoratorOptions<TParam, TTransformed> = {},
  ): ReflectableDecorator<TParam, TTransformed> {
    const metadataKey = options.key ?? uid(21);
    const decoratorFn =
      (metadataValue: TParam) =>
      (target: object | Function, key?: string | symbol, descriptor?: any) => {
        const value = options.transform
          ? options.transform(metadataValue)
          : metadataValue;
        SetMetadata(metadataKey, value ?? {})(target, key!, descriptor);
      };

    decoratorFn.KEY = metadataKey;
    return decoratorFn as ReflectableDecorator<TParam, TTransformed>;
  }

  /**
   * Retrieve metadata for a reflectable decorator for a specified target.
   *
   * @example
   * `const roles = this.reflector.get(Roles, context.getHandler());`
   *
   * @param decorator reflectable decorator created through `Reflector.createDecorator`
   * @param target context (decorated object) to retrieve metadata from
   *
   */
  public get<T extends ReflectableDecorator<any>>(
    decorator: T,
    target: Type<any> | Function,
  ): T extends ReflectableDecorator<any, infer R> ? R : unknown;
  /**
   * Retrieve metadata for a specified key for a specified target.
   *
   * @example
   * `const roles = this.reflector.get<string[]>('roles', context.getHandler());`
   *
   * @param metadataKey lookup key for metadata to retrieve
   * @param target context (decorated object) to retrieve metadata from
   *
   */
  public get<TResult = any, TKey = any>(
    metadataKey: TKey,
    target: Type<any> | Function,
  ): TResult;
  /**
   * Retrieve metadata for a specified key or decorator for a specified target.
   *
   * @example
   * `const roles = this.reflector.get<string[]>('roles', context.getHandler());`
   *
   * @param metadataKey lookup key or decorator for metadata to retrieve
   * @param target context (decorated object) to retrieve metadata from
   *
   */
  public get<TResult = any, TKey = any>(
    metadataKeyOrDecorator: TKey,
    target: Type<any> | Function,
  ): TResult {
    const metadataKey =
      (metadataKeyOrDecorator as ReflectableDecorator<unknown>).KEY ??
      metadataKeyOrDecorator;

    return Reflect.getMetadata(metadataKey, target);
  }

  /**
   * Retrieve metadata for a specified decorator for a specified set of targets.
   *
   * @param decorator lookup decorator for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAll<TParam = any, TTransformed = TParam>(
    decorator: ReflectableDecorator<TParam, TTransformed>,
    targets: (Type<any> | Function)[],
  ): TTransformed extends Array<any> ? TTransformed : TTransformed[];
  /**
   * Retrieve metadata for a specified key for a specified set of targets.
   *
   * @param metadataKey lookup key for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAll<TResult extends any[] = any[], TKey = any>(
    metadataKey: TKey,
    targets: (Type<any> | Function)[],
  ): TResult;
  /**
   * Retrieve metadata for a specified key or decorator for a specified set of targets.
   *
   * @param metadataKeyOrDecorator lookup key or decorator for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAll<TResult extends any[] = any[], TKey = any>(
    metadataKeyOrDecorator: TKey,
    targets: (Type<any> | Function)[],
  ): TResult {
    return (targets || []).map(target =>
      this.get(metadataKeyOrDecorator, target),
    ) as TResult;
  }

  /**
   * Retrieve metadata for a specified decorator for a specified set of targets and merge results.
   *
   * @param decorator lookup decorator for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndMerge<TParam = any, TTransformed = TParam>(
    decorator: ReflectableDecorator<TParam, TTransformed>,
    targets: (Type<any> | Function)[],
  ): TTransformed extends Array<any>
    ? TTransformed
    : TTransformed extends object
      ? TTransformed
      : TTransformed[];
  /**
   * Retrieve metadata for a specified key for a specified set of targets and merge results.
   *
   * @param metadataKey lookup key for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndMerge<TResult extends any[] | object = any[], TKey = any>(
    metadataKey: TKey,
    targets: (Type<any> | Function)[],
  ): TResult;
  /**
   * Retrieve metadata for a specified key or decorator for a specified set of targets and merge results.
   *
   * @param metadataKeyOrDecorator lookup key for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndMerge<TResult extends any[] | object = any[], TKey = any>(
    metadataKeyOrDecorator: TKey,
    targets: (Type<any> | Function)[],
  ): TResult {
    const metadataCollection = this.getAll<any[], TKey>(
      metadataKeyOrDecorator,
      targets,
    ).filter(item => item !== undefined);

    if (isEmpty(metadataCollection)) {
      return metadataCollection as TResult;
    }
    if (metadataCollection.length === 1) {
      const value = metadataCollection[0];
      if (isObject(value)) {
        return value as TResult;
      }
      return metadataCollection as TResult;
    }
    return metadataCollection.reduce((a, b) => {
      if (Array.isArray(a)) {
        return a.concat(b);
      }
      if (isObject(a) && isObject(b)) {
        return {
          ...a,
          ...b,
        };
      }
      return [a, b];
    });
  }

  /**
   * Retrieve metadata for a specified decorator for a specified set of targets and return a first not undefined value.
   *
   * @param decorator lookup decorator for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndOverride<TParam = any, TTransformed = TParam>(
    decorator: ReflectableDecorator<TParam, TTransformed>,
    targets: (Type<any> | Function)[],
  ): TTransformed;
  /**
   * Retrieve metadata for a specified key for a specified set of targets and return a first not undefined value.
   *
   * @param metadataKey lookup key for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndOverride<TResult = any, TKey = any>(
    metadataKey: TKey,
    targets: (Type<any> | Function)[],
  ): TResult;
  /**
   * Retrieve metadata for a specified key or decorator for a specified set of targets and return a first not undefined value.
   *
   * @param metadataKeyOrDecorator lookup key or metadata for metadata to retrieve
   * @param targets context (decorated objects) to retrieve metadata from
   *
   */
  public getAllAndOverride<TResult = any, TKey = any>(
    metadataKeyOrDecorator: TKey,
    targets: (Type<any> | Function)[],
  ): TResult | undefined {
    for (const target of targets) {
      const result = this.get(metadataKeyOrDecorator, target);
      if (result !== undefined) {
        return result;
      }
    }
    return undefined;
  }
}



================================================
FILE: packages/core/test/application-config.spec.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { GlobalPrefixOptions } from '@nestjs/common/interfaces';
import { expect } from 'chai';
import { ApplicationConfig } from '../application-config';
import { ExcludeRouteMetadata } from '../router/interfaces/exclude-route-metadata.interface';

describe('ApplicationConfig', () => {
  let appConfig: ApplicationConfig;

  beforeEach(() => {
    appConfig = new ApplicationConfig();
  });
  describe('globalPath', () => {
    it('should set global path', () => {
      const path = 'test';
      appConfig.setGlobalPrefix(path);

      expect(appConfig.getGlobalPrefix()).to.be.eql(path);
    });
    it('should set global path options', () => {
      const options: GlobalPrefixOptions<ExcludeRouteMetadata> = {
        exclude: [
          {
            path: '/health',
            pathRegex: new RegExp(/health/),
            requestMethod: RequestMethod.GET,
          },
        ],
      };
      appConfig.setGlobalPrefixOptions(options);

      expect(appConfig.getGlobalPrefixOptions()).to.be.eql(options);
    });
    it('should has empty string as a global path by default', () => {
      expect(appConfig.getGlobalPrefix()).to.be.eql('');
    });
    it('should has empty string as a global path option by default', () => {
      expect(appConfig.getGlobalPrefixOptions()).to.be.eql({});
    });
  });
  describe('IOAdapter', () => {
    it('should set io adapter', () => {
      const ioAdapter = { test: 0 };
      appConfig.setIoAdapter(ioAdapter as any);

      expect(appConfig.getIoAdapter()).to.be.eql(ioAdapter);
    });
  });
  describe('Pipes', () => {
    it('should set global pipes', () => {
      const pipes = ['test', 'test2'];
      appConfig.useGlobalPipes(...(pipes as any));

      expect(appConfig.getGlobalPipes()).to.be.eql(pipes);
    });
    it('should add pipe', () => {
      const pipe = 'testOne';
      appConfig.addGlobalPipe(pipe as any);

      expect(appConfig.getGlobalPipes()).to.contain(pipe);
    });
    it('should add global pipe', () => {
      const pipe = 'testOne';
      appConfig.addGlobalRequestPipe(pipe as any);

      expect(appConfig.getGlobalRequestPipes()).to.contain(pipe);
    });
  });
  describe('Filters', () => {
    it('should set global filters', () => {
      const filters = ['test', 'test2'];
      appConfig.useGlobalFilters(...(filters as any));

      expect(appConfig.getGlobalFilters()).to.be.eql(filters);
    });
    it('should add filter', () => {
      const filter = 'testOne';
      appConfig.addGlobalFilter(filter as any);

      expect(appConfig.getGlobalFilters()).to.contain(filter);
    });
    it('should add request filter', () => {
      const filter = 'testOne';
      appConfig.addGlobalRequestFilter(filter as any);

      expect(appConfig.getGlobalRequestFilters()).to.contain(filter);
    });
  });
  describe('Guards', () => {
    it('should set global guards', () => {
      const guards = ['test', 'test2'];
      appConfig.useGlobalGuards(...(guards as any));

      expect(appConfig.getGlobalGuards()).to.be.eql(guards);
    });
    it('should add guard', () => {
      const guard = 'testOne';
      appConfig.addGlobalGuard(guard as any);

      expect(appConfig.getGlobalGuards()).to.contain(guard);
    });
    it('should add request guard', () => {
      const guard = 'testOne';
      appConfig.addGlobalRequestGuard(guard as any);

      expect(appConfig.getGlobalRequestGuards()).to.contain(guard);
    });
  });
  describe('Interceptors', () => {
    it('should set global interceptors', () => {
      const interceptors = ['test', 'test2'];
      appConfig.useGlobalInterceptors(...(interceptors as any));

      expect(appConfig.getGlobalInterceptors()).to.be.eql(interceptors);
    });
    it('should add interceptor', () => {
      const interceptor = 'testOne';
      appConfig.addGlobalInterceptor(interceptor as any);

      expect(appConfig.getGlobalInterceptors()).to.contain(interceptor);
    });
    it('should add request interceptor', () => {
      const interceptor = 'testOne';
      appConfig.addGlobalRequestInterceptor(interceptor as any);

      expect(appConfig.getGlobalRequestInterceptors()).to.contain(interceptor);
    });
  });
  describe('Versioning', () => {
    it('should set versioning', () => {
      const options = { type: 'test' };
      appConfig.enableVersioning(options as any);

      expect(appConfig.getVersioning()).to.be.eql(options);
    });

    it('should ignore duplicated versions on defaultVersion array', () => {
      const options = { type: 'test', defaultVersion: ['1', '2', '2', '1'] };
      appConfig.enableVersioning(options as any);

      expect(appConfig.getVersioning()!.defaultVersion).to.be.eql(['1', '2']);
    });

    it('should have undefined as the versioning by default', () => {
      expect(appConfig.getVersioning()).to.be.eql(undefined);
    });
  });
});



================================================
FILE: packages/core/test/metadata-scanner.spec.ts
================================================
import { expect } from 'chai';
import { MetadataScanner } from '../metadata-scanner';

describe('MetadataScanner', () => {
  let scanner: MetadataScanner;
  beforeEach(() => {
    scanner = new MetadataScanner();
  });
  describe('scanFromPrototype', () => {
    class Parent {
      constructor() {}
      public testParent() {}
      public testParent2() {}
      get propParent() {
        return '';
      }
      set valParent(value) {}
    }

    class Test extends Parent {
      constructor() {
        super();
      }
      get prop() {
        return '';
      }
      set val(value) {}
      public test() {}
      public test2() {}
    }

    it('should return only methods', () => {
      const methods = scanner.getAllMethodNames(Test.prototype);
      expect(methods).to.eql(['test', 'test2', 'testParent', 'testParent2']);
    });

    it('should return the same instance for the same prototype', () => {
      const methods1 = scanner.getAllMethodNames(Test.prototype);
      const methods2 = scanner.getAllMethodNames(Test.prototype);
      expect(methods1 === methods2).to.eql(true);
    });

    it('should keep compatibility with older methods', () => {
      const methods1 = scanner.getAllMethodNames(Test.prototype).map(m => m[0]);
      const methods2 = scanner.scanFromPrototype(
        new Test(),
        Test.prototype,
        r => r[0],
      );

      expect(methods1).to.eql(methods2);

      const methods3 = scanner.getAllMethodNames(Test.prototype);
      const methods4 = [
        ...new Set(scanner.getAllFilteredMethodNames(Test.prototype)),
      ];

      expect(methods3).to.eql(methods4);
    });
  });
});



================================================
FILE: packages/core/test/nest-application-context.spec.ts
================================================
import { InjectionToken, Provider, Scope } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { setTimeout } from 'timers/promises';
import { ContextIdFactory } from '../helpers/context-id-factory';
import { NestContainer } from '../injector/container';
import { Injector } from '../injector/injector';
import { InstanceLoader } from '../injector/instance-loader';
import { GraphInspector } from '../inspector/graph-inspector';
import { NestApplicationContext } from '../nest-application-context';

describe('NestApplicationContext', () => {
  class A {}

  async function testHelper(
    injectionKey: InjectionToken,
    scope: Scope,
    additionalProviders: Array<Provider> = [],
  ): Promise<NestApplicationContext> {
    const nestContainer = new NestContainer();
    const injector = new Injector();
    const instanceLoader = new InstanceLoader(
      nestContainer,
      injector,
      new GraphInspector(nestContainer),
    );
    const { moduleRef } = (await nestContainer.addModule(class T {}, []))!;

    nestContainer.addProvider(
      {
        provide: injectionKey,
        useClass: A,
        scope,
      },
      moduleRef.token,
    );

    for (const provider of additionalProviders) {
      nestContainer.addProvider(provider, moduleRef.token);
    }

    nestContainer.addInjectable(
      {
        provide: injectionKey,
        useClass: A,
        scope,
      },
      moduleRef.token,
      'interceptor',
    );

    const modules = nestContainer.getModules();
    await instanceLoader.createInstancesOfDependencies(modules);

    const applicationContext = new NestApplicationContext(nestContainer);
    return applicationContext;
  }

  describe('listenToShutdownSignals', () => {
    it('shutdown process should not be interrupted by another handler', async () => {
      const signal = 'SIGTERM';
      let processUp = true;
      let promisesResolved = false;
      const applicationContext = await testHelper(A, Scope.DEFAULT);
      applicationContext.enableShutdownHooks([signal]);

      const waitProcessDown = new Promise(resolve => {
        const shutdownCleanupRef = applicationContext['shutdownCleanupRef'];
        const handler = () => {
          if (
            !process
              .listeners(signal)
              .find(handler => handler == shutdownCleanupRef)
          ) {
            processUp = false;
            process.removeListener(signal, handler);
            resolve(undefined);
          }
          return undefined;
        };
        process.on(signal, handler);
      });

      // add some third party handler
      process.on(signal, signal => {
        // do some work
        process.kill(process.pid, signal);
      });

      const hookStub = sinon
        .stub(applicationContext as any, 'callShutdownHook')
        .callsFake(async () => {
          // run some async code
          await new Promise(resolve => setImmediate(() => resolve(undefined)));
          if (processUp) {
            promisesResolved = true;
          }
        });
      process.kill(process.pid, signal);
      await waitProcessDown;
      hookStub.restore();
      expect(processUp).to.be.false;
      expect(promisesResolved).to.be.true;
    });

    it('should defer shutdown until all init hooks are resolved', async () => {
      const clock = sinon.useFakeTimers({
        toFake: ['setTimeout'],
      });
      const signal = 'SIGTERM';

      const onModuleInitStub = sinon.stub();
      const onApplicationShutdownStub = sinon.stub();

      class B {
        async onModuleInit() {
          await setTimeout(5000);
          onModuleInitStub();
        }

        async onApplicationShutdown() {
          await setTimeout(1000);
          onApplicationShutdownStub();
        }
      }

      const applicationContext = await testHelper(A, Scope.DEFAULT, [
        { provide: B, useClass: B, scope: Scope.DEFAULT },
      ]);
      applicationContext.enableShutdownHooks([signal]);

      const ignoreProcessSignal = () => {
        // noop to prevent process from exiting
      };
      process.on(signal, ignoreProcessSignal);

      const deferredShutdown = async () => {
        await setTimeout(1);
        process.kill(process.pid, signal);
      };
      void Promise.all([applicationContext.init(), deferredShutdown()]);

      await clock.nextAsync();
      expect(onModuleInitStub.called).to.be.false;
      expect(onApplicationShutdownStub.called).to.be.false;

      await clock.nextAsync();
      expect(onModuleInitStub.called).to.be.true;
      expect(onApplicationShutdownStub.called).to.be.false;

      await clock.nextAsync();
      expect(onModuleInitStub.called).to.be.true;
      expect(onApplicationShutdownStub.called).to.be.true;

      clock.restore();
    });
  });

  describe('get', () => {
    describe('when scope = DEFAULT', () => {
      it('should get value with function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.get(key);
        const a2: A = await applicationContext.get(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });

      it('should get value with string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.get(key);
        const a2: A = await applicationContext.get(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });

      it('should get value with symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.get(key);
        const a2: A = await applicationContext.get(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });
    });

    describe('when scope = REQUEST', () => {
      it('should throw error when use function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.REQUEST);

        expect(() => applicationContext.get(key)).to.be.throw;
      });

      it('should throw error when use string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.REQUEST);

        expect(() => applicationContext.get(key)).to.be.throw;
      });

      it('should throw error when use symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.REQUEST);

        expect(() => applicationContext.get(key)).to.be.throw;
      });
    });

    describe('when scope = TRANSIENT', () => {
      it('should throw error when use function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        expect(() => applicationContext.get(key)).to.be.throw;
      });

      it('should throw error when use string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        expect(() => applicationContext.get(key)).to.be.throw;
      });

      it('should throw error when use symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        expect(() => applicationContext.get(key)).to.be.throw;
      });
    });
  });

  describe('resolve', () => {
    describe('when scope = DEFAULT', () => {
      it('should resolve value with function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });

      it('should resolve value with string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });

      it('should resolve value with symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.DEFAULT);

        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).equal(a2);
      });
    });

    describe('when scope = REQUEST', () => {
      it('should resolve value with function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.REQUEST);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });

      it('should resolve value with string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.REQUEST);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });

      it('should resolve value with symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.REQUEST);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });
    });

    describe('when scope = TRANSIENT', () => {
      it('should resolve value with function injection key', async () => {
        const key = A;
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });

      it('should resolve value with string injection key', async () => {
        const key = 'KEY_A';
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });

      it('should resolve value with symbol injection key', async () => {
        const key = Symbol('KEY_A');
        const applicationContext = await testHelper(key, Scope.TRANSIENT);

        const contextId = ContextIdFactory.create();
        const a1: A = await applicationContext.resolve(key);
        const a2: A = await applicationContext.resolve(key, contextId);
        const a3: A = await applicationContext.resolve(key, contextId);

        expect(a1).instanceOf(A);
        expect(a2).instanceOf(A);
        expect(a1).not.equal(a2);
        expect(a2).equal(a3);
      });
    });
  });
});



================================================
FILE: packages/core/test/nest-application.spec.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { expect } from 'chai';
import { ApplicationConfig } from '../application-config';
import { NestContainer } from '../injector/container';
import { GraphInspector } from '../inspector/graph-inspector';
import { NestApplication } from '../nest-application';
import { mapToExcludeRoute } from './../middleware/utils';
import { NoopHttpAdapter } from './utils/noop-adapter.spec';
import { MicroserviceOptions } from '@nestjs/microservices';
import * as sinon from 'sinon';

describe('NestApplication', () => {
  describe('Hybrid Application', () => {
    class Interceptor {
      public intercept(context, next) {
        return next();
      }
    }
    it('default should use new ApplicationConfig', () => {
      const applicationConfig = new ApplicationConfig();
      const container = new NestContainer(applicationConfig);
      const instance = new NestApplication(
        container,
        new NoopHttpAdapter({}),
        applicationConfig,
        new GraphInspector(container),
        {},
      );
      instance.useGlobalInterceptors(new Interceptor());
      const microservice = instance.connectMicroservice<MicroserviceOptions>(
        {},
      );
      expect((instance as any).config.getGlobalInterceptors().length).to.equal(
        1,
      );
      expect(
        (microservice as any).applicationConfig.getGlobalInterceptors().length,
      ).to.equal(0);
    });
    it('should inherit existing ApplicationConfig', () => {
      const applicationConfig = new ApplicationConfig();
      const container = new NestContainer(applicationConfig);
      const instance = new NestApplication(
        container,
        new NoopHttpAdapter({}),
        applicationConfig,
        new GraphInspector(container),
        {},
      );
      instance.useGlobalInterceptors(new Interceptor());
      const microservice = instance.connectMicroservice<MicroserviceOptions>(
        {},
        { inheritAppConfig: true },
      );
      expect((instance as any).config.getGlobalInterceptors().length).to.equal(
        1,
      );
      expect(
        (microservice as any).applicationConfig.getGlobalInterceptors().length,
      ).to.equal(1);
    });
  });
  describe('Global Prefix', () => {
    it('should get correct global prefix options', () => {
      const applicationConfig = new ApplicationConfig();
      const container = new NestContainer(applicationConfig);
      const instance = new NestApplication(
        container,
        new NoopHttpAdapter({}),
        applicationConfig,
        new GraphInspector(container),
        {},
      );
      const excludeRoute = ['foo', { path: 'bar', method: RequestMethod.GET }];
      instance.setGlobalPrefix('api', {
        exclude: excludeRoute,
      });
      expect(applicationConfig.getGlobalPrefixOptions()).to.eql({
        exclude: mapToExcludeRoute(excludeRoute),
      });
    });
  });
  describe('Double initialization', () => {
    it('should initialize application only once', async () => {
      const noopHttpAdapter = new NoopHttpAdapter({});
      const httpAdapterSpy = sinon.spy(noopHttpAdapter);

      const applicationConfig = new ApplicationConfig();

      const container = new NestContainer(applicationConfig);
      container.setHttpAdapter(noopHttpAdapter);

      const instance = new NestApplication(
        container,
        noopHttpAdapter,
        applicationConfig,
        new GraphInspector(container),
        {},
      );

      await instance.init();
      await instance.init();

      expect(httpAdapterSpy.init.calledOnce).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/scanner.spec.ts
================================================
import { Catch, Injectable } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { GUARDS_METADATA } from '../../common/constants';
import { Controller } from '../../common/decorators/core/controller.decorator';
import { UseGuards } from '../../common/decorators/core/use-guards.decorator';
import { Module } from '../../common/decorators/modules/module.decorator';
import { Scope } from '../../common/interfaces';
import { ApplicationConfig } from '../application-config';
import { APP_FILTER, APP_GUARD, APP_INTERCEPTOR, APP_PIPE } from '../constants';
import { InvalidClassModuleException } from '../errors/exceptions/invalid-class-module.exception';
import { InvalidModuleException } from '../errors/exceptions/invalid-module.exception';
import { UndefinedModuleException } from '../errors/exceptions/undefined-module.exception';
import { NestContainer } from '../injector/container';
import { InstanceWrapper } from '../injector/instance-wrapper';
import { GraphInspector } from '../inspector/graph-inspector';
import { ModuleOverride } from '../interfaces/module-override.interface';
import { MetadataScanner } from '../metadata-scanner';
import { DependenciesScanner } from '../scanner';
import Sinon = require('sinon');

describe('DependenciesScanner', () => {
  class Guard {}

  @Injectable()
  class TestComponent {}

  @Catch()
  class TestExceptionFilterWithoutInjectable {}

  @Controller('')
  class TestController {}

  @Module({
    providers: [TestComponent],
    controllers: [TestController],
    exports: [TestComponent],
  })
  class BasicModule {}

  @Module({
    imports: [BasicModule],
    providers: [TestComponent],
    controllers: [TestController],
  })
  class TestModule {}

  @Module({
    imports: [undefined!],
  })
  class UndefinedModule {}

  @Module({
    imports: [null!],
  })
  class InvalidModule {}

  let scanner: DependenciesScanner;
  let untypedScanner: any;
  let mockContainer: sinon.SinonMock;
  let container: NestContainer;
  let graphInspector: GraphInspector;

  beforeEach(() => {
    container = new NestContainer();
    mockContainer = sinon.mock(container);
    graphInspector = new GraphInspector(container);

    scanner = new DependenciesScanner(
      container,
      new MetadataScanner(),
      graphInspector,
      new ApplicationConfig(),
    );
    untypedScanner = scanner as any;
    sinon.stub(scanner, 'registerCoreModule').callsFake(async () => {});
  });

  afterEach(() => {
    mockContainer.restore();
  });

  it('should "insertOrOverrideModule" call twice (2 modules) container method "addModule"', async () => {
    const expectationCountAddModule = mockContainer
      .expects('addModule')
      .twice();
    const expectationCountReplaceModule = mockContainer
      .expects('replaceModule')
      .never();

    await scanner.scan(TestModule);
    expectationCountAddModule.verify();
    expectationCountReplaceModule.verify();
  });

  it('should "insertProvider" call twice (2 components) container method "addProvider"', async () => {
    const expectation = mockContainer.expects('addProvider').twice();
    const stub = sinon.stub(scanner, 'insertExportedProviderOrModule');

    await scanner.scan(TestModule);
    expectation.verify();
    stub.restore();
  });

  it('should "insertController" call twice (2 components) container method "addController"', async () => {
    const expectation = mockContainer.expects('addController').twice();
    await scanner.scan(TestModule);
    expectation.verify();
  });

  it('should "insertExportedProviderOrModule" call once (1 component) container method "addExportedProviderOrModule"', async () => {
    const expectation = mockContainer
      .expects('addExportedProviderOrModule')
      .once();
    await scanner.scan(TestModule);
    expectation.verify();
  });

  describe('when there is modules overrides', () => {
    @Injectable()
    class OverwrittenTestComponent {}

    @Controller('')
    class OverwrittenControlerOne {}

    @Controller('')
    class OverwrittenControllerTwo {}

    @Module({
      controllers: [OverwrittenControlerOne],
      providers: [OverwrittenTestComponent],
    })
    class OverwrittenModuleOne {}

    @Module({
      controllers: [OverwrittenControllerTwo],
    })
    class OverwrittenModuleTwo {}

    @Module({
      imports: [OverwrittenModuleOne, OverwrittenModuleTwo],
    })
    class OverrideTestModule {}

    @Injectable()
    class OverrideTestComponent {}

    @Controller('')
    class OverrideControllerOne {}

    @Controller('')
    class OverrideControllerTwo {}

    @Module({
      controllers: [OverwrittenControlerOne],
      providers: [OverrideTestComponent],
    })
    class OverrideModuleOne {}

    @Module({
      controllers: [OverrideControllerTwo],
    })
    class OverrideModuleTwo {}

    const modulesToOverride: ModuleOverride[] = [
      { moduleToReplace: OverwrittenModuleOne, newModule: OverrideModuleOne },
      { moduleToReplace: OverwrittenModuleTwo, newModule: OverrideModuleTwo },
    ];

    it('should "putModule" call twice (2 modules) container method "replaceModule"', async () => {
      const expectationReplaceModuleFirst = mockContainer
        .expects('replaceModule')
        .once()
        .withArgs(OverwrittenModuleOne, OverrideModuleOne, sinon.match.array);
      const expectationReplaceModuleSecond = mockContainer
        .expects('replaceModule')
        .once()
        .withArgs(OverwrittenModuleTwo, OverrideModuleTwo, sinon.match.array);
      const expectationCountAddModule = mockContainer
        .expects('addModule')
        .once();

      await scanner.scan(OverrideTestModule, {
        overrides: modulesToOverride,
      });

      expectationReplaceModuleFirst.verify();
      expectationReplaceModuleSecond.verify();
      expectationCountAddModule.verify();
    });

    it('should "insertProvider" call once container method "addProvider"', async () => {
      const expectation = mockContainer.expects('addProvider').once();

      await scanner.scan(OverrideTestModule);
      expectation.verify();
    });

    it('should "insertController" call twice (2 components) container method "addController"', async () => {
      const expectation = mockContainer.expects('addController').twice();
      await scanner.scan(OverrideTestModule);
      expectation.verify();
    });

    it('should "putModule" call container method "replaceModule" with forwardRef() when forwardRef property exists', async () => {
      const overwrittenForwardRefSpy = sinon.spy();

      @Module({})
      class OverwrittenForwardRef {}

      @Module({})
      class Overwritten {
        public static forwardRef() {
          overwrittenForwardRefSpy();
          return OverwrittenForwardRef;
        }
      }

      const overrideForwardRefSpy = sinon.spy();

      @Module({})
      class OverrideForwardRef {}

      @Module({})
      class Override {
        public static forwardRef() {
          overrideForwardRefSpy();
          return OverrideForwardRef;
        }
      }

      @Module({
        imports: [Overwritten],
      })
      class OverrideForwardRefTestModule {}

      await scanner.scan(OverrideForwardRefTestModule, {
        overrides: [
          {
            moduleToReplace: Overwritten,
            newModule: Override,
          },
        ],
      });

      expect(overwrittenForwardRefSpy.called).to.be.true;
      expect(overrideForwardRefSpy.called).to.be.true;
    });
  });

  describe('reflectDynamicMetadata', () => {
    describe('when param has prototype', () => {
      it('should call "reflectParamInjectables" and "reflectInjectables"', () => {
        const reflectInjectables = sinon
          .stub(scanner, 'reflectInjectables')
          .callsFake(() => undefined);

        const reflectParamInjectables = sinon
          .stub(scanner, 'reflectParamInjectables')
          .callsFake(() => undefined);

        scanner.reflectDynamicMetadata({ prototype: true } as any, '');
        expect(reflectInjectables.called).to.be.true;
        expect(reflectParamInjectables.called).to.be.true;
      });
    });
    describe('when param has not prototype', () => {
      it('should not call ""reflectParamInjectables" and "reflectInjectables"', () => {
        const reflectInjectables = sinon
          .stub(scanner, 'reflectInjectables')
          .callsFake(() => undefined);
        const reflectParamInjectables = sinon
          .stub(scanner, 'reflectParamInjectables')

          .callsFake(() => undefined);
        scanner.reflectDynamicMetadata({} as any, '');

        expect(reflectInjectables.called).to.be.false;
        expect(reflectParamInjectables.called).to.be.false;
      });
    });
  });

  describe('insertInjectable', () => {
    class InjectableCls {}
    class HostCls {}

    const instanceWrapper = { id: 'random_id' };
    const token = 'token';
    const methodKey = 'methodKey';

    let addInjectableStub: Sinon.SinonStub;
    let insertEnhancerMetadataCacheStub: Sinon.SinonStub;

    beforeEach(() => {
      addInjectableStub = sinon
        .stub(untypedScanner.container, 'addInjectable')
        .callsFake(() => instanceWrapper);
      insertEnhancerMetadataCacheStub = sinon
        .stub(graphInspector, 'insertEnhancerMetadataCache')
        .callsFake(() => undefined);
    });

    describe('when injectable is of type function', () => {
      const subtype = 'filter';
      beforeEach(() => {
        scanner.insertInjectable(
          InjectableCls,
          token,
          HostCls,
          subtype,
          methodKey,
        );
      });

      it('should call "addInjectable"', () => {
        expect(addInjectableStub.calledWith(InjectableCls, token)).to.be.true;
      });

      it('should call "insertEnhancerMetadataCache"', () => {
        expect(
          insertEnhancerMetadataCacheStub.calledWith({
            moduleToken: token,
            classRef: HostCls,
            enhancerInstanceWrapper: instanceWrapper,
            targetNodeId: instanceWrapper.id,
            methodKey,
            subtype,
          }),
        ).to.be.true;
      });
    });
    describe('when injectable is not of type function', () => {
      const injectableRef = new InjectableCls();
      const subtype = 'interceptor';

      beforeEach(() => {
        scanner.insertInjectable(
          injectableRef,
          token,
          HostCls,
          subtype,
          methodKey,
        );
      });

      it('should not call "addInjectable"', () => {
        expect(addInjectableStub.notCalled).to.be.true;
      });

      it('should call "insertEnhancerMetadataCache"', () => {
        expect(
          insertEnhancerMetadataCacheStub.calledWith({
            moduleToken: token,
            classRef: HostCls,
            enhancerRef: injectableRef,
            methodKey,
            subtype,
          }),
        ).to.be.true;
      });
    });
  });

  class CompMethod {
    @UseGuards(Guard)
    public method() {}

    @UseGuards(Guard, Guard)
    public method2() {}
  }
  describe('reflectKeyMetadata', () => {
    it('should return undefined', () => {
      const result = scanner.reflectKeyMetadata(TestComponent, 'key', 'method');
      expect(result).to.be.undefined;
    });
    it('should return an array that consists of 1 element', () => {
      const methodKey = 'method';
      const result = scanner.reflectKeyMetadata(
        CompMethod,
        GUARDS_METADATA,
        methodKey,
      );
      expect(result).to.be.deep.equal({ methodKey, metadata: [Guard] });
    });
    it('should return an array that consists of 2 elements', () => {
      const methodKey = 'method2';
      const result = scanner.reflectKeyMetadata(
        CompMethod,
        GUARDS_METADATA,
        methodKey,
      );
      expect(result).to.be.deep.equal({ methodKey, metadata: [Guard, Guard] });
    });
  });

  describe('insertModule', () => {
    it('should call forwardRef() when forwardRef property exists', async () => {
      sinon.stub(container, 'addModule').returns({} as any);

      const module = { forwardRef: sinon.stub().returns(class {}) };
      await scanner.insertModule(module, []);

      expect(module.forwardRef.called).to.be.true;
    });
    it('should throw "InvalidClassModuleException" exception when supplying a class annotated with `@Injectable()` decorator', () => {
      sinon.stub(container, 'addModule').returns({} as any);

      expect(scanner.insertModule(TestComponent, [])).to.be.rejectedWith(
        InvalidClassModuleException,
      );
    });
    it('should throw "InvalidClassModuleException" exception when supplying a class annotated with `@Controller()` decorator', () => {
      sinon.stub(container, 'addModule').returns({} as any);

      expect(scanner.insertModule(TestController, [])).to.be.rejectedWith(
        InvalidClassModuleException,
      );
    });
    it('should throw "InvalidClassModuleException" exception when supplying a class annotated with (only) `@Catch()` decorator', () => {
      sinon.stub(container, 'addModule').returns({} as any);

      expect(
        scanner.insertModule(TestExceptionFilterWithoutInjectable, []),
      ).to.be.rejectedWith(InvalidClassModuleException);
    });
  });

  describe('insertImport', () => {
    it('should call forwardRef() when forwardRef property exists', async () => {
      const module = { forwardRef: sinon.stub().returns({}) };

      sinon.stub(container, 'addImport').returns({} as any);
      await scanner.insertImport(module, [] as any, 'test');
      expect(module.forwardRef.called).to.be.true;
    });
    describe('when "related" is nil', () => {
      it('should throw exception', async () => {
        let error;
        try {
          await scanner.insertImport(undefined, [] as any, 'test');
        } catch (e) {
          error = e;
        }
        expect(error).to.not.be.undefined;
      });
    });
  });

  describe('insertProvider', () => {
    const token = 'token';

    describe('when provider is not custom', () => {
      it('should call container "addProvider" with expected args', () => {
        const provider = {};
        const expectation = mockContainer
          .expects('addProvider')
          .withArgs(provider, token);

        mockContainer.expects('addProvider').callsFake(() => false);
        scanner.insertProvider(provider as any, token);

        expectation.verify();
      });
    });
    describe('when provider is custom', () => {
      describe('and is global', () => {
        const provider = {
          provide: APP_INTERCEPTOR,
          useValue: true,
        };

        it('should call container "addProvider" with expected args', () => {
          const expectation = mockContainer.expects('addProvider').atLeast(1);

          mockContainer.expects('addProvider').callsFake(() => false);
          scanner.insertProvider(provider, token);

          expectation.verify();
        });
        it('should push new object to "applicationProvidersApplyMap" array', () => {
          mockContainer.expects('addProvider').callsFake(() => false);
          scanner.insertProvider(provider, token);
          const applyMap = untypedScanner.applicationProvidersApplyMap;

          expect(applyMap).to.have.length(1);
          expect(applyMap[0].moduleKey).to.be.eql(token);
        });
      });
      describe('and is global and request/transient scoped', () => {
        const provider = {
          provide: APP_INTERCEPTOR,
          useValue: true,
          scope: Scope.REQUEST,
        };
        it('should call container "addInjectable" with expected args', () => {
          const expectation = mockContainer.expects('addInjectable').atLeast(1);

          mockContainer.expects('addInjectable').callsFake(() => false);
          scanner.insertProvider(provider, token);

          expectation.verify();
        });
      });
      describe('and is not global', () => {
        const component = {
          provide: 'CUSTOM',
          useValue: true,
        };
        it('should call container "addProvider" with expected args', () => {
          const expectation = mockContainer
            .expects('addProvider')
            .withArgs(component, token);

          mockContainer.expects('addProvider').callsFake(() => false);
          scanner.insertProvider(component, token);

          expectation.verify();
        });
        it('should not push new object to "applicationProvidersApplyMap" array', () => {
          expect(untypedScanner.applicationProvidersApplyMap).to.have.length(0);

          mockContainer.expects('addProvider').callsFake(() => false);
          scanner.insertProvider(component, token);
          expect(untypedScanner.applicationProvidersApplyMap).to.have.length(0);
        });
      });
    });
  });
  describe('applyApplicationProviders', () => {
    it('should apply each provider', () => {
      const provider = {
        moduleKey: 'moduleToken',
        providerKey: 'providerToken',
        type: APP_GUARD,
      };
      untypedScanner.applicationProvidersApplyMap = [provider];

      const expectedInstance = {};
      const instanceWrapper = {
        instance: expectedInstance,
      } as unknown as InstanceWrapper;
      mockContainer.expects('getModules').callsFake(() => ({
        get: () => ({
          providers: { get: () => instanceWrapper },
        }),
      }));

      const applySpy = sinon.spy();
      sinon.stub(scanner, 'getApplyProvidersMap').callsFake(() => ({
        [provider.type]: applySpy,
      }));

      const insertAttachedEnhancerStub = sinon.stub(
        graphInspector,
        'insertAttachedEnhancer',
      );

      scanner.applyApplicationProviders();

      expect(applySpy.called).to.be.true;
      expect(applySpy.calledWith(expectedInstance)).to.be.true;
      expect(insertAttachedEnhancerStub.calledWith(instanceWrapper)).to.be.true;
    });
    it('should apply each globally scoped provider', () => {
      const provider = {
        moduleKey: 'moduleToken',
        providerKey: 'providerToken',
        type: APP_GUARD,
        scope: Scope.REQUEST,
      };
      untypedScanner.applicationProvidersApplyMap = [provider];

      const expectedInstanceWrapper = new InstanceWrapper();
      mockContainer.expects('getModules').callsFake(() => ({
        get: () => ({
          injectables: { get: () => expectedInstanceWrapper },
        }),
      }));

      const applySpy = sinon.spy();
      sinon.stub(scanner, 'getApplyRequestProvidersMap').callsFake(() => ({
        [provider.type]: applySpy,
      }));

      const insertAttachedEnhancerStub = sinon.stub(
        graphInspector,
        'insertAttachedEnhancer',
      );

      scanner.applyApplicationProviders();

      expect(applySpy.called).to.be.true;
      expect(applySpy.calledWith(expectedInstanceWrapper)).to.be.true;
      expect(insertAttachedEnhancerStub.calledWith(expectedInstanceWrapper)).to
        .be.true;
    });
  });

  describe('addScopedEnhancersMetadata', () => {
    const provider = {
      moduleKey: 'moduleToken',
      providerKey: 'providerToken',
      type: APP_GUARD,
      scope: Scope.REQUEST,
    };

    it('should add enhancers metadata to every controller and every entry provider', () => {
      untypedScanner.applicationProvidersApplyMap = [provider];

      const instance = new InstanceWrapper({ name: 'test' });
      const controllers = new Map();
      const providers = new Map();

      const fakeController = new InstanceWrapper();
      const fakeProvider = new InstanceWrapper();

      const providerToken = 'entryProvider';
      controllers.set('test', fakeController);
      providers.set(providerToken, fakeProvider);

      mockContainer.expects('getModules').callsFake(() => ({
        get: () => ({
          injectables: { get: () => instance },
          controllers,
          entryProviders: Array.from(providers.values()),
        }),
        values() {
          return [this.get()];
        },
      }));

      const addEnhancerMetadataControllerSpy = sinon.spy(
        fakeController,
        'addEnhancerMetadata',
      );
      const addEnhancerMetadataProviderSpy = sinon.spy(
        fakeProvider,
        'addEnhancerMetadata',
      );
      scanner.addScopedEnhancersMetadata();

      expect(addEnhancerMetadataControllerSpy.called).to.be.true;
      expect(addEnhancerMetadataControllerSpy.calledWith(instance)).to.be.true;
      expect(addEnhancerMetadataProviderSpy.called).to.be.true;
      expect(addEnhancerMetadataProviderSpy.calledWith(instance)).to.be.true;
    });
  });

  describe('getApplyProvidersMap', () => {
    describe(`when token is ${APP_INTERCEPTOR}`, () => {
      it('call "addGlobalInterceptor"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalInterceptor',
        );
        scanner.getApplyProvidersMap()[APP_INTERCEPTOR](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_GUARD}`, () => {
      it('call "addGlobalGuard"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalGuard',
        );
        scanner.getApplyProvidersMap()[APP_GUARD](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_PIPE}`, () => {
      it('call "addGlobalPipe"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalPipe',
        );
        scanner.getApplyProvidersMap()[APP_PIPE](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_FILTER}`, () => {
      it('call "addGlobalFilter"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalFilter',
        );
        scanner.getApplyProvidersMap()[APP_FILTER](null);
        expect(addSpy.called).to.be.true;
      });
    });
  });
  describe('getApplyRequestProvidersMap', () => {
    describe(`when token is ${APP_INTERCEPTOR}`, () => {
      it('call "addGlobalRequestInterceptor"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalRequestInterceptor',
        );
        scanner.getApplyRequestProvidersMap()[APP_INTERCEPTOR](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_GUARD}`, () => {
      it('call "addGlobalRequestGuard"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalRequestGuard',
        );
        scanner.getApplyRequestProvidersMap()[APP_GUARD](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_PIPE}`, () => {
      it('call "addGlobalRequestPipe"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalRequestPipe',
        );
        scanner.getApplyRequestProvidersMap()[APP_PIPE](null);
        expect(addSpy.called).to.be.true;
      });
    });
    describe(`when token is ${APP_FILTER}`, () => {
      it('call "addGlobalRequestFilter"', () => {
        const addSpy = sinon.spy(
          untypedScanner.applicationConfig,
          'addGlobalRequestFilter',
        );
        scanner.getApplyRequestProvidersMap()[APP_FILTER](null);
        expect(addSpy.called).to.be.true;
      });
    });
  });
  describe('scanForModules', () => {
    it('should throw an exception when the imports array includes undefined', async () => {
      try {
        await scanner.scanForModules({
          moduleDefinition: UndefinedModule,
          scope: [UndefinedModule],
        });
      } catch (exception) {
        expect(exception instanceof UndefinedModuleException).to.be.true;
      }
    });
    it('should throw an exception when the imports array includes an invalid value', async () => {
      try {
        await scanner.scanForModules({
          moduleDefinition: InvalidModule,
          scope: [InvalidModule],
        });
      } catch (exception) {
        expect(exception instanceof InvalidModuleException).to.be.true;
      }
    });
  });
});



================================================
FILE: packages/core/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/core/test/errors/test/exception-handler.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ExceptionHandler } from '../../../errors/exception-handler';
import { RuntimeException } from '../../../errors/exceptions/runtime.exception';

describe('ExceptionHandler', () => {
  let instance: ExceptionHandler;
  beforeEach(() => {
    instance = new ExceptionHandler();
  });
  describe('handle', () => {
    let logger: { error: Function };
    let errorSpy: sinon.SinonSpy;
    beforeEach(() => {
      logger = {
        error: () => {},
      };
      (ExceptionHandler as any).logger = logger;
      errorSpy = sinon.spy(logger, 'error');
    });
    it('should call the logger.error method with the thrown exception passed as an argument', () => {
      const exception = new RuntimeException('msg');
      instance.handle(exception);
      expect(errorSpy.calledWith(exception)).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/errors/test/exceptions-zone.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Logger } from '@nestjs/common';
import { ExceptionsZone } from '../../../errors/exceptions-zone';

describe('ExceptionsZone', () => {
  const rethrow = err => {
    throw err;
  };

  describe('run', () => {
    let callback: sinon.SinonSpy;
    beforeEach(() => {
      callback = sinon.spy();
    });
    it('should call callback', () => {
      ExceptionsZone.run(callback as any, rethrow, false);
      expect(callback.called).to.be.true;
    });
    describe('when callback throws exception', () => {
      const exceptionHandler = {
        handle: () => {},
      };
      let handleSpy: sinon.SinonSpy;
      let LoggerFlushSpy: sinon.SinonSpy;
      before(() => {
        (ExceptionsZone as any).exceptionHandler = exceptionHandler;
        handleSpy = sinon.spy(exceptionHandler, 'handle');
        LoggerFlushSpy = sinon.spy(Logger, 'flush');
      });
      after(() => {
        LoggerFlushSpy.restore();
      });
      describe('when callback throws exception and autoFlushLogs is false', () => {
        it('should call "handle" method of exceptionHandler and rethrows and not flush logs', () => {
          const throwsCallback = () => {
            throw new Error('');
          };
          expect(() =>
            ExceptionsZone.run(throwsCallback, rethrow, false),
          ).to.throws();

          expect(handleSpy.called).to.be.true;

          expect(LoggerFlushSpy.called).to.be.false;
        });
      });

      describe('when callback throws exception and autoFlushLogs is true', () => {
        it('should call "handle" method of exceptionHandler and rethrows and flush logs', () => {
          const throwsCallback = () => {
            throw new Error('');
          };
          expect(() =>
            ExceptionsZone.run(throwsCallback, rethrow, true),
          ).to.throws();

          expect(handleSpy.called).to.be.true;

          expect(LoggerFlushSpy.called).to.be.true;
        });
      });
    });
  });

  describe('asyncRun', () => {
    let callback: sinon.SinonSpy;
    beforeEach(() => {
      callback = sinon.spy();
    });
    it('should call callback', async () => {
      await ExceptionsZone.asyncRun(callback as any, rethrow, false);
      expect(callback.called).to.be.true;
    });
    describe('when callback throws exception', () => {
      const exceptionHandler = {
        handle: () => {},
      };
      let handleSpy: sinon.SinonSpy;
      let LoggerFlushSpy: sinon.SinonSpy;
      before(() => {
        (ExceptionsZone as any).exceptionHandler = exceptionHandler;
        handleSpy = sinon.spy(exceptionHandler, 'handle');
        LoggerFlushSpy = sinon.spy(Logger, 'flush');
      });
      after(() => {
        LoggerFlushSpy.restore();
      });
      describe('when callback throws exception and autoFlushLogs is false', () => {
        it('should call "handle" method of exceptionHandler and rethrows error and not flush logs', async () => {
          const throwsCallback = () => {
            throw new Error('');
          };
          expect(ExceptionsZone.asyncRun(throwsCallback, rethrow, false)).to
            .eventually.be.rejected;

          expect(handleSpy.called).to.be.true;

          expect(LoggerFlushSpy.called).to.be.false;
        });
      });
      describe('when callback throws exception and autoFlushLogs is true', () => {
        it('should call "handle" method of exceptionHandler and rethrows error and flush logs', async () => {
          const throwsCallback = () => {
            throw new Error('');
          };
          expect(ExceptionsZone.asyncRun(throwsCallback, rethrow, true)).to
            .eventually.be.rejected;

          expect(handleSpy.called).to.be.true;

          expect(LoggerFlushSpy.called).to.be.true;
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/errors/test/messages.spec.ts
================================================
import { expect } from 'chai';
import { UnknownDependenciesException } from '../../../errors/exceptions/unknown-dependencies.exception';
import {
  INVALID_MODULE_MESSAGE,
  UNDEFINED_MODULE_MESSAGE,
} from '../../../errors/messages';
import { Module } from '../../../injector/module';
import { stringCleaner } from '../../utils/string.cleaner';

describe('Error Messages', () => {
  const CatsModule = { name: 'CatsModule' };
  const AppModule = { name: 'AppModule' };

  describe('UNKNOWN_DEPENDENCIES_MESSAGE', () => {
    const index = 0;
    it('should display class', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?, CatService). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
      @Module({
        imports: [ /* the Module containing dependency */ ]
      })
      `);

      class CatService {}

      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatService', {
          index,
          dependencies: ['', CatService],
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the provide token', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?, MY_TOKEN). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
      @Module({
      imports: [ /* the Module containing dependency */ ]
      })
      `);

      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatService', {
          index,
          dependencies: ['', 'MY_TOKEN'],
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the provide token as double-quoted string for string-based tokens', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?). Please make sure that the argument "FooRepository" at index [0] is available in the current context.

      Potential solutions:
      - If "FooRepository" is a provider, is it part of the current Module?
      - If "FooRepository" is exported from a separate @Module, is that module imported within Module?
      @Module({
      imports: [ /* the Module containing "FooRepository" */ ]
      })
      `);

      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatService', {
          index: 0,
          dependencies: ['FooRepository'],
          name: 'FooRepository',
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the function name', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?, CatFunction). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
      @Module({
        imports: [ /* the Module containing dependency */ ]
      })
      `);

      function CatFunction() {}
      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatService', {
          index,
          dependencies: ['', CatFunction],
        }).message,
      );
      expect(actualMessage).to.equal(expectedResult);
    });
    it('should use "+" if unknown dependency name', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?, +). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
        @Module({
          imports: [ /* the Module containing dependency */ ]
        })
      `);

      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatService', {
          index,
          dependencies: ['', undefined!],
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the module name', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatService (?, MY_TOKEN). Please make sure that the argument dependency at index [0] is available in the TestModule context.

      Potential solutions:
      - Is TestModule a valid NestJS module?
      - If dependency is a provider, is it part of the current TestModule?
      - If dependency is exported from a separate @Module, is that module imported within TestModule?
        @Module({
          imports: [ /* the Module containing dependency */ ]
        })
      `);

      class MetaType {
        name: string;
      }
      class TestModule {
        metatype: MetaType;
      }
      const myModule = new TestModule();
      const myMetaType = new MetaType();
      myMetaType.name = 'TestModule';
      myModule.metatype = myMetaType;

      const actualMessage = stringCleaner(
        new UnknownDependenciesException(
          'CatService',
          { index, dependencies: ['', 'MY_TOKEN'] },
          myModule as Module,
        ).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the symbol name of the provider', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the Symbol(CatProvider) (?). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
        @Module({
          imports: [ /* the Module containing dependency */ ]
        })
      `);

      const actualMessage = stringCleaner(
        new UnknownDependenciesException(Symbol('CatProvider'), {
          index,
          dependencies: [''],
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
    it('should display the symbol dependency of the provider', () => {
      const expectedResult =
        stringCleaner(`Nest can't resolve dependencies of the CatProvider (?, Symbol(DogProvider)). Please make sure that the argument dependency at index [0] is available in the current context.

      Potential solutions:
      - If dependency is a provider, is it part of the current Module?
      - If dependency is exported from a separate @Module, is that module imported within Module?
        @Module({
          imports: [ /* the Module containing dependency */ ]
        })
      `);

      const actualMessage = stringCleaner(
        new UnknownDependenciesException('CatProvider', {
          index,
          dependencies: ['', Symbol('DogProvider')],
        }).message,
      );

      expect(actualMessage).to.equal(expectedResult);
    });
  });

  describe('UNDEFINED_MODULE_EXCEPTION', () => {
    it('should display the module name with the undefined index and scope', () => {
      const expectedMessage =
        stringCleaner(`Nest cannot create the CatsModule instance.
The module at index [0] of the CatsModule "imports" array is undefined.

Potential causes:
- A circular dependency between modules. Use forwardRef() to avoid it. Read more: https://docs.nestjs.com/fundamentals/circular-dependency
- The module at index [0] is of type "undefined". Check your import statements and the type of the module.

Scope [AppModule -> CatsModule]`);

      const actualMessage = stringCleaner(
        UNDEFINED_MODULE_MESSAGE(CatsModule, 0, [AppModule, CatsModule]),
      );

      expect(actualMessage).to.be.eq(expectedMessage);
    });
  });

  describe('INVALID_MODULE_MESSAGE', () => {
    it('should display the module name with the invalid index and scope', () => {
      const expectedMessage =
        stringCleaner(`Nest cannot create the CatsModule instance.
Received an unexpected value at index [0] of the CatsModule "imports" array.

Scope [AppModule -> CatsModule]`);

      const actualMessage = stringCleaner(
        INVALID_MODULE_MESSAGE(CatsModule, 0, [AppModule, CatsModule]),
      );

      expect(actualMessage).to.be.eq(expectedMessage);
    });
  });
});



================================================
FILE: packages/core/test/exceptions/base-exception-filter.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { BaseExceptionFilterContext } from '../../exceptions/base-exception-filter-context';
import { NestContainer } from '../../injector/container';

export class Filter {}

describe('BaseExceptionFilterContext', () => {
  let filter: BaseExceptionFilterContext;
  let container: NestContainer;

  beforeEach(() => {
    container = new NestContainer();
    filter = new BaseExceptionFilterContext(container);
  });

  describe('getFilterInstance', () => {
    describe('when param is an object', () => {
      it('should return instance', () => {
        const instance = { catch: () => null };
        expect(filter.getFilterInstance(instance)).to.be.eql(instance);
      });
    });
    describe('when param is a constructor', () => {
      it('should pick instance from container', () => {
        const wrapper = {
          instance: 'test',
          getInstanceByContextId: () => wrapper,
        };
        sinon
          .stub(filter, 'getInstanceByMetatype')
          .callsFake(() => wrapper as any);
        expect(filter.getFilterInstance(Filter)).to.be.eql(wrapper.instance);
      });
      it('should return null', () => {
        sinon.stub(filter, 'getInstanceByMetatype').callsFake(() => null!);
        expect(filter.getFilterInstance(Filter)).to.be.eql(null);
      });
    });
  });

  describe('getInstanceByMetatype', () => {
    describe('when "moduleContext" is nil', () => {
      it('should return undefined', () => {
        (filter as any).moduleContext = undefined;
        expect(filter.getInstanceByMetatype(null!)).to.be.undefined;
      });
    });
    describe('when "moduleContext" is not nil', () => {
      beforeEach(() => {
        (filter as any).moduleContext = 'test';
      });

      describe('and when module exists', () => {
        it('should return undefined', () => {
          sinon.stub(container.getModules(), 'get').callsFake(() => undefined);
          expect(filter.getInstanceByMetatype(null!)).to.be.undefined;
        });
      });

      describe('and when module does not exist', () => {
        it('should return instance', () => {
          const instance = { test: true };
          const module = { injectables: { get: () => instance } };
          sinon
            .stub(container.getModules(), 'get')
            .callsFake(() => module as any);
          expect(filter.getInstanceByMetatype(class {})).to.be.eql(instance);
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/exceptions/exceptions-handler.spec.ts
================================================
import { HttpException } from '@nestjs/common';
import { isNil, isObject } from '@nestjs/common/utils/shared.utils';
import { expect } from 'chai';
import * as createHttpError from 'http-errors';
import * as sinon from 'sinon';
import { AbstractHttpAdapter } from '../../adapters';
import { InvalidExceptionFilterException } from '../../errors/exceptions/invalid-exception-filter.exception';
import { ExceptionsHandler } from '../../exceptions/exceptions-handler';
import { ExecutionContextHost } from '../../helpers/execution-context-host';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('ExceptionsHandler', () => {
  let adapter: AbstractHttpAdapter;
  let handler: ExceptionsHandler;
  let statusStub: sinon.SinonStub;
  let jsonStub: sinon.SinonStub;
  let response: any;

  beforeEach(() => {
    adapter = new NoopHttpAdapter({});
    handler = new ExceptionsHandler(adapter);
    statusStub = sinon.stub();
    jsonStub = sinon.stub();

    response = {
      status: statusStub,
      json: jsonStub,
    };
    response.status.returns(response);
    response.json.returns(response);
  });

  describe('next', () => {
    beforeEach(() => {
      sinon
        .stub(adapter, 'reply')
        .callsFake((responseRef: any, body: any, statusCode?: number) => {
          if (statusCode) {
            responseRef.status(statusCode);
          }
          if (isNil(body)) {
            return responseRef.send();
          }
          return isObject(body)
            ? responseRef.json(body)
            : responseRef.send(String(body));
        });
    });
    it('should send expected response status code and message when exception is unknown', () => {
      handler.next(new Error(), new ExecutionContextHost([0, response]));

      expect(statusStub.calledWith(500)).to.be.true;
      expect(
        jsonStub.calledWith({
          statusCode: 500,
          message: 'Internal server error',
        }),
      ).to.be.true;
    });
    describe('when exception is instantiated by "http-errors" library', () => {
      it('should send expected response status code and message', () => {
        const error = new createHttpError.NotFound('User does not exist');
        handler.next(error, new ExecutionContextHost([0, response]));

        expect(statusStub.calledWith(404)).to.be.true;
        expect(
          jsonStub.calledWith({
            statusCode: 404,
            message: 'User does not exist',
          }),
        ).to.be.true;
      });
    });
    describe('when exception is an instance of HttpException', () => {
      it('should send expected response status code and json object', () => {
        const status = 401;
        const message = {
          custom: 'Unauthorized',
        };
        handler.next(
          new HttpException(message, status),
          new ExecutionContextHost([0, response]),
        );

        expect(statusStub.calledWith(status)).to.be.true;
        expect(jsonStub.calledWith(message)).to.be.true;
      });
      it('should send expected response status code and transform message to json', () => {
        const status = 401;
        const message = 'Unauthorized';

        handler.next(
          new HttpException(message, status),
          new ExecutionContextHost([0, response]),
        );

        expect(statusStub.calledWith(status)).to.be.true;
        expect(jsonStub.calledWith({ message, statusCode: status })).to.be.true;
      });
    });
    describe('when "invokeCustomFilters" returns true', () => {
      beforeEach(() => {
        sinon.stub(handler, 'invokeCustomFilters').returns(true);
      });
      it('should do nothing', () => {
        handler.next(
          new Error(),
          sinon.createStubInstance(ExecutionContextHost),
        );

        expect(statusStub.notCalled).to.be.true;
        expect(jsonStub.notCalled).to.be.true;
      });
    });
  });
  describe('setCustomFilters', () => {
    const filters = ['test', 'test2'];
    it('should set custom filters', () => {
      handler.setCustomFilters(filters as any);
      expect((handler as any).filters).to.be.eql(filters);
    });
    it('should throw exception when passed argument is not an array', () => {
      expect(() => handler.setCustomFilters(null!)).to.throws(
        InvalidExceptionFilterException,
      );
    });
  });
  describe('invokeCustomFilters', () => {
    describe('when filters array is empty', () => {
      it('should return false', () => {
        expect(handler.invokeCustomFilters(null, null!)).to.be.false;
      });
    });
    describe('when filters array is not empty', () => {
      let filters, funcSpy;
      class TestException {}

      beforeEach(() => {
        funcSpy = sinon.spy();
      });
      describe('when filter exists in filters array', () => {
        beforeEach(() => {
          filters = [{ exceptionMetatypes: [TestException], func: funcSpy }];
          (handler as any).filters = filters;
        });
        it('should call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.false;
        });
        it('should call funcSpy with exception and response passed as an arguments', () => {
          const exception = new TestException();
          const res = { foo: 'bar' };

          handler.invokeCustomFilters(exception, res as any);
          expect(funcSpy.calledWith(exception, res)).to.be.true;
        });
        it('should return true', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .true;
        });
      });
      describe('when filter does not exists in filters array', () => {
        it('should not call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.true;
        });
        it('should return false', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .false;
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/exceptions/external-exception-filter-context.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Catch } from '../../../common/decorators/core/catch.decorator';
import { UseFilters } from '../../../common/decorators/core/exception-filters.decorator';
import { ApplicationConfig } from '../../application-config';
import { ExternalExceptionFilterContext } from '../../exceptions/external-exception-filter-context';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';

describe('ExternalExceptionFilterContext', () => {
  let applicationConfig: ApplicationConfig;
  let exceptionFilter: ExternalExceptionFilterContext;

  class CustomException {}
  @Catch(CustomException)
  class ExceptionFilter implements ExceptionFilter {
    public catch(exc, res) {}
  }
  class ClassWithNoMetadata implements ExceptionFilter {
    public catch(exc, res) {}
  }

  beforeEach(() => {
    applicationConfig = new ApplicationConfig();
    exceptionFilter = new ExternalExceptionFilterContext(
      new NestContainer(),
      applicationConfig,
    );
  });
  describe('create', () => {
    describe('when filters metadata is empty', () => {
      class EmptyMetadata {}
      beforeEach(() => {
        sinon.stub(exceptionFilter, 'createContext').returns([]);
      });
      it('should return plain ExceptionHandler object', () => {
        const filter = exceptionFilter.create(
          new EmptyMetadata(),
          () => ({}) as any,
          undefined!,
        );
        expect((filter as any).filters).to.be.empty;
      });
    });
    describe('when filters metadata is not empty', () => {
      @UseFilters(new ExceptionFilter())
      class WithMetadata {}

      it('should return ExceptionHandler object with exception filters', () => {
        const filter = exceptionFilter.create(
          new WithMetadata(),
          () => ({}) as any,
          undefined!,
        );
        expect((filter as any).filters).to.not.be.empty;
      });
    });
  });
  describe('reflectCatchExceptions', () => {
    it('should return FILTER_CATCH_EXCEPTIONS metadata', () => {
      expect(
        exceptionFilter.reflectCatchExceptions(new ExceptionFilter()),
      ).to.be.eql([CustomException]);
    });
    it('should return an empty array when metadata was found', () => {
      expect(
        exceptionFilter.reflectCatchExceptions(new ClassWithNoMetadata()),
      ).to.be.eql([]);
    });
  });
  describe('createConcreteContext', () => {
    class InvalidFilter {}
    const filters = [new ExceptionFilter(), new InvalidFilter(), 'test'];

    it('should return expected exception filters metadata', () => {
      const resolved = exceptionFilter.createConcreteContext(filters as any);
      expect(resolved).to.have.length(1);
      expect(resolved[0].exceptionMetatypes).to.be.deep.equal([
        CustomException,
      ]);
      expect(resolved[0].func).to.be.a('function');
    });
  });

  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global filters', () => {
        const expectedResult = applicationConfig.getGlobalFilters();
        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped filters', () => {
        const globalFilters: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedFilterWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalFilters')
          .callsFake(() => globalFilters);
        sinon
          .stub(applicationConfig, 'getGlobalRequestFilters')
          .callsFake(() => scopedFilterWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(
          instance,
          ...globalFilters,
        );
      });
    });
  });
});



================================================
FILE: packages/core/test/exceptions/external-exceptions-handler.spec.ts
================================================
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { ExternalExceptionFilter } from '../../exceptions/external-exception-filter';
import { ExternalExceptionsHandler } from '../../exceptions/external-exceptions-handler';

describe('ExternalExceptionsHandler', () => {
  let handler: ExternalExceptionsHandler;

  beforeEach(() => {
    handler = new ExternalExceptionsHandler();

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore The 'logger' property is private but we want to avoid showing useless error logs
    ExternalExceptionFilter.logger.error = () => {};
  });

  describe('next', () => {
    it('should method returns expected stream with message when exception is unknown', () => {
      const error = new Error();
      expect(() => handler.next(error, null!)).to.throw(error);
    });
    describe('when "invokeCustomFilters" returns value', () => {
      const observable$ = of(true);
      beforeEach(() => {
        sinon.stub(handler, 'invokeCustomFilters').returns(observable$ as any);
      });
      it('should return observable', () => {
        const result = handler.next(new Error(), null!);
        expect(result).to.be.eql(observable$);
      });
    });
  });
  describe('setCustomFilters', () => {
    const filters = ['test', 'test2'];
    it('should set custom filters', () => {
      handler.setCustomFilters(filters as any);
      expect((handler as any).filters).to.be.eql(filters);
    });
    it('should throw exception when passed argument is not an array', () => {
      expect(() => handler.setCustomFilters(null!)).to.throw();
    });
  });
  describe('invokeCustomFilters', () => {
    describe('when filters array is empty', () => {
      it('should return identity', () => {
        expect(handler.invokeCustomFilters(null, null!)).to.be.null;
      });
    });
    describe('when filters array is not empty', () => {
      let filters, funcSpy;
      class TestException {}
      class AnotherTestException {}

      beforeEach(() => {
        funcSpy = sinon.spy();
      });
      describe('when filter exists in filters array', () => {
        beforeEach(() => {
          filters = [{ exceptionMetatypes: [TestException], func: funcSpy }];
          (handler as any).filters = filters;
        });
        it('should call funcSpy', async () => {
          await handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.false;
        });
        it('should call funcSpy with exception and response passed as an arguments', async () => {
          const exception = new TestException();
          await handler.invokeCustomFilters(exception, null!);
          expect(funcSpy.calledWith(exception)).to.be.true;
        });
        it('should return stream', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .not.null;
        });
      });
      describe('when filter does not exists in filters array', () => {
        beforeEach(() => {
          filters = [
            { exceptionMetatypes: [AnotherTestException], func: funcSpy },
          ];
          (handler as any).filters = filters;
        });
        it('should not call funcSpy', async () => {
          await handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.true;
        });
        it('should return null', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .null;
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/guards/guards-consumer.spec.ts
================================================
import { expect } from 'chai';
import { of } from 'rxjs';
import { GuardsConsumer } from '../../guards/guards-consumer';

describe('GuardsConsumer', () => {
  let consumer: GuardsConsumer;
  let guards: any[];
  beforeEach(() => {
    consumer = new GuardsConsumer();
    guards = [{ canActivate: () => true }, { canActivate: () => true }];
  });
  describe('tryActivate', () => {
    describe('when guards array is empty', () => {
      it('should return true', async () => {
        const canActivate = await consumer.tryActivate(
          [],
          [],
          { constructor: null },
          null!,
        );
        expect(canActivate).to.be.true;
      });
    });
    describe('when guards array is not empty', () => {
      describe('when at least on guard returns false', () => {
        it('should return false', async () => {
          const canActivate = await consumer.tryActivate(
            [...guards, { canActivate: () => false }],
            [],
            { constructor: null },
            null!,
          );
          expect(canActivate).to.be.false;
        });
      });
      describe('when each guard returns true', () => {
        it('should return true', async () => {
          const canActivate = await consumer.tryActivate(
            guards,
            [],
            { constructor: null },
            null!,
          );
          expect(canActivate).to.be.true;
        });
      });
    });
  });
  describe('pickResult', () => {
    describe('when result is Observable', () => {
      it('should return result', async () => {
        expect(await consumer.pickResult(of(true))).to.be.true;
      });
    });
    describe('when result is Promise', () => {
      it('should await promise', async () => {
        expect(await consumer.pickResult(Promise.resolve(true))).to.be.true;
      });
    });
  });
});



================================================
FILE: packages/core/test/guards/guards-context-creator.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ApplicationConfig } from '../../application-config';
import { GuardsContextCreator } from '../../guards/guards-context-creator';
import { InstanceWrapper } from '../../injector/instance-wrapper';

class Guard {}

describe('GuardsContextCreator', () => {
  let guardsContextCreator: GuardsContextCreator;
  let applicationConfig: ApplicationConfig;
  let guards: any[];
  let container: any;
  let getSpy: sinon.SinonSpy;

  class Guard1 {}
  class Guard2 {}

  beforeEach(() => {
    guards = [
      {
        name: 'Guard1',
        token: Guard1,
        metatype: Guard1,
        instance: {
          canActivate: () => true,
        },
        getInstanceByContextId: () => guards[0],
      },
      {
        name: 'Guard2',
        token: Guard2,
        metatype: Guard2,
        instance: {
          canActivate: () => true,
        },
        getInstanceByContextId: () => guards[1],
      },
      {},
      undefined,
    ];
    getSpy = sinon.stub().returns({
      injectables: new Map([
        [Guard1, guards[0]],
        [Guard2, guards[1]],
      ]),
    });
    container = {
      getModules: () => ({
        get: getSpy,
      }),
    };
    applicationConfig = new ApplicationConfig();
    guardsContextCreator = new GuardsContextCreator(
      container,
      applicationConfig,
    );
  });
  describe('createConcreteContext', () => {
    describe('when `moduleContext` is nil', () => {
      it('should return empty array', () => {
        const result = guardsContextCreator.createConcreteContext(guards);
        expect(result).to.be.empty;
      });
    });
    describe('when `moduleContext` is defined', () => {
      beforeEach(() => {
        guardsContextCreator['moduleContext'] = 'test';
      });
      it('should filter metatypes', () => {
        const guardTypeRefs = [guards[0].metatype, guards[1].instance];
        expect(
          guardsContextCreator.createConcreteContext(guardTypeRefs),
        ).to.have.length(2);
      });
    });
  });

  describe('getGuardInstance', () => {
    describe('when param is an object', () => {
      it('should return instance', () => {
        const instance = { canActivate: () => null! };
        expect(guardsContextCreator.getGuardInstance(instance)).to.be.eql(
          instance,
        );
      });
    });
    describe('when param is a constructor', () => {
      it('should pick instance from container', () => {
        const wrapper = {
          instance: 'test',
          getInstanceByContextId: () => wrapper,
        };
        sinon
          .stub(guardsContextCreator, 'getInstanceByMetatype')
          .callsFake(() => wrapper as any);
        expect(guardsContextCreator.getGuardInstance(Guard)).to.be.eql(
          wrapper.instance,
        );
      });
      it('should return null', () => {
        sinon
          .stub(guardsContextCreator, 'getInstanceByMetatype')
          .callsFake(() => null!);
        expect(guardsContextCreator.getGuardInstance(Guard)).to.be.eql(null);
      });
    });
  });

  describe('getInstanceByMetatype', () => {
    describe('when "moduleContext" is nil', () => {
      it('should return undefined', () => {
        (guardsContextCreator as any).moduleContext = undefined;
        expect(guardsContextCreator.getInstanceByMetatype(null!)).to.be
          .undefined;
      });
    });
    describe('when "moduleContext" is not nil', () => {
      beforeEach(() => {
        (guardsContextCreator as any).moduleContext = 'test';
      });

      describe('but module does not exist', () => {
        it('should return undefined', () => {
          expect(
            guardsContextCreator.getInstanceByMetatype(class RandomModule {}),
          ).to.be.undefined;
        });
      });
    });
  });

  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global guards', () => {
        const expectedResult = applicationConfig.getGlobalGuards();
        expect(guardsContextCreator.getGlobalMetadata()).to.be.equal(
          expectedResult,
        );
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped guards', () => {
        const globalGuards: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedGuardWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalGuards')
          .callsFake(() => globalGuards);
        sinon
          .stub(applicationConfig, 'getGlobalRequestGuards')
          .callsFake(() => scopedGuardWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(guardsContextCreator.getGlobalMetadata({ id: 3 })).to.contains(
          instance,
          ...globalGuards,
        );
      });
    });
  });
});



================================================
FILE: packages/core/test/helpers/application-ref-host.spec.ts
================================================
import { expect } from 'chai';
import { HttpAdapterHost } from '../../helpers/http-adapter-host';

describe('HttpAdapterHost', () => {
  let applicationRefHost: HttpAdapterHost;
  beforeEach(() => {
    applicationRefHost = new HttpAdapterHost();
  });

  it('should wrap application reference', () => {
    const ref = {};
    applicationRefHost.httpAdapter = ref as any;

    expect(applicationRefHost.httpAdapter).to.be.eql(ref);
  });

  it('should emit listen event when listening is set to true', done => {
    applicationRefHost.listen$.subscribe(() => {
      expect(applicationRefHost.listening).to.be.true;
      done();
    });
    applicationRefHost.listening = true;
  });

  it('listening should return false if the application isnt listening yet', () => {
    expect(applicationRefHost.listening).to.be.false;
  });
});



================================================
FILE: packages/core/test/helpers/context-id-factory.spec.ts
================================================
import { expect } from 'chai';
import { createContextId } from '../../helpers/context-id-factory';

describe('createContextId', () => {
  it('should return an object with random "id" property', () => {
    expect(createContextId()).to.have.property('id');
  });
});



================================================
FILE: packages/core/test/helpers/context-utils.spec.ts
================================================
import { CUSTOM_ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import { Body, createParamDecorator, Request } from '@nestjs/common/decorators';
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';
import { expect } from 'chai';
import { ROUTE_ARGS_METADATA } from '../../../common/constants';
import { ContextUtils } from '../../helpers/context-utils';
import { ExecutionContextHost } from '../../helpers/execution-context-host';

describe('ContextUtils', () => {
  let contextUtils: ContextUtils;

  beforeEach(() => {
    contextUtils = new ContextUtils();
  });
  describe('reflectCallbackMetadata', () => {
    const CustomDecorator = createParamDecorator(() => {});
    class TestController {
      public callback(
        @Request() req,
        @Body() body,
        @CustomDecorator() custom,
      ) {}
    }
    it('should return ROUTE_ARGS_METADATA callback metadata', () => {
      const instance = new TestController();
      const metadata = contextUtils.reflectCallbackMetadata(
        instance,
        'callback',
        ROUTE_ARGS_METADATA,
      );

      const expectedMetadata = {
        [`${RouteParamtypes.REQUEST}:0`]: {
          index: 0,
          data: undefined,
          pipes: [],
        },
        [`${RouteParamtypes.BODY}:1`]: {
          index: 1,
          data: undefined,
          pipes: [],
        },
        [`custom${CUSTOM_ROUTE_ARGS_METADATA}:2`]: {
          index: 2,
          factory: () => {},
          data: undefined,
        },
      };
      expect(metadata[`${RouteParamtypes.REQUEST}:0`]).to.deep.equal(
        expectedMetadata[`${RouteParamtypes.REQUEST}:0`],
      );
      expect(metadata[`${RouteParamtypes.REQUEST}:1`]).to.deep.equal(
        expectedMetadata[`${RouteParamtypes.REQUEST}:1`],
      );

      const keys = Object.keys(metadata);
      const custom = keys.find(key =>
        key.includes(CUSTOM_ROUTE_ARGS_METADATA),
      )!;

      expect(metadata[custom]).to.be.an('object');
      expect(metadata[custom].index).to.be.eq(2);
      expect(metadata[custom].data).to.be.eq(undefined);
      expect(metadata[custom].factory).to.be.a('function');
    });
  });
  describe('getArgumentsLength', () => {
    it('should return maximum index + 1 (length) placed in array', () => {
      const max = 4;
      const metadata = {
        [RouteParamtypes.REQUEST]: { index: 0 },
        [RouteParamtypes.BODY]: {
          index: max,
        },
      };
      expect(
        contextUtils.getArgumentsLength(Object.keys(metadata), metadata),
      ).to.be.eq(max + 1);
    });
  });
  describe('createNullArray', () => {
    it('should create N size array filled with null', () => {
      const size = 3;
      expect(contextUtils.createNullArray(size)).to.be.deep.eq([
        undefined,
        undefined,
        undefined,
      ]);
    });
  });
  describe('mergeParamsMetatypes', () => {
    it('should return "paramsProperties" when paramtypes array doesn\'t exists', () => {
      const paramsProperties = ['1'];
      expect(
        contextUtils.mergeParamsMetatypes(paramsProperties as any, null!),
      ).to.be.eql(paramsProperties);
    });
  });
  describe('getCustomFactory', () => {
    const contextFactory = (args: unknown[]) => new ExecutionContextHost(args);

    describe('when factory is function', () => {
      it('should return curried factory', () => {
        const data = 3;
        const result = 10;
        const customFactory = (_, req) => result;

        expect(
          contextUtils.getCustomFactory(customFactory, data, contextFactory)(),
        ).to.be.eql(result);
      });
    });
    describe('when factory is undefined / is not a function', () => {
      it('should return curried null identity', () => {
        const customFactory = undefined;
        expect(
          contextUtils.getCustomFactory(
            customFactory!,
            undefined,
            contextFactory,
          )(),
        ).to.be.eql(null);
      });
    });
  });
});



================================================
FILE: packages/core/test/helpers/execution-context-host.spec.ts
================================================
import { expect } from 'chai';
import { ExecutionContextHost } from '../../helpers/execution-context-host';

describe('ExecutionContextHost', () => {
  let contextHost: ExecutionContextHost;

  const args = ['test', 'test2', 'test3'],
    constructorRef = { test: 'test' },
    callback = () => null;

  beforeEach(() => {
    contextHost = new ExecutionContextHost(
      args,
      constructorRef as any,
      callback,
    );
  });

  describe('getClass', () => {
    it('should return constructorRef', () => {
      expect(contextHost.getClass()).to.be.eql(constructorRef);
    });
  });

  describe('getHandler', () => {
    it('should return handler', () => {
      expect(contextHost.getHandler()).to.be.eql(callback);
    });
  });

  describe('getArgs', () => {
    it('should return args', () => {
      expect(contextHost.getArgs()).to.be.eql(args);
    });
  });

  describe('getArgByIndex', () => {
    it('should return argument by index', () => {
      expect(contextHost.getArgByIndex(0)).to.be.eql(args[0]);
    });
  });

  describe('switchToRpc', () => {
    it('should return rpc proxy', () => {
      const proxy = contextHost.switchToRpc();
      expect(proxy.getData).to.be.a('function');
      expect(proxy.getContext).to.be.a('function');
      expect(proxy.getData()).to.be.eq(args[0]);
      expect(proxy.getContext()).to.be.eq(args[1]);
    });
  });

  describe('switchToHttp', () => {
    it('should return http proxy', () => {
      const proxy = contextHost.switchToHttp();
      expect(proxy.getRequest).to.be.a('function');
      expect(proxy.getResponse).to.be.a('function');
      expect(proxy.getNext).to.be.a('function');
      expect(proxy.getRequest()).to.be.eq(args[0]);
      expect(proxy.getResponse()).to.be.eq(args[1]);
      expect(proxy.getNext()).to.be.eq(args[2]);
    });
  });

  describe('switchToWs', () => {
    it('should return ws proxy', () => {
      const proxy = contextHost.switchToWs();
      expect(proxy.getData).to.be.a('function');
      expect(proxy.getClient).to.be.a('function');
      expect(proxy.getClient()).to.be.eq(args[0]);
      expect(proxy.getData()).to.be.eq(args[1]);
    });
  });
});



================================================
FILE: packages/core/test/helpers/external-context-creator.spec.ts
================================================
import { ForbiddenException } from '@nestjs/common';
import { CUSTOM_ROUTE_ARGS_METADATA } from '@nestjs/common/constants';
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { ExternalExceptionFilterContext } from '../../exceptions/external-exception-filter-context';
import { GuardsConsumer } from '../../guards/guards-consumer';
import { GuardsContextCreator } from '../../guards/guards-context-creator';
import { ExternalContextCreator } from '../../helpers/external-context-creator';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';
import { ModulesContainer } from '../../injector/modules-container';
import { InterceptorsConsumer } from '../../interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '../../interceptors/interceptors-context-creator';
import { PipesConsumer } from '../../pipes/pipes-consumer';
import { PipesContextCreator } from '../../pipes/pipes-context-creator';
import { RouteParamsFactory } from '../../router/route-params-factory';

describe('ExternalContextCreator', () => {
  let contextCreator: ExternalContextCreator;
  let callback: any;
  let bindSpy: sinon.SinonSpy;
  let applySpy: sinon.SinonSpy;
  let guardsConsumer: GuardsConsumer;
  let pipesConsumer: PipesConsumer;
  let guardsContextCreator: GuardsContextCreator;

  beforeEach(() => {
    callback = {
      bind: () => ({}),
      apply: () => ({}),
    };
    bindSpy = sinon.spy(callback, 'bind');
    applySpy = sinon.spy(callback, 'apply');

    guardsConsumer = new GuardsConsumer();
    pipesConsumer = new PipesConsumer();
    guardsContextCreator = new GuardsContextCreator(new NestContainer());
    sinon.stub(guardsContextCreator, 'create').returns([{}] as any);
    contextCreator = new ExternalContextCreator(
      guardsContextCreator,
      guardsConsumer,
      new InterceptorsContextCreator(new NestContainer()),
      new InterceptorsConsumer(),
      new ModulesContainer(),
      new PipesContextCreator(new NestContainer()),
      pipesConsumer,
      new ExternalExceptionFilterContext(new NestContainer()),
    );
  });
  describe('create', () => {
    it('should call "getContextModuleName" with expected argument', done => {
      const getContextModuleKeySpy = sinon.spy(
        contextCreator,
        'getContextModuleKey',
      );
      contextCreator.create({ foo: 'bar' }, callback, '', '', null!);
      expect(getContextModuleKeySpy.called).to.be.true;
      done();
    });
    describe('returns proxy function', () => {
      let proxyContext;
      let instance;

      beforeEach(() => {
        instance = { foo: 'bar' };
        proxyContext = contextCreator.create(instance, callback, '', '', null!);
      });
      it('should be a function', () => {
        expect(proxyContext).to.be.a('function');
      });
      describe('when proxy function called', () => {
        describe('when can not activate', () => {
          it('should throw exception when "tryActivate" returns false', async () => {
            sinon
              .stub(guardsConsumer, 'tryActivate')
              .callsFake(async () => false);
            let err: any;
            try {
              await proxyContext(1, 2, 3);
            } catch (e) {
              err = e;
            }
            expect(err).to.be.instanceOf(ForbiddenException);
          });
        });
        describe('when can activate', () => {
          it('should apply context and args', async () => {
            const args = [1, 2, 3];
            sinon
              .stub(guardsConsumer, 'tryActivate')
              .callsFake(async () => true);

            await proxyContext(...args);
            expect(applySpy.called).to.be.true;
          });
        });
      });
    });
  });
  describe('getContextModuleKey', () => {
    describe('when constructor is undefined', () => {
      it('should return empty string', () => {
        expect(contextCreator.getContextModuleKey(undefined)).to.be.eql('');
      });
    });
    describe('when module reference provider exists', () => {
      it('should return module key', () => {
        const modules = new Map();
        const moduleKey = 'key';

        const moduleRef = new Module(class {}, modules as any);
        modules.set(moduleKey, moduleRef);
        (contextCreator as any).modulesContainer = modules;

        sinon.stub(moduleRef, 'hasProvider').callsFake(() => true);

        expect(
          contextCreator.getContextModuleKey({ randomObject: true } as any),
        ).to.be.eql(moduleKey);
      });
    });
    describe('when provider does not exists', () => {
      it('should return empty string', () => {
        expect(contextCreator.getContextModuleKey({} as any)).to.be.eql('');
      });
    });
  });
  describe('exchangeKeysForValues', () => {
    it('should exchange arguments keys for appropriate values', () => {
      const metadata = {
        [RouteParamtypes.REQUEST]: { index: 0, data: 'test', pipes: [] },
        [RouteParamtypes.BODY]: { index: 2, data: 'test', pipes: [] },
        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {
          index: 3,
          data: 'custom',
          pipes: [],
        },
      };
      const keys = Object.keys(metadata);
      const values = contextCreator.exchangeKeysForValues(
        keys,
        metadata,
        '',
        new RouteParamsFactory(),
      );
      const expectedValues = [
        { index: 0, type: RouteParamtypes.REQUEST, data: 'test' },
        { index: 2, type: RouteParamtypes.BODY, data: 'test' },
        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },
      ];
      expect(values[0]).to.deep.include(expectedValues[0]);
      expect(values[1]).to.deep.include(expectedValues[1]);
    });
  });
  describe('getParamValue', () => {
    let consumerApplySpy: sinon.SinonSpy;
    const value = 3,
      metatype = null,
      transforms = [{ transform: sinon.spy() }];

    beforeEach(() => {
      consumerApplySpy = sinon.spy(pipesConsumer, 'apply');
    });
    it('should call "consumer.apply"', async () => {
      await contextCreator.getParamValue(
        value,
        { metatype, type: RouteParamtypes.NEXT, data: null },
        transforms,
      );
      expect(consumerApplySpy.called).to.be.true;
    });
  });
  describe('createPipesFn', () => {
    describe('when "paramsOptions" is empty', () => {
      it('returns null', async () => {
        const pipesFn = contextCreator.createPipesFn([], []);
        expect(pipesFn).to.be.null;
      });
    });
    describe('when "paramsOptions" is not empty', () => {
      it('returns function', async () => {
        const pipesFn = contextCreator.createPipesFn(
          [],
          [
            {
              index: 1,
              type: 'test',
              data: null!,
              pipes: [],
              extractValue: () => null,
            },
          ],
        )!;
        await pipesFn([]);
        expect(pipesFn).to.be.a('function');
      });
    });
  });

  describe('transformToResult', () => {
    describe('when resultOrDeferred', () => {
      describe('is Promise', () => {
        it('should return Promise', async () => {
          const value = 100;
          expect(
            await contextCreator.transformToResult(Promise.resolve(value)),
          ).to.be.eq(100);
        });
      });

      describe('is Observable', () => {
        it('should return Promise', async () => {
          const value = 100;
          expect(await contextCreator.transformToResult(of(value))).to.be.eq(
            100,
          );
        });
      });

      describe('is value', () => {
        it('should return Promise', async () => {
          const value = 100;
          expect(await contextCreator.transformToResult(value)).to.be.eq(100);
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/helpers/external-proxy.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { HttpException } from '../../../common/exceptions/http.exception';
import { ExternalExceptionsHandler } from '../../exceptions/external-exceptions-handler';
import { ExternalErrorProxy } from '../../helpers/external-proxy';

describe('ExternalErrorProxy', () => {
  let externalErrorProxy: ExternalErrorProxy;
  let handlerMock: sinon.SinonMock;
  let handler: ExternalExceptionsHandler;

  beforeEach(() => {
    handler = new ExternalExceptionsHandler();
    handlerMock = sinon.mock(handler);
    externalErrorProxy = new ExternalErrorProxy();
  });

  describe('createProxy', () => {
    it('should method return thunk', () => {
      const proxy = externalErrorProxy.createProxy(() => {}, handler);
      expect(typeof proxy === 'function').to.be.true;
    });

    it('should method encapsulate callback passed as argument', async () => {
      const expectation = handlerMock.expects('next').once();
      const proxy = externalErrorProxy.createProxy((req, res, next) => {
        throw new HttpException('test', 500);
      }, handler);
      await proxy(null, null, null);
      expectation.verify();
    });

    it('should method encapsulate async callback passed as argument', async () => {
      const expectation = handlerMock.expects('next').once();
      const proxy = externalErrorProxy.createProxy(async (req, res, next) => {
        throw new HttpException('test', 500);
      }, handler);

      await proxy(null, null, null);

      expectation.verify();
    });
  });
});



================================================
FILE: packages/core/test/helpers/router-method-factory.spec.ts
================================================
import { expect } from 'chai';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { RouterMethodFactory } from '../../helpers/router-method-factory';

describe('RouterMethodFactory', () => {
  let factory: RouterMethodFactory;

  const target: any = {
    get: () => {},
    post: () => {},
    use: () => {},
    delete: () => {},
    put: () => {},
    patch: () => {},
    options: () => {},
    head: () => {},
    propfind: () => {},
    proppatch: () => {},
    mkcol: () => {},
    copy: () => {},
    move: () => {},
    lock: () => {},
    unlock: () => {},
    all: () => {},
  };
  beforeEach(() => {
    factory = new RouterMethodFactory();
  });

  it('should return proper method', () => {
    expect(factory.get(target, RequestMethod.DELETE)).to.equal(target.delete);
    expect(factory.get(target, RequestMethod.POST)).to.equal(target.post);
    expect(factory.get(target, RequestMethod.ALL)).to.equal(target.all);
    expect(factory.get(target, RequestMethod.PUT)).to.equal(target.put);
    expect(factory.get(target, RequestMethod.GET)).to.equal(target.get);
    expect(factory.get(target, RequestMethod.PATCH)).to.equal(target.patch);
    expect(factory.get(target, RequestMethod.OPTIONS)).to.equal(target.options);
    expect(factory.get(target, RequestMethod.HEAD)).to.equal(target.head);
    expect(factory.get(target, RequestMethod.PROPFIND)).to.equal(
      target.propfind,
    );
    expect(factory.get(target, RequestMethod.PROPPATCH)).to.equal(
      target.proppatch,
    );
    expect(factory.get(target, RequestMethod.MKCOL)).to.equal(target.mkcol);
    expect(factory.get(target, RequestMethod.COPY)).to.equal(target.copy);
    expect(factory.get(target, RequestMethod.MOVE)).to.equal(target.move);
    expect(factory.get(target, RequestMethod.LOCK)).to.equal(target.lock);
    expect(factory.get(target, RequestMethod.UNLOCK)).to.equal(target.unlock);
    expect(factory.get(target, -1 as any)).to.equal(target.use);
  });
});



================================================
FILE: packages/core/test/hooks/before-app-shutdown.hook.spec.ts
================================================
import { BeforeApplicationShutdown } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { callBeforeAppShutdownHook } from '../../hooks/before-app-shutdown.hook';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';

class SampleProvider implements BeforeApplicationShutdown {
  beforeApplicationShutdown(signal?: string) {}
}

class SampleModule implements BeforeApplicationShutdown {
  beforeApplicationShutdown(signal?: string) {}
}

class WithoutHookProvider {}

describe('BeforeAppShutdown', () => {
  let moduleRef: Module;
  let sampleProvider: SampleProvider;

  beforeEach(() => {
    sampleProvider = new SampleProvider();
    moduleRef = new Module(SampleModule, new NestContainer());

    const moduleWrapperRef = moduleRef.getProviderByKey(SampleModule);
    moduleWrapperRef.instance = new SampleModule();

    moduleRef.addProvider({
      provide: SampleProvider,
      useValue: sampleProvider,
    });
    moduleRef.addProvider({
      provide: WithoutHookProvider,
      useValue: new WithoutHookProvider(),
    });
  });

  describe('callBeforeAppShutdownHook', () => {
    it('should call "beforeApplicationShutdown" hook for the entire module', async () => {
      const signal = 'SIGTERM';

      const hookSpy = sinon.spy(sampleProvider, 'beforeApplicationShutdown');
      await callBeforeAppShutdownHook(moduleRef, signal);

      expect(hookSpy.calledWith(signal)).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/hooks/on-app-bootstrap.hook.spec.ts
================================================
import { OnApplicationBootstrap } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { callModuleBootstrapHook } from '../../hooks/on-app-bootstrap.hook';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';

class SampleProvider implements OnApplicationBootstrap {
  onApplicationBootstrap() {}
}

class SampleModule implements OnApplicationBootstrap {
  onApplicationBootstrap() {}
}

class WithoutHookProvider {}

describe('OnApplicationBootstrap', () => {
  let moduleRef: Module;
  let sampleProvider: SampleProvider;

  beforeEach(() => {
    sampleProvider = new SampleProvider();
    moduleRef = new Module(SampleModule, new NestContainer());

    const moduleWrapperRef = moduleRef.getProviderByKey(SampleModule);
    moduleWrapperRef.instance = new SampleModule();

    moduleRef.addProvider({
      provide: SampleProvider,
      useValue: sampleProvider,
    });
    moduleRef.addProvider({
      provide: WithoutHookProvider,
      useValue: new WithoutHookProvider(),
    });
  });

  describe('callModuleBootstrapHook', () => {
    it('should call "onApplicationBootstrap" hook for the entire module', async () => {
      const hookSpy = sinon.spy(sampleProvider, 'onApplicationBootstrap');
      await callModuleBootstrapHook(moduleRef);

      expect(hookSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/hooks/on-app-shutdown.hook.spec.ts
================================================
import { OnApplicationShutdown } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { callAppShutdownHook } from '../../hooks/on-app-shutdown.hook';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';

class SampleProvider implements OnApplicationShutdown {
  onApplicationShutdown() {}
}

class SampleModule implements OnApplicationShutdown {
  onApplicationShutdown() {}
}

class WithoutHookProvider {}

describe('OnApplicationShutdown', () => {
  let moduleRef: Module;
  let sampleProvider: SampleProvider;

  beforeEach(() => {
    sampleProvider = new SampleProvider();
    moduleRef = new Module(SampleModule, new NestContainer());

    const moduleWrapperRef = moduleRef.getProviderByKey(SampleModule);
    moduleWrapperRef.instance = new SampleModule();

    moduleRef.addProvider({
      provide: SampleProvider,
      useValue: sampleProvider,
    });
    moduleRef.addProvider({
      provide: WithoutHookProvider,
      useValue: new WithoutHookProvider(),
    });
  });

  describe('callAppShutdownHook', () => {
    it('should call "onApplicationShutdown" hook for the entire module', async () => {
      const hookSpy = sinon.spy(sampleProvider, 'onApplicationShutdown');
      await callAppShutdownHook(moduleRef);

      expect(hookSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/hooks/on-module-destroy.hook.spec.ts
================================================
import { OnModuleDestroy } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { callModuleDestroyHook } from '../../hooks/on-module-destroy.hook';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';

class SampleProvider implements OnModuleDestroy {
  onModuleDestroy() {}
}

class SampleModule implements OnModuleDestroy {
  onModuleDestroy() {}
}

class WithoutHookProvider {}

describe('OnModuleDestroy', () => {
  let moduleRef: Module;
  let sampleProvider: SampleProvider;

  beforeEach(() => {
    sampleProvider = new SampleProvider();
    moduleRef = new Module(SampleModule, new NestContainer());

    const moduleWrapperRef = moduleRef.getProviderByKey(SampleModule);
    moduleWrapperRef.instance = new SampleModule();

    moduleRef.addProvider({
      provide: SampleProvider,
      useValue: sampleProvider,
    });
    moduleRef.addProvider({
      provide: WithoutHookProvider,
      useValue: new WithoutHookProvider(),
    });
  });

  describe('callModuleDestroyHook', () => {
    it('should call "onModuleDestroy" hook for the entire module', async () => {
      const hookSpy = sinon.spy(sampleProvider, 'onModuleDestroy');
      await callModuleDestroyHook(moduleRef);

      expect(hookSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/hooks/on-module-init.hook.spec.ts
================================================
import { OnModuleInit } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { callModuleInitHook } from '../../hooks/on-module-init.hook';
import { NestContainer } from '../../injector/container';
import { Module } from '../../injector/module';

class SampleProvider implements OnModuleInit {
  onModuleInit() {}
}

class SampleModule implements OnModuleInit {
  onModuleInit() {}
}

class WithoutHookProvider {}

describe('OnModuleInit', () => {
  let moduleRef: Module;
  let sampleProvider: SampleProvider;

  beforeEach(() => {
    sampleProvider = new SampleProvider();
    moduleRef = new Module(SampleModule, new NestContainer());

    const moduleWrapperRef = moduleRef.getProviderByKey(SampleModule);
    moduleWrapperRef.instance = new SampleModule();

    moduleRef.addProvider({
      provide: SampleProvider,
      useValue: sampleProvider,
    });
    moduleRef.addProvider({
      provide: WithoutHookProvider,
      useValue: new WithoutHookProvider(),
    });
  });

  describe('callModuleInitHook', () => {
    it('should call "onModuleInit" hook for the entire module', async () => {
      const hookSpy = sinon.spy(sampleProvider, 'onModuleInit');
      await callModuleInitHook(moduleRef);

      expect(hookSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/injector/compiler.spec.ts
================================================
import { expect } from 'chai';
import { ModuleCompiler } from '../../injector/compiler';
import { ByReferenceModuleOpaqueKeyFactory } from '../../injector/opaque-key-factory/by-reference-module-opaque-key-factory';

describe('ModuleCompiler', () => {
  let compiler: ModuleCompiler;
  beforeEach(() => {
    compiler = new ModuleCompiler(new ByReferenceModuleOpaqueKeyFactory());
  });

  describe('extractMetadata', () => {
    describe('when module is a dynamic module', () => {
      it('should return object with "type" and "dynamicMetadata" property', () => {
        const obj = { module: 'test', providers: [] };
        const { module, ...dynamicMetadata } = obj;
        expect(compiler.extractMetadata(obj as any)).to.be.deep.equal({
          type: module,
          dynamicMetadata,
        });
      });
    });
    describe('when module is a not dynamic module', () => {
      it('should return object with "type" property', () => {
        const type = 'test';
        expect(compiler.extractMetadata(type as any)).to.be.deep.equal({
          type,
          dynamicMetadata: undefined,
        });
      });
    });
  });

  describe('isDynamicModule', () => {
    describe('when module is a dynamic module', () => {
      it('should return true', () => {
        expect(compiler.isDynamicModule({ module: true } as any)).to.be.true;
      });
    });
    describe('when module is a dynamic module', () => {
      it('should return false', () => {
        expect(compiler.isDynamicModule({ x: true } as any)).to.be.false;
      });
    });
  });
});



================================================
FILE: packages/core/test/injector/container.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Module } from '../../../common/decorators/modules/module.decorator';
import { Global } from '../../../common/index';
import { CircularDependencyException } from '../../errors/exceptions/circular-dependency.exception';
import { UnknownModuleException } from '../../errors/exceptions/unknown-module.exception';
import { NestContainer } from '../../injector/container';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('NestContainer', () => {
  let container: NestContainer;
  let untypedContainer: any;

  @Module({})
  class TestModule {}

  @Global()
  @Module({})
  class GlobalTestModule {}

  beforeEach(() => {
    container = new NestContainer();
    untypedContainer = container as any;
  });

  it('should "addProvider" throw "UnknownModuleException" when module is not stored in collection', () => {
    expect(() => container.addProvider({} as any, 'TestModule')).throw(
      UnknownModuleException,
    );
  });

  it('should "addProvider" throw "CircularDependencyException" when provider is nil', () => {
    expect(() => container.addProvider(null!, 'TestModule')).throw(
      CircularDependencyException,
    );
  });

  it('should "addController" throw "UnknownModuleException" when module is not stored in collection', () => {
    expect(() => container.addController(null!, 'TestModule')).throw(
      UnknownModuleException,
    );
  });

  it('should "addExportedProviderOrModule" throw "UnknownModuleException" when module is not stored in collection', () => {
    expect(() =>
      container.addExportedProviderOrModule(null!, 'TestModule'),
    ).throw(UnknownModuleException);
  });

  it('should "addInjectable" throw "UnknownModuleException" when module is not stored in collection', () => {
    expect(() => container.addInjectable(null!, 'TestModule', null!)).throw(
      UnknownModuleException,
    );
  });

  describe('clear', () => {
    it('should call `clear` on modules collection', () => {
      const clearSpy = sinon.spy(untypedContainer.modules, 'clear');
      container.clear();
      expect(clearSpy.called).to.be.true;
    });
  });

  describe('addModule', () => {
    it('should not add module if already exists in collection', async () => {
      const modules = new Map();
      const setSpy = sinon.spy(modules, 'set');
      untypedContainer.modules = modules;

      await container.addModule(TestModule as any, []);
      await container.addModule(TestModule as any, []);

      expect(setSpy.calledOnce).to.be.true;
    });

    it('should throw an exception when metatype is not defined', () => {
      expect(container.addModule(undefined!, [])).to.eventually.throws();
    });

    it('should add global module when module is global', async () => {
      const addGlobalModuleSpy = sinon.spy(container, 'addGlobalModule');
      await container.addModule(GlobalTestModule as any, []);
      expect(addGlobalModuleSpy.calledOnce).to.be.true;
    });
  });

  describe('replaceModule', () => {
    it('should replace module if already exists in collection', async () => {
      @Module({})
      class ReplaceTestModule {}

      const modules = new Map();
      const setSpy = sinon.spy(modules, 'set');
      untypedContainer.modules = modules;

      await container.addModule(TestModule as any, []);
      await container.replaceModule(
        TestModule as any,
        ReplaceTestModule as any,
        [],
      );

      expect(setSpy.calledTwice).to.be.true;
    });

    it('should throw an exception when metatype is not defined', () => {
      expect(container.addModule(undefined!, [])).to.eventually.throws();
    });

    it('should add global module when module is global', async () => {
      const addGlobalModuleSpy = sinon.spy(container, 'addGlobalModule');
      await container.addModule(GlobalTestModule as any, []);
      expect(addGlobalModuleSpy.calledOnce).to.be.true;
    });
  });

  describe('isGlobalModule', () => {
    describe('when module is not globally scoped', () => {
      it('should return false', () => {
        expect(container.isGlobalModule(TestModule)).to.be.false;
      });
    });
    describe('when module is globally scoped', () => {
      it('should return true', () => {
        expect(container.isGlobalModule(GlobalTestModule)).to.be.true;
      });
    });
    describe('when dynamic module is globally scoped', () => {
      it('should return true', () => {
        expect(container.isGlobalModule(TestModule, { global: true })).to.be
          .true;
      });
    });
  });

  describe('bindGlobalsToImports', () => {
    it('should call "bindGlobalModuleToModule" for every global module', () => {
      const global1 = { test: 1 };
      const global2 = { test: 2 };

      container.addGlobalModule(global1 as any);
      container.addGlobalModule(global2 as any);

      const bindGlobalModuleToModuleSpy = sinon.spy(
        container,
        'bindGlobalModuleToModule',
      );
      container.bindGlobalsToImports({
        addImport: sinon.spy(),
      } as any);
      expect(bindGlobalModuleToModuleSpy.calledTwice).to.be.true;
    });
  });

  describe('bindGlobalModuleToModule', () => {
    describe('when "module" is not "globalModule"', () => {
      it('should call "addImport"', () => {
        const module = { addImport: sinon.spy() };
        container.bindGlobalModuleToModule(module as any, null!);
        expect(module.addImport.calledOnce).to.be.true;
      });
    });
    describe('when "module" is "globalModule"', () => {
      it('should not call "addImport"', () => {
        const module = { addImport: sinon.spy() };
        container.bindGlobalModuleToModule(module as any, module as any);
        expect(module.addImport.calledOnce).to.be.false;
      });
    });
  });

  describe('addDynamicMetadata', () => {
    let token: string;
    let collection: Map<string, any>;

    beforeEach(() => {
      token = 'token';
      collection = new Map();
      untypedContainer.dynamicModulesMetadata = collection;
    });
    describe('when dynamic metadata exists', () => {
      it('should add to the dynamic metadata collection', async () => {
        const addSpy = sinon.spy(collection, 'set');
        const dynamicMetadata = { module: null! };

        await container.addDynamicMetadata(token, dynamicMetadata, []);
        expect(addSpy.calledWith(token, dynamicMetadata)).to.be.true;
      });
    });
    describe('when dynamic metadata does not exists', () => {
      it('should not add to the dynamic metadata collection', async () => {
        const addSpy = sinon.spy(collection, 'set');
        await container.addDynamicMetadata(token, null!, []);
        expect(addSpy.called).to.be.false;
      });
    });
  });

  class Test {}
  describe('addDynamicModules', () => {
    describe('when array is empty/undefined', () => {
      it('should not call "addModule"', async () => {
        const addModuleSpy = sinon.spy(container, 'addModule');
        await container.addDynamicModules(undefined!, []);
        expect(addModuleSpy.called).to.be.false;
      });
    });
    describe('when array is not empty/undefined', () => {
      it('should call "addModule"', async () => {
        const addModuleSpy = sinon.spy(container, 'addModule');
        await container.addDynamicModules([Test] as any, []);
        expect(addModuleSpy.called).to.be.true;
      });
    });
  });

  describe('get applicationConfig', () => {
    it('should return ApplicationConfig instance', () => {
      expect(container.applicationConfig).to.be.eql(
        untypedContainer._applicationConfig,
      );
    });
  });

  describe('setHttpAdapter', () => {
    it('should set http adapter', () => {
      const httpAdapter = new NoopHttpAdapter({});
      container.setHttpAdapter(httpAdapter);

      const internalStorage = untypedContainer.internalProvidersStorage;
      expect(internalStorage.httpAdapter).to.be.eql(httpAdapter);
    });
  });

  describe('getModuleByKey', () => {
    it('should return module by passed key', () => {
      const key = 'test';
      const value = {};
      container.getModules().set(key, value as any);

      expect(container.getModuleByKey(key)).to.be.eql(value);
    });
  });

  describe('registerCoreModuleRef', () => {
    it('should register core module ref', () => {
      const ref = {} as any;
      container.registerCoreModuleRef(ref);
      expect(untypedContainer.internalCoreModule).to.be.eql(ref);
    });
  });
});



================================================
FILE: packages/core/test/injector/injector.spec.ts
================================================
import { Optional } from '@nestjs/common';
import { PARAMTYPES_METADATA } from '@nestjs/common/constants';
import * as chai from 'chai';
import { expect } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import * as sinon from 'sinon';
import { Inject } from '../../../common/decorators/core/inject.decorator';
import { Injectable } from '../../../common/decorators/core/injectable.decorator';
import { STATIC_CONTEXT } from '../../injector/constants';
import { NestContainer } from '../../injector/container';
import { Injector, PropertyDependency } from '../../injector/injector';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { Module } from '../../injector/module';

chai.use(chaiAsPromised);

describe('Injector', () => {
  let injector: Injector;

  beforeEach(() => {
    injector = new Injector();
  });

  describe('loadInstance', () => {
    @Injectable()
    class DependencyOne {}

    @Injectable()
    class DependencyTwo {}

    @Injectable()
    class MainTest {
      @Inject() property: DependencyOne;

      constructor(
        public one: DependencyOne,
        @Inject() public two: DependencyTwo,
      ) {}
    }

    let moduleDeps: Module;
    let mainTest, depOne, depTwo;

    beforeEach(() => {
      moduleDeps = new Module(DependencyTwo, new NestContainer());
      mainTest = new InstanceWrapper({
        name: 'MainTest',
        token: 'MainTest',
        metatype: MainTest,
        instance: Object.create(MainTest.prototype),
        isResolved: false,
      });
      depOne = new InstanceWrapper({
        name: DependencyOne,
        token: DependencyOne,
        metatype: DependencyOne,
        instance: Object.create(DependencyOne.prototype),
        isResolved: false,
      });
      depTwo = new InstanceWrapper({
        name: DependencyTwo,
        token: DependencyTwo,
        metatype: DependencyTwo,
        instance: Object.create(DependencyTwo.prototype),
        isResolved: false,
      });
      moduleDeps.providers.set('MainTest', mainTest);
      moduleDeps.providers.set(DependencyOne, depOne);
      moduleDeps.providers.set(DependencyTwo, depTwo);
      moduleDeps.providers.set('MainTestResolved', {
        ...mainTest,
        isResolved: true,
      });
    });

    it('should create an instance of component with proper dependencies', async () => {
      await injector.loadInstance(mainTest, moduleDeps.providers, moduleDeps);
      const { instance } = moduleDeps.providers.get(
        'MainTest',
      ) as InstanceWrapper<MainTest>;

      expect(instance.one).instanceof(DependencyOne);
      expect(instance.two).instanceof(DependencyTwo);
      expect(instance).instanceof(MainTest);
    });

    it('should set "isResolved" property to true after instance initialization', async () => {
      await injector.loadInstance(mainTest, moduleDeps.providers, moduleDeps);
      const { isResolved } = (
        moduleDeps.providers.get('MainTest') as InstanceWrapper<MainTest>
      ).getInstanceByContextId(STATIC_CONTEXT);
      expect(isResolved).to.be.true;
    });

    it('should throw RuntimeException when type is not stored in collection', () => {
      return expect(
        injector.loadInstance({} as any, moduleDeps.providers, moduleDeps),
      ).to.eventually.be.rejected;
    });

    it('should await done$ when "isPending"', () => {
      const wrapper = new InstanceWrapper({
        name: 'MainTest',
        metatype: MainTest,
        instance: Object.create(MainTest.prototype),
        isResolved: false,
      });
      const host = wrapper.getInstanceByContextId(STATIC_CONTEXT);
      host.donePromise = Promise.resolve();
      host.isPending = true;

      expect(
        injector.loadInstance(wrapper, moduleDeps.providers, moduleDeps),
      ).to.eventually.not.throw();
    });

    it('should await done$ when "isPending" and rethrow an exception (if thrown)', () => {
      const error = new Error('Test error');
      const wrapper = new InstanceWrapper({
        name: 'MainTest',
        metatype: MainTest,
        instance: Object.create(MainTest.prototype),
        isResolved: false,
      });
      const host = wrapper.getInstanceByContextId(STATIC_CONTEXT);
      host.donePromise = Promise.resolve(error);
      host.isPending = true;

      expect(
        injector.loadInstance(wrapper, moduleDeps.providers, moduleDeps),
      ).to.eventually.throw(error);
    });

    it('should return undefined when metatype is resolved', async () => {
      const result = await injector.loadInstance(
        new InstanceWrapper({
          name: 'MainTestResolved',
          metatype: MainTest,
          instance: Object.create(MainTest.prototype),
          isResolved: true,
        }),
        moduleDeps.providers,
        moduleDeps,
      );
      expect(result).to.be.undefined;
    });
  });

  describe('loadPrototype', () => {
    @Injectable()
    class Test {}

    let moduleDeps: Module;
    let test;

    beforeEach(() => {
      moduleDeps = new Module(Test, new NestContainer());
      test = new InstanceWrapper({
        name: 'Test',
        token: 'Test',
        metatype: Test,
        instance: null,
        isResolved: false,
      });
      moduleDeps.providers.set('Test', test);
    });

    it('should create prototype of instance', () => {
      injector.loadPrototype(test, moduleDeps.providers);
      expect(moduleDeps.providers.get('Test')!.instance).to.deep.equal(
        Object.create(Test.prototype),
      );
    });

    it('should return undefined when collection is nil', () => {
      const result = injector.loadPrototype(test, null!);
      expect(result).to.be.undefined;
    });

    it('should return undefined when target isResolved', () => {
      const collection = {
        get: () => ({
          getInstanceByContextId: () => ({ isResolved: true }),
          createPrototype: () => {},
        }),
      };
      const result = injector.loadPrototype(test, collection as any);
      expect(result).to.be.undefined;
    });

    it('should return undefined when "inject" is not nil', () => {
      const collection = {
        get: () => new InstanceWrapper({ inject: [] }),
      };
      const result = injector.loadPrototype(test, collection as any);
      expect(result).to.be.undefined;
    });
  });

  describe('resolveSingleParam', () => {
    it('should throw "RuntimeException" when param is undefined', async () => {
      return expect(
        injector.resolveSingleParam(
          null!,
          undefined!,
          { index: 0, dependencies: [] },
          null!,
        ),
      ).to.eventually.be.rejected;
    });
  });

  describe('loadMiddleware', () => {
    let loadInstanceSpy: sinon.SinonSpy;

    beforeEach(() => {
      loadInstanceSpy = sinon.spy();
      injector.loadInstance = loadInstanceSpy;
    });

    it('should call "loadInstance" when instance is not resolved', async () => {
      const collection = {
        get: (...args) => ({}),
        set: (...args) => {},
      };

      await injector.loadMiddleware(
        { metatype: { name: '', prototype: {} } } as any,
        collection as any,
        null!,
      );
      expect(loadInstanceSpy.called).to.be.true;
    });

    it('should not call "loadInstanceSpy" when instance is not resolved', async () => {
      const collection = {
        get: (...args) => ({
          instance: {},
        }),
        set: (...args) => {},
      };

      await injector.loadMiddleware(
        { metatype: { name: '' } } as any,
        collection as any,
        null!,
      );
      expect(loadInstanceSpy.called).to.be.false;
    });
  });

  describe('loadController', () => {
    let loadInstance: sinon.SinonSpy;

    beforeEach(() => {
      loadInstance = sinon.spy();
      injector.loadInstance = loadInstance;
    });

    it('should call "loadInstance" with expected arguments', async () => {
      const module = { controllers: [] };
      const wrapper = { test: 'test', getEnhancersMetadata: () => [] };

      await injector.loadController(wrapper as any, module as any);
      expect(loadInstance.calledWith(wrapper, module.controllers, module)).to.be
        .true;
    });
  });

  describe('loadInjectable', () => {
    let loadInstance: sinon.SinonSpy;

    beforeEach(() => {
      loadInstance = sinon.spy();
      injector.loadInstance = loadInstance;
    });

    it('should call "loadInstance" with expected arguments', async () => {
      const module = { injectables: [] };
      const wrapper = { test: 'test' };

      await injector.loadInjectable(wrapper as any, module as any);
      expect(loadInstance.calledWith(wrapper, module.injectables, module)).to.be
        .true;
    });
  });

  describe('lookupComponent', () => {
    let lookupComponentInImports: sinon.SinonStub;
    const metatype = { name: 'test', metatype: { name: 'test' } };
    const wrapper = new InstanceWrapper({
      name: 'Test',
      metatype: metatype as any,
      instance: null,
      isResolved: false,
    });
    beforeEach(() => {
      lookupComponentInImports = sinon.stub();
      (injector as any).lookupComponentInImports = lookupComponentInImports;
    });

    it('should return object from collection if exists', async () => {
      const instance = { test: 3 };
      const collection = {
        has: () => true,
        get: () => instance,
      };
      const result = await injector.lookupComponent(
        collection as any,
        null!,
        { name: metatype.name, index: 0, dependencies: [] },
        wrapper,
      );
      expect(result).to.be.equal(instance);
    });

    it('should throw an exception if recursion happens', () => {
      const name = 'RecursionService';
      const instance = { test: 3 };
      const collection = {
        has: () => true,
        get: () => instance,
      };
      const result = injector.lookupComponent(
        collection as any,
        null!,
        { name, index: 0, dependencies: [] },
        Object.assign(wrapper, {
          name,
        }),
      );
      expect(result).to.eventually.be.rejected;
    });

    it('should call "lookupComponentInImports" when object is not in collection', async () => {
      lookupComponentInImports.returns({});
      const collection = {
        has: () => false,
      };
      await injector.lookupComponent(
        collection as any,
        null!,
        { name: metatype.name, index: 0, dependencies: [] },
        wrapper,
      );
      expect(lookupComponentInImports.called).to.be.true;
    });

    it('should throw "UnknownDependenciesException" when instanceWrapper is null and "exports" collection does not contain token', () => {
      lookupComponentInImports.returns(null);
      const collection = {
        has: () => false,
      };
      const module = { exports: collection };
      expect(
        injector.lookupComponent(
          collection as any,
          module as any,
          { name: metatype.name, index: 0, dependencies: [] },
          wrapper,
        ),
      ).to.eventually.be.rejected;
    });

    it('should not throw "UnknownDependenciesException" instanceWrapper is not null', () => {
      lookupComponentInImports.returns({});
      const collection = {
        has: () => false,
      };
      const module = { exports: collection };
      expect(
        injector.lookupComponent(
          collection as any,
          module as any,
          { name: metatype.name, index: 0, dependencies: [] },
          wrapper,
        ),
      ).to.eventually.be.not.rejected;
    });
  });

  describe('lookupComponentInImports', () => {
    let loadProvider: sinon.SinonSpy;
    const metatype = { name: 'test' };
    const module = {
      relatedModules: new Map(),
    };

    beforeEach(() => {
      loadProvider = sinon.spy();
      (injector as any).loadProvider = loadProvider;
    });

    it('should return null when there is no related modules', async () => {
      const result = await injector.lookupComponentInImports(
        module as any,
        'testToken',
        new InstanceWrapper(),
      );
      expect(result).to.be.eq(null);
    });

    it('should return null when related modules do not have appropriate component', () => {
      let moduleFixture = {
        relatedModules: new Map([
          [
            'key',
            {
              providers: {
                has: () => false,
              },
              exports: {
                has: () => true,
              },
            },
          ],
        ] as any),
      };
      expect(
        injector.lookupComponentInImports(
          moduleFixture as any,
          metatype as any,
          null!,
        ),
      ).to.be.eventually.eq(null);

      moduleFixture = {
        relatedModules: new Map([
          [
            'key',
            {
              providers: {
                has: () => true,
              },
              exports: {
                has: () => false,
              },
            },
          ],
        ] as any),
      };
      expect(
        injector.lookupComponentInImports(
          moduleFixture as any,
          metatype as any,
          null!,
        ),
      ).to.eventually.be.eq(null);
    });

    it('should call "loadProvider" when component is not resolved', async () => {
      const moduleFixture = {
        imports: new Map([
          [
            'key',
            {
              providers: {
                has: () => true,
                get: () =>
                  new InstanceWrapper({
                    isResolved: false,
                  }),
              },
              exports: {
                has: () => true,
              },
              imports: new Map(),
            },
          ],
        ] as any),
      };
      await injector.lookupComponentInImports(
        moduleFixture as any,
        metatype as any,
        new InstanceWrapper(),
      );
      expect(loadProvider.called).to.be.true;
    });

    it('should not call "loadProvider" when component is resolved', async () => {
      const moduleFixture = {
        relatedModules: new Map([
          [
            'key',
            {
              providers: {
                has: () => true,
                get: () => ({
                  isResolved: true,
                }),
              },
              exports: {
                has: () => true,
              },
              relatedModules: new Map(),
            },
          ],
        ] as any),
      };
      await injector.lookupComponentInImports(
        moduleFixture as any,
        metatype as any,
        null!,
      );
      expect(loadProvider.called).to.be.false;
    });
  });

  describe('resolveParamToken', () => {
    let forwardRef;
    let wrapper;
    let param;

    describe('when "forwardRef" property is not nil', () => {
      beforeEach(() => {
        forwardRef = 'test';
        wrapper = {};
        param = {
          forwardRef: () => forwardRef,
        };
      });
      it('return forwardRef() result', () => {
        expect(injector.resolveParamToken(wrapper, param)).to.be.eql(
          forwardRef,
        );
      });
      it('set wrapper "forwardRef" property to true', () => {
        injector.resolveParamToken(wrapper, param);
        expect(wrapper.forwardRef).to.be.true;
      });
    });
    describe('when "forwardRef" property is nil', () => {
      beforeEach(() => {
        forwardRef = 'test';
        wrapper = {};
        param = {};
      });
      it('set wrapper "forwardRef" property to false', () => {
        injector.resolveParamToken(wrapper, param);
        expect(wrapper.forwardRef).to.be.undefined;
      });
      it('return param', () => {
        expect(injector.resolveParamToken(wrapper, param)).to.be.eql(param);
      });
    });
  });

  describe('resolveComponentInstance', () => {
    let module: any;
    beforeEach(() => {
      module = {
        providers: [],
      };
    });

    describe('when instanceWrapper is not resolved and does not have forward ref', () => {
      it('should call loadProvider', async () => {
        const wrapper = new InstanceWrapper({ isResolved: false });

        const loadStub = sinon
          .stub(injector, 'loadProvider')
          .callsFake(() => null!);
        sinon
          .stub(injector, 'lookupComponent')
          .returns(Promise.resolve(wrapper));

        await injector.resolveComponentInstance(
          module,
          '',
          { index: 0, dependencies: [] },
          wrapper,
        );
        expect(loadStub.called).to.be.true;
      });
      it('should not call loadProvider (isResolved)', async () => {
        const wrapper = new InstanceWrapper({ isResolved: true });
        const loadStub = sinon
          .stub(injector, 'loadProvider')
          .callsFake(() => null!);

        sinon
          .stub(injector, 'lookupComponent')
          .returns(Promise.resolve(wrapper));

        await injector.resolveComponentInstance(
          module,
          '',
          { index: 0, dependencies: [] },
          wrapper,
        );
        expect(loadStub.called).to.be.false;
      });
      it('should not call loadProvider (forwardRef)', async () => {
        const wrapper = new InstanceWrapper({
          isResolved: false,
          forwardRef: true,
        });
        const loadStub = sinon
          .stub(injector, 'loadProvider')
          .callsFake(() => null!);

        sinon
          .stub(injector, 'lookupComponent')
          .returns(Promise.resolve(wrapper));

        await injector.resolveComponentInstance(
          module,
          '',
          { index: 0, dependencies: [] },
          wrapper,
        );
        expect(loadStub.called).to.be.false;
      });
    });

    describe('when instanceWrapper has async property', () => {
      it('should await instance', async () => {
        sinon.stub(injector, 'loadProvider').callsFake(() => null!);

        const instance = Promise.resolve(true);
        const wrapper = new InstanceWrapper({
          isResolved: false,
          forwardRef: true,
          async: true,
          instance,
        });
        sinon
          .stub(injector, 'lookupComponent')
          .returns(Promise.resolve(wrapper));

        const result = await injector.resolveComponentInstance(
          module,
          '',
          { index: 0, dependencies: [] },
          wrapper,
        );
        expect(result.instance).to.be.true;
      });
    });
  });

  describe('applyProperties', () => {
    describe('when instance is not an object', () => {
      it('should return undefined', () => {
        expect(injector.applyProperties('test', [])).to.be.undefined;
      });
    });

    describe('when instance is an object', () => {
      it('should apply each not nil property', () => {
        const properties = [
          { key: 'one', instance: {} },
          { key: 'two', instance: null },
          { key: 'three', instance: true },
        ];
        const obj: Record<any, any> = {};
        injector.applyProperties(obj, properties as PropertyDependency[]);

        expect(obj.one).to.be.eql(properties[0].instance);
        expect(obj.two).to.be.undefined;
        expect(obj.three).to.be.eql(properties[2].instance);
      });
    });
  });

  describe('instantiateClass', () => {
    class TestClass {}

    describe('when context is static', () => {
      it('should instantiate class', async () => {
        const wrapper = new InstanceWrapper({ metatype: TestClass });
        await injector.instantiateClass([], wrapper, wrapper, STATIC_CONTEXT);

        expect(wrapper.instance).to.not.be.undefined;
        expect(wrapper.instance).to.be.instanceOf(TestClass);
      });
      it('should call factory', async () => {
        const wrapper = new InstanceWrapper({
          inject: [],
          metatype: (() => ({})) as any,
        });
        await injector.instantiateClass([], wrapper, wrapper, STATIC_CONTEXT);

        expect(wrapper.instance).to.not.be.undefined;
      });
    });
    describe('when context is not static', () => {
      it('should not instantiate class', async () => {
        const ctx = { id: 3 };
        const wrapper = new InstanceWrapper({ metatype: TestClass });
        await injector.instantiateClass([], wrapper, wrapper, ctx);

        expect(wrapper.instance).to.be.undefined;
        expect(wrapper.getInstanceByContextId(ctx).isResolved).to.be.true;
      });

      it('should not call factory', async () => {
        const wrapper = new InstanceWrapper({
          inject: [],
          metatype: sinon.spy() as any,
        });
        await injector.instantiateClass([], wrapper, wrapper, { id: 2 });
        expect(wrapper.instance).to.be.undefined;
        expect((wrapper.metatype as any).called).to.be.false;
      });
    });
  });

  describe('loadPerContext', () => {
    class TestClass {}

    it('should load instance per context id', async () => {
      const container = new NestContainer();
      const moduleCtor = class TestModule {};
      const ctx = STATIC_CONTEXT;
      const { moduleRef } = (await container.addModule(moduleCtor, []))!;

      moduleRef.addProvider({
        provide: TestClass,
        useClass: TestClass,
      });

      const instance = await injector.loadPerContext(
        new TestClass(),
        moduleRef,
        moduleRef.providers,
        ctx,
      );
      expect(instance).to.be.instanceOf(TestClass);
    });
  });

  describe('loadEnhancersPerContext', () => {
    it('should load enhancers per context id', async () => {
      const wrapper = new InstanceWrapper();
      wrapper.addEnhancerMetadata(
        new InstanceWrapper({
          host: new Module(class {}, new NestContainer()),
        }),
      );
      wrapper.addEnhancerMetadata(
        new InstanceWrapper({
          host: new Module(class {}, new NestContainer()),
        }),
      );

      const loadInstanceStub = sinon
        .stub(injector, 'loadInstance')
        .callsFake(async () => ({}) as any);

      await injector.loadEnhancersPerContext(wrapper, STATIC_CONTEXT);
      expect(loadInstanceStub.calledTwice).to.be.true;
    });
  });

  describe('loadCtorMetadata', () => {
    it('should resolve ctor metadata', async () => {
      const wrapper = new InstanceWrapper();
      wrapper.addCtorMetadata(0, new InstanceWrapper());
      wrapper.addCtorMetadata(1, new InstanceWrapper());

      const resolveComponentHostStub = sinon
        .stub(injector, 'resolveComponentHost')
        .callsFake(async () => new InstanceWrapper());

      await injector.loadCtorMetadata(
        wrapper.getCtorMetadata(),
        STATIC_CONTEXT,
      );
      expect(resolveComponentHostStub.calledTwice).to.be.true;
    });
  });

  describe('loadPropertiesMetadata', () => {
    it('should resolve properties metadata', async () => {
      const wrapper = new InstanceWrapper();
      wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
      wrapper.addPropertiesMetadata('key2', new InstanceWrapper());

      const resolveComponentHostStub = sinon
        .stub(injector, 'resolveComponentHost')
        .callsFake(async () => new InstanceWrapper());

      await injector.loadPropertiesMetadata(
        wrapper.getPropertiesMetadata(),
        STATIC_CONTEXT,
      );
      expect(resolveComponentHostStub.calledTwice).to.be.true;
    });
  });

  describe('resolveConstructorParams', () => {
    it('should call "loadCtorMetadata" if metadata is not undefined', async () => {
      const wrapper = new InstanceWrapper();
      const metadata = [];
      sinon.stub(wrapper, 'getCtorMetadata').callsFake(() => metadata);

      const loadCtorMetadataSpy = sinon.spy(injector, 'loadCtorMetadata');
      await injector.resolveConstructorParams(
        wrapper,
        null!,
        [],
        () => {
          expect(loadCtorMetadataSpy.called).to.be.true;
        },
        { id: 2 },
      );
    });
  });

  describe('resolveProperties', () => {
    it('should call "loadPropertiesMetadata" if metadata is not undefined', async () => {
      const wrapper = new InstanceWrapper();
      const metadata = [];
      sinon.stub(wrapper, 'getPropertiesMetadata').callsFake(() => metadata);

      const loadPropertiesMetadataSpy = sinon.spy(
        injector,
        'loadPropertiesMetadata',
      );
      await injector.resolveProperties(wrapper, null!, null!, { id: 2 });
      expect(loadPropertiesMetadataSpy.called).to.be.true;
    });
  });

  describe('getClassDependencies', () => {
    it('should return an array that consists of deps and optional dep ids', async () => {
      class FixtureDep1 {}
      class FixtureDep2 {}

      @Injectable()
      class FixtureClass {
        constructor(
          private dep1: FixtureDep1,
          @Optional() private dep2: FixtureDep2,
        ) {}
      }

      const wrapper = new InstanceWrapper({ metatype: FixtureClass });
      const [dependencies, optionalDependenciesIds] =
        injector.getClassDependencies(wrapper);

      expect(dependencies).to.deep.eq([FixtureDep1, FixtureDep2]);
      expect(optionalDependenciesIds).to.deep.eq([1]);
    });

    it('should not mutate the constructor metadata', async () => {
      class FixtureDep1 {}
      /** This needs to be something other than FixtureDep1 so the test can ensure that the metadata was not mutated */
      const injectionToken = 'test_token';

      @Injectable()
      class FixtureClass {
        constructor(@Inject(injectionToken) private dep1: FixtureDep1) {}
      }

      const wrapper = new InstanceWrapper({ metatype: FixtureClass });
      const [dependencies] = injector.getClassDependencies(wrapper);
      expect(dependencies).to.deep.eq([injectionToken]);

      const paramtypes = Reflect.getMetadata(PARAMTYPES_METADATA, FixtureClass);
      expect(paramtypes).to.deep.eq([FixtureDep1]);
    });
  });

  describe('getFactoryProviderDependencies', () => {
    it('should return an array that consists of deps and optional dep ids', async () => {
      class FixtureDep1 {}
      class FixtureDep2 {}

      const wrapper = new InstanceWrapper({
        inject: [
          FixtureDep1,
          { token: FixtureDep2, optional: true },
          { token: FixtureDep2, optional: false },
          {} as any,
        ],
      });
      const [dependencies, optionalDependenciesIds] =
        injector.getFactoryProviderDependencies(wrapper);

      expect(dependencies).to.deep.eq([
        FixtureDep1,
        FixtureDep2,
        FixtureDep2,
        {},
      ]);
      expect(optionalDependenciesIds).to.deep.eq([1]);
    });
  });

  describe('addDependencyMetadata', () => {
    interface IInjector extends Omit<Injector, 'addDependencyMetadata'> {
      addDependencyMetadata: (
        keyOrIndex: symbol | string | number,
        hostWrapper: InstanceWrapper,
        instanceWrapper: InstanceWrapper,
      ) => void;
    }

    let exposedInjector: IInjector;
    let hostWrapper: InstanceWrapper;
    let instanceWrapper: InstanceWrapper;

    beforeEach(() => {
      exposedInjector = injector as unknown as IInjector;
      hostWrapper = new InstanceWrapper();
      instanceWrapper = new InstanceWrapper();
    });

    it('should add dependency metadata to PropertiesMetadata when key is symbol', async () => {
      const addPropertiesMetadataSpy = sinon.spy(
        hostWrapper,
        'addPropertiesMetadata',
      );

      const key = Symbol.for('symbol');
      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);

      expect(addPropertiesMetadataSpy.called).to.be.true;
    });

    it('should add dependency metadata to PropertiesMetadata when key is string', async () => {
      const addPropertiesMetadataSpy = sinon.spy(
        hostWrapper,
        'addPropertiesMetadata',
      );

      const key = 'string';
      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);

      expect(addPropertiesMetadataSpy.called).to.be.true;
    });

    it('should add dependency metadata to CtorMetadata when key is number', async () => {
      const addCtorMetadataSpy = sinon.spy(hostWrapper, 'addCtorMetadata');

      const key = 0;
      exposedInjector.addDependencyMetadata(key, hostWrapper, instanceWrapper);

      expect(addCtorMetadataSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/injector/instance-loader.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Injectable } from '../../../common';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import { NestContainer } from '../../injector/container';
import { Injector } from '../../injector/injector';
import { InstanceLoader } from '../../injector/instance-loader';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { GraphInspector } from '../../inspector/graph-inspector';

describe('InstanceLoader', () => {
  @Controller('')
  class TestCtrl {}

  @Injectable()
  class TestProvider {}

  let loader: InstanceLoader;
  let injector: Injector;
  let container: NestContainer;
  let graphInspector: GraphInspector;
  let inspectInstanceWrapperStub: sinon.SinonStub;
  let mockContainer: sinon.SinonMock;
  let moduleMock: Record<string, any>;

  beforeEach(() => {
    container = new NestContainer();
    graphInspector = new GraphInspector(container);

    inspectInstanceWrapperStub = sinon.stub(
      graphInspector,
      'inspectInstanceWrapper',
    );

    injector = new Injector();
    loader = new InstanceLoader(container, injector, graphInspector);
    mockContainer = sinon.mock(container);

    moduleMock = {
      imports: new Set(),
      providers: new Map(),
      controllers: new Map(),
      injectables: new Map(),
      exports: new Set(),
      metatype: { name: 'test' },
    };

    const modules = new Map();
    modules.set('Test', moduleMock);
    mockContainer.expects('getModules').returns(modules);
  });

  it('should call "loadPrototype" for every provider and controller in every module', async () => {
    const providerWrapper = new InstanceWrapper({
      instance: null,
      metatype: TestProvider,
      token: 'TestProvider',
    });
    const ctrlWrapper = new InstanceWrapper({
      instance: null,
      metatype: TestCtrl,
      token: 'TestRoute',
    });

    moduleMock.providers.set('TestProvider', providerWrapper);
    moduleMock.controllers.set('TestRoute', ctrlWrapper);

    const loadProviderPrototypeStub = sinon.stub(injector, 'loadPrototype');

    sinon.stub(injector, 'loadController');
    sinon.stub(injector, 'loadProvider');

    await loader.createInstancesOfDependencies();

    expect(
      loadProviderPrototypeStub.calledWith(
        providerWrapper,
        moduleMock.providers,
      ),
    ).to.be.true;
    expect(
      loadProviderPrototypeStub.calledWith(ctrlWrapper, moduleMock.controllers),
    ).to.be.true;
  });

  describe('for every provider in every module', () => {
    const testProviderToken = 'TestProvider';

    let loadProviderStub: sinon.SinonStub;

    beforeEach(async () => {
      const testProviderWrapper = new InstanceWrapper({
        instance: null,
        metatype: TestProvider,
        name: testProviderToken,
        token: testProviderToken,
      });
      moduleMock.providers.set(testProviderToken, testProviderWrapper);

      loadProviderStub = sinon.stub(injector, 'loadProvider');
      sinon.stub(injector, 'loadController');

      await loader.createInstancesOfDependencies();
    });

    it('should call "loadProvider"', async () => {
      expect(
        loadProviderStub.calledWith(
          moduleMock.providers.get(testProviderToken),
          moduleMock as any,
        ),
      ).to.be.true;
    });

    it('should call "inspectInstanceWrapper"', async () => {
      expect(
        inspectInstanceWrapperStub.calledWith(
          moduleMock.providers.get(testProviderToken),
          moduleMock as any,
        ),
      ).to.be.true;
    });
  });

  describe('for every controller in every module', () => {
    let loadControllerStub: sinon.SinonStub;

    beforeEach(async () => {
      const wrapper = new InstanceWrapper({
        name: 'TestRoute',
        token: 'TestRoute',
        instance: null,
        metatype: TestCtrl,
      });
      moduleMock.controllers.set('TestRoute', wrapper);

      sinon.stub(injector, 'loadProvider');
      loadControllerStub = sinon.stub(injector, 'loadController');

      await loader.createInstancesOfDependencies();
    });
    it('should call "loadController"', async () => {
      expect(
        loadControllerStub.calledWith(
          moduleMock.controllers.get('TestRoute'),
          moduleMock as any,
        ),
      ).to.be.true;
    });
    it('should call "inspectInstanceWrapper"', async () => {
      expect(
        inspectInstanceWrapperStub.calledWith(
          moduleMock.controllers.get('TestRoute'),
          moduleMock as any,
        ),
      ).to.be.true;
    });
  });

  describe('for every injectable in every module', () => {
    let loadInjectableStub: sinon.SinonStub;

    beforeEach(async () => {
      const testInjectable = new InstanceWrapper({
        instance: null,
        metatype: TestProvider,
        name: 'TestProvider',
        token: 'TestProvider',
      });
      moduleMock.injectables.set('TestProvider', testInjectable);

      loadInjectableStub = sinon.stub(injector, 'loadInjectable');
      sinon.stub(injector, 'loadController');

      await loader.createInstancesOfDependencies();
    });

    it('should call "loadInjectable"', async () => {
      expect(
        loadInjectableStub.calledWith(
          moduleMock.injectables.get('TestProvider'),
          moduleMock as any,
        ),
      ).to.be.true;
    });
    it('should call "inspectInstanceWrapper"', async () => {
      expect(
        inspectInstanceWrapperStub.calledWith(
          moduleMock.injectables.get('TestProvider'),
          moduleMock as any,
        ),
      ).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/injector/instance-wrapper.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { createContextId } from '../../helpers';
import { STATIC_CONTEXT } from '../../injector/constants';
import { InstanceWrapper } from '../../injector/instance-wrapper';

class TestClass {}

describe('InstanceWrapper', () => {
  describe('initialize', () => {
    const partial = {
      name: 'test',
      metatype: TestClass,
      scope: Scope.DEFAULT,
      instance: new TestClass(),
    };
    it('should assign partial', () => {
      const instance = new InstanceWrapper(partial);

      expect(instance.name).to.be.eql(partial.name);
      expect(instance.scope).to.be.eql(partial.scope);
      expect(instance.metatype).to.be.eql(partial.metatype);
    });
    it('should set instance by context id', () => {
      const instance = new InstanceWrapper(partial);

      expect(
        instance.getInstanceByContextId(STATIC_CONTEXT).instance,
      ).to.be.eql(partial.instance);
    });
  });

  describe('isDependencyTreeStatic', () => {
    describe('when circular reference', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper();
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeStatic()).to.be.true;
        expect(otherWrapper.isDependencyTreeStatic()).to.be.true;
      });
    });
    describe('when circular reference and one non static', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper({ scope: Scope.REQUEST });
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeStatic()).to.be.false;
        expect(otherWrapper.isDependencyTreeStatic()).to.be.false;
      });
    });
    describe('when circular reference and one durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: true,
        });
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeStatic()).to.be.false;
        expect(otherWrapper.isDependencyTreeStatic()).to.be.false;
      });
    });
    describe('when request scoped', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(wrapper.isDependencyTreeStatic()).to.be.false;
      });
    });
    describe('when request scoped durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: true,
        });
        expect(wrapper.isDependencyTreeStatic()).to.be.false;
      });
    });
    describe('when request scoped explicit non durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: false,
        });
        expect(wrapper.isDependencyTreeStatic()).to.be.false;
      });
    });
    describe('when default', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper({});
        expect(wrapper.isDependencyTreeStatic()).to.be.true;
      });
    });
    describe('when statically scoped', () => {
      describe('dependencies, properties, enhancers', () => {
        describe('dependencies non static, properties static, enhancers static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
        describe('dependencies static, properties non static, enhancers static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
        describe('dependencies static, properties static, enhancers non static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
      });
      describe('dependencies', () => {
        describe('when each is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.true;
          });
        });
        describe('when one is not static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addCtorMetadata(
              1,
              new InstanceWrapper({
                scope: Scope.REQUEST,
              }),
            );
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
      });
      describe('properties', () => {
        describe('when each is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.true;
          });
        });
        describe('when one is not static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
      });
      describe('enhancers', () => {
        describe('when each is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.true;
          });
        });
        describe('when one is not static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeStatic()).to.be.false;
          });
        });
      });
    });
  });

  describe('isDependencyTreeDurable', () => {
    describe('when circular reference and default scope', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper();
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeDurable()).to.be.false;
        expect(otherWrapper.isDependencyTreeDurable()).to.be.false;
      });
    });
    describe('when circular reference and one non durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper({ scope: Scope.REQUEST });
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeDurable()).to.be.false;
        expect(otherWrapper.isDependencyTreeDurable()).to.be.false;
      });
    });
    describe('when circular reference and one durable', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper();
        const otherWrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: true,
        });
        wrapper.addCtorMetadata(0, otherWrapper);
        otherWrapper.addCtorMetadata(0, wrapper);
        expect(wrapper.isDependencyTreeDurable()).to.be.true;
        expect(otherWrapper.isDependencyTreeDurable()).to.be.true;
      });
    });
    describe('when request scoped and durable', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: true,
        });
        expect(wrapper.isDependencyTreeDurable()).to.be.true;
      });
    });
    describe('when request scoped and non durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(wrapper.isDependencyTreeDurable()).to.be.false;
      });
    });
    describe('when request scoped and explicit non durable', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
          durable: false,
        });
        expect(wrapper.isDependencyTreeDurable()).to.be.false;
      });
    });
    describe('when default scope', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper();
        expect(wrapper.isDependencyTreeDurable()).to.be.false;
      });
    });
    describe('when statically scoped', () => {
      describe('dependencies, properties, enhancers', () => {
        describe('dependencies non durable, properties non durable, enhancers durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addCtorMetadata(1, new InstanceWrapper());
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('dependencies non durable, properties durable, enhancers durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addCtorMetadata(1, new InstanceWrapper());
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('dependencies non durable, properties durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addCtorMetadata(1, new InstanceWrapper());
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addPropertiesMetadata(
              'key2',
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('properties durable, enhancers non durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addPropertiesMetadata(
              'key2',
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('dependencies durable, enhancers non durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
      });
      describe('dependencies', () => {
        describe('when wrapper is non durable and dependency is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is non durable and dependency is durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
            });
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is durable and dependency is non durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addCtorMetadata(
              0,
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when each is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and non-durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addCtorMetadata(
              1,
              new InstanceWrapper({
                scope: Scope.REQUEST,
              }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addCtorMetadata(
              1,
              new InstanceWrapper({
                scope: Scope.REQUEST,
                durable: true,
              }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when one is not static, durable and non durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addCtorMetadata(0, new InstanceWrapper());
            wrapper.addCtorMetadata(
              1,
              new InstanceWrapper({
                scope: Scope.REQUEST,
                durable: true,
              }),
            );
            wrapper.addCtorMetadata(
              2,
              new InstanceWrapper({
                scope: Scope.REQUEST,
              }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
      });
      describe('properties', () => {
        describe('when wrapper is non durable and dependency is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is non durable and dependency is durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
            });
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is durable and dependency is non durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when each is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata('key1', new InstanceWrapper());
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and non-durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when one is not static, non durable and durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addPropertiesMetadata(
              'key1',
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addPropertiesMetadata('key2', new InstanceWrapper());
            wrapper.addPropertiesMetadata(
              'key3',
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
      });
      describe('enhancers', () => {
        describe('when wrapper is non durable and dependency is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({ scope: Scope.REQUEST });
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is non durable and dependency is durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
            });
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when wrapper is durable and dependency is static', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when wrapper is durable and dependency is non durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper({
              scope: Scope.REQUEST,
              durable: true,
            });
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when each is static', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and non-durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
        describe('when one is not static and durable', () => {
          it('should return true', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            expect(wrapper.isDependencyTreeDurable()).to.be.true;
          });
        });
        describe('when one is not static, non durable and durable', () => {
          it('should return false', () => {
            const wrapper = new InstanceWrapper();
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST, durable: true }),
            );
            wrapper.addEnhancerMetadata(new InstanceWrapper());
            wrapper.addEnhancerMetadata(
              new InstanceWrapper({ scope: Scope.REQUEST }),
            );
            expect(wrapper.isDependencyTreeDurable()).to.be.false;
          });
        });
      });
    });
  });

  describe('isNotMetatype', () => {
    describe('when metatype is nil', () => {
      it('should return true', () => {
        const instance = new InstanceWrapper({ metatype: null });
        expect(instance.isNotMetatype).to.be.true;
      });
    });
    describe('when metatype is not nil', () => {
      it('should return false', () => {
        const instance = new InstanceWrapper({ metatype: TestClass });
        expect(instance.isNotMetatype).to.be.false;
      });
    });
  });

  describe('addEnhancerMetadata', () => {
    it('should add enhancers metadata', () => {
      const instance = new InstanceWrapper();
      const enhancers = [new InstanceWrapper()];
      instance.addEnhancerMetadata(enhancers[0]);
      expect(instance.getEnhancersMetadata()).to.be.eql(enhancers);
    });
  });

  describe('when set instance has been called', () => {
    it('should set static context value', () => {
      const instance = { test: true };
      const wrapper = new InstanceWrapper();
      wrapper.instance = instance;

      expect(wrapper.getInstanceByContextId(STATIC_CONTEXT).instance).to.be.eql(
        instance,
      );
    });
  });

  describe('cloneStaticInstance', () => {
    describe('when wrapper is static', () => {
      it('should return static instance', () => {
        const instance = { test: true };
        const wrapper = new InstanceWrapper({ instance });

        expect(wrapper.cloneStaticInstance({ id: 0 }).instance).to.be.eql(
          instance,
        );
      });
    });
    describe('when wrapper is not static', () => {
      it('should clone instance by context id', () => {
        const instance = { test: true };
        const wrapper = new InstanceWrapper({ instance, scope: Scope.REQUEST });

        expect(wrapper.cloneStaticInstance({ id: 0 }).instance).to.be.undefined;
      });
    });
  });

  describe('getInstanceByContextId', () => {
    describe('when transient and inquirer has been passed', () => {
      it('should call "getInstanceByInquirerId"', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        const getInstanceByInquirerIdSpy = sinon.spy(
          wrapper,
          'getInstanceByInquirerId',
        );
        wrapper.getInstanceByContextId(STATIC_CONTEXT, 'inquirerId');
        expect(getInstanceByInquirerIdSpy.called).to.be.true;
      });
    });
  });

  describe('setInstanceByContextId', () => {
    describe('when transient and inquirer has been passed', () => {
      it('should call "setInstanceByInquirerId"', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        const setInstanceByInquirerIdSpy = sinon.spy(
          wrapper,
          'setInstanceByInquirerId',
        );
        wrapper.setInstanceByContextId(
          STATIC_CONTEXT,
          { instance: {} },
          'inquirerId',
        );
        expect(setInstanceByInquirerIdSpy.called).to.be.true;
      });
    });
  });

  describe('removeInstanceByContextId', () => {
    describe('without inquirer', () => {
      it('should remove instance for given context', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });

        const contextId = createContextId();
        wrapper.setInstanceByContextId(contextId, { instance: {} });

        const existingContext = wrapper.getInstanceByContextId(contextId);
        expect(existingContext.instance).to.be.not.undefined;
        wrapper.removeInstanceByContextId(contextId);

        const removedContext = wrapper.getInstanceByContextId(contextId);
        expect(removedContext.instance).to.be.undefined;
      });
    });

    describe('when transient and inquirer has been passed', () => {
      it('should remove instance for given context', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });

        wrapper.setInstanceByContextId(
          STATIC_CONTEXT,
          { instance: {} },
          'inquirerId',
        );

        const existingContext = wrapper.getInstanceByContextId(
          STATIC_CONTEXT,
          'inquirerId',
        );
        expect(existingContext.instance).to.be.not.undefined;
        wrapper.removeInstanceByContextId(STATIC_CONTEXT, 'inquirerId');

        const removedContext = wrapper.getInstanceByContextId(
          STATIC_CONTEXT,
          'inquirerId',
        );
        expect(removedContext.instance).to.be.undefined;
      });
    });
  });

  describe('isInRequestScope', () => {
    describe('when tree and context are not static and is not transient', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(wrapper.isInRequestScope({ id: 3 })).to.be.true;
      });
    });
    describe('otherwise', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        expect(wrapper.isInRequestScope({ id: 3 })).to.be.false;

        const wrapper2 = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(wrapper2.isInRequestScope(STATIC_CONTEXT)).to.be.false;
      });
    });
  });

  describe('isLazyTransient', () => {
    describe('when inquirer is request scoped and context is not static and is transient', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        expect(
          wrapper.isLazyTransient(
            { id: 3 },
            new InstanceWrapper({
              scope: Scope.REQUEST,
            }),
          ),
        ).to.be.true;
      });
    });
    describe('otherwise', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        expect(wrapper.isLazyTransient({ id: 3 }, new InstanceWrapper())).to.be
          .false;

        const wrapper2 = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(
          wrapper2.isLazyTransient(
            STATIC_CONTEXT,
            new InstanceWrapper({
              scope: Scope.TRANSIENT,
            }),
          ),
        ).to.be.false;
      });
    });
  });

  describe('isStatic', () => {
    describe('when inquirer is not request scoped and context and tree are static', () => {
      it('should return true', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.DEFAULT,
        });
        expect(
          wrapper.isStatic(
            STATIC_CONTEXT,
            new InstanceWrapper({
              scope: Scope.DEFAULT,
            }),
          ),
        ).to.be.true;
      });
    });
    describe('otherwise', () => {
      it('should return false', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.REQUEST,
        });
        expect(wrapper.isStatic({ id: 3 }, new InstanceWrapper())).to.be.false;

        const wrapper2 = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        expect(
          wrapper2.isStatic(
            STATIC_CONTEXT,
            new InstanceWrapper({
              scope: Scope.REQUEST,
            }),
          ),
        ).to.be.false;
      });
    });
  });

  describe('getStaticTransientInstances', () => {
    describe('when instance is not transient', () => {
      it('should return an empty array', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.DEFAULT,
        });
        expect(wrapper.getStaticTransientInstances()).to.be.eql([]);
      });
    });
    describe('when instance is transient', () => {
      it('should return all static instances', () => {
        const wrapper = new InstanceWrapper({
          scope: Scope.TRANSIENT,
        });
        const instanceHost = {
          instance: {},
        };
        wrapper.setInstanceByInquirerId(STATIC_CONTEXT, 'test', instanceHost);
        expect(wrapper.getStaticTransientInstances()).to.be.eql([instanceHost]);
      });
    });
  });

  describe('mergeWith', () => {
    describe('when provider is a ValueProvider', () => {
      it('should provide the given value in the STATIC_CONTEXT', () => {
        const wrapper = new InstanceWrapper();
        wrapper.mergeWith({
          useValue: 'value',
          provide: 'token',
        });

        expect(
          wrapper.getInstanceByContextId(STATIC_CONTEXT).instance,
        ).to.be.equal('value');
      });
    });

    describe('when provider is a ClassProvider', () => {
      it('should alter the instance wrapper metatype with the given class', () => {
        const wrapper = new InstanceWrapper();

        wrapper.mergeWith({
          useClass: TestClass,
          provide: 'token',
        });

        expect(wrapper.metatype).to.be.eql(TestClass);
      });
    });

    describe('when provider is a FactoryProvider', () => {
      describe('and it has injected dependencies', () => {
        it('should alter the instance wrapper metatype and inject attributes with the given values', () => {
          const wrapper = new InstanceWrapper();

          const factory = (_dependency1: any, _dependency2: any) => {};
          const injectedDependencies = ['dependency1', 'dependency2'];

          wrapper.mergeWith({
            provide: 'token',
            useFactory: factory,
            inject: injectedDependencies,
          });

          expect(wrapper.metatype).to.be.eql(factory);
          expect(wrapper.inject).to.be.eq(injectedDependencies);
        });
      });

      describe('and it has no injected dependencies', () => {
        it('should alter the instance wrapper metatype with the given values', () => {
          const wrapper = new InstanceWrapper();
          const factory = (_dependency1: any, _dependency2: any) => {};

          wrapper.mergeWith({
            provide: 'token',
            useFactory: factory,
          });

          expect(wrapper.metatype).to.be.eql(factory);
          expect(wrapper.inject).to.be.eql([]);
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/injector/module.spec.ts
================================================
import { Controller, Scope } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Injectable } from '../../../common';
import { Module as ModuleDecorator } from '../../../common/decorators/modules/module.decorator';
import { RuntimeException } from '../../errors/exceptions/runtime.exception';
import { UnknownElementException } from '../../errors/exceptions/unknown-element.exception';
import { UnknownExportException } from '../../errors/exceptions/unknown-export.exception';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { Module } from '../../injector/module';

describe('Module', () => {
  let moduleRef: Module;
  let untypedModuleRef: any;
  let container: NestContainer;

  @ModuleDecorator({})
  class TestModule {}

  @Injectable()
  class TestProvider {}

  beforeEach(() => {
    container = new NestContainer();
    moduleRef = new Module(TestModule, container);
    untypedModuleRef = moduleRef as any;
  });

  it('should add controller', () => {
    const collection = new Map();
    const setSpy = sinon.spy(collection, 'set');
    untypedModuleRef._controllers = collection;

    @Controller({ scope: Scope.REQUEST, durable: true })
    class Test {}

    moduleRef.addController(Test);
    expect(
      setSpy.calledWith(
        Test,
        new InstanceWrapper({
          host: moduleRef,
          token: Test,
          name: 'Test',
          scope: Scope.REQUEST,
          metatype: Test,
          durable: true,
          instance: null,
          isResolved: false,
        }),
      ),
    ).to.be.true;
  });

  it('should add injectable', () => {
    const collection = new Map();
    const setSpy = sinon.spy(collection, 'set');
    untypedModuleRef._injectables = collection;

    moduleRef.addInjectable(TestProvider, 'interceptor', TestModule);
    expect(
      setSpy.calledWith(
        TestProvider,
        new InstanceWrapper({
          host: moduleRef,
          name: 'TestProvider',
          token: TestProvider,
          scope: undefined,
          metatype: TestProvider,
          instance: null,
          durable: undefined,
          isResolved: false,
          subtype: 'interceptor',
        }),
      ),
    ).to.be.true;
  });

  describe('when injectable is custom provided', () => {
    it('should call `addCustomProvider`', () => {
      const addCustomProviderSpy = sinon.spy(moduleRef, 'addCustomProvider');

      moduleRef.addInjectable({ provide: 'test' } as any, 'guard');
      expect(addCustomProviderSpy.called).to.be.true;
    });
  });

  it('should add provider', () => {
    const collection = new Map();
    const setSpy = sinon.spy(collection, 'set');
    untypedModuleRef._providers = collection;

    moduleRef.addProvider(TestProvider);
    expect(
      setSpy.calledWith(
        TestProvider,
        new InstanceWrapper({
          host: moduleRef,
          name: 'TestProvider',
          token: TestProvider,
          scope: undefined,
          metatype: TestProvider,
          durable: undefined,
          instance: null,
          isResolved: false,
        }),
      ),
    ).to.be.true;
  });

  it('should call "addCustomProvider" when "provide" property exists', () => {
    const addCustomProvider = sinon.spy();
    moduleRef.addCustomProvider = addCustomProvider;

    const provider = { provide: 'test', useValue: 'test' };

    moduleRef.addProvider(provider as any);
    expect(addCustomProvider.called).to.be.true;
  });

  it('should call "addCustomClass" when "useClass" property exists', () => {
    const addCustomClass = sinon.spy();
    moduleRef.addCustomClass = addCustomClass;

    const provider = { provide: 'test', useClass: () => null };

    moduleRef.addCustomProvider(provider as any, new Map());
    expect(addCustomClass.called).to.be.true;
  });

  it('should call "addCustomValue" when "useValue" property exists', () => {
    const addCustomValue = sinon.spy();
    moduleRef.addCustomValue = addCustomValue;

    const provider = { provide: 'test', useValue: () => null };

    moduleRef.addCustomProvider(provider as any, new Map());
    expect(addCustomValue.called).to.be.true;
  });

  it('should call "addCustomValue" when "useValue" property exists but its value is `undefined`', () => {
    const addCustomValue = sinon.spy();
    moduleRef.addCustomValue = addCustomValue;

    const provider = { provide: 'test', useValue: undefined };

    moduleRef.addCustomProvider(provider as any, new Map());
    expect(addCustomValue.called).to.be.true;
  });

  it('should call "addCustomFactory" when "useFactory" property exists', () => {
    const addCustomFactory = sinon.spy();
    moduleRef.addCustomFactory = addCustomFactory;

    const provider = { provide: 'test', useFactory: () => null };

    moduleRef.addCustomProvider(provider as any, new Map());
    expect(addCustomFactory.called).to.be.true;
  });

  it('should call "addCustomUseExisting" when "useExisting" property exists', () => {
    const addCustomUseExisting = sinon.spy();
    moduleRef.addCustomUseExisting = addCustomUseExisting;

    const provider = { provide: 'test', useExisting: () => null };

    moduleRef.addCustomUseExisting(provider as any, new Map());
    expect(addCustomUseExisting.called).to.be.true;
  });

  describe('addCustomClass', () => {
    const type = { name: 'TypeTest' };
    const provider = { provide: type, useClass: type, durable: true };
    let setSpy: sinon.SinonSpy;

    beforeEach(() => {
      const collection = new Map();
      setSpy = sinon.spy(collection, 'set');
      untypedModuleRef._providers = collection;
    });
    it('should store provider', () => {
      moduleRef.addCustomClass(provider as any, untypedModuleRef._providers);
      expect(
        setSpy.calledWith(
          provider.provide,
          new InstanceWrapper({
            host: moduleRef,
            token: type as any,
            name: provider.provide.name,
            scope: undefined,
            metatype: type as any,
            durable: true,
            instance: null,
            isResolved: false,
            subtype: undefined,
          }),
        ),
      ).to.be.true;
    });
  });

  describe('addCustomValue', () => {
    let setSpy: sinon.SinonSpy;
    const value = () => ({});
    const provider = { provide: value, useValue: value };

    beforeEach(() => {
      const collection = new Map();
      setSpy = sinon.spy(collection, 'set');
      untypedModuleRef._providers = collection;
    });

    it('should store provider', () => {
      moduleRef.addCustomValue(provider as any, untypedModuleRef._providers);
      expect(
        setSpy.calledWith(
          provider.provide,
          new InstanceWrapper({
            host: moduleRef,
            token: provider.provide,
            name: provider.provide.name,
            scope: Scope.DEFAULT,
            metatype: null,
            instance: value,
            isResolved: true,
            async: false,
            subtype: undefined,
          }),
        ),
      ).to.be.true;
    });
  });

  describe('addCustomFactory', () => {
    const type = { name: 'TypeTest' };
    const inject = [1, 2, 3];
    const provider = { provide: type, useFactory: type, inject, durable: true };

    let setSpy: sinon.SinonSpy;
    beforeEach(() => {
      const collection = new Map();
      setSpy = sinon.spy(collection, 'set');
      untypedModuleRef._providers = collection;
    });
    it('should store provider', () => {
      moduleRef.addCustomFactory(provider as any, untypedModuleRef._providers);

      expect(
        setSpy.calledWith(
          provider.provide,
          new InstanceWrapper({
            host: moduleRef,
            token: provider.provide as any,
            name: provider.provide.name,
            scope: undefined,
            metatype: type as any,
            durable: true,
            instance: null,
            isResolved: false,
            inject: inject as any,
            subtype: undefined,
          }),
        ),
      ).to.be.true;
    });
  });

  describe('addCustomUseExisting', () => {
    const type = { name: 'TypeTest' };
    const provider = { provide: type, useExisting: type };

    let setSpy: sinon.SinonSpy;
    beforeEach(() => {
      const collection = new Map();
      setSpy = sinon.spy(collection, 'set');
      untypedModuleRef._providers = collection;
    });
    it('should store provider', () => {
      moduleRef.addCustomUseExisting(
        provider as any,
        untypedModuleRef._providers,
      );
      const factoryFn = untypedModuleRef._providers.get(
        provider.provide,
      ).metatype;

      const token = provider.provide as any;
      expect(
        setSpy.calledWith(
          token,
          new InstanceWrapper({
            host: moduleRef,
            token,
            name: provider.provide.name,
            metatype: factoryFn,
            instance: null,
            inject: [provider.useExisting as any],
            isResolved: false,
            isAlias: true,
            subtype: undefined,
          }),
        ),
      ).to.be.true;
      expect(factoryFn(provider.useExisting)).to.be.eql(type);
    });
  });

  describe('when get instance', () => {
    describe('when metatype does not exists in providers collection', () => {
      beforeEach(() => {
        sinon.stub(untypedModuleRef._providers, 'has').returns(false);
      });
      it('should throw RuntimeException', () => {
        expect(() => moduleRef.instance).to.throws(RuntimeException);
      });
    });
    describe('when metatype exists in providers collection', () => {
      it('should return null', () => {
        expect(moduleRef.instance).to.be.eql(null);
      });
    });
  });

  describe('when exported provider is custom provided', () => {
    beforeEach(() => {
      sinon.stub(moduleRef, 'validateExportedProvider').callsFake(o => o);
    });
    it('should call `addCustomExportedProvider`', () => {
      const addCustomExportedProviderSpy = sinon.spy(
        moduleRef,
        'addCustomExportedProvider',
      );

      moduleRef.addExportedProviderOrModule({ provide: 'test' } as any);
      expect(addCustomExportedProviderSpy.called).to.be.true;
    });
    it('should support symbols', () => {
      const addCustomExportedProviderSpy = sinon.spy(
        moduleRef,
        'addCustomExportedProvider',
      );
      const symb = Symbol('test');
      moduleRef.addExportedProviderOrModule({ provide: symb } as any);
      expect(addCustomExportedProviderSpy.called).to.be.true;
      expect(untypedModuleRef._exports.has(symb)).to.be.true;
    });
  });

  describe('replace', () => {
    describe('when provider', () => {
      it('should call `mergeWith`', () => {
        const wrapper = {
          mergeWith: sinon.spy(),
        };
        sinon.stub(moduleRef, 'hasProvider').callsFake(() => true);
        sinon.stub(moduleRef.providers, 'get').callsFake(() => wrapper as any);

        moduleRef.replace(null!, { isProvider: true });
        expect(wrapper.mergeWith.called).to.be.true;
      });
    });
    describe('when guard', () => {
      it('should call `mergeWith`', () => {
        const wrapper = {
          mergeWith: sinon.spy(),
          isProvider: true,
        };
        sinon.stub(moduleRef, 'hasInjectable').callsFake(() => true);
        sinon
          .stub(moduleRef.injectables, 'get')
          .callsFake(() => wrapper as any);

        moduleRef.replace(null!, {});
        expect(wrapper.mergeWith.called).to.be.true;
      });
    });
  });

  describe('imports', () => {
    it('should return relatedModules', () => {
      const test = ['test'];
      untypedModuleRef._imports = test;

      expect(moduleRef.imports).to.be.eql(test);
    });
  });

  describe('injectables', () => {
    it('should return injectables', () => {
      const test = ['test'];
      untypedModuleRef._injectables = test;
      expect(moduleRef.injectables).to.be.eql(test);
    });
  });

  describe('controllers', () => {
    it('should return controllers', () => {
      const test = ['test'];
      untypedModuleRef._controllers = test;

      expect(moduleRef.controllers).to.be.eql(test);
    });
  });

  describe('exports', () => {
    it('should return exports', () => {
      const test = ['test'];
      untypedModuleRef._exports = test;

      expect(moduleRef.exports).to.be.eql(test);
    });
  });

  describe('providers', () => {
    it('should return providers', () => {
      const test = ['test'];
      untypedModuleRef._providers = test;

      expect(moduleRef.providers).to.be.eql(test);
    });
  });

  describe('createModuleReferenceType', () => {
    let customModuleRef: any;

    beforeEach(() => {
      const Class = moduleRef.createModuleReferenceType();
      customModuleRef = new Class();
    });

    it('should return metatype with "get" method', () => {
      expect(!!customModuleRef.get).to.be.true;
    });
    describe('get', () => {
      it('should throw exception if not exists', () => {
        expect(() => customModuleRef.get('fail')).to.throws(
          UnknownElementException,
        );
      });
    });
  });
  describe('validateExportedProvider', () => {
    const token = 'token';

    describe('when unit exists in provider collection', () => {
      it('should behave as identity', () => {
        untypedModuleRef._providers = new Map([[token, true]]);
        expect(moduleRef.validateExportedProvider(token)).to.be.eql(token);
      });
    });
    describe('when unit exists in related modules collection', () => {
      it('should behave as identity', () => {
        class Random {}
        untypedModuleRef._imports = new Set([
          new Module(Random, new NestContainer()),
        ]);
        expect(moduleRef.validateExportedProvider(Random)).to.be.eql(Random);
      });
    });
    describe('when unit does not exist in both provider and related modules collections', () => {
      it('should throw UnknownExportException', () => {
        expect(() => moduleRef.validateExportedProvider(token)).to.throws(
          UnknownExportException,
        );
      });
    });
  });

  describe('hasProvider', () => {
    describe('when module has provider', () => {
      it('should return true', () => {
        const token = 'test';
        moduleRef.providers.set(token, new InstanceWrapper());
        expect(moduleRef.hasProvider(token)).to.be.true;
      });
    });
    describe('otherwise', () => {
      it('should return false', () => {
        expect(moduleRef.hasProvider('_')).to.be.false;
      });
    });
  });

  describe('hasInjectable', () => {
    describe('when module has injectable', () => {
      it('should return true', () => {
        const token = 'test';
        moduleRef.injectables.set(token, new InstanceWrapper());
        expect(moduleRef.hasInjectable(token)).to.be.true;
      });
    });
    describe('otherwise', () => {
      it('should return false', () => {
        expect(moduleRef.hasInjectable('_')).to.be.false;
      });
    });
  });

  describe('getter "id"', () => {
    it('should return module id', () => {
      expect(moduleRef.id).to.be.equal(moduleRef['_id']);
    });
  });

  describe('getProviderByKey', () => {
    describe('when does not exist', () => {
      it('should return undefined', () => {
        expect(moduleRef.getProviderByKey('test')).to.be.undefined;
      });
    });
    describe('otherwise', () => {
      it('should return instance wrapper', () => {
        moduleRef.addProvider(TestProvider);
        expect(moduleRef.getProviderByKey(TestProvider)).to.not.be.undefined;
      });
    });
  });
});



================================================
FILE: packages/core/test/injector/helpers/provider-classifier.spec.ts
================================================
import { ClassProvider, FactoryProvider, ValueProvider } from '@nestjs/common';
import { expect } from 'chai';
import {
  isClassProvider,
  isFactoryProvider,
  isValueProvider,
} from '../../../injector/helpers/provider-classifier';

describe('provider classifier', () => {
  describe('isClassProvider', () => {
    it('should return true if useClass is present', () => {
      const classProvider: ClassProvider = {
        useClass: class TestClass {},
        provide: 'token',
      };

      expect(isClassProvider(classProvider)).to.be.true;
    });

    it('should return false if useClass is undefined', () => {
      const classProvider: ClassProvider = {
        useClass: undefined!,
        provide: 'token',
      };

      expect(isClassProvider(classProvider)).to.be.false;
    });

    it('should return false if useClass is not present', () => {
      const classProvider = {
        provide: 'token',
      };

      expect(isClassProvider(classProvider as ClassProvider)).to.be.false;
    });

    it('should return false if provider is undefined', () => {
      const classProvider = undefined!;

      expect(isClassProvider(classProvider)).to.be.false;
    });
  });

  describe('isValueProvider', () => {
    it('should return true if useValue is not undefined', () => {
      const valueProvider: ValueProvider = {
        useValue: 'value',
        provide: 'token',
      };

      expect(isValueProvider(valueProvider)).to.be.true;
    });

    it('should return true if useValue is "false"', () => {
      const valueProvider: ValueProvider = {
        useValue: false,
        provide: 'token',
      };

      expect(isValueProvider(valueProvider)).to.be.true;
    });

    it('should return true if useValue is "null"', () => {
      const valueProvider: ValueProvider = {
        useValue: null,
        provide: 'token',
      };

      expect(isValueProvider(valueProvider)).to.be.true;
    });

    it('should return true if useValue is an empty string', () => {
      const valueProvider: ValueProvider = {
        useValue: null,
        provide: '',
      };

      expect(isValueProvider(valueProvider)).to.be.true;
    });

    it('should return false if useValue is undefined', () => {
      const valueProvider: ValueProvider = {
        useValue: undefined,
        provide: 'token',
      };

      expect(isValueProvider(valueProvider)).to.be.false;
    });

    it('should return false if useValue is not present', () => {
      const valueProvider = {
        provide: 'token',
      };

      expect(isValueProvider(valueProvider as ValueProvider)).to.be.false;
    });

    it('should return false if provider is undefined', () => {
      const valueProvider = undefined!;

      expect(isValueProvider(valueProvider as ValueProvider)).to.be.false;
    });
  });

  describe('isFactoryProvider', () => {
    it('should return true if useFactory is present', () => {
      const factoryProvider: FactoryProvider = {
        provide: 'token',
        useFactory: () => {},
      };

      expect(isFactoryProvider(factoryProvider)).to.be.true;
    });

    it('should return false if useFactory is not present', () => {
      const factoryProvider = {
        provide: 'token',
      };

      expect(isFactoryProvider(factoryProvider as FactoryProvider)).to.be.false;
    });

    it('should return false if useFactory is undefined', () => {
      const factoryProvider: FactoryProvider = {
        provide: 'token',
        useFactory: undefined!,
      };

      expect(isFactoryProvider(factoryProvider)).to.be.false;
    });
  });
});



================================================
FILE: packages/core/test/injector/internal-core-module/internal-core-module-factory.spec.ts
================================================
import { ClassProvider, FactoryProvider } from '@nestjs/common';
import { expect } from 'chai';
import { ExternalContextCreator } from '../../../helpers/external-context-creator';
import { HttpAdapterHost } from '../../../helpers/http-adapter-host';
import { LazyModuleLoader, ModulesContainer } from '../../../injector';
import { NestContainer } from '../../../injector/container';
import { InternalCoreModule } from '../../../injector/internal-core-module/internal-core-module';
import { InternalCoreModuleFactory } from '../../../injector/internal-core-module/internal-core-module-factory';
import { SerializedGraph } from '../../../inspector/serialized-graph';

describe('InternalCoreModuleFactory', () => {
  it('should return the internal core module definition', () => {
    const moduleDefinition = InternalCoreModuleFactory.create(
      new NestContainer(),
      null!,
      null!,
      null!,
      null!,
    );

    expect(moduleDefinition.module).to.equal(InternalCoreModule);

    const providedInjectables = moduleDefinition.providers!.map(
      item => (item as ClassProvider | FactoryProvider).provide,
    );
    expect(providedInjectables).to.deep.equal([
      ExternalContextCreator,
      ModulesContainer,
      HttpAdapterHost,
      LazyModuleLoader,
      SerializedGraph,
    ]);

    const lazyModuleLoaderProvider = moduleDefinition.providers!.find(
      item => (item as FactoryProvider)?.provide === LazyModuleLoader,
    ) as FactoryProvider;
    expect(lazyModuleLoaderProvider.useFactory()).to.be.instanceOf(
      LazyModuleLoader,
    );
  });
});



================================================
FILE: packages/core/test/injector/lazy-module-loader/lazy-module-loader.spec.ts
================================================
import { Module } from '@nestjs/common';
import { expect } from 'chai';
import {
  LazyModuleLoader,
  ModuleRef,
  ModulesContainer,
  NestContainer,
} from '../../../injector';
import { Injector } from '../../../injector/injector';
import { InstanceLoader } from '../../../injector/instance-loader';
import { GraphInspector } from '../../../inspector/graph-inspector';
import { MetadataScanner } from '../../../metadata-scanner';
import { DependenciesScanner } from '../../../scanner';

describe('LazyModuleLoader', () => {
  let lazyModuleLoader: LazyModuleLoader;
  let dependenciesScanner: DependenciesScanner;
  let instanceLoader: InstanceLoader;
  let modulesContainer: ModulesContainer;

  class NoopLogger {
    log() {}
    error() {}
    warn() {}
  }

  beforeEach(() => {
    const nestContainer = new NestContainer();
    const graphInspector = new GraphInspector(nestContainer);
    dependenciesScanner = new DependenciesScanner(
      nestContainer,
      new MetadataScanner(),
      graphInspector,
    );

    const injector = new Injector();
    instanceLoader = new InstanceLoader(
      nestContainer,
      injector,
      graphInspector,
      new NoopLogger(),
    );
    modulesContainer = nestContainer.getModules();
    lazyModuleLoader = new LazyModuleLoader(
      dependenciesScanner,
      instanceLoader,
      nestContainer['moduleCompiler'],
      modulesContainer,
    );
  });
  describe('load', () => {
    const bProvider = { provide: 'B', useValue: 'B' };

    @Module({ providers: [bProvider], exports: [bProvider] })
    class ModuleB {}

    @Module({ imports: [ModuleB] })
    class ModuleA {}

    describe('when module was not loaded yet', () => {
      it('should load it and return a module reference', async () => {
        const moduleRef = await lazyModuleLoader.load(() => ModuleA);
        expect(moduleRef).to.be.instanceOf(ModuleRef);
        expect(moduleRef.get(bProvider.provide, { strict: false })).to.equal(
          bProvider.useValue,
        );
      });
    });
    describe('when module was loaded already', () => {
      @Module({})
      class ModuleC {}

      it('should return an existing module reference', async () => {
        const moduleRef = await lazyModuleLoader.load(() => ModuleC);
        const moduleRef2 = await lazyModuleLoader.load(() => ModuleC);
        expect(moduleRef).to.equal(moduleRef2);
      });
    });
  });
});



================================================
FILE: packages/core/test/injector/opaque-key-factory/by-reference-module-opaque-key-factory.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ByReferenceModuleOpaqueKeyFactory } from '../../../injector/opaque-key-factory/by-reference-module-opaque-key-factory';

describe('ByReferenceModuleOpaqueKeyFactory', () => {
  const moduleId = 'constId';
  let factory: ByReferenceModuleOpaqueKeyFactory;

  describe('when generating algorithm is random', () => {
    beforeEach(() => {
      factory = new ByReferenceModuleOpaqueKeyFactory();
      sinon.stub(factory as any, 'generateRandomString').returns(moduleId);
    });

    describe('createForStatic', () => {
      class Module {}

      it('should return expected token', () => {
        const type = Module;
        const token1 = factory.createForStatic(type);
        const token2 = factory.createForStatic(type);
        expect(token1).to.be.deep.eq(token2);
      });
    });

    describe('createForDynamic', () => {
      class Module {}

      it('should include dynamic metadata', () => {
        const dynamicModule = {
          module: Module,
          providers: [
            {
              provide: 'test',
              useValue: 'test',
            },
          ],
        };
        const token1 = factory.createForDynamic(
          dynamicModule.module,
          {
            providers: dynamicModule.providers,
          },
          dynamicModule,
        );
        const token2 = factory.createForDynamic(
          dynamicModule.module,
          {
            providers: dynamicModule.providers,
          },
          dynamicModule,
        );

        expect(token1).to.be.deep.eq(token2);
      });
    });
  });
  describe('when generating algorithm is shallow', () => {
    beforeEach(() => {
      factory = new ByReferenceModuleOpaqueKeyFactory({
        keyGenerationStrategy: 'shallow',
      });
      sinon.stub(factory as any, 'generateRandomString').returns(moduleId);
    });

    describe('createForStatic', () => {
      class Module {}

      it('should return expected token', () => {
        const type = Module;
        const token1 = factory.createForStatic(type);
        const token2 = factory.createForStatic(type);

        expect(token1).to.be.deep.eq(token2);
      });
    });

    describe('createForDynamic', () => {
      class Module {}

      it('should include dynamic metadata', () => {
        const dynamicModule = {
          module: Module,
          providers: [
            {
              provide: 'test',
              useValue: 'test',
            },
          ],
        };

        const token1 = factory.createForDynamic(
          dynamicModule.module,
          {
            providers: dynamicModule.providers,
          },
          dynamicModule,
        );
        const token2 = factory.createForDynamic(
          dynamicModule.module,
          {
            providers: dynamicModule.providers,
          },
          dynamicModule,
        );

        expect(token1).to.be.deep.eq(token2);
      });
    });
  });
});



================================================
FILE: packages/core/test/injector/opaque-key-factory/deep-hashed-module-opaque-key-factory.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { DeepHashedModuleOpaqueKeyFactory } from '../../../injector/opaque-key-factory/deep-hashed-module-opaque-key-factory';

describe('DeepHashedModuleOpaqueKeyFactory', () => {
  const moduleId = 'constId';
  let factory: DeepHashedModuleOpaqueKeyFactory;

  beforeEach(() => {
    factory = new DeepHashedModuleOpaqueKeyFactory();
    sinon.stub(factory, 'getModuleId').returns(moduleId);
  });
  describe('createForStatic', () => {
    class Module {}

    it('should return expected token', () => {
      const type = Module;
      const token1 = factory.createForStatic(type);
      const token2 = factory.createForStatic(type);
      expect(token1).to.be.deep.eq(token2);
    });
  });
  describe('createForDynamic', () => {
    class Module {}

    it('should include dynamic metadata', () => {
      const type = Module;
      const token1 = factory.createForDynamic(type, {
        providers: [{}],
      } as any);
      const token2 = factory.createForDynamic(type, {
        providers: [{}],
      } as any);

      expect(token1).to.be.deep.eq(token2);
    });
  });

  describe('getModuleName', () => {
    it('should map module metatype to name', () => {
      const metatype = () => {};
      expect(factory.getModuleName(metatype as any)).to.be.eql(metatype.name);
    });
  });

  describe('getStringifiedOpaqueToken', () => {
    describe('when metadata exists', () => {
      it('should return hash', () => {
        const metadata = { providers: ['', {}] };
        expect(factory.getStringifiedOpaqueToken(metadata as any)).to.be.eql(
          JSON.stringify(metadata),
        );
      });
      it('should return hash with class', () => {
        class Provider {}
        const metadata = { providers: [Provider], exports: [Provider] };
        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(
          '{"providers":["Provider"],"exports":["Provider"]}',
        );
      });
      it('should return hash with value provider with non-class function', () => {
        const provider = {
          provide: 'ProvideValue',
          useValue: function Provider() {},
        };
        const metadata = { providers: [provider] };
        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(
          `{"providers":[{"provide":"ProvideValue","useValue":"${provider.useValue.toString()}"}]}`,
        );
      });
      it('should serialize symbols in a dynamic metadata object', () => {
        const metadata = {
          providers: [
            {
              provide: Symbol('a'),
              useValue: 'a',
            },
            {
              provide: Symbol('b'),
              useValue: 'b',
            },
          ],
        };

        expect(factory.getStringifiedOpaqueToken(metadata)).to.be.eql(
          '{"providers":[{"provide":"Symbol(a)","useValue":"a"},{"provide":"Symbol(b)","useValue":"b"}]}',
        );
      });
    });

    describe('when metadata does not exist', () => {
      it('should return empty string', () => {
        expect(factory.getStringifiedOpaqueToken(undefined)).to.be.eql('');
      });
    });
  });
});



================================================
FILE: packages/core/test/inspector/graph-inspector.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { Module } from '../../injector/module';
import { GraphInspector } from '../../inspector/graph-inspector';
import { EnhancerMetadataCacheEntry } from '../../inspector/interfaces/enhancer-metadata-cache-entry.interface';
import { SerializedGraph } from '../../inspector/serialized-graph';

describe('GraphInspector', () => {
  let graphInspector: GraphInspector;
  let enhancersMetadataCache: Array<EnhancerMetadataCacheEntry>;
  let graph: SerializedGraph;
  let container: NestContainer;

  beforeEach(() => {
    container = new NestContainer();
    graphInspector = new GraphInspector(container);

    enhancersMetadataCache = graphInspector['enhancersMetadataCache'];
    graph = graphInspector['graph'];
  });

  describe('insertEnhancerMetadataCache', () => {
    it('should insert an enhancer metadata cache entry', () => {
      const entry = {
        moduleToken: 'moduleToken',
        classRef: class AppService {},
        methodKey: undefined,
        subtype: 'guard' as const,
      };
      graphInspector.insertEnhancerMetadataCache(entry);
      expect(enhancersMetadataCache).includes(entry);
    });
  });

  describe('inspectInstanceWrapper', () => {
    class AppService {}

    it('should inspect given instance wrapper and insert appropriate edges', () => {
      const moduleRef = new Module(class TestModule {}, container);
      const instanceWrapper = new InstanceWrapper({
        token: AppService,
        name: AppService.name,
        metatype: AppService,
      });

      const param1 = new InstanceWrapper({
        token: 'PARAM_1',
        metatype: class A {},
        host: new Module(class AModule {}, container),
      });
      const param2 = new InstanceWrapper({
        token: 'PARAM_2',
        metatype: class B {},
        host: new Module(class BModule {}, container),
      });
      const dependency = new InstanceWrapper({
        name: 'PROPERTY',
        token: 'PROPERTY',
        metatype: class C {},
        host: new Module(class CModule {}, container),
      });

      instanceWrapper.addCtorMetadata(0, param1);
      instanceWrapper.addCtorMetadata(1, param2);
      instanceWrapper.addCtorMetadata(2, dependency);

      graphInspector.inspectInstanceWrapper(instanceWrapper, moduleRef);

      const edgesArr = [...graph['edges'].values()];
      expect(edgesArr).to.deep.equal([
        {
          id: edgesArr[0].id,
          metadata: {
            injectionType: 'constructor',
            keyOrIndex: 0,
            sourceClassName: instanceWrapper.metatype!.name,
            sourceClassToken: instanceWrapper.token,
            sourceModuleName: 'TestModule',
            targetClassName: param1.name,
            targetClassToken: 'PARAM_1',
            targetModuleName: 'AModule',
            type: 'class-to-class',
          },
          source: instanceWrapper.id,
          target: param1.id,
        },
        {
          id: edgesArr[1].id,
          metadata: {
            injectionType: 'constructor',
            keyOrIndex: 1,
            sourceClassName: instanceWrapper.metatype!.name,
            sourceClassToken: instanceWrapper.token,
            sourceModuleName: 'TestModule',
            targetClassName: param2.name,
            targetClassToken: 'PARAM_2',
            targetModuleName: 'BModule',
            type: 'class-to-class',
          },
          source: instanceWrapper.id,
          target: param2.id,
        },
        {
          id: edgesArr[2].id,
          metadata: {
            injectionType: 'constructor',
            keyOrIndex: 2,
            sourceClassName: 'AppService',
            sourceClassToken: AppService,
            sourceModuleName: 'TestModule',
            targetClassName: dependency.name,
            targetClassToken: 'PROPERTY',
            targetModuleName: 'CModule',
            type: 'class-to-class',
          },
          source: instanceWrapper.id,
          target: dependency.id,
        },
      ]);
    });
  });

  describe('inspectModules', () => {
    class TestModule {}
    class AController {}
    class RandomPipe {}

    it('should inspect all modules', async () => {
      const { moduleRef } = (await container.addModule(TestModule, []))!;
      moduleRef.addController(AController);

      const subtype = 'interceptor';
      const enhancerInstanceWrapper = moduleRef.addInjectable(
        class Enhancer {},
        subtype,
      ) as InstanceWrapper;

      const methodKey = 'findOne';
      enhancersMetadataCache.push(
        {
          moduleToken: moduleRef.token,
          classRef: AController,
          enhancerRef: new RandomPipe(),
          methodKey,
          subtype,
        },
        {
          moduleToken: moduleRef.token,
          classRef: AController,
          enhancerRef: function test() {},
          methodKey,
          subtype,
        },
        {
          moduleToken: moduleRef.token,
          classRef: AController,
          enhancerInstanceWrapper,
          methodKey: undefined,
          subtype,
        },
      );

      const serializedNode = { metadata: {} };
      sinon.stub(graph, 'getNodeById').callsFake(() => serializedNode as any);

      graphInspector.inspectModules();

      expect(serializedNode).to.deep.equal({
        metadata: {
          enhancers: [
            { methodKey, name: RandomPipe.name, subtype },
            { methodKey, name: 'Function', subtype },
            { methodKey: undefined, id: enhancerInstanceWrapper.id, subtype },
          ],
        },
      });
    });
  });

  describe('insertAttachedEnhancer', () => {
    it('should upsert existing node (update metadata) and add node to "attachedEnhancers" array', () => {
      const instanceWrapper = new InstanceWrapper({
        metatype: class A {},
        token: 'A',
      });

      const nodeDefinition = {
        id: instanceWrapper.id,
        label: 'A',
        parent: '2c989d11-2731-4828-a2eb-c86d10c73621',
        metadata: {
          type: 'provider' as const,
          sourceModuleName: 'AppModule',
          durable: false,
          static: true,
          scope: Scope.DEFAULT,
          transient: false,
          token: class A {},
          exported: false,
          initTime: 100,
        },
      };
      const insertedNode = graph.insertNode(nodeDefinition)!;

      graphInspector.insertAttachedEnhancer(instanceWrapper);

      expect(insertedNode.metadata).to.deep.equal({
        ...nodeDefinition.metadata,
        global: true,
      });
      expect(graph['extras'].attachedEnhancers).to.deep.contain({
        nodeId: insertedNode.id,
      });
    });
  });
});



================================================
FILE: packages/core/test/inspector/serialized-graph.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { expect } from 'chai';
import { ApplicationConfig } from '../../application-config';
import { Edge } from '../../inspector/interfaces/edge.interface';
import { Node } from '../../inspector/interfaces/node.interface';
import { SerializedGraph } from '../../inspector/serialized-graph';

describe('SerializedGraph', () => {
  let serializedGraph: SerializedGraph;
  let nodesCollection: Map<string, Node>;
  let edgesCollection: Map<string, Edge>;

  beforeEach(() => {
    serializedGraph = new SerializedGraph();
    nodesCollection = serializedGraph['nodes'];
    edgesCollection = serializedGraph['edges'];
  });

  describe('insertNode', () => {
    describe('when node definition represents an internal provider', () => {
      it('should insert a node with the expected schema (internal: true)', () => {
        const nodeDefinition = {
          id: '11430093-e992-4ae6-8ba4-c7db80419de8',
          label: 'ApplicationConfig',
          parent: '2c989d11-2731-4828-a2eb-c86d10c73621',
          metadata: {
            type: 'provider' as const,
            sourceModuleName: 'AppModule',
            durable: false,
            static: true,
            transient: false,
            token: ApplicationConfig,
            scope: Scope.DEFAULT,
            exported: false,
            initTime: 100,
          },
        };
        serializedGraph.insertNode(nodeDefinition);

        expect(nodesCollection.get(nodeDefinition.id)).to.deep.equal({
          ...nodeDefinition,
          metadata: {
            ...nodeDefinition.metadata,
            internal: true,
          },
        });
      });
    });
    describe('otherwise', () => {
      it('should insert a node with the expected schema', () => {
        class AppService {}

        const nodeDefinition = {
          id: '11430093-e992-4ae6-8ba4-c7db80419de8',
          label: 'AppService',
          parent: '2c989d11-2731-4828-a2eb-c86d10c73621',
          metadata: {
            type: 'provider' as const,
            sourceModuleName: 'AppModule',
            durable: false,
            static: true,
            transient: false,
            token: AppService,
            scope: Scope.DEFAULT,
            exported: false,
            initTime: 100,
          },
        };
        serializedGraph.insertNode(nodeDefinition);

        expect(nodesCollection.get(nodeDefinition.id)).to.equal(nodeDefinition);
      });
    });
  });

  describe('insertEdge', () => {
    describe('when edge definition represents internal providers connection', () => {
      it('should insert an edge with the expected schema (internal: true)', () => {
        const edgeDefinition = {
          source: '8920252f-4e7d-4f9e-9eeb-71da467a35cc',
          target: 'c97bc04d-cfcf-41b1-96ec-db729f33676e',
          metadata: {
            type: 'class-to-class' as const,
            sourceModuleName: 'UtilsExceptionsModule',
            sourceClassName: 'AllExceptionsFilter',
            targetClassName: 'HttpAdapterHost',
            sourceClassToken:
              'APP_FILTER (UUID: 4187828c-5c76-4aed-a29f-a6eb40054b9d)',
            targetClassToken: 'HttpAdapterHost',
            targetModuleName: 'InternalCoreModule',
            keyOrIndex: 0,
            injectionType: 'constructor' as const,
          },
        };
        const edge = serializedGraph.insertEdge(edgeDefinition);

        expect(edgesCollection.get(edge.id)).to.deep.equal({
          ...edgeDefinition,
          metadata: {
            ...edgeDefinition.metadata,
            internal: true,
          },
          id: edge.id,
        });
      });
    });
    describe('otherwise', () => {
      it('should insert an edge with the expected schema', () => {
        const edgeDefinition = {
          source: '8920252f-4e7d-4f9e-9eeb-71da467a35cc',
          target: 'c97bc04d-cfcf-41b1-96ec-db729f33676e',
          metadata: {
            type: 'class-to-class' as const,
            sourceModuleName: 'UtilsExceptionsModule',
            sourceClassName: 'AllExceptionsFilter',
            targetClassName: 'AppService',
            sourceClassToken:
              'APP_FILTER (UUID: 4187828c-5c76-4aed-a29f-a6eb40054b9d)',
            targetClassToken: 'AppService',
            targetModuleName: 'InternalCoreModule',
            keyOrIndex: 0,
            injectionType: 'constructor' as const,
          },
        };
        const edge = serializedGraph.insertEdge(edgeDefinition);

        expect(edgesCollection.get(edge.id)).to.deep.equal({
          ...edgeDefinition,
          id: edge.id,
        });
      });
    });
  });

  describe('getNodeById', () => {
    it('should return a given node', () => {
      const nodeDefinition = {
        id: '11430093-e992-4ae6-8ba4-c7db80419de8',
        label: 'AppService',
        parent: '2c989d11-2731-4828-a2eb-c86d10c73621',
        metadata: {
          type: 'provider' as const,
          sourceModuleName: 'AppModule',
          durable: false,
          static: true,
          transient: false,
          scope: Scope.DEFAULT,
          token: 'AppService',
          exported: true,
          initTime: 100,
        },
      };

      nodesCollection.set(nodeDefinition.id, nodeDefinition);
      expect(serializedGraph.getNodeById(nodeDefinition.id)).to.eq(
        nodeDefinition,
      );
    });
  });
});



================================================
FILE: packages/core/test/interceptors/interceptors-consumer.spec.ts
================================================
import { CallHandler, ExecutionContext, NestInterceptor } from '@nestjs/common';
import { AsyncLocalStorage } from 'async_hooks';
import { expect } from 'chai';
import { Observable, defer, lastValueFrom, merge, of, retry } from 'rxjs';
import * as sinon from 'sinon';
import { InterceptorsConsumer } from '../../interceptors/interceptors-consumer';

describe('InterceptorsConsumer', () => {
  let consumer: InterceptorsConsumer;
  let interceptors: any[];
  beforeEach(() => {
    consumer = new InterceptorsConsumer();
    interceptors = [
      {
        intercept: sinon.stub().callsFake((ctx, handler) => handler.handle()),
      },
      {
        intercept: sinon
          .stub()
          .callsFake(async (ctx, handler) => handler.handle()),
      },
    ];
  });
  describe('intercept', () => {
    describe('when interceptors array is empty', () => {
      let next: sinon.SinonSpy;
      beforeEach(() => {
        next = sinon.spy();
      });
      it('should call next()', async () => {
        await consumer.intercept([], null!, { constructor: null }, null!, next);
        expect(next.calledOnce).to.be.true;
      });
    });
    describe('when interceptors array is not empty', () => {
      let next: sinon.SinonSpy;
      beforeEach(() => {
        next = sinon.stub().returns(Promise.resolve(''));
      });
      it('does not call `intercept` (lazy evaluation)', async () => {
        await consumer.intercept(
          interceptors,
          null!,
          { constructor: null },
          null!,
          next,
        );

        expect(interceptors[0].intercept.called).to.be.false;
        expect(interceptors[1].intercept.called).to.be.false;
      });
      it('should call every `intercept` method when subscribe', async () => {
        const intercepted = await consumer.intercept(
          interceptors,
          null!,
          { constructor: null },
          null!,
          next,
        );
        await transformToResult(intercepted);

        expect(interceptors[0].intercept.calledOnce).to.be.true;
        expect(interceptors[1].intercept.calledOnce).to.be.true;
      });
      it('should not call `next` (lazy evaluation)', async () => {
        await consumer.intercept(
          interceptors,
          null!,
          { constructor: null },
          null!,
          next,
        );
        expect(next.called).to.be.false;
      });
      it('should call `next` when subscribe', async () => {
        const intercepted = await consumer.intercept(
          interceptors,
          null!,
          { constructor: null },
          null!,
          next,
        );
        await transformToResult(intercepted);
        expect(next.called).to.be.true;
      });
    });

    describe('when AsyncLocalStorage is used', () => {
      it('should allow an interceptor to set values in AsyncLocalStorage that are accessible from the controller', async () => {
        const storage = new AsyncLocalStorage<Record<string, any>>();
        class StorageInterceptor implements NestInterceptor {
          intercept(
            _context: ExecutionContext,
            next: CallHandler<any>,
          ): Observable<any> | Promise<Observable<any>> {
            return storage.run({ value: 'hello' }, () => next.handle());
          }
        }
        const next = () => {
          return Promise.resolve(storage.getStore()!.value);
        };
        const intercepted = await consumer.intercept(
          [new StorageInterceptor()],
          null!,
          { constructor: null },
          null!,
          next,
        );
        const result = await transformToResult(intercepted);
        expect(result).to.equal('hello');
      });
    });

    describe('when retrying is enabled', () => {
      it('should retry a specified amount of times', async () => {
        let count = 0;
        const next = () => {
          count++;
          if (count < 3) {
            return Promise.reject(new Error('count not reached'));
          }
          return Promise.resolve(count);
        };
        class RetryInterceptor implements NestInterceptor {
          intercept(
            _context: ExecutionContext,
            next: CallHandler<any>,
          ): Observable<any> | Promise<Observable<any>> {
            return next.handle().pipe(retry(4));
          }
        }
        const intercepted = await consumer.intercept(
          [new RetryInterceptor()],
          null!,
          { constructor: null },
          null!,
          next,
        );
        expect(await transformToResult(intercepted)).to.equal(3);
      });
    });
  });
  describe('createContext', () => {
    it('should return execution context object', () => {
      const instance = { constructor: {} };
      const callback = () => null;
      const context = consumer.createContext([], instance, callback);

      expect(context.getClass()).to.be.eql(instance.constructor);
      expect(context.getHandler()).to.be.eql(callback);
    });
  });
  describe('transformDeferred', () => {
    describe('when next() result is plain value', () => {
      it('should return Observable', async () => {
        const val = 3;
        const next = async () => val;
        expect(await lastValueFrom(consumer.transformDeferred(next))).to.be.eql(
          val,
        );
      });
    });
    describe('when next() result is Promise', () => {
      it('should return Observable', async () => {
        const val = 3;
        const next = async () => val;
        expect(await lastValueFrom(consumer.transformDeferred(next))).to.be.eql(
          val,
        );
      });
    });
    describe('when next() result is Observable', () => {
      it('should return Observable', async () => {
        const val = 3;
        const next = async () => of(val);
        expect(
          await lastValueFrom(consumer.transformDeferred(next) as any),
        ).to.be.eql(val);
      });
    });
  });
  describe('deferred promise conversion', () => {
    it('should convert promise to observable deferred', async () => {
      class TestError extends Error {}
      const testInterceptors = [
        {
          intercept: sinon.stub().callsFake(async (ctx, handler) => {
            return merge(
              handler.handle(),
              defer(() => {
                throw new TestError();
              }),
            );
          }),
        },
        {
          intercept: sinon
            .stub()
            .callsFake(async (ctx, handler) => handler.handle()),
        },
        {
          intercept: sinon
            .stub()
            .callsFake(async (ctx, handler) => handler.handle()),
        },
      ];

      const observable = await consumer.intercept(
        testInterceptors,
        null!,
        { constructor: null },
        null!,
        async () => 1,
      );

      try {
        await transformToResult(observable);
      } catch (error) {
        if (!(error instanceof TestError)) {
          throw error;
        }
      }
      expect(testInterceptors[2].intercept.called).to.be.false;
    });
  });
});

async function transformToResult(resultOrDeferred: any) {
  if (resultOrDeferred && typeof resultOrDeferred.subscribe === 'function') {
    return lastValueFrom(resultOrDeferred);
  }
  return resultOrDeferred;
}



================================================
FILE: packages/core/test/interceptors/interceptors-context-creator.spec.ts
================================================
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { ApplicationConfig } from '../../application-config';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { InterceptorsContextCreator } from '../../interceptors/interceptors-context-creator';

class Interceptor {}

describe('InterceptorsContextCreator', () => {
  let interceptorsContextCreator: InterceptorsContextCreator;
  let interceptors: any[];
  let applicationConfig: ApplicationConfig;
  let container: any;
  let getSpy: sinon.SinonSpy;

  class Interceptor1 {}
  class Interceptor2 {}

  beforeEach(() => {
    interceptors = [
      {
        name: Interceptor1.name,
        token: Interceptor1,
        metatype: Interceptor1,
        getInstanceByContextId: () => interceptors[0],
        instance: {
          intercept: () => of(true),
        },
      },
      {
        name: Interceptor2.name,
        token: Interceptor2,
        metatype: Interceptor2,
        getInstanceByContextId: () => interceptors[1],
        instance: {
          intercept: () => of(true),
        },
      },
      {},
      undefined,
    ];
    getSpy = sinon.stub().returns({
      injectables: new Map([
        [Interceptor1, interceptors[0]],
        [Interceptor2, interceptors[1]],
      ]),
    });
    container = {
      getModules: () => ({
        get: getSpy,
      }),
    };
    applicationConfig = new ApplicationConfig();
    interceptorsContextCreator = new InterceptorsContextCreator(
      container,
      applicationConfig,
    );
  });
  describe('createConcreteContext', () => {
    describe('when `moduleContext` is nil', () => {
      it('should return empty array', () => {
        const result =
          interceptorsContextCreator.createConcreteContext(interceptors);
        expect(result).to.be.empty;
      });
    });
    describe('when `moduleContext` is defined', () => {
      beforeEach(() => {
        interceptorsContextCreator['moduleContext'] = 'test';
      });
      it('should filter metatypes', () => {
        const interceptorTypeRefs = [
          interceptors[0].metatype,
          interceptors[1].instance,
        ];
        expect(
          interceptorsContextCreator.createConcreteContext(interceptorTypeRefs),
        ).to.have.length(2);
      });
    });
  });

  describe('getInterceptorInstance', () => {
    describe('when param is an object', () => {
      it('should return instance', () => {
        const instance = { intercept: () => null! };
        expect(
          interceptorsContextCreator.getInterceptorInstance(instance),
        ).to.be.eql(instance);
      });
    });
    describe('when param is a constructor', () => {
      it('should pick instance from container', () => {
        const wrapper: InstanceWrapper = {
          instance: 'test',
          getInstanceByContextId: () => wrapper,
        } as any;
        sinon
          .stub(interceptorsContextCreator, 'getInstanceByMetatype')
          .callsFake(() => wrapper);
        expect(
          interceptorsContextCreator.getInterceptorInstance(Interceptor),
        ).to.be.eql(wrapper.instance);
      });
      it('should return null', () => {
        sinon
          .stub(interceptorsContextCreator, 'getInstanceByMetatype')
          .callsFake(() => null!);
        expect(
          interceptorsContextCreator.getInterceptorInstance(Interceptor),
        ).to.be.eql(null);
      });
    });
  });

  describe('getInstanceByMetatype', () => {
    describe('when "moduleContext" is nil', () => {
      it('should return undefined', () => {
        (interceptorsContextCreator as any).moduleContext = undefined;
        expect(interceptorsContextCreator.getInstanceByMetatype(null!)).to.be
          .undefined;
      });
    });
    describe('when "moduleContext" is not nil', () => {
      beforeEach(() => {
        (interceptorsContextCreator as any).moduleContext = 'test';
      });

      describe('and when module exists', () => {
        it('should return undefined', () => {
          expect(interceptorsContextCreator.getInstanceByMetatype(class {})).to
            .be.undefined;
        });
      });
    });
  });

  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global interceptors', () => {
        const expectedResult = applicationConfig.getGlobalInterceptors();
        expect(interceptorsContextCreator.getGlobalMetadata()).to.be.equal(
          expectedResult,
        );
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped interceptors', () => {
        const globalInterceptors: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedInterceptorWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalInterceptors')
          .callsFake(() => globalInterceptors);
        sinon
          .stub(applicationConfig, 'getGlobalRequestInterceptors')
          .callsFake(() => scopedInterceptorWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(
          interceptorsContextCreator.getGlobalMetadata({ id: 3 }),
        ).to.contains(instance, ...globalInterceptors);
      });
    });
  });
});



================================================
FILE: packages/core/test/middleware/builder.spec.ts
================================================
import { expect } from 'chai';
import {
  Controller,
  Delete,
  Get,
  Head,
  Options,
  Patch,
  Post,
  Put,
  RequestMethod,
  Version,
  VersioningType,
} from '../../../common';
import { MiddlewareConfigProxy } from '../../../common/interfaces';
import { ApplicationConfig } from '../../application-config';
import { NestContainer } from '../../injector/container';
import { MiddlewareBuilder } from '../../middleware/builder';
import { RouteInfoPathExtractor } from '../../middleware/route-info-path-extractor';
import { RoutesMapper } from '../../middleware/routes-mapper';
import { NoopHttpAdapter } from './../utils/noop-adapter.spec';

describe('MiddlewareBuilder', () => {
  let builder: MiddlewareBuilder;

  beforeEach(() => {
    const container = new NestContainer();
    const appConfig = new ApplicationConfig();
    appConfig.enableVersioning({ type: VersioningType.URI });
    builder = new MiddlewareBuilder(
      new RoutesMapper(container, appConfig),
      new NoopHttpAdapter({}),
      new RouteInfoPathExtractor(appConfig),
    );
  });
  describe('apply', () => {
    it('should return configuration proxy', () => {
      const configProxy = builder.apply([]);
      const metatype = (MiddlewareBuilder as any).ConfigProxy;
      expect(configProxy instanceof metatype).to.be.true;
    });

    describe('configuration proxy', () => {
      describe('when "forRoutes()" called', () => {
        let configProxy: MiddlewareConfigProxy;
        beforeEach(() => {
          configProxy = builder.apply([]);
        });
        @Controller('path')
        class Test {
          @Get('route')
          public getAll() {}

          @Version('1')
          @Get('versioned')
          public getAllVersioned() {}
        }
        const route = { path: '/test', method: RequestMethod.GET };

        it('should store configuration passed as argument', () => {
          configProxy.forRoutes(route, Test);

          expect(builder.build()).to.deep.equal([
            {
              middleware: [],
              forRoutes: [
                {
                  method: RequestMethod.GET,
                  path: route.path,
                },
                {
                  method: RequestMethod.GET,
                  path: '/path/route',
                },
                {
                  method: RequestMethod.GET,
                  path: '/path/versioned',
                  version: '1',
                },
              ],
            },
          ]);
        });

        @Controller('users')
        class UsersController {
          @Head('rsvp')
          hRsvp() {}

          @Options('rsvp')
          oRsvp() {}

          @Get('rsvp')
          gRsvp() {}

          @Post('rsvp')
          pRsvp() {}

          @Put('rsvp')
          puRsvp() {}

          @Patch('rsvp')
          ptRsvp() {}

          @Delete('rsvp')
          dRsvp() {}

          @Post()
          create() {}

          @Get()
          findAll() {}

          @Get(':id')
          findOne() {}

          @Patch(':id')
          update() {}

          @Delete(':id')
          remove() {}
        }

        it('should remove overlapping routes', () => {
          configProxy.forRoutes(UsersController);

          expect(builder.build()).to.deep.equal([
            {
              middleware: [],
              forRoutes: [
                {
                  method: RequestMethod.HEAD,
                  path: '/users/rsvp',
                },
                {
                  method: RequestMethod.OPTIONS,
                  path: '/users/rsvp',
                },
                {
                  method: RequestMethod.POST,
                  path: '/users/rsvp',
                },
                {
                  method: RequestMethod.PUT,
                  path: '/users/rsvp',
                },
                {
                  method: RequestMethod.POST,
                  path: '/users/',
                },
                {
                  method: RequestMethod.GET,
                  path: '/users/',
                },
                {
                  method: RequestMethod.GET,
                  path: '/users/:id',
                },
                {
                  method: RequestMethod.PATCH,
                  path: '/users/:id',
                },
                {
                  method: RequestMethod.DELETE,
                  path: '/users/:id',
                },
                // Overlapping:
                // {
                //   method: RequestMethod.GET,
                //   path: '/users/rsvp',
                // },
                // {
                //   method: RequestMethod.PATCH,
                //   path: '/users/rsvp',
                // },
                // {
                //   method: RequestMethod.DELETE,
                //   path: '/users/rsvp',
                // },
              ],
            },
          ]);
        });
      });
    });
  });

  describe('exclude', () => {
    it('should map string to RouteInfo', () => {
      const path = '/test';
      const proxy: any = builder.apply().exclude(path);

      expect(proxy.getExcludedRoutes()).to.be.eql([
        {
          path,
          method: -1,
        },
      ]);
    });
  });
});



================================================
FILE: packages/core/test/middleware/container.spec.ts
================================================
import { expect } from 'chai';
import { Injectable } from '../../../common';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import { RequestMapping } from '../../../common/decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { MiddlewareConfiguration } from '../../../common/interfaces/middleware/middleware-configuration.interface';
import { NestMiddleware } from '../../../common/interfaces/middleware/nest-middleware.interface';
import { NestContainer } from '../../injector';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { Module } from '../../injector/module';
import { MiddlewareContainer } from '../../middleware/container';

describe('MiddlewareContainer', () => {
  class ExampleModule {}

  @Controller('test')
  class TestRoute {
    @RequestMapping({ path: 'test' })
    public getTest() {}

    @RequestMapping({ path: 'another', method: RequestMethod.DELETE })
    public getAnother() {}
  }

  @Injectable()
  class TestMiddleware implements NestMiddleware {
    public use(req, res, next) {}
  }

  let container: MiddlewareContainer;

  beforeEach(() => {
    const nestContainer = new NestContainer();
    const modules = nestContainer.getModules();

    modules.set('Module', new Module(ExampleModule, nestContainer));
    modules.set('Test', new Module(ExampleModule, nestContainer));

    container = new MiddlewareContainer(nestContainer);
  });

  it('should store expected configurations for given module', () => {
    const config: MiddlewareConfiguration[] = [
      {
        middleware: [TestMiddleware],
        forRoutes: [TestRoute, 'test'],
      },
    ];
    container.insertConfig(config, 'Module');
    expect([...container.getConfigurations().get('Module')!]).to.deep.equal(
      config,
    );
  });

  it('should store expected middleware for given module', () => {
    const config: MiddlewareConfiguration[] = [
      {
        middleware: TestMiddleware,
        forRoutes: [TestRoute],
      },
    ];

    const key = 'Test';
    container.insertConfig(config, key);

    const collection = container.getMiddlewareCollection(key);
    const insertedMiddleware = collection.get(TestMiddleware);

    expect(collection.size).to.eql(config.length);
    expect(insertedMiddleware).to.be.instanceOf(InstanceWrapper);
    expect(insertedMiddleware!.scope).to.be.undefined;
    expect(insertedMiddleware!.metatype).to.be.eql(TestMiddleware);
  });
});



================================================
FILE: packages/core/test/middleware/middleware-module.spec.ts
================================================
import { Injectable } from '@nestjs/common';
import { RouteInfoPathExtractor } from '@nestjs/core/middleware/route-info-path-extractor';
import * as chai from 'chai';
import { expect } from 'chai';
import * as chaiAsPromised from 'chai-as-promised';
import * as sinon from 'sinon';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import { RequestMapping } from '../../../common/decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { NestMiddleware } from '../../../common/interfaces/middleware/nest-middleware.interface';
import { ApplicationConfig } from '../../application-config';
import { InvalidMiddlewareException } from '../../errors/exceptions/invalid-middleware.exception';
import { RuntimeException } from '../../errors/exceptions/runtime.exception';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { Module } from '../../injector/module';
import { GraphInspector } from '../../inspector/graph-inspector';
import { MiddlewareBuilder } from '../../middleware/builder';
import { MiddlewareContainer } from '../../middleware/container';
import { MiddlewareModule } from '../../middleware/middleware-module';
import { RouterExceptionFilters } from '../../router/router-exception-filters';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

chai.use(chaiAsPromised);

describe('MiddlewareModule', () => {
  let middlewareModule: MiddlewareModule;
  let graphInspector: GraphInspector;

  @Controller('test')
  class BasicController {}

  @Controller('test')
  class BaseController {
    @RequestMapping({ path: 'test' })
    public getTest() {}

    @RequestMapping({ path: 'another', method: RequestMethod.DELETE })
    public getAnother() {}
  }

  @Injectable()
  class TestMiddleware implements NestMiddleware {
    public use(req, res, next) {}
  }

  beforeEach(() => {
    const container = new NestContainer();
    const appConfig = new ApplicationConfig();
    graphInspector = new GraphInspector(container);
    middlewareModule = new MiddlewareModule();
    middlewareModule['routerExceptionFilter'] = new RouterExceptionFilters(
      new NestContainer(),
      appConfig,
      new NoopHttpAdapter({}),
    );
    middlewareModule['routeInfoPathExtractor'] = new RouteInfoPathExtractor(
      appConfig,
    );
    middlewareModule['routerExceptionFilter'] = new RouterExceptionFilters(
      container,
      appConfig,
      new NoopHttpAdapter({}),
    );
    middlewareModule['graphInspector'] = graphInspector;
  });

  describe('loadConfiguration', () => {
    it('should call "configure" method if method is implemented', async () => {
      const stubContainer = new NestContainer();
      stubContainer
        .getModules()
        .set('Test', new Module(class {}, stubContainer));

      const configureSpy = sinon.spy();
      const mockModule = {
        instance: {
          configure: configureSpy,
        },
      };

      (middlewareModule as any).container = stubContainer;
      await middlewareModule.loadConfiguration(
        new MiddlewareContainer(stubContainer),
        mockModule as any,
        'Test',
      );

      expect(configureSpy.calledOnce).to.be.true;
      expect(
        configureSpy.calledWith(
          new MiddlewareBuilder(
            (middlewareModule as any).routesMapper,
            undefined!,
            new RouteInfoPathExtractor(new ApplicationConfig()),
          ),
        ),
      ).to.be.true;
    });
  });

  describe('registerRouteMiddleware', () => {
    class TestModule {}

    let nestContainer: NestContainer;

    beforeEach(() => {
      nestContainer = new NestContainer();
      nestContainer
        .getModules()
        .set('Test', new Module(TestModule, nestContainer));
    });
    it('should throw "RuntimeException" exception when middleware is not stored in container', () => {
      const route = { path: 'Test' };
      const configuration = {
        middleware: [TestMiddleware],
        forRoutes: [BaseController],
      };
      const useSpy = sinon.spy();
      const app = { use: useSpy };

      middlewareModule['container'] = nestContainer;

      expect(
        middlewareModule.registerRouteMiddleware(
          new MiddlewareContainer(nestContainer),
          route as any,
          configuration,
          'Test',
          app,
        ),
      ).to.eventually.be.rejectedWith(RuntimeException);
    });

    it('should throw "InvalidMiddlewareException" exception when middleware does not have "use" method', () => {
      @Injectable()
      class InvalidMiddleware {}

      const route = { path: 'Test' };
      const configuration = {
        middleware: [InvalidMiddleware],
        forRoutes: [BaseController],
      };

      const useSpy = sinon.spy();
      const app = { use: useSpy };

      const container = new MiddlewareContainer(nestContainer);
      const moduleKey = 'Test';
      container.insertConfig([configuration], moduleKey);

      const instance = new InvalidMiddleware();
      container.getMiddlewareCollection(moduleKey).set('InvalidMiddleware', {
        metatype: InvalidMiddleware,
        instance,
      } as any);

      expect(
        middlewareModule.registerRouteMiddleware(
          container,
          route as any,
          configuration,
          moduleKey,
          app,
        ),
      ).to.be.rejectedWith(InvalidMiddlewareException);
    });

    it('should mount middleware when is stored in container', async () => {
      const route = 'testPath';
      const configuration = {
        middleware: [TestMiddleware],
        forRoutes: ['test', BasicController, BaseController],
      };

      const createMiddlewareFactoryStub = sinon
        .stub()
        .callsFake(() => () => null);
      const app = {
        createMiddlewareFactory: createMiddlewareFactoryStub,
      };

      const stubContainer = new NestContainer();
      stubContainer
        .getModules()
        .set('Test', new Module(TestModule, stubContainer));

      const container = new MiddlewareContainer(stubContainer);
      const moduleKey = 'Test';
      container.insertConfig([configuration], moduleKey);

      const instance = new TestMiddleware();
      container.getMiddlewareCollection(moduleKey).set(
        TestMiddleware,
        new InstanceWrapper({
          metatype: TestMiddleware,
          instance,
        }),
      );
      sinon
        .stub(stubContainer, 'getModuleByKey')
        .callsFake(() => new Module(class {}, stubContainer));
      middlewareModule['container'] = stubContainer;

      await middlewareModule.registerRouteMiddleware(
        container,
        { path: route, method: RequestMethod.ALL },
        configuration,
        moduleKey,
        app,
      );
      expect(createMiddlewareFactoryStub.calledOnce).to.be.true;
    });

    it('should insert the expected middleware definition', async () => {
      const route = 'testPath';
      const configuration = {
        middleware: [TestMiddleware],
        forRoutes: ['test', BasicController, BaseController],
      };
      const instance = new TestMiddleware();
      const instanceWrapper = new InstanceWrapper({
        metatype: TestMiddleware,
        instance,
        name: TestMiddleware.name,
      });
      const createMiddlewareFactoryStub = sinon
        .stub()
        .callsFake(() => () => null);
      const app = {
        createMiddlewareFactory: createMiddlewareFactoryStub,
      };

      const stubContainer = new NestContainer();
      stubContainer
        .getModules()
        .set('Test', new Module(TestModule, stubContainer));
      const container = new MiddlewareContainer(stubContainer);
      const moduleKey = 'Test';
      container.insertConfig([configuration], moduleKey);
      container
        .getMiddlewareCollection(moduleKey)
        .set(TestMiddleware, instanceWrapper);
      sinon
        .stub(stubContainer, 'getModuleByKey')
        .callsFake(() => new Module(class {}, stubContainer));
      middlewareModule['container'] = stubContainer;

      const insertEntrypointDefinitionSpy = sinon.spy(
        graphInspector,
        'insertEntrypointDefinition',
      );

      await middlewareModule.registerRouteMiddleware(
        container,
        { path: route, method: RequestMethod.ALL },
        configuration,
        moduleKey,
        app,
      );

      expect(createMiddlewareFactoryStub.calledOnce).to.be.true;
      expect(
        insertEntrypointDefinitionSpy.calledWith({
          type: 'middleware',
          methodName: 'use',
          className: instanceWrapper.name,
          classNodeId: instanceWrapper.id,
          metadata: {
            key: route,
            path: route,
            requestMethod: 'ALL',
            version: undefined,
          } as any,
        }),
      ).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/middleware/resolver.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Injectable } from '../../../common';
import { NestMiddleware } from '../../../common/interfaces/middleware/nest-middleware.interface';
import { NestContainer } from '../../injector';
import { Injector } from '../../injector/injector';
import { MiddlewareContainer } from '../../middleware/container';
import { MiddlewareResolver } from '../../middleware/resolver';

describe('MiddlewareResolver', () => {
  @Injectable()
  class TestMiddleware implements NestMiddleware {
    public use(req, res, next) {}
  }

  let resolver: MiddlewareResolver;
  let container: MiddlewareContainer;
  let mockContainer: sinon.SinonMock;

  beforeEach(() => {
    const injector = new Injector();
    container = new MiddlewareContainer(new NestContainer());
    resolver = new MiddlewareResolver(container, injector);
    mockContainer = sinon.mock(container);
  });

  it('should resolve middleware instances from container', async () => {
    const loadMiddleware = sinon.stub(resolver['injector'], 'loadMiddleware');
    const middleware = new Map();
    const wrapper = {
      instance: { metatype: {} },
      metatype: TestMiddleware,
    };
    middleware.set('TestMiddleware', wrapper);

    const module = { metatype: { name: '' } } as any;
    mockContainer.expects('getMiddlewareCollection').returns(middleware);
    await resolver.resolveInstances(module, null!);

    expect(loadMiddleware.callCount).to.be.equal(middleware.size);
    expect(loadMiddleware.calledWith(wrapper as any, middleware, module)).to.be
      .true;

    loadMiddleware.restore();
  });
});



================================================
FILE: packages/core/test/middleware/route-info-path-extractor.spec.ts
================================================
import { RequestMethod, VersioningType } from '@nestjs/common';
import { ApplicationConfig } from '@nestjs/core';
import { mapToExcludeRoute } from '@nestjs/core/middleware/utils';
import { expect } from 'chai';
import { RouteInfoPathExtractor } from './../../middleware/route-info-path-extractor';

describe('RouteInfoPathExtractor', () => {
  describe('extractPathsFrom', () => {
    let appConfig: ApplicationConfig;
    let routeInfoPathExtractor: RouteInfoPathExtractor;

    beforeEach(() => {
      appConfig = new ApplicationConfig();
      appConfig.enableVersioning({
        type: VersioningType.URI,
      });
      routeInfoPathExtractor = new RouteInfoPathExtractor(appConfig);
    });

    it(`should return correct paths`, () => {
      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/*']);

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/v1$', '/v1/*']);
    });

    it(`should return correct paths when set global prefix`, () => {
      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/api$', '/api/*']);

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1$', '/api/v1/*']);
    });

    it(`should return correct paths when set global prefix and global prefix options`, () => {
      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');
      Reflect.set(
        routeInfoPathExtractor,
        'excludedGlobalPrefixRoutes',
        mapToExcludeRoute(['foo']),
      );

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/api$', '/api/*', '/foo']);

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1$', '/api/v1/*', '/v1/foo']);

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: 'foo',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/v1/foo']);

      expect(
        routeInfoPathExtractor.extractPathsFrom({
          path: 'bar',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1/bar']);
    });
  });

  describe('extractPathFrom', () => {
    let appConfig: ApplicationConfig;
    let routeInfoPathExtractor: RouteInfoPathExtractor;

    beforeEach(() => {
      appConfig = new ApplicationConfig();
      appConfig.enableVersioning({
        type: VersioningType.URI,
      });
      routeInfoPathExtractor = new RouteInfoPathExtractor(appConfig);
    });

    it(`should return correct path`, () => {
      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/*']);

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/v1/*']);
    });

    it(`should return correct path when set global prefix`, () => {
      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/*']);

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1/*']);
    });

    it(`should return correct path when set global prefix and global prefix options`, () => {
      Reflect.set(routeInfoPathExtractor, 'prefixPath', '/api');
      Reflect.set(
        routeInfoPathExtractor,
        'excludedGlobalPrefixRoutes',
        mapToExcludeRoute(['foo']),
      );

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
        }),
      ).to.eql(['/*']);

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: '*',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1/*']);

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: 'foo',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/v1/foo']);

      expect(
        routeInfoPathExtractor.extractPathFrom({
          path: 'bar',
          method: RequestMethod.ALL,
          version: '1',
        }),
      ).to.eql(['/api/v1/bar']);
    });
  });
});



================================================
FILE: packages/core/test/middleware/routes-mapper.spec.ts
================================================
import { expect } from 'chai';
import { Version, VersioningType } from '../../../common';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import {
  Get,
  RequestMapping,
} from '../../../common/decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { MiddlewareConfiguration } from '../../../common/interfaces';
import { ApplicationConfig } from '../../application-config';
import { NestContainer } from '../../injector/container';
import { RoutesMapper } from '../../middleware/routes-mapper';

describe('RoutesMapper', () => {
  @Controller('test')
  class TestRoute {
    @RequestMapping({ path: 'test' })
    public getTest() {}

    @RequestMapping({ path: 'another', method: RequestMethod.DELETE })
    public getAnother() {}

    @Version('1')
    @Get('versioned')
    public getVersioned() {}
  }

  let mapper: RoutesMapper;
  beforeEach(() => {
    const appConfig = new ApplicationConfig();
    appConfig.enableVersioning({ type: VersioningType.URI });
    mapper = new RoutesMapper(new NestContainer(), appConfig);
  });

  it('should map @Controller() to "ControllerMetadata" in forRoutes', () => {
    const config: MiddlewareConfiguration = {
      middleware: 'Test',
      forRoutes: [
        { path: 'test', method: RequestMethod.GET },
        { path: 'versioned', version: '1', method: RequestMethod.GET },
        TestRoute,
      ],
    };

    expect(mapper.mapRouteToRouteInfo(config.forRoutes[0])).to.deep.equal([
      { path: '/test', method: RequestMethod.GET },
    ]);

    expect(mapper.mapRouteToRouteInfo(config.forRoutes[1])).to.deep.equal([
      { path: '/versioned', version: '1', method: RequestMethod.GET },
    ]);

    expect(mapper.mapRouteToRouteInfo(config.forRoutes[2])).to.deep.equal([
      { path: '/test/test', method: RequestMethod.GET },
      { path: '/test/another', method: RequestMethod.DELETE },
      { path: '/test/versioned', method: RequestMethod.GET, version: '1' },
    ]);
  });
  @Controller(['test', 'test2'])
  class TestRouteWithMultiplePaths {
    @RequestMapping({ path: 'test' })
    public getTest() {}

    @RequestMapping({ path: 'another', method: RequestMethod.DELETE })
    public getAnother() {}
  }

  it('should map a controller with multiple paths to "ControllerMetadata" in forRoutes', () => {
    const config = {
      middleware: 'Test',
      forRoutes: [
        { path: 'test', method: RequestMethod.GET },
        TestRouteWithMultiplePaths,
      ],
    };

    expect(mapper.mapRouteToRouteInfo(config.forRoutes[0])).to.deep.equal([
      { path: '/test', method: RequestMethod.GET },
    ]);
    expect(mapper.mapRouteToRouteInfo(config.forRoutes[1])).to.deep.equal([
      { path: '/test/test', method: RequestMethod.GET },
      { path: '/test/another', method: RequestMethod.DELETE },
      { path: '/test2/test', method: RequestMethod.GET },
      { path: '/test2/another', method: RequestMethod.DELETE },
    ]);
  });

  @Controller({
    version: '1',
    path: 'versioned',
  })
  class VersionedController {
    @Get()
    hello() {
      return 'Hello from "VersionedController"!';
    }

    @Version('2')
    @Get('/override')
    override() {
      return 'Hello from "VersionedController"!';
    }
  }

  @Controller({
    version: ['1', '2'],
  })
  class MultipleVersionController {
    @Get('multiple')
    multiple() {
      return 'Multiple Versions 1 or 2';
    }
  }

  it('should map a versioned controller to the corresponding route info objects (single version)', () => {
    expect(mapper.mapRouteToRouteInfo(VersionedController)).to.deep.equal([
      { path: '/versioned/', version: '1', method: RequestMethod.GET },
      { path: '/versioned/override', version: '2', method: RequestMethod.GET },
    ]);
  });

  it('should map a versioned controller to the corresponding route info objects (multiple versions)', () => {
    expect(mapper.mapRouteToRouteInfo(MultipleVersionController)).to.deep.equal(
      [
        { path: '/multiple', version: '1', method: RequestMethod.GET },
        { path: '/multiple', version: '2', method: RequestMethod.GET },
      ],
    );
  });
});



================================================
FILE: packages/core/test/middleware/utils.spec.ts
================================================
import { RequestMethod } from '@nestjs/common';
import { addLeadingSlash } from '@nestjs/common/utils/shared.utils';
import { expect } from 'chai';
import { pathToRegexp } from 'path-to-regexp';
import * as sinon from 'sinon';
import {
  assignToken,
  filterMiddleware,
  isMiddlewareClass,
  isMiddlewareRouteExcluded,
  mapToClass,
  mapToExcludeRoute,
} from '../../middleware/utils';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('middleware utils', () => {
  const noopAdapter = new NoopHttpAdapter({});

  class Test {}
  function fnMiddleware(req, res, next) {}

  describe('mapToExcludeRoute', () => {
    it('should return exclude route metadata', () => {
      const stringRoute = 'foo';
      const routeInfo = {
        path: 'bar',
        method: RequestMethod.GET,
      };
      expect(mapToExcludeRoute([stringRoute, routeInfo])).to.eql([
        {
          path: stringRoute,
          requestMethod: RequestMethod.ALL,
          pathRegex: pathToRegexp(addLeadingSlash(stringRoute)).regexp,
        },
        {
          path: routeInfo.path,
          requestMethod: routeInfo.method,
          pathRegex: pathToRegexp(addLeadingSlash(routeInfo.path)).regexp,
        },
      ]);
    });
  });
  describe('filterMiddleware', () => {
    let middleware: any[];
    beforeEach(() => {
      middleware = [Test, fnMiddleware, undefined, null];
    });
    it('should return filtered middleware', () => {
      expect(filterMiddleware(middleware, [], noopAdapter)).to.have.length(2);
    });
  });
  describe('mapToClass', () => {
    describe('when middleware is a class', () => {
      describe('when there is no excluded routes', () => {
        it('should return an identity', () => {
          const type = mapToClass(Test, [], noopAdapter);
          expect(type).to.eql(Test);
        });
      });
      describe('when there are excluded routes', () => {
        it('should return a host class', () => {
          const type = mapToClass(
            Test,
            mapToExcludeRoute([{ path: '*', method: RequestMethod.ALL }]),
            noopAdapter,
          );
          expect(type).to.not.eql(Test);
          expect(type.name).to.eql(Test.name);
        });
      });
    });
    describe('when middleware is a function', () => {
      it('should return a metatype', () => {
        const metatype = mapToClass(fnMiddleware, [], noopAdapter);
        expect(metatype).to.not.eql(fnMiddleware);
      });
      it('should define a `use` method', () => {
        const metatype = mapToClass(fnMiddleware, [], noopAdapter);
        expect(new metatype().use).to.exist;
      });
      it('should encapsulate a function', () => {
        const spy = sinon.spy();
        const metatype = mapToClass(spy, [], noopAdapter);
        new metatype().use();
        expect(spy.called).to.be.true;
      });
    });
  });
  describe('isMiddlewareClass', () => {
    describe('when middleware is a class', () => {
      it('should returns true', () => {
        expect(isMiddlewareClass(Test)).to.be.true;
      });
    });
    describe('when middleware is a function', () => {
      it('should returns false', () => {
        expect(isMiddlewareClass(fnMiddleware)).to.be.false;
      });
    });
  });
  describe('assignToken', () => {
    describe('should define `name` property on metatype', () => {
      const AnonymousType = class {};
      assignToken(AnonymousType);
      expect(AnonymousType.name).to.exist;
    });
    describe('should use passed token as `name`', () => {
      const AnonymousType = class {};
      const token = 'token';

      assignToken(AnonymousType, token);
      expect(AnonymousType.name).to.eq(token);
    });
  });

  describe('isRouteExcluded', () => {
    let adapter: NoopHttpAdapter;

    beforeEach(() => {
      adapter = new NoopHttpAdapter({});
      sinon.stub(adapter, 'getRequestMethod').callsFake(() => 'GET');
      sinon.stub(adapter, 'getRequestUrl').callsFake(() => '/cats/3');
    });
    describe('when route is excluded (new syntax *path)', () => {
      const path = '/cats/*path';
      const excludedRoutes = mapToExcludeRoute([
        {
          path,
          method: RequestMethod.GET,
        },
      ]);
      it('should return true', () => {
        expect(isMiddlewareRouteExcluded({}, excludedRoutes, adapter)).to.be
          .true;
      });
    });
    describe('when route is excluded (legacy syntax (.*))', () => {
      const path = '/cats/(.*)';
      const excludedRoutes = mapToExcludeRoute([
        {
          path,
          method: RequestMethod.GET,
        },
      ]);
      it('should return true', () => {
        expect(isMiddlewareRouteExcluded({}, excludedRoutes, adapter)).to.be
          .true;
      });
    });
    describe('when route is not excluded', () => {
      it('should return false', () => {
        expect(isMiddlewareRouteExcluded({}, [], adapter)).to.be.false;
      });
    });
  });
});



================================================
FILE: packages/core/test/pipes/params-token-factory.spec.ts
================================================
import { expect } from 'chai';
import { RouteParamtypes } from '../../../common/enums/route-paramtypes.enum';
import { ParamsTokenFactory } from '../../pipes/params-token-factory';

describe('ParamsTokenFactory', () => {
  let factory: ParamsTokenFactory;
  beforeEach(() => {
    factory = new ParamsTokenFactory();
  });
  describe('exchangeEnumForString', () => {
    describe('when key is', () => {
      describe(`RouteParamtypes.BODY`, () => {
        it('should return body object', () => {
          expect(factory.exchangeEnumForString(RouteParamtypes.BODY)).to.be.eql(
            'body',
          );
        });
      });
      describe(`RouteParamtypes.QUERY`, () => {
        it('should return query object', () => {
          expect(
            factory.exchangeEnumForString(RouteParamtypes.QUERY),
          ).to.be.eql('query');
        });
      });
      describe(`RouteParamtypes.PARAM`, () => {
        it('should return params object', () => {
          expect(
            factory.exchangeEnumForString(RouteParamtypes.PARAM),
          ).to.be.eql('param');
        });
      });
      describe('not available', () => {
        it('should return "custom"', () => {
          expect(factory.exchangeEnumForString(-1 as any)).to.be.eql('custom');
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/pipes/pipes-consumer.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { RouteParamtypes } from '../../../common/enums/route-paramtypes.enum';
import { PipesConsumer } from '../../pipes/pipes-consumer';

const createPipe = (transform: Function) => ({ transform });

describe('PipesConsumer', () => {
  let consumer: PipesConsumer;
  beforeEach(() => {
    consumer = new PipesConsumer();
  });
  describe('apply', () => {
    let value, metatype, type, stringifiedType, transforms, data;
    beforeEach(() => {
      value = 0;
      data = null;
      (metatype = {}), (type = RouteParamtypes.QUERY);
      stringifiedType = 'query';
      transforms = [
        createPipe(sinon.stub().callsFake(val => val + 1)),
        createPipe(sinon.stub().callsFake(val => Promise.resolve(val + 1))),
        createPipe(sinon.stub().callsFake(val => val + 1)),
      ];
    });
    it('should call all transform functions', done => {
      /* eslint-disable-next-line @typescript-eslint/no-floating-promises */
      consumer.apply(value, { metatype, type, data }, transforms).then(() => {
        expect(
          transforms.reduce(
            (prev, next) => prev && next.transform.called,
            true,
          ),
        ).to.be.true;

        done();
      });
    });
    it('should return expected result', done => {
      const expectedResult = 3;
      /* eslint-disable-next-line @typescript-eslint/no-floating-promises */
      consumer
        .apply(value, { metatype, type, data }, transforms)
        .then(result => {
          expect(result).to.be.eql(expectedResult);
          done();
        });
    });
  });
});



================================================
FILE: packages/core/test/pipes/pipes-context-creator.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ApplicationConfig } from '../../application-config';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { PipesContextCreator } from '../../pipes/pipes-context-creator';

class Pipe {}

describe('PipesContextCreator', () => {
  let creator: PipesContextCreator;
  let container: NestContainer;
  let applicationConfig: ApplicationConfig;

  beforeEach(() => {
    container = new NestContainer();
    applicationConfig = new ApplicationConfig();
    creator = new PipesContextCreator(container, applicationConfig);
  });
  describe('createConcreteContext', () => {
    describe('when metadata is empty or undefined', () => {
      it('should return empty array', () => {
        expect(creator.createConcreteContext(undefined!)).to.be.deep.equal([]);
        expect(creator.createConcreteContext([])).to.be.deep.equal([]);
      });
    });
    describe('when metadata is not empty or undefined', () => {
      const metadata = [null, {}, { transform: () => ({}) }];
      it('should return expected array', () => {
        const transforms = creator.createConcreteContext(metadata as any);
        expect(transforms).to.have.length(1);
      });
    });
  });
  describe('getPipeInstance', () => {
    describe('when param is an object', () => {
      it('should return instance', () => {
        const instance = { transform: () => null };
        expect(creator.getPipeInstance(instance)).to.be.eql(instance);
      });
    });
    describe('when param is a constructor', () => {
      it('should pick instance from container', () => {
        const wrapper: InstanceWrapper = {
          instance: 'test',
          getInstanceByContextId: () => wrapper,
        } as any;
        sinon.stub(creator, 'getInstanceByMetatype').callsFake(() => wrapper);
        expect(creator.getPipeInstance(Pipe)).to.be.eql(wrapper.instance);
      });
      it('should return null', () => {
        sinon.stub(creator, 'getInstanceByMetatype').callsFake(() => null!);
        expect(creator.getPipeInstance(Pipe)).to.be.eql(null);
      });
    });
  });

  describe('getInstanceByMetatype', () => {
    describe('when "moduleContext" is nil', () => {
      it('should return undefined', () => {
        (creator as any).moduleContext = undefined;
        expect(creator.getInstanceByMetatype(null!)).to.be.undefined;
      });
    });
    describe('when "moduleContext" is not nil', () => {
      beforeEach(() => {
        (creator as any).moduleContext = 'test';
      });

      describe('and when module exists', () => {
        it('should return undefined', () => {
          sinon.stub(container.getModules(), 'get').callsFake(() => undefined);
          expect(creator.getInstanceByMetatype(null!)).to.be.undefined;
        });
      });

      describe('and when module does not exist', () => {
        it('should return instance', () => {
          const instance = { test: true };
          const module = { injectables: { get: () => instance } };
          sinon
            .stub(container.getModules(), 'get')
            .callsFake(() => module as any);
          expect(creator.getInstanceByMetatype(class Test {})).to.be.eql(
            instance,
          );
        });
      });
    });
  });

  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global pipes', () => {
        const expectedResult = applicationConfig.getGlobalPipes();
        expect(creator.getGlobalMetadata()).to.be.equal(expectedResult);
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped pipes', () => {
        const globalPipes: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedPipeWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalPipes')
          .callsFake(() => globalPipes);
        sinon
          .stub(applicationConfig, 'getGlobalRequestPipes')
          .callsFake(() => scopedPipeWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(creator.getGlobalMetadata({ id: 3 })).to.contains(
          instance,
          ...globalPipes,
        );
      });
    });
  });
});



================================================
FILE: packages/core/test/repl/assign-to-object.util.spec.ts
================================================
import { expect } from 'chai';
import { assignToObject } from '../../repl/assign-to-object.util';

describe('assignToObject', () => {
  it('should copy all enumerable properties and their descriptors', () => {
    const sourceObj = {};
    Object.defineProperty(sourceObj, 'foo', {
      value: 123,
      configurable: true,
      enumerable: true,
      writable: true,
    });
    Object.defineProperty(sourceObj, 'bar', {
      value: 456,
      configurable: true,
      enumerable: true,
      writable: false,
    });
    const targetObj = {};

    assignToObject(targetObj, sourceObj);

    expect(Object.getOwnPropertyDescriptor(targetObj, 'foo')).to.be.eql({
      value: 123,
      configurable: true,
      enumerable: true,
      writable: true,
    });
    expect(Object.getOwnPropertyDescriptor(targetObj, 'bar')).to.be.eql({
      value: 456,
      configurable: true,
      enumerable: true,
      writable: false,
    });
  });
});



================================================
FILE: packages/core/test/repl/repl-context.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NestContainer } from '../../injector/container';
import { ReplContext } from '../../repl/repl-context';

describe('ReplContext', () => {
  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  afterEach(() => sinon.restore());

  it('writeToStdout', () => {
    const stdOutWrite = sinon.stub(process.stdout, 'write');
    const text = sinon.stub() as unknown as string;

    replContext.writeToStdout(text);

    expect(stdOutWrite.calledOnce).to.be.true;
    expect(stdOutWrite.calledWith(text)).to.be.true;
  });
});



================================================
FILE: packages/core/test/repl/native-functions/debug-repl-fn.spec.ts
================================================
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NestContainer } from '../../../injector/container';
import { DebugReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';

describe('DebugReplFn', () => {
  let debugReplFn: DebugReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();
    const { moduleRef: aModuleRef } = (await container.addModule(
      class ModuleA {},
      [],
    ))!;
    const { moduleRef: bModuleRef } = (await container.addModule(
      class ModuleB {},
      [],
    ))!;

    container.addController(class ControllerA {}, aModuleRef.token);
    container.addProvider(class ProviderA1 {}, aModuleRef.token);
    container.addProvider(class ProviderA2 {}, aModuleRef.token);
    container.addProvider(class SharedProvider {}, aModuleRef.token);
    container.addProvider(
      { provide: 'StringToken', useValue: 123 },
      aModuleRef.token,
    );

    container.addProvider(class ProviderB1 {}, bModuleRef.token);
    container.addProvider(class ProviderB2 {}, bModuleRef.token);
    container.addProvider(class SharedProvider {}, bModuleRef.token);

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    debugReplFn = replContext.nativeFunctions.get('debug') as DebugReplFn;

    // To avoid coloring the output:
    sinon.stub(clc, 'yellow').callsFake(text => text);
    sinon.stub(clc, 'green').callsFake(text => text);
  });
  afterEach(() => sinon.restore());

  it('the function name should be "debug"', () => {
    expect(debugReplFn).to.not.be.undefined;
    expect(debugReplFn.fnDefinition.name).to.eql('debug');
  });

  describe('action', () => {
    it('should print all modules along with their controllers and providers', () => {
      let outputText = '';

      sinon
        .stub(replContext, 'writeToStdout')
        .callsFake(text => (outputText += text));

      debugReplFn.action();

      expect(outputText).to.equal(`
ModuleA:
 - controllers:
  ◻ ControllerA
 - providers:
  ◻ ProviderA1
  ◻ ProviderA2
  ◻ SharedProvider
  ◻ "StringToken"
ModuleB:
 - providers:
  ◻ ProviderB1
  ◻ ProviderB2
  ◻ SharedProvider

`);
    });

    describe('when module passed as a class reference', () => {
      it("should print a specified module's controllers and providers", () => {
        let outputText = '';

        sinon
          .stub(replContext, 'writeToStdout')
          .callsFake(text => (outputText += text));

        debugReplFn.action(class ModuleA {});

        expect(outputText).to.equal(`
ModuleA:
 - controllers:
  ◻ ControllerA
 - providers:
  ◻ ProviderA1
  ◻ ProviderA2
  ◻ SharedProvider
  ◻ "StringToken"

`);
      });
    });
    describe("when module passed as a string (module's key)", () => {
      it("should print a specified module's controllers and providers", () => {
        let outputText = '';

        sinon
          .stub(replContext, 'writeToStdout')
          .callsFake(text => (outputText += text));

        debugReplFn.action('ModuleA');

        expect(outputText).to.equal(`
ModuleA:
 - controllers:
  ◻ ControllerA
 - providers:
  ◻ ProviderA1
  ◻ ProviderA2
  ◻ SharedProvider
  ◻ "StringToken"

`);
      });
    });
  });
});



================================================
FILE: packages/core/test/repl/native-functions/get-repl-fn.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { GetReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';
import { NestContainer } from '../../../injector/container';

describe('GetReplFn', () => {
  let getReplFn: GetReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    getReplFn = replContext.nativeFunctions.get('get') as GetReplFn;
  });
  afterEach(() => sinon.restore());

  it('the function name should be "get"', () => {
    expect(getReplFn).to.not.be.undefined;
    expect(getReplFn.fnDefinition.name).to.eql('get');
  });

  describe('action', () => {
    it('should pass arguments down to the application context', () => {
      const token = 'test';
      getReplFn.action(token);
      expect(mockApp.get.calledWith(token)).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/repl/native-functions/help-repl-fn.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { HelpReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';
import { NestContainer } from '../../../injector/container';

describe('HelpReplFn', () => {
  let helpReplFn: HelpReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    helpReplFn = replContext.nativeFunctions.get('help') as HelpReplFn;

    // To avoid coloring the output:
    sinon.stub(clc, 'bold').callsFake(text => text);
    sinon.stub(clc, 'cyanBright').callsFake(text => text);
  });
  afterEach(() => sinon.restore());

  it('the function name should be "help"', () => {
    expect(helpReplFn).to.not.be.undefined;
    expect(helpReplFn.fnDefinition.name).to.eql('help');
  });

  describe('action', () => {
    it('should print all available native functions and their description', () => {
      let outputText = '';
      sinon
        .stub(replContext, 'writeToStdout')
        .callsFake(text => (outputText += text));

      helpReplFn.action();

      expect(outputText).to
        .equal(`You can call .help on any function listed below (e.g.: help.help):

$ - Retrieves an instance of either injectable or controller, otherwise, throws exception.
debug - Print all registered modules as a list together with their controllers and providers.
If the argument is passed in, for example, "debug(MyModule)" then it will only print components of this specific module.
get - Retrieves an instance of either injectable or controller, otherwise, throws exception.
help - Display all available REPL native functions.
methods - Display all public methods available on a given provider or controller.
resolve - Resolves transient or request-scoped instance of either injectable or controller, otherwise, throws exception.
select - Allows navigating through the modules tree, for example, to pull out a specific instance from the selected module.
`);
    });
  });
});



================================================
FILE: packages/core/test/repl/native-functions/methods-repl-fn.spec.ts
================================================
import { clc } from '@nestjs/common/utils/cli-colors.util';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NestContainer } from '../../../injector/container';
import { MethodsReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';

describe('MethodsReplFn', () => {
  let methodsReplFn: MethodsReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();
    const { moduleRef: aModuleRef } = (await container.addModule(
      class ModuleA {},
      [],
    ))!;
    const { moduleRef: bModuleRef } = (await container.addModule(
      class ModuleB {},
      [],
    ))!;

    container.addController(class ControllerA {}, aModuleRef.token);
    container.addProvider(class ProviderA1 {}, aModuleRef.token);
    container.addProvider(class ProviderA2 {}, aModuleRef.token);

    container.addProvider(class ProviderB1 {}, bModuleRef.token);
    container.addProvider(class ProviderB2 {}, bModuleRef.token);

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    methodsReplFn = replContext.nativeFunctions.get('methods') as MethodsReplFn;

    // To avoid coloring the output:
    sinon.stub(clc, 'yellow').callsFake(text => text);
    sinon.stub(clc, 'green').callsFake(text => text);
  });
  afterEach(() => sinon.restore());

  it('the function name should be "methods"', () => {
    expect(methodsReplFn).to.not.be.undefined;
    expect(methodsReplFn.fnDefinition.name).to.eql('methods');
  });

  describe('action', () => {
    describe('when token is a class reference', () => {
      it('should print all class methods', () => {
        class BaseService {
          create() {}
        }
        class TestService extends BaseService {
          findAll() {}
          findOne() {}
        }

        let outputText = '';

        sinon
          .stub(replContext, 'writeToStdout')
          .callsFake(text => (outputText += text));

        methodsReplFn.action(TestService);

        expect(outputText).to.equal(`
Methods:
 ◻ findAll
 ◻ findOne
 ◻ create

`);
      });
    });

    describe('when token is a string', () => {
      it('should grab provider from the container and print its all methods', () => {
        class ProviderA1 {
          findAll() {}
          findOne() {}
        }
        let outputText = '';

        sinon
          .stub(replContext, 'writeToStdout')
          .callsFake(text => (outputText += text));

        mockApp.get.callsFake(() => new ProviderA1());

        methodsReplFn.action('ProviderA1');

        expect(outputText).to.equal(`
Methods:
 ◻ findAll
 ◻ findOne

`);
      });
    });
  });
});



================================================
FILE: packages/core/test/repl/native-functions/resolve-repl-fn.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ResolveReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';
import { NestContainer } from '../../../injector/container';

describe('ResolveReplFn', () => {
  let resolveReplFn: ResolveReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    resolveReplFn = replContext.nativeFunctions.get('resolve') as ResolveReplFn;
  });
  afterEach(() => sinon.restore());

  it('the function name should be "resolve"', () => {
    expect(resolveReplFn).to.not.be.undefined;
    expect(resolveReplFn.fnDefinition.name).to.eql('resolve');
  });

  describe('action', () => {
    it('should pass arguments down to the application context', async () => {
      const token = 'test';
      const contextId = {};

      await resolveReplFn.action(token, contextId);
      expect(mockApp.resolve.calledWith(token, contextId)).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/repl/native-functions/select-repl-fn.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { SelectReplFn } from '../../../repl/native-functions';
import { ReplContext } from '../../../repl/repl-context';
import { NestContainer } from '../../../injector/container';

describe('SelectReplFn', () => {
  let selectReplFn: SelectReplFn;

  let replContext: ReplContext;
  let mockApp: {
    container: NestContainer;
    get: sinon.SinonStub;
    resolve: sinon.SinonSpy;
    select: sinon.SinonSpy;
  };

  before(async () => {
    const container = new NestContainer();

    mockApp = {
      container,
      get: sinon.stub(),
      resolve: sinon.spy(),
      select: sinon.spy(),
    };
    replContext = new ReplContext(mockApp as any);
  });

  beforeEach(() => {
    selectReplFn = replContext.nativeFunctions.get('select') as SelectReplFn;
  });
  afterEach(() => sinon.restore());

  it('the function name should be "select"', () => {
    expect(selectReplFn).to.not.be.undefined;
    expect(selectReplFn.fnDefinition.name).to.eql('select');
  });

  describe('action', () => {
    it('should pass arguments down to the application context', () => {
      const moduleCls = class TestModule {};
      selectReplFn.action(moduleCls);
      expect(mockApp.select.calledWith(moduleCls)).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/router/paths-explorer.spec.ts
================================================
import { expect } from 'chai';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import {
  All,
  Get,
  Post,
} from '../../../common/decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { MetadataScanner } from '../../metadata-scanner';
import { PathsExplorer } from '../../router/paths-explorer';

describe('PathsExplorer', () => {
  @Controller('global')
  class TestRoute {
    @Get('test')
    public getTest() {}

    @Post('test')
    public postTest() {}

    @All('another-test')
    public anotherTest() {}

    @Get(['foo', 'bar'])
    public getTestUsingArray() {}
  }

  @Controller(['global', 'global-alias'])
  class TestRouteAlias {
    @Get('test')
    public getTest() {}

    @Post('test')
    public postTest() {}

    @All('another-test')
    public anotherTest() {}

    @Get(['foo', 'bar'])
    public getTestUsingArray() {}
  }

  let pathsExplorer: PathsExplorer;

  beforeEach(() => {
    pathsExplorer = new PathsExplorer(new MetadataScanner());
  });

  describe('scanForPaths', () => {
    it('should method return expected list of route paths', () => {
      const paths = pathsExplorer.scanForPaths(new TestRoute());

      expect(paths).to.have.length(4);

      expect(paths[0].path).to.eql(['/test']);
      expect(paths[1].path).to.eql(['/test']);
      expect(paths[2].path).to.eql(['/another-test']);
      expect(paths[3].path).to.eql(['/foo', '/bar']);

      expect(paths[0].requestMethod).to.eql(RequestMethod.GET);
      expect(paths[1].requestMethod).to.eql(RequestMethod.POST);
      expect(paths[2].requestMethod).to.eql(RequestMethod.ALL);
      expect(paths[3].requestMethod).to.eql(RequestMethod.GET);
    });

    it('should method return expected list of route paths alias', () => {
      const paths = pathsExplorer.scanForPaths(new TestRouteAlias());

      expect(paths).to.have.length(4);

      expect(paths[0].path).to.eql(['/test']);
      expect(paths[1].path).to.eql(['/test']);
      expect(paths[2].path).to.eql(['/another-test']);
      expect(paths[3].path).to.eql(['/foo', '/bar']);

      expect(paths[0].requestMethod).to.eql(RequestMethod.GET);
      expect(paths[1].requestMethod).to.eql(RequestMethod.POST);
      expect(paths[2].requestMethod).to.eql(RequestMethod.ALL);
      expect(paths[3].requestMethod).to.eql(RequestMethod.GET);
    });
  });

  describe('exploreMethodMetadata', () => {
    it('should method return expected object which represent single route', () => {
      const instance = new TestRoute();
      const instanceProto = Object.getPrototypeOf(instance);

      const route = pathsExplorer.exploreMethodMetadata(
        instance,
        instanceProto,
        'getTest',
      )!;

      expect(route.path).to.eql(['/test']);
      expect(route.requestMethod).to.eql(RequestMethod.GET);
      expect(route.targetCallback).to.eq(instance.getTest);
    });

    it('should method return expected object which represent single route with alias', () => {
      const instance = new TestRouteAlias();
      const instanceProto = Object.getPrototypeOf(instance);

      const route = pathsExplorer.exploreMethodMetadata(
        instance,
        instanceProto,
        'getTest',
      )!;

      expect(route.path).to.eql(['/test']);
      expect(route.requestMethod).to.eql(RequestMethod.GET);
      expect(route.targetCallback).to.eq(instance.getTest);
    });

    it('should method return expected object which represent multiple routes', () => {
      const instance = new TestRoute();
      const instanceProto = Object.getPrototypeOf(instance);

      const route = pathsExplorer.exploreMethodMetadata(
        instance,
        instanceProto,
        'getTestUsingArray',
      )!;

      expect(route.path).to.eql(['/foo', '/bar']);
      expect(route.requestMethod).to.eql(RequestMethod.GET);
      expect(route.targetCallback).to.eq(instance.getTestUsingArray);
    });

    it('should method return expected object which represent multiple routes with alias', () => {
      const instance = new TestRouteAlias();
      const instanceProto = Object.getPrototypeOf(instance);

      const route = pathsExplorer.exploreMethodMetadata(
        instance,
        instanceProto,
        'getTestUsingArray',
      )!;

      expect(route.path).to.eql(['/foo', '/bar']);
      expect(route.requestMethod).to.eql(RequestMethod.GET);
      expect(route.targetCallback).to.eq(instance.getTestUsingArray);
    });

    describe('when new implementation is injected into router', () => {
      it('should method return changed impl of single route', () => {
        const instance = new TestRoute();
        const instanceProto = Object.getPrototypeOf(instance);

        const newImpl = function () {};
        instance.getTest = newImpl;

        const route = pathsExplorer.exploreMethodMetadata(
          instance,
          instanceProto,
          'getTest',
        )!;

        expect(route.targetCallback).to.eq(newImpl);
        expect(route.path).to.eql(['/test']);
        expect(route.requestMethod).to.eql(RequestMethod.GET);
      });

      it('should method return changed impl of single route which alias applied', () => {
        const instance = new TestRouteAlias();
        const instanceProto = Object.getPrototypeOf(instance);

        const newImpl = function () {};
        instance.getTest = newImpl;

        const route = pathsExplorer.exploreMethodMetadata(
          instance,
          instanceProto,
          'getTest',
        )!;

        expect(route.targetCallback).to.eq(newImpl);
        expect(route.path).to.eql(['/test']);
        expect(route.requestMethod).to.eql(RequestMethod.GET);
      });

      it('should method return changed impl of multiple routes', () => {
        const instance = new TestRoute();
        const instanceProto = Object.getPrototypeOf(instance);

        const newImpl = function () {};
        instance.getTestUsingArray = newImpl;

        const route = pathsExplorer.exploreMethodMetadata(
          instance,
          instanceProto,
          'getTestUsingArray',
        )!;

        expect(route.targetCallback).to.eq(newImpl);
        expect(route.path).to.eql(['/foo', '/bar']);
        expect(route.requestMethod).to.eql(RequestMethod.GET);
      });

      it('should method return changed impl of multiple routes which alias applied', () => {
        const instance = new TestRouteAlias();
        const instanceProto = Object.getPrototypeOf(instance);

        const newImpl = function () {};
        instance.getTestUsingArray = newImpl;

        const route = pathsExplorer.exploreMethodMetadata(
          instance,
          instanceProto,
          'getTestUsingArray',
        )!;

        expect(route.targetCallback).to.eq(newImpl);
        expect(route.path).to.eql(['/foo', '/bar']);
        expect(route.requestMethod).to.eql(RequestMethod.GET);
      });
    });
  });
});



================================================
FILE: packages/core/test/router/route-params-factory.spec.ts
================================================
import { expect } from 'chai';
import { RouteParamtypes } from '../../../common/enums/route-paramtypes.enum';
import { RouteParamsFactory } from '../../router/route-params-factory';

describe('RouteParamsFactory', () => {
  let factory: RouteParamsFactory;
  let untypedFactory: any;

  beforeEach(() => {
    factory = new RouteParamsFactory();
    untypedFactory = factory as any;
  });

  describe('exchangeKeyForValue', () => {
    const res = {};
    const next = () => ({});
    const req = {
      ip: 'ip',
      session: null,
      rawBody: Buffer.from('{"foo":"bar"}'),
      body: {
        foo: 'bar',
      },
      headers: {
        foo: 'bar',
      },
      params: {
        foo: 'bar',
      },
      hosts: {
        foo: 'bar',
      },
      query: {
        foo: 'bar',
      },
      file: 'file',
      files: 'files',
    };
    describe('when key is', () => {
      const args = [null, { res, req, next }];
      describe(`RouteParamtypes.NEXT`, () => {
        it('should return next object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.NEXT, ...args),
          ).to.be.eql(next);
        });
      });
      describe(`RouteParamtypes.RESPONSE`, () => {
        it('should return response object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(
              RouteParamtypes.RESPONSE,
              ...args,
            ),
          ).to.be.eql(res);
        });
      });
      describe(`RouteParamtypes.REQUEST`, () => {
        it('should return request object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(
              RouteParamtypes.REQUEST,
              ...args,
            ),
          ).to.be.eql(req);
        });
      });
      describe(`RouteParamtypes.BODY`, () => {
        it('should return body object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.BODY, ...args),
          ).to.be.eql(req.body);
        });
      });
      describe(`RouteParamtypes.RAW_BODY`, () => {
        it('should return rawBody buffer', () => {
          expect(
            untypedFactory.exchangeKeyForValue(
              RouteParamtypes.RAW_BODY,
              ...args,
            ),
          ).to.be.eql(req.rawBody);
        });
      });
      describe(`RouteParamtypes.HEADERS`, () => {
        it('should return headers object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(
              RouteParamtypes.HEADERS,
              ...args,
            ),
          ).to.be.eql(req.headers);
        });
      });
      describe(`RouteParamtypes.IP`, () => {
        it('should return ip property', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.IP, ...args),
          ).to.be.equal(req.ip);
        });
      });
      describe(`RouteParamtypes.SESSION`, () => {
        it('should return session object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(
              RouteParamtypes.SESSION,
              ...args,
            ),
          ).to.be.eql(req.session);
        });
      });
      describe(`RouteParamtypes.QUERY`, () => {
        it('should return query object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.QUERY, ...args),
          ).to.be.eql(req.query);
        });
      });
      describe(`RouteParamtypes.PARAM`, () => {
        it('should return params object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.PARAM, ...args),
          ).to.be.eql(req.params);
        });
      });
      describe(`RouteParamtypes.HOST`, () => {
        it('should return hosts object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.HOST, ...args),
          ).to.be.eql(req.hosts);
        });
      });
      describe(`RouteParamtypes.FILE`, () => {
        it('should return file object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.FILE, ...args),
          ).to.be.eql(req.file);
        });
      });
      describe(`RouteParamtypes.FILES`, () => {
        it('should return files object', () => {
          expect(
            untypedFactory.exchangeKeyForValue(RouteParamtypes.FILES, ...args),
          ).to.be.eql(req.files);
        });
      });
      describe('not available', () => {
        it('should return null', () => {
          expect(untypedFactory.exchangeKeyForValue(-1, ...args)).to.be.eql(
            null,
          );
        });
      });
    });
  });
});



================================================
FILE: packages/core/test/router/route-path-factory.spec.ts
================================================
import { RequestMethod, VERSION_NEUTRAL, VersioningType } from '@nestjs/common';
import { expect } from 'chai';
import { pathToRegexp } from 'path-to-regexp';
import * as sinon from 'sinon';
import { ApplicationConfig } from '../../application-config';
import { RoutePathFactory } from '../../router/route-path-factory';

describe('RoutePathFactory', () => {
  let routePathFactory: RoutePathFactory;
  let applicationConfig: ApplicationConfig;

  beforeEach(() => {
    applicationConfig = new ApplicationConfig();
    routePathFactory = new RoutePathFactory(applicationConfig);
  });

  describe('create', () => {
    it('should return valid, concatenated paths (various combinations)', () => {
      expect(
        routePathFactory.create({
          ctrlPath: 'ctrlPath/',
          methodPath: '',
        }),
      ).to.deep.equal(['/ctrlPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath',
          methodPath: '',
        }),
      ).to.deep.equal(['/ctrlPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath',
        }),
      ).to.deep.equal(['/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: 'ctrlPath/',
          methodPath: 'methodPath/',
        }),
      ).to.deep.equal(['/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: 'ctrlPath/',
          methodPath: 'methodPath',
          modulePath: 'modulePath',
        }),
      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: 'ctrlPath/',
          methodPath: 'methodPath',
          modulePath: '/modulePath',
        }),
      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
        }),
      ).to.deep.equal(['/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
          globalPrefix: 'api',
        }),
      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
          globalPrefix: '/api',
        }),
      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
          globalPrefix: '/api',
          versioningOptions: {
            type: VersioningType.HEADER,
            header: 'x',
          },
          methodVersion: '1.0.0',
          controllerVersion: '1.1.1',
        }),
      ).to.deep.equal(['/api/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
          globalPrefix: '/api/',
          versioningOptions: {
            type: VersioningType.URI,
          },
          methodVersion: '1.0.0',
          controllerVersion: '1.1.1',
        }),
      ).to.deep.equal(['/api/v1.0.0/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          modulePath: '/modulePath/',
          versioningOptions: {
            type: VersioningType.URI,
          },
          methodVersion: '1.0.0',
          controllerVersion: '1.1.1',
        }),
      ).to.deep.equal(['/v1.0.0/modulePath/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          globalPrefix: '/api',
          versioningOptions: {
            type: VersioningType.URI,
          },
          methodVersion: '1.0.0',
          controllerVersion: '1.1.1',
        }),
      ).to.deep.equal(['/api/v1.0.0/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          globalPrefix: '/api',
          versioningOptions: {
            type: VersioningType.URI,
          },
          controllerVersion: '1.1.1',
        }),
      ).to.deep.equal(['/api/v1.1.1/ctrlPath/methodPath']);

      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/methodPath/',
          globalPrefix: '/api',
          versioningOptions: {
            type: VersioningType.URI,
          },
          controllerVersion: ['1.1.1', '1.2.3'],
        }),
      ).to.deep.equal([
        '/api/v1.1.1/ctrlPath/methodPath',
        '/api/v1.2.3/ctrlPath/methodPath',
      ]);

      expect(
        routePathFactory.create({
          ctrlPath: '',
          methodPath: '',
          globalPrefix: '/api',
          versioningOptions: {
            type: VersioningType.URI,
          },
          controllerVersion: ['1.1.1', '1.2.3'],
        }),
      ).to.deep.equal(['/api/v1.1.1', '/api/v1.2.3']);

      expect(
        routePathFactory.create({
          ctrlPath: '',
          methodPath: '',
          globalPrefix: '',
          controllerVersion: VERSION_NEUTRAL,
          versioningOptions: {
            type: VersioningType.URI,
            defaultVersion: VERSION_NEUTRAL,
          },
        }),
      ).to.deep.equal(['/']);

      expect(
        routePathFactory.create({
          ctrlPath: '',
          methodPath: '',
          globalPrefix: '',
          controllerVersion: ['1', VERSION_NEUTRAL],
          versioningOptions: {
            type: VersioningType.URI,
            defaultVersion: ['1', VERSION_NEUTRAL],
          },
        }),
      ).to.deep.equal(['/v1', '/']);

      expect(
        routePathFactory.create({
          ctrlPath: '',
          methodPath: '',
          globalPrefix: '',
        }),
      ).to.deep.equal(['/']);

      sinon.stub(routePathFactory, 'isExcludedFromGlobalPrefix').returns(true);
      expect(
        routePathFactory.create({
          ctrlPath: '/ctrlPath/',
          methodPath: '/',
          modulePath: '/',
          globalPrefix: '/api',
        }),
      ).to.deep.equal(['/ctrlPath']);
      sinon.restore();
    });
  });

  describe('isExcludedFromGlobalPrefix', () => {
    describe('when there is no exclude configuration', () => {
      it('should return false', () => {
        sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({
          exclude: undefined,
        });
        expect(
          routePathFactory.isExcludedFromGlobalPrefix(
            '/cats',
            RequestMethod.GET,
          ),
        ).to.be.false;
      });
    });
    describe('otherwise', () => {
      describe('when route is not excluded', () => {
        it('should return false', () => {
          sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({
            exclude: [
              {
                path: '/random',
                pathRegex: pathToRegexp('/random').regexp,
                requestMethod: RequestMethod.ALL,
              },
            ],
          });
          expect(
            routePathFactory.isExcludedFromGlobalPrefix(
              '/cats',
              RequestMethod.GET,
            ),
          ).to.be.false;
        });
      });
      describe('when route is excluded (by path)', () => {
        it('should return true', () => {
          sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({
            exclude: [
              {
                path: '/cats',
                pathRegex: pathToRegexp('/cats').regexp,
                requestMethod: RequestMethod.ALL,
              },
            ],
          });
          expect(
            routePathFactory.isExcludedFromGlobalPrefix(
              '/cats',
              RequestMethod.GET,
            ),
          ).to.be.true;
        });

        describe('when route is excluded (by method and path)', () => {
          it('should return true', () => {
            sinon.stub(applicationConfig, 'getGlobalPrefixOptions').returns({
              exclude: [
                {
                  path: '/cats',
                  pathRegex: pathToRegexp('/cats').regexp,
                  requestMethod: RequestMethod.GET,
                },
              ],
            });
            expect(
              routePathFactory.isExcludedFromGlobalPrefix(
                '/cats',
                RequestMethod.GET,
              ),
            ).to.be.true;
            expect(
              routePathFactory.isExcludedFromGlobalPrefix(
                '/cats',
                RequestMethod.POST,
              ),
            ).to.be.false;
          });
        });
      });
    });
  });

  describe('getVersionPrefix', () => {
    describe('when URI versioning is enabled', () => {
      describe('and prefix is disabled', () => {
        it('should return empty string', () => {
          expect(
            routePathFactory.getVersionPrefix({
              type: VersioningType.URI,
              prefix: false,
            }),
          ).to.equal('');
        });
      });
      describe('and prefix is undefined', () => {
        it('should return the default prefix', () => {
          expect(
            routePathFactory.getVersionPrefix({
              type: VersioningType.URI,
            }),
          ).to.equal('v');
        });
      });
      describe('and prefix is specified', () => {
        it('should return it', () => {
          expect(
            routePathFactory.getVersionPrefix({
              type: VersioningType.URI,
              prefix: 'test',
            }),
          ).to.equal('test');
        });
      });
    });
    describe('when URI versioning is disabled', () => {
      it('should return default prefix', () => {
        expect(
          routePathFactory.getVersionPrefix({
            type: VersioningType.HEADER,
            header: 'X',
          }),
        ).to.equal('v');
      });
    });
  });
});



================================================
FILE: packages/core/test/router/router-exception-filters.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Catch } from '../../../common/decorators/core/catch.decorator';
import { UseFilters } from '../../../common/decorators/core/exception-filters.decorator';
import { ApplicationConfig } from '../../application-config';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { RouterExceptionFilters } from '../../router/router-exception-filters';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RouterExceptionFilters', () => {
  let applicationConfig: ApplicationConfig;
  let exceptionFilter: RouterExceptionFilters;

  class CustomException {}
  @Catch(CustomException)
  class ExceptionFilter {
    public catch(exc, res) {}
  }

  beforeEach(() => {
    applicationConfig = new ApplicationConfig();
    exceptionFilter = new RouterExceptionFilters(
      new NestContainer(),
      applicationConfig,
      new NoopHttpAdapter({}),
    );
  });
  describe('create', () => {
    describe('when filters metadata is empty', () => {
      class EmptyMetadata {}
      beforeEach(() => {
        sinon.stub(exceptionFilter, 'createContext').returns([]);
      });
      it('should return plain ExceptionHandler object', () => {
        const filter = exceptionFilter.create(
          new EmptyMetadata(),
          () => ({}) as any,
          undefined,
        );
        expect((filter as any).filters).to.be.empty;
      });
    });
    describe('when filters metadata is not empty', () => {
      @UseFilters(new ExceptionFilter())
      class WithMetadata {}

      it('should return ExceptionHandler object with exception filters', () => {
        const filter = exceptionFilter.create(
          new WithMetadata(),
          () => ({}) as any,
          undefined,
        );
        expect((filter as any).filters).to.not.be.empty;
      });
    });
  });
  describe('reflectCatchExceptions', () => {
    it('should return FILTER_CATCH_EXCEPTIONS metadata', () => {
      expect(
        exceptionFilter.reflectCatchExceptions(new ExceptionFilter()),
      ).to.be.eql([CustomException]);
    });
  });
  describe('createConcreteContext', () => {
    class InvalidFilter {}
    const filters = [new ExceptionFilter(), new InvalidFilter(), 'test'];

    it('should return expected exception filters metadata', () => {
      const resolved = exceptionFilter.createConcreteContext(filters as any);
      expect(resolved).to.have.length(1);
      expect(resolved[0].exceptionMetatypes).to.be.deep.equal([
        CustomException,
      ]);
      expect(resolved[0].func).to.be.a('function');
    });
  });
  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global filters', () => {
        const expectedResult = applicationConfig.getGlobalFilters();
        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped filters', () => {
        const globalFilters: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedFilterWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalFilters')
          .callsFake(() => globalFilters);
        sinon
          .stub(applicationConfig, 'getGlobalRequestFilters')
          .callsFake(() => scopedFilterWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(
          instance,
          ...globalFilters,
        );
      });
    });
  });
});



================================================
FILE: packages/core/test/router/router-execution-context.spec.ts
================================================
import { ForbiddenException } from '@nestjs/common/exceptions/forbidden.exception';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { PassThrough } from 'stream';
import { HttpException, HttpStatus, RouteParamMetadata } from '../../../common';
import { CUSTOM_ROUTE_ARGS_METADATA } from '../../../common/constants';
import { RouteParamtypes } from '../../../common/enums/route-paramtypes.enum';
import { AbstractHttpAdapter } from '../../adapters';
import { ApplicationConfig } from '../../application-config';
import { FORBIDDEN_MESSAGE } from '../../guards/constants';
import { GuardsConsumer } from '../../guards/guards-consumer';
import { GuardsContextCreator } from '../../guards/guards-context-creator';
import { HandlerResponseBasicFn } from '../../helpers/handler-metadata-storage';
import { NestContainer } from '../../injector/container';
import { InterceptorsConsumer } from '../../interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '../../interceptors/interceptors-context-creator';
import { PipesConsumer } from '../../pipes/pipes-consumer';
import { PipesContextCreator } from '../../pipes/pipes-context-creator';
import { RouteParamsFactory } from '../../router/route-params-factory';
import { RouterExecutionContext } from '../../router/router-execution-context';
import { HeaderStream } from '../../router/sse-stream';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RouterExecutionContext', () => {
  let contextCreator: RouterExecutionContext;
  let callback: any;
  let applySpy: sinon.SinonSpy;
  let factory: RouteParamsFactory;
  let consumer: PipesConsumer;
  let guardsConsumer: GuardsConsumer;
  let interceptorsConsumer: InterceptorsConsumer;
  let adapter: AbstractHttpAdapter;

  beforeEach(() => {
    callback = {
      bind: () => ({}),
      apply: () => ({}),
    };
    applySpy = sinon.spy(callback, 'apply');

    factory = new RouteParamsFactory();
    consumer = new PipesConsumer();
    guardsConsumer = new GuardsConsumer();
    interceptorsConsumer = new InterceptorsConsumer();
    adapter = new NoopHttpAdapter({});
    contextCreator = new RouterExecutionContext(
      factory,
      new PipesContextCreator(new NestContainer(), new ApplicationConfig()),
      consumer,
      new GuardsContextCreator(new NestContainer()),
      guardsConsumer,
      new InterceptorsContextCreator(new NestContainer()),
      interceptorsConsumer,
      adapter,
    );
  });
  describe('create', () => {
    describe('when callback metadata is not undefined', () => {
      let metadata: Record<number, RouteParamMetadata>;
      let exchangeKeysForValuesSpy: sinon.SinonSpy;
      beforeEach(() => {
        metadata = {
          [RouteParamtypes.NEXT]: { index: 0 },
          [RouteParamtypes.BODY]: {
            index: 2,
            data: 'test',
          },
        };
        sinon
          .stub((contextCreator as any).contextUtils, 'reflectCallbackMetadata')
          .returns(metadata);
        sinon
          .stub(
            (contextCreator as any).contextUtils,
            'reflectCallbackParamtypes',
          )
          .returns([]);
        exchangeKeysForValuesSpy = sinon.spy(
          contextCreator,
          'exchangeKeysForValues',
        );
      });
      it('should call "exchangeKeysForValues" with expected arguments', done => {
        const keys = Object.keys(metadata);

        contextCreator.create({ foo: 'bar' }, callback, '', '', 0);
        expect(exchangeKeysForValuesSpy.called).to.be.true;
        expect(exchangeKeysForValuesSpy.calledWith(keys, metadata)).to.be.true;
        done();
      });
      describe('returns proxy function', () => {
        let proxyContext;
        let instance;
        let tryActivateStub;
        beforeEach(() => {
          instance = { foo: 'bar' };

          const canActivateFn = contextCreator.createGuardsFn(
            [1] as any,
            null!,
            null!,
          );
          sinon.stub(contextCreator, 'createGuardsFn').returns(canActivateFn);
          tryActivateStub = sinon
            .stub(guardsConsumer, 'tryActivate')
            .callsFake(async () => true);
          proxyContext = contextCreator.create(instance, callback, '', '', 0);
        });
        it('should be a function', () => {
          expect(proxyContext).to.be.a('function');
        });
        describe('when proxy function called', () => {
          let request;
          const response = {
            status: () => response,
            send: () => response,
            json: () => response,
          };
          const next = {};

          beforeEach(() => {
            request = {
              body: {
                test: 3,
              },
            };
          });
          it('should apply expected context and arguments to callback', done => {
            tryActivateStub.callsFake(async () => true);
            proxyContext(request, response, next).then(() => {
              const args = [next, undefined, request.body.test];
              expect(applySpy.called).to.be.true;
              expect(applySpy.calledWith(instance, args)).to.be.true;
              done();
            });
          });
          it('should throw exception when "tryActivate" returns false', async () => {
            tryActivateStub.callsFake(async () => false);

            let error: HttpException;
            try {
              await proxyContext(request, response, next);
            } catch (e) {
              error = e;
            }
            expect(error!).to.be.instanceOf(ForbiddenException);
            expect(error!.message).to.be.eql('Forbidden resource');
            expect(error!.getResponse()).to.be.eql({
              statusCode: HttpStatus.FORBIDDEN,
              error: 'Forbidden',
              message: FORBIDDEN_MESSAGE,
            });
          });
          it('should apply expected context when "canActivateFn" apply', () => {
            proxyContext(request, response, next).then(() => {
              expect(tryActivateStub.args[0][1][0]).to.equals(request);
              expect(tryActivateStub.args[0][1][1]).to.equals(response);
              expect(tryActivateStub.args[0][1][2]).to.equals(next);
            });
          });
          it('should apply expected context when "intercept" apply', () => {
            const interceptStub = sinon.stub(interceptorsConsumer, 'intercept');
            proxyContext(request, response, next).then(() => {
              expect(interceptStub.args[0][1][0]).to.equals(request);
              expect(interceptStub.args[0][1][1]).to.equals(response);
              expect(interceptStub.args[0][1][2]).to.equals(next);
            });
          });
        });
      });
    });
  });

  describe('exchangeKeysForValues', () => {
    it('should exchange arguments keys for appropriate values', () => {
      const metadata = {
        [RouteParamtypes.REQUEST]: { index: 0, data: 'test', pipes: [] },
        [RouteParamtypes.BODY]: { index: 2, data: 'test', pipes: [] },
        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {
          index: 3,
          data: 'custom',
          pipes: [],
        },
      };
      const keys = Object.keys(metadata);
      const values = contextCreator.exchangeKeysForValues(keys, metadata, '');
      const expectedValues = [
        { index: 0, type: RouteParamtypes.REQUEST, data: 'test' },
        { index: 2, type: RouteParamtypes.BODY, data: 'test' },
        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },
      ];
      expect(values[0]).to.deep.include(expectedValues[0]);
      expect(values[1]).to.deep.include(expectedValues[1]);
    });
  });

  describe('getParamValue', () => {
    let consumerApplySpy: sinon.SinonSpy;
    const value = 3,
      metatype = null,
      transforms = [{ transform: sinon.spy() }];

    beforeEach(() => {
      consumerApplySpy = sinon.spy(consumer, 'apply');
    });
    describe('when paramtype is query, body, rawBody or param', () => {
      it('should call "consumer.apply" with expected arguments', async () => {
        await contextCreator.getParamValue(
          value,
          { metatype, type: RouteParamtypes.QUERY, data: null },
          transforms,
        );
        expect(
          consumerApplySpy.calledWith(
            value,
            { metatype, type: RouteParamtypes.QUERY, data: null },
            transforms,
          ),
        ).to.be.true;

        await contextCreator.getParamValue(
          value,
          { metatype, type: RouteParamtypes.BODY, data: null },
          transforms,
        );
        expect(
          consumerApplySpy.calledWith(
            value,
            { metatype, type: RouteParamtypes.BODY, data: null },
            transforms,
          ),
        ).to.be.true;

        await contextCreator.getParamValue(
          value,
          { metatype, type: RouteParamtypes.RAW_BODY, data: null },
          transforms,
        );
        expect(
          consumerApplySpy.calledWith(
            value,
            { metatype, type: RouteParamtypes.RAW_BODY, data: null },
            transforms,
          ),
        ).to.be.true;

        await contextCreator.getParamValue(
          value,
          { metatype, type: RouteParamtypes.PARAM, data: null },
          transforms,
        );
        expect(
          consumerApplySpy.calledWith(
            value,
            { metatype, type: RouteParamtypes.PARAM, data: null },
            transforms,
          ),
        ).to.be.true;
      });
    });
  });
  describe('isPipeable', () => {
    describe('when paramtype is not query, body, param and custom', () => {
      it('should return false', () => {
        const result = contextCreator.isPipeable(RouteParamtypes.NEXT);
        expect(result).to.be.false;
      });
      it('otherwise', () => {
        expect(contextCreator.isPipeable(RouteParamtypes.BODY)).to.be.true;
        expect(contextCreator.isPipeable(RouteParamtypes.RAW_BODY)).to.be.true;
        expect(contextCreator.isPipeable(RouteParamtypes.QUERY)).to.be.true;
        expect(contextCreator.isPipeable(RouteParamtypes.PARAM)).to.be.true;
        expect(contextCreator.isPipeable(RouteParamtypes.FILE)).to.be.true;
        expect(contextCreator.isPipeable(RouteParamtypes.FILES)).to.be.true;
        expect(contextCreator.isPipeable('custom')).to.be.true;
      });
    });
  });
  describe('createPipesFn', () => {
    describe('when "paramsOptions" is empty', () => {
      it('returns null', async () => {
        const pipesFn = contextCreator.createPipesFn([], []);
        expect(pipesFn).to.be.null;
      });
    });
  });
  describe('createGuardsFn', () => {
    it('should throw ForbiddenException when "tryActivate" returns false', async () => {
      const guardsFn = contextCreator.createGuardsFn([null!], null!, null!)!;
      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);

      let error: ForbiddenException;
      try {
        await guardsFn([]);
      } catch (e) {
        error = e;
      }

      expect(error!).to.be.instanceOf(ForbiddenException);
      expect(error!.message).to.be.eql('Forbidden resource');
      expect(error!.getResponse()).to.be.eql({
        statusCode: HttpStatus.FORBIDDEN,
        message: FORBIDDEN_MESSAGE,
        error: 'Forbidden',
      });
    });
  });
  describe('createHandleResponseFn', () => {
    describe('when "renderTemplate" is defined', () => {
      beforeEach(() => {
        sinon
          .stub(adapter, 'render')
          .callsFake((response, view: string, options: any) => {
            return response.render(view, options);
          });
      });
      it('should call "res.render()" with expected args', async () => {
        const template = 'template';
        const value = 'test';
        const response = { render: sinon.spy() };

        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(template);

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;
        await handler(value, response);

        expect(response.render.calledWith(template, value)).to.be.true;
      });
    });
    describe('when "renderTemplate" is undefined', () => {
      it('should not call "res.render()"', async () => {
        const result = Promise.resolve('test');
        const response = { render: sinon.spy() };

        sinon.stub(contextCreator, 'reflectResponseHeaders').returns([]);
        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns(undefined!);

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;
        await handler(result, response);

        expect(response.render.called).to.be.false;
      });
    });
    describe('when "redirectResponse" is present', () => {
      beforeEach(() => {
        sinon
          .stub(adapter, 'redirect')
          .callsFake((response, statusCode: number, url: string) => {
            return response.redirect(statusCode, url);
          });
      });
      it('should call "res.redirect()" with expected args', async () => {
        const redirectResponse = {
          url: 'http://test.com',
          statusCode: 302,
        };
        const response = { redirect: sinon.spy() };

        const handler = contextCreator.createHandleResponseFn(
          () => {},
          true,
          redirectResponse,
          200,
        ) as HandlerResponseBasicFn;
        await handler(redirectResponse, response);

        expect(
          response.redirect.calledWith(
            redirectResponse.statusCode,
            redirectResponse.url,
          ),
        ).to.be.true;
      });
    });

    describe('when "redirectResponse" is undefined', () => {
      it('should not call "res.redirect()"', async () => {
        const result = Promise.resolve('test');
        const response = { redirect: sinon.spy() };

        sinon.stub(contextCreator, 'reflectResponseHeaders').returns([]);
        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns(undefined!);

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;
        await handler(result, response);

        expect(response.redirect.called).to.be.false;
      });
    });

    describe('when replying with result', () => {
      it('should call "adapter.reply()" with expected args', async () => {
        const result = Promise.resolve('test');
        const response = {};

        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns(undefined!);

        const handler = contextCreator.createHandleResponseFn(
          null!,
          false,
          undefined,
          1234,
        ) as HandlerResponseBasicFn;
        const adapterReplySpy = sinon.spy(adapter, 'reply');
        await handler(result, response);
        expect(
          adapterReplySpy.calledOnceWithExactly(
            sinon.match.same(response),
            'test',
            1234,
          ),
        ).to.be.true;
      });
    });

    describe('when "isSse" is enabled', () => {
      it('should delegate result to SseStream', async () => {
        const result = of('test');
        const response = new PassThrough();
        response.write = sinon.spy();

        const request = new PassThrough();
        request.on = sinon.spy();

        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns('/');

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;
        await handler(result, response, request);

        expect((response.write as any).called).to.be.true;
        expect((request.on as any).called).to.be.true;
      });

      it('should not allow a non-observable result', async () => {
        const result = Promise.resolve('test');
        const response = new PassThrough();
        const request = new PassThrough();

        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns('/');

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;

        try {
          await handler(result, response, request);
        } catch (e) {
          expect(e.message).to.equal(
            'You must return an Observable stream to use Server-Sent Events (SSE).',
          );
        }
      });

      it('should apply any headers that exists on the response', async () => {
        const result = of('test');
        const response = new PassThrough() as HeaderStream;
        response.write = sinon.spy();
        response.writeHead = sinon.spy();
        response.flushHeaders = sinon.spy();
        response.getHeaders = sinon
          .stub()
          .returns({ 'access-control-headers': 'some-cors-value' });

        const request = new PassThrough();
        request.on = sinon.spy();

        sinon.stub(contextCreator, 'reflectRenderTemplate').returns(undefined!);
        sinon.stub(contextCreator, 'reflectSse').returns('/');

        const handler = contextCreator.createHandleResponseFn(
          null!,
          true,
          undefined,
          200,
        ) as HandlerResponseBasicFn;
        await handler(result, response, request);

        expect(
          (response.writeHead as sinon.SinonSpy).calledWith(
            200,
            sinon.match.hasNested('access-control-headers', 'some-cors-value'),
          ),
        ).to.be.true;
      });
    });
  });
});



================================================
FILE: packages/core/test/router/router-explorer.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import {
  All,
  Get,
  Post,
} from '../../../common/decorators/http/request-mapping.decorator';
import { RequestMethod } from '../../../common/enums/request-method.enum';
import { VersioningType } from '../../../common/enums/version-type.enum';
import { Injector } from '../../../core/injector/injector';
import { ApplicationConfig } from '../../application-config';
import { UnknownRequestMappingException } from '../../errors/exceptions/unknown-request-mapping.exception';
import { ExecutionContextHost } from '../../helpers/execution-context-host';
import { NestContainer } from '../../injector/container';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { GraphInspector } from '../../inspector/graph-inspector';
import { MetadataScanner } from '../../metadata-scanner';
import { RoutePathMetadata } from '../../router/interfaces/route-path-metadata.interface';
import { RoutePathFactory } from '../../router/route-path-factory';
import { RouterExceptionFilters } from '../../router/router-exception-filters';
import { RouterExplorer } from '../../router/router-explorer';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RouterExplorer', () => {
  @Controller('global')
  class TestRoute {
    @Get('test')
    public getTest() {}

    @Post('test')
    public postTest() {}

    @All('another-test')
    public anotherTest() {}

    @Get(['foo', 'bar'])
    public getTestUsingArray() {}
  }

  @Controller(['global', 'global-alias'])
  class TestRouteAlias {
    @Get('test')
    public getTest() {}

    @Post('test')
    public postTest() {}

    @All('another-test')
    public anotherTest() {}

    @Get(['foo', 'bar'])
    public getTestUsingArray() {}
  }

  class ClassWithMissingControllerDecorator {}

  let routerBuilder: RouterExplorer;
  let injector: Injector;
  let exceptionsFilter: RouterExceptionFilters;
  let applicationConfig: ApplicationConfig;
  let routePathFactory: RoutePathFactory;
  let graphInspector: GraphInspector;

  beforeEach(() => {
    const container = new NestContainer();

    applicationConfig = new ApplicationConfig();
    injector = new Injector();
    routePathFactory = new RoutePathFactory(applicationConfig);
    graphInspector = new GraphInspector(container);
    exceptionsFilter = new RouterExceptionFilters(
      container,
      applicationConfig,
      null!,
    );
    routerBuilder = new RouterExplorer(
      new MetadataScanner(),
      container,
      injector,
      null!,
      exceptionsFilter,
      applicationConfig,
      routePathFactory,
      graphInspector,
    );
  });

  describe('applyPathsToRouterProxy', () => {
    it('should method return expected object which represent single route', () => {
      const bindStub = sinon.stub(
        routerBuilder,
        'applyCallbackToRouter' as any,
      );
      const paths = [
        { path: [''], requestMethod: RequestMethod.GET },
        { path: ['test'], requestMethod: RequestMethod.GET },
        { path: ['foo', 'bar'], requestMethod: RequestMethod.GET },
      ];

      routerBuilder.applyPathsToRouterProxy(
        null!,
        paths as any,
        null!,
        '',
        {},
        '',
      );

      expect(bindStub.calledWith(null, paths[0], null)).to.be.true;
      expect(bindStub.callCount).to.be.eql(paths.length);
    });

    it('should method return expected object which represents a single versioned route', () => {
      const bindStub = sinon.stub(
        routerBuilder,
        'applyCallbackToRouter' as any,
      );
      const paths = [
        { path: [''], requestMethod: RequestMethod.GET },
        { path: ['test'], requestMethod: RequestMethod.GET },
        { path: ['foo', 'bar'], requestMethod: RequestMethod.GET },
      ];

      const routePathMetadata: RoutePathMetadata = {
        versioningOptions: { type: VersioningType.URI },
      };
      routerBuilder.applyPathsToRouterProxy(
        null!,
        paths as any,
        null!,
        '',
        routePathMetadata,
        '1',
      );

      expect(
        bindStub.calledWith(null, paths[0], null, '', routePathMetadata, '1'),
      ).to.be.true;
      expect(bindStub.callCount).to.be.eql(paths.length);
    });
  });

  describe('extractRouterPath', () => {
    it('should return expected path', () => {
      expect(routerBuilder.extractRouterPath(TestRoute)).to.be.eql(['/global']);
    });

    it('should return expected path with alias', () => {
      expect(routerBuilder.extractRouterPath(TestRouteAlias)).to.be.eql([
        '/global',
        '/global-alias',
      ]);
    });

    it("should throw UnknownRequestMappingException when missing the `@Controller()` decorator in the class, displaying class's name", () => {
      expect(() =>
        routerBuilder.extractRouterPath(ClassWithMissingControllerDecorator),
      ).to.throw(
        UnknownRequestMappingException,
        /ClassWithMissingControllerDecorator/,
      );
    });
  });

  describe('createRequestScopedHandler', () => {
    let nextSpy: sinon.SinonSpy;

    beforeEach(() => {
      sinon.stub(injector, 'loadPerContext').callsFake(() => {
        throw new Error();
      });
      nextSpy = sinon.spy();
      sinon.stub(exceptionsFilter, 'create').callsFake(
        () =>
          ({
            next: nextSpy,
          }) as any,
      );
    });

    describe('when "loadPerContext" throws', () => {
      const moduleKey = 'moduleKey';
      const methodKey = 'methodKey';
      const module = {
        controllers: new Map(),
      } as any;
      const wrapper = new InstanceWrapper({
        instance: { [methodKey]: {} },
      });

      it('should delegate error to exception filters', async () => {
        const handler = routerBuilder.createRequestScopedHandler(
          wrapper,
          RequestMethod.ALL,
          module,
          moduleKey,
          methodKey,
        );
        await handler(null!, null, null!);

        expect(nextSpy.called).to.be.true;
        expect(nextSpy.getCall(0).args[0]).to.be.instanceOf(Error);
        expect(nextSpy.getCall(0).args[1]).to.be.instanceOf(
          ExecutionContextHost,
        );
      });
    });
  });

  describe('applyVersionFilter', () => {
    it('should call and return the `applyVersionFilter` from the underlying http server', () => {
      const router = sinon.spy(new NoopHttpAdapter({}));
      const routePathMetadata: RoutePathMetadata = {
        methodVersion:
          sinon.fake() as unknown as RoutePathMetadata['methodVersion'],
        versioningOptions:
          sinon.fake() as unknown as RoutePathMetadata['versioningOptions'],
      };
      const handler = sinon.stub();

      // We're using type assertion here because `applyVersionFilter` is private
      const versionFilter = (routerBuilder as any).applyVersionFilter(
        router,
        routePathMetadata,
        handler,
      );

      expect(
        router.applyVersionFilter.calledOnceWithExactly(
          handler,
          routePathMetadata.methodVersion!,
          routePathMetadata.versioningOptions!,
        ),
      ).to.be.true;

      expect(router.applyVersionFilter.returnValues[0]).to.be.equal(
        versionFilter,
      );
    });
  });

  describe('copyMetadataToCallback', () => {
    it('should then copy the metadata from the original callback to the target callback', () => {
      const originalCallback = () => {};
      Reflect.defineMetadata(
        'test_metadata_key',
        'test_metadata_value',
        originalCallback,
      );

      const targetCallback = () => {};

      // We're using type assertion here because `copyMetadataToCallback` is private
      (routerBuilder as any).copyMetadataToCallback(
        originalCallback,
        targetCallback,
      );

      expect(
        Reflect.getMetadata('test_metadata_key', targetCallback),
      ).to.be.equal('test_metadata_value');
    });
  });
});



================================================
FILE: packages/core/test/router/router-module.spec.ts
================================================
import { expect } from 'chai';
import { ModulesContainer, NestContainer } from '../../injector';
import { Module } from '../../injector/module';
import { Routes } from '../../router/interfaces';
import {
  RouterModule,
  ROUTES,
  targetModulesByContainer,
} from '../../router/router-module';

class TestModuleClass {}

describe('RouterModule', () => {
  const routes: Routes = [{ path: 'test', module: TestModuleClass }];

  describe('register', () => {
    it('should return a dynamic module with routes registered as a provider', () => {
      expect(RouterModule.register(routes)).to.deep.equal({
        module: RouterModule,
        providers: [
          {
            provide: ROUTES,
            useValue: routes,
          },
        ],
      });
    });
  });
  describe('when instantiated', () => {
    it('should update the "targetModulesByContainer" weak map', () => {
      const moduleRef = new Module(TestModuleClass, new NestContainer(null!));
      const container = new ModulesContainer([
        [TestModuleClass.name, moduleRef],
      ]);

      new RouterModule(container, routes);

      class NotRegisteredModuleClass {}

      new RouterModule(container, [
        {
          path: 'random',
          module: NotRegisteredModuleClass,
        },
      ]);

      expect(targetModulesByContainer.get(container)!.has(moduleRef)).to.be
        .true;
    });
  });
});



================================================
FILE: packages/core/test/router/router-proxy.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { HttpException } from '../../../common/exceptions/http.exception';
import { ExceptionsHandler } from '../../exceptions/exceptions-handler';
import { ExecutionContextHost } from '../../helpers/execution-context-host';
import { RouterProxy } from '../../router/router-proxy';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RouterProxy', () => {
  let routerProxy: RouterProxy;
  let handler: ExceptionsHandler;
  const httpException = new HttpException('test', 500);
  let nextStub: sinon.SinonStub;
  beforeEach(() => {
    handler = new ExceptionsHandler(new NoopHttpAdapter({}));
    nextStub = sinon.stub(handler, 'next');
    routerProxy = new RouterProxy();
  });

  describe('createProxy', () => {
    it('should method return thunk', () => {
      const proxy = routerProxy.createProxy(() => {}, handler);
      expect(typeof proxy === 'function').to.be.true;
    });

    it('should method encapsulate callback passed as argument', async () => {
      const proxy = routerProxy.createProxy((req, res, next) => {
        throw httpException;
      }, handler);
      await proxy(null, null, null!);

      expect(nextStub.calledOnce).to.be.true;
      expect(
        nextStub.calledWith(
          httpException,
          new ExecutionContextHost([null, null, null]),
        ),
      ).to.be.true;
    });

    it('should method encapsulate async callback passed as argument', async () => {
      const proxy = routerProxy.createProxy(async (req, res, next) => {
        throw httpException;
      }, handler);

      await proxy(null, null, null!);

      expect(nextStub.calledOnce).to.be.true;
      expect(
        nextStub.calledWith(
          httpException,
          new ExecutionContextHost([null, null, null]),
        ),
      ).to.be.true;
    });
  });

  describe('createExceptionLayerProxy', () => {
    it('should method return thunk', () => {
      const proxy = routerProxy.createExceptionLayerProxy(() => {}, handler);
      expect(typeof proxy === 'function').to.be.true;
    });

    it('should method encapsulate callback passed as argument', async () => {
      const proxy = routerProxy.createExceptionLayerProxy(
        (err, req, res, next) => {
          throw httpException;
        },
        handler,
      );
      await proxy(null, null, null, null!);

      expect(nextStub.calledOnce).to.be.true;
      expect(
        nextStub.calledWith(
          httpException,
          new ExecutionContextHost([null, null, null]),
        ),
      ).to.be.true;
    });

    it('should method encapsulate async callback passed as argument', async () => {
      const proxy = routerProxy.createExceptionLayerProxy(
        async (err, req, res, next) => {
          throw httpException;
        },
        handler,
      );

      await proxy(null, null, null, null!);

      expect(nextStub.calledOnce).to.be.true;
      expect(
        nextStub.calledWith(
          httpException,
          new ExecutionContextHost([null, null, null]),
        ),
      ).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/router/router-response-controller.spec.ts
================================================
import { isNil, isObject } from '@nestjs/common/utils/shared.utils';
import { expect } from 'chai';
import { IncomingMessage, ServerResponse } from 'http';
import { Observable, of, Subject } from 'rxjs';
import * as sinon from 'sinon';
import { PassThrough, Writable } from 'stream';
import { HttpStatus, RequestMethod } from '../../../common';
import { RouterResponseController } from '../../router/router-response-controller';
import { SseStream } from '../../router/sse-stream';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RouterResponseController', () => {
  let adapter: NoopHttpAdapter;
  let routerResponseController: RouterResponseController;

  beforeEach(() => {
    adapter = new NoopHttpAdapter({});
    routerResponseController = new RouterResponseController(adapter);
  });

  describe('apply', () => {
    let response: {
      send: sinon.SinonSpy;
      status?: sinon.SinonSpy;
      json: sinon.SinonSpy;
    };
    beforeEach(() => {
      response = { send: sinon.spy(), json: sinon.spy(), status: sinon.spy() };
    });
    describe('when result is', () => {
      beforeEach(() => {
        sinon
          .stub(adapter, 'reply')
          .callsFake((responseRef: any, body: any, statusCode?: number) => {
            if (statusCode) {
              responseRef.status(statusCode);
            }
            if (isNil(body)) {
              return responseRef.send();
            }
            return isObject(body)
              ? responseRef.json(body)
              : responseRef.send(String(body));
          });
      });
      describe('nil', () => {
        it('should call send()', async () => {
          const value = null;
          await routerResponseController.apply(value, response, 200);
          expect(response.send.called).to.be.true;
        });
      });
      describe('string', () => {
        it('should call send(value)', async () => {
          const value = 'string';
          await routerResponseController.apply(value, response, 200);
          expect(response.send.called).to.be.true;
          expect(response.send.calledWith(String(value))).to.be.true;
        });
      });
      describe('object', () => {
        it('should call json(value)', async () => {
          const value = { test: 'test' };
          await routerResponseController.apply(value, response, 200);
          expect(response.json.called).to.be.true;
          expect(response.json.calledWith(value)).to.be.true;
        });
      });
    });
  });

  describe('transformToResult', () => {
    describe('when resultOrDeferred', () => {
      describe('is Promise', () => {
        it('should return Promise that resolves to the value resolved by the input Promise', async () => {
          const value = 100;
          expect(
            await routerResponseController.transformToResult(
              Promise.resolve(value),
            ),
          ).to.be.eq(value);
        });
      });

      describe('is Observable', () => {
        it('should return toPromise', async () => {
          const lastValue = 100;
          expect(
            await routerResponseController.transformToResult(
              of(1, 2, 3, lastValue),
            ),
          ).to.be.eq(lastValue);
        });
      });

      describe('is an object that has the method `subscribe`', () => {
        it('should return a Promise that resolves to the input value', async () => {
          const value = { subscribe() {} };
          expect(
            await routerResponseController.transformToResult(value),
          ).to.equal(value);
        });
      });

      describe('is an ordinary value', () => {
        it('should return a Promise that resolves to the input value', async () => {
          const value = 100;
          expect(
            await routerResponseController.transformToResult(value),
          ).to.be.eq(value);
        });
      });
    });
  });

  describe('getStatusByMethod', () => {
    describe('when RequestMethod is POST', () => {
      it('should return 201', () => {
        expect(
          routerResponseController.getStatusByMethod(RequestMethod.POST),
        ).to.be.eql(201);
      });
    });
    describe('when RequestMethod is not POST', () => {
      it('should return 200', () => {
        expect(
          routerResponseController.getStatusByMethod(RequestMethod.GET),
        ).to.be.eql(200);
      });
    });
  });

  describe('render', () => {
    beforeEach(() => {
      sinon
        .stub(adapter, 'render')
        .callsFake((response, view: string, options: any) => {
          return response.render(view, options);
        });
    });
    it('should call "res.render()" with expected args', async () => {
      const template = 'template';
      const value = 'test';
      const result = Promise.resolve(value);
      const response = { render: sinon.spy() };

      await routerResponseController.render(result, response, template);
      expect(response.render.calledWith(template, value)).to.be.true;
    });
  });

  describe('setHeaders', () => {
    let setHeaderStub: sinon.SinonStub;

    beforeEach(() => {
      setHeaderStub = sinon.stub(adapter, 'setHeader').callsFake(() => ({}));
    });

    it('should set all custom headers', () => {
      const response = {};
      const headers = [{ name: 'test', value: 'test_value' }];

      routerResponseController.setHeaders(response, headers);
      expect(
        setHeaderStub.calledWith(response, headers[0].name, headers[0].value),
      ).to.be.true;
    });
  });

  describe('status', () => {
    let statusStub: sinon.SinonStub;

    beforeEach(() => {
      statusStub = sinon.stub(adapter, 'status').callsFake(() => ({}));
    });

    it('should set status', () => {
      const response = {};
      const statusCode = 400;

      routerResponseController.setStatus(response, statusCode);
      expect(statusStub.calledWith(response, statusCode)).to.be.true;
    });
  });

  describe('redirect should HttpServer.redirect', () => {
    it('should transformToResult', async () => {
      const transformToResultSpy = sinon
        .stub(routerResponseController, 'transformToResult')
        .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));
      const result = {};
      await routerResponseController.redirect(result, null, null!);
      expect(transformToResultSpy.firstCall.args[0]).to.be.equal(result);
    });
    it('should pass the response to redirect', async () => {
      sinon
        .stub(routerResponseController, 'transformToResult')
        .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));
      const redirectSpy = sinon.spy(adapter, 'redirect');
      const response = {};
      await routerResponseController.redirect(null, response, null!);
      expect(redirectSpy.firstCall.args[0]).to.be.equal(response);
    });
    describe('status code', () => {
      it('should come from the transformed result if present', async () => {
        sinon
          .stub(routerResponseController, 'transformToResult')
          .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));
        const redirectSpy = sinon.spy(adapter, 'redirect');
        await routerResponseController.redirect(null, null, {
          statusCode: 999,
          url: 'not form here',
        });
        expect(redirectSpy.firstCall.args[1]).to.be.eql(123);
      });
      it('should come from the redirectResponse if not on the transformed result', async () => {
        sinon
          .stub(routerResponseController, 'transformToResult')
          .returns(Promise.resolve({}));
        const redirectSpy = sinon.spy(adapter, 'redirect');
        await routerResponseController.redirect(null, null, {
          statusCode: 123,
          url: 'redirect url',
        });
        expect(redirectSpy.firstCall.args[1]).to.be.eql(123);
      });
      it('should default to HttpStatus.FOUND', async () => {
        sinon
          .stub(routerResponseController, 'transformToResult')
          .returns(Promise.resolve({}));
        const redirectSpy = sinon.spy(adapter, 'redirect');
        await routerResponseController.redirect(null, null, {
          url: 'redirect url',
        });
        expect(redirectSpy.firstCall.args[1]).to.be.eql(HttpStatus.FOUND);
      });
    });
    describe('url', () => {
      it('should come from the transformed result if present', async () => {
        sinon
          .stub(routerResponseController, 'transformToResult')
          .returns(Promise.resolve({ statusCode: 123, url: 'redirect url' }));
        const redirectSpy = sinon.spy(adapter, 'redirect');
        await routerResponseController.redirect(null, null, {
          url: 'not from here',
        });
        expect(redirectSpy.firstCall.args[2]).to.be.eql('redirect url');
      });
      it('should come from the redirectResponse if not on the transformed result', async () => {
        sinon
          .stub(routerResponseController, 'transformToResult')
          .returns(Promise.resolve({}));
        const redirectSpy = sinon.spy(adapter, 'redirect');
        await routerResponseController.redirect(null, null, {
          statusCode: 123,
          url: 'redirect url',
        });
        expect(redirectSpy.firstCall.args[2]).to.be.eql('redirect url');
      });
    });
  });
  describe('Server-Sent-Events', () => {
    it('should accept only observables', async () => {
      const result = Promise.resolve('test');
      try {
        routerResponseController.sse(
          result as unknown as any,
          {} as unknown as ServerResponse,
          {} as unknown as IncomingMessage,
        );
      } catch (e) {
        expect(e.message).to.eql(
          'You must return an Observable stream to use Server-Sent Events (SSE).',
        );
      }
    });

    it('should write string', async () => {
      class Sink extends Writable {
        private readonly chunks: string[] = [];

        _write(
          chunk: any,
          encoding: string,
          callback: (error?: Error | null) => void,
        ): void {
          this.chunks.push(chunk);
          callback();
        }

        get content() {
          return this.chunks.join('');
        }
      }

      const written = (stream: Writable) =>
        new Promise((resolve, reject) =>
          stream.on('error', reject).on('finish', resolve),
        );

      const result = of('test');
      const response = new Sink();
      const request = new PassThrough();
      routerResponseController.sse(
        result,
        response as unknown as ServerResponse,
        request as unknown as IncomingMessage,
      );
      request.destroy();
      await written(response);
      expect(response.content).to.eql(
        `
id: 1
data: test

`,
      );
    });

    it('should close on request close', done => {
      const result = of('test');
      const response = new Writable();
      response.end = () => done() as any;
      response._write = () => {};

      const request = new Writable();
      request._write = () => {};

      routerResponseController.sse(
        result,
        response as unknown as ServerResponse,
        request as unknown as IncomingMessage,
      );
      request.emit('close');
    });

    it('should close the request when observable completes', done => {
      const result = of('test');
      const response = new Writable();
      response.end = done as any;
      response._write = () => {};

      const request = new Writable();
      request._write = () => {};

      routerResponseController.sse(
        result,
        response as unknown as ServerResponse,
        request as unknown as IncomingMessage,
      );
    });

    it('should allow to intercept the response', done => {
      const result = sinon.spy();
      const response = new Writable();
      response.end();
      response._write = () => {};

      const request = new Writable();
      request._write = () => {};

      try {
        routerResponseController.sse(
          result as unknown as Observable<string>,
          response as unknown as ServerResponse,
          request as unknown as IncomingMessage,
        );
      } catch {
        // Whether an error is thrown or not
        // is not relevant, so long as
        // result is not called
      }

      sinon.assert.notCalled(result);
      done();
    });

    describe('when writing data too densely', () => {
      const DEFAULT_MAX_LISTENERS = SseStream.defaultMaxListeners;
      const MAX_LISTENERS = 1;
      const sandbox = sinon.createSandbox();

      beforeEach(() => {
        // Can't access to the internal sseStream,
        // as a workaround, set `defaultMaxListeners` of `SseStream` and reset the max listeners of `process`
        const PROCESS_MAX_LISTENERS = process.getMaxListeners();
        SseStream.defaultMaxListeners = MAX_LISTENERS;
        process.setMaxListeners(PROCESS_MAX_LISTENERS);

        const sseStream = sinon.createStubInstance(SseStream);
        const originalWrite = SseStream.prototype.write;
        // Make `.write()` always return false, so as to listen `drain` event
        sseStream.write.callsFake(function (...args: any[]) {
          originalWrite.apply(this, args);
          return false;
        });
        sandbox.replace(SseStream.prototype, 'write', sseStream.write);
      });

      afterEach(() => {
        sandbox.restore();
        SseStream.defaultMaxListeners = DEFAULT_MAX_LISTENERS;
      });

      it('should not cause memory leak', async () => {
        let maxDrainListenersExceededWarning = null;
        process.on('warning', (warning: any) => {
          if (
            warning.name === 'MaxListenersExceededWarning' &&
            warning.emitter instanceof SseStream &&
            warning.type === 'drain' &&
            warning.count === MAX_LISTENERS + 1
          ) {
            maxDrainListenersExceededWarning = warning;
          }
        });

        const result = new Subject();

        const response = new Writable();
        response._write = () => {};

        const request = new Writable();
        request._write = () => {};

        routerResponseController.sse(
          result,
          response as unknown as ServerResponse,
          request as unknown as IncomingMessage,
        );

        // Send multiple messages simultaneously
        Array.from({ length: MAX_LISTENERS + 1 }).forEach((_, i) =>
          result.next(String(i)),
        );

        await new Promise(resolve => process.nextTick(resolve));

        expect(maxDrainListenersExceededWarning).to.equal(null);
      });
    });

    describe('when there is an error', () => {
      it('should close the request', done => {
        const result = new Subject();
        const response = new Writable();
        response.end = done as any;
        response._write = () => {};

        const request = new Writable();
        request._write = () => {};

        routerResponseController.sse(
          result,
          response as unknown as ServerResponse,
          request as unknown as IncomingMessage,
        );

        result.error(new Error('Some error'));
      });

      it('should write the error message to the stream', async () => {
        class Sink extends Writable {
          private readonly chunks: string[] = [];

          _write(
            chunk: any,
            encoding: string,
            callback: (error?: Error | null) => void,
          ): void {
            this.chunks.push(chunk);
            callback();
          }

          get content() {
            return this.chunks.join('');
          }
        }

        const written = (stream: Writable) =>
          new Promise((resolve, reject) =>
            stream.on('error', reject).on('finish', resolve),
          );

        const result = new Subject();
        const response = new Sink();
        const request = new PassThrough();
        routerResponseController.sse(
          result,
          response as unknown as ServerResponse,
          request as unknown as IncomingMessage,
        );

        result.error(new Error('Some error'));
        request.destroy();

        await written(response);
        expect(response.content).to.eql(
          `
event: error
id: 1
data: Some error

`,
        );
      });
    });
  });
});



================================================
FILE: packages/core/test/router/routes-resolver.spec.ts
================================================
import {
  BadRequestException,
  Module,
  Post,
  VersioningType,
} from '@nestjs/common';
import { MODULE_PATH } from '@nestjs/common/constants';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Controller } from '../../../common/decorators/core/controller.decorator';
import { Get } from '../../../common/decorators/http/request-mapping.decorator';
import { ApplicationConfig } from '../../application-config';
import { NestContainer } from '../../injector';
import { Injector } from '../../injector/injector';
import { InstanceWrapper } from '../../injector/instance-wrapper';
import { GraphInspector } from '../../inspector/graph-inspector';
import { SerializedGraph } from '../../inspector/serialized-graph';
import { RoutesResolver } from '../../router/routes-resolver';
import { NoopHttpAdapter } from '../utils/noop-adapter.spec';

describe('RoutesResolver', () => {
  @Controller('global')
  class TestRoute {
    @Get('test')
    public getTest() {}

    @Post('another-test')
    public anotherTest() {}
  }

  @Controller({ host: 'api.example.com' })
  class TestHostRoute {
    @Get()
    public getTest() {}
  }

  @Controller({ version: '1' })
  class TestVersionRoute {
    @Get()
    public getTest() {}
  }

  @Module({
    controllers: [TestRoute],
  })
  class TestModule {}

  @Module({
    controllers: [TestRoute],
  })
  class TestModule2 {}

  let router: any;
  let routesResolver: RoutesResolver;
  let untypedRoutesResolver: any;
  let container: NestContainer;
  let modules: Map<string, any>;
  let applicationRef: any;

  beforeEach(() => {
    modules = new Map();
    applicationRef = {
      use: () => ({}),
      setNotFoundHandler: sinon.spy(),
      setErrorHandler: sinon.spy(),
    } as any;
    container = {
      getModules: () => modules,
      getModuleByKey: (key: string) => modules.get(key),
      getHttpAdapterRef: () => applicationRef,
      serializedGraph: new SerializedGraph(),
    } as any;
    router = {
      get() {},
      post() {},
    };
  });

  beforeEach(() => {
    routesResolver = new RoutesResolver(
      container,
      new ApplicationConfig(),
      new Injector(),
      new GraphInspector(container),
    );
    untypedRoutesResolver = routesResolver as any;
  });

  describe('registerRouters', () => {
    it('should register controllers to router instance', () => {
      const routes = new Map();
      const routeWrapper = new InstanceWrapper({
        instance: new TestRoute(),
        metatype: TestRoute,
      });
      routes.set('TestRoute', routeWrapper);

      const appInstance = new NoopHttpAdapter(router);
      const exploreSpy = sinon.spy(
        untypedRoutesResolver.routerExplorer,
        'explore',
      );
      const moduleName = '';
      modules.set(moduleName, {});

      sinon
        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
        .callsFake(() => ['']);
      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);

      const routePathMetadata = {
        ctrlPath: '',
        modulePath: '',
        globalPrefix: '',
        controllerVersion: undefined,
        versioningOptions: undefined,
        methodVersion: undefined,
        methodPath: '/another-test',
      };
      expect(exploreSpy.called).to.be.true;
      expect(
        exploreSpy.calledWith(
          routeWrapper,
          moduleName,
          appInstance,
          undefined,
          routePathMetadata,
        ),
      ).to.be.true;
    });

    it('should register with host when specified', () => {
      const routes = new Map();
      const routeWrapper = new InstanceWrapper({
        instance: new TestHostRoute(),
        metatype: TestHostRoute,
      });
      routes.set('TestHostRoute', routeWrapper);

      const appInstance = new NoopHttpAdapter(router);
      const exploreSpy = sinon.spy(
        untypedRoutesResolver.routerExplorer,
        'explore',
      );
      const moduleName = '';
      modules.set(moduleName, {});

      sinon
        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
        .callsFake(() => ['']);
      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);

      const routePathMetadata = {
        ctrlPath: '',
        modulePath: '',
        globalPrefix: '',
        controllerVersion: undefined,
        versioningOptions: undefined,
        methodVersion: undefined,
        methodPath: '/',
      };

      expect(exploreSpy.called).to.be.true;
      expect(
        exploreSpy.calledWith(
          routeWrapper,
          moduleName,
          appInstance,
          'api.example.com',
          routePathMetadata,
        ),
      ).to.be.true;
    });

    it('should register with version when specified', () => {
      const applicationConfig = new ApplicationConfig();
      applicationConfig.enableVersioning({
        type: VersioningType.URI,
      });
      routesResolver = new RoutesResolver(
        container,
        applicationConfig,
        new Injector(),
        new GraphInspector(container),
      );
      untypedRoutesResolver = routesResolver as any;

      const routes = new Map();
      const routeWrapper = new InstanceWrapper({
        instance: new TestVersionRoute(),
        metatype: TestVersionRoute,
      });
      routes.set('TestVersionRoute', routeWrapper);

      const appInstance = new NoopHttpAdapter(router);
      const exploreSpy = sinon.spy(
        untypedRoutesResolver.routerExplorer,
        'explore',
      );
      const moduleName = '';
      modules.set(moduleName, {});

      sinon
        .stub(untypedRoutesResolver.routerExplorer, 'extractRouterPath')
        .callsFake(() => ['']);
      routesResolver.registerRouters(routes, moduleName, '', '', appInstance);

      const routePathMetadata = {
        ctrlPath: '',
        modulePath: '',
        globalPrefix: '',
        controllerVersion: '1',
        versioningOptions: {
          type: VersioningType.URI,
        },
        methodVersion: undefined,
        methodPath: '/',
      };

      expect(exploreSpy.called).to.be.true;
      expect(
        exploreSpy.calledWith(
          routeWrapper,
          moduleName,
          appInstance,
          undefined,
          routePathMetadata,
        ),
      ).to.be.true;
    });
  });

  describe('resolve', () => {
    it('should call "registerRouters" for each module', () => {
      const routes = new Map();
      routes.set(
        'TestRoute',
        new InstanceWrapper({
          instance: new TestRoute(),
          metatype: TestRoute,
        }),
      );
      modules.set('TestModule', { routes, metatype: class {} });
      modules.set('TestModule2', { routes, metatype: class {} });

      const registerRoutersStub = sinon
        .stub(routesResolver, 'registerRouters')
        .callsFake(() => undefined);

      routesResolver.resolve({ use: sinon.spy() } as any, 'basePath');
      expect(registerRoutersStub.calledTwice).to.be.true;
    });

    describe('registerRouters', () => {
      it('should register each module with the base path and append the module path if present ', () => {
        const routes = new Map();
        routes.set('TestRoute', {
          instance: new TestRoute(),
          metatype: TestRoute,
        });

        Reflect.defineMetadata(MODULE_PATH, '/test', TestModule);
        modules.set('TestModule', { routes, metatype: TestModule });
        modules.set('TestModule2', { routes, metatype: TestModule2 });

        const spy = sinon
          .stub(routesResolver, 'registerRouters')
          .callsFake(() => undefined);

        routesResolver.resolve(applicationRef, 'api/v1');

        expect(
          spy
            .getCall(0)
            .calledWith(sinon.match.any, sinon.match.any, 'api/v1', '/test'),
        ).to.be.true;
        expect(
          spy
            .getCall(1)
            .calledWith(
              sinon.match.any,
              sinon.match.any,
              'api/v1',
              sinon.match.any,
            ),
        ).to.be.true;
      });

      it('should register each module with the module path if present', () => {
        const routes = new Map();
        routes.set('TestRoute', {
          instance: new TestRoute(),
          metatype: TestRoute,
        });

        Reflect.defineMetadata(MODULE_PATH, '/test', TestModule);
        modules.set('TestModule', { routes, metatype: TestModule });
        modules.set('TestModule2', { routes, metatype: TestModule2 });

        const spy = sinon
          .stub(routesResolver, 'registerRouters')
          .callsFake(() => undefined);

        routesResolver.resolve(applicationRef, '');

        expect(
          spy
            .getCall(0)
            .calledWith(sinon.match.any, sinon.match.any, '', '/test'),
        ).to.be.true;
        // without module path
        expect(
          spy
            .getCall(1)
            .calledWith(sinon.match.any, sinon.match.any, '', undefined),
        ).to.be.true;
      });
    });
  });

  describe('mapExternalExceptions', () => {
    describe('when exception prototype is', () => {
      describe('SyntaxError', () => {
        it('should map to BadRequestException', () => {
          const err = new SyntaxError();
          const outputErr = routesResolver.mapExternalException(err);
          expect(outputErr).to.be.instanceof(BadRequestException);
        });
      });
      describe('URIError', () => {
        it('should map to BadRequestException', () => {
          const err = new URIError();
          const outputErr = routesResolver.mapExternalException(err);
          expect(outputErr).to.be.instanceof(BadRequestException);
        });
      });
      describe('other', () => {
        it('should behave as an identity', () => {
          const err = new Error();
          const outputErr = routesResolver.mapExternalException(err);
          expect(outputErr).to.be.eql(err);
        });
      });
    });
  });

  describe('registerNotFoundHandler', () => {
    it('should register not found handler', () => {
      routesResolver.registerNotFoundHandler();

      expect(applicationRef.setNotFoundHandler.called).to.be.true;
    });
  });

  describe('registerExceptionHandler', () => {
    it('should register exception handler', () => {
      routesResolver.registerExceptionHandler();

      expect(applicationRef.setErrorHandler.called).to.be.true;
    });
  });
});



================================================
FILE: packages/core/test/router/sse-stream.spec.ts
================================================
import { expect } from 'chai';
import { EventSource } from 'eventsource';
import { createServer, OutgoingHttpHeaders } from 'http';
import { AddressInfo } from 'net';
import { Writable } from 'stream';
import { HeaderStream, SseStream } from '../../router/sse-stream';

const noop = () => {};

const written = (stream: Writable) =>
  new Promise((resolve, reject) =>
    stream.on('error', reject).on('finish', resolve),
  );

class Sink extends Writable implements HeaderStream {
  private readonly chunks: string[] = [];

  constructor(
    public readonly writeHead?: (
      statusCode: number,
      headers?: OutgoingHttpHeaders | string,
    ) => void,
  ) {
    super({ objectMode: true });
  }

  _write(
    chunk: any,
    encoding: string,
    callback: (error?: Error | null) => void,
  ): void {
    this.chunks.push(chunk);
    callback();
  }

  get content() {
    return this.chunks.join('');
  }
}

describe('SseStream', () => {
  it('writes multiple multiline messages', async () => {
    const sse = new SseStream();
    const sink = new Sink();
    sse.pipe(sink);

    sse.writeMessage(
      {
        data: 'hello\nworld',
      },
      noop,
    );
    sse.writeMessage(
      {
        data: 'bonjour\nmonde',
      },
      noop,
    );
    sse.end();
    await written(sink);

    expect(sink.content).to.equal(
      `
id: 1
data: hello
data: world

id: 2
data: bonjour
data: monde

`,
    );
  });

  it('writes object messages as JSON', async () => {
    const sse = new SseStream();
    const sink = new Sink();
    sse.pipe(sink);

    sse.writeMessage(
      {
        data: { hello: 'world' },
      },
      noop,
    );
    sse.end();
    await written(sink);

    expect(sink.content).to.equal(
      `
id: 1
data: {"hello":"world"}

`,
    );
  });

  it('writes all message attributes', async () => {
    const sse = new SseStream();
    const sink = new Sink();
    sse.pipe(sink);

    sse.writeMessage(
      {
        type: 'tea-time',
        id: 'the-id',
        retry: 222,
        data: 'hello',
      },
      noop,
    );
    sse.end();
    await written(sink);

    expect(sink.content).to.equal(
      `
event: tea-time
id: the-id
retry: 222
data: hello

`,
    );
  });

  it('sets headers on destination when it looks like a HTTP Response', callback => {
    const sse = new SseStream();
    const sink = new Sink(
      (status: number, headers: string | OutgoingHttpHeaders) => {
        expect(headers).to.deep.equal({
          'Content-Type': 'text/event-stream',
          Connection: 'keep-alive',
          'Cache-Control':
            'private, no-cache, no-store, must-revalidate, max-age=0, no-transform',
          Pragma: 'no-cache',
          Expire: '0',
          'X-Accel-Buffering': 'no',
        });
        callback();
        return sink;
      },
    );
    sse.pipe(sink);
  });

  it('sets additional headers when provided', callback => {
    const sse = new SseStream();
    const sink = new Sink(
      (status: number, headers: string | OutgoingHttpHeaders) => {
        expect(headers).to.contain.keys('access-control-headers');
        expect(headers['access-control-headers']).to.equal('some-cors-value');
        callback();
        return sink;
      },
    );

    sse.pipe(sink, {
      additionalHeaders: { 'access-control-headers': 'some-cors-value' },
    });
  });

  it('allows an eventsource to connect', callback => {
    let sse: SseStream;
    const server = createServer((req, res) => {
      sse = new SseStream(req);
      sse.pipe(res);
    });

    server.listen(() => {
      const es = new EventSource(
        `http://localhost:${(server.address() as AddressInfo).port}`,
      );
      es.onmessage = e => {
        expect(e.data).to.equal('hello');
        es.close();
        server.close(callback);
      };
      es.onopen = () => sse.writeMessage({ data: 'hello' }, noop);
      es.onerror = e =>
        callback(new Error(`Error from EventSource: ${JSON.stringify(e)}`));
    });
  });
});



================================================
FILE: packages/core/test/router/utils/flat-routes.spec.ts
================================================
import { Module } from '@nestjs/common';
import { expect } from 'chai';
import { flattenRoutePaths } from '../../../router/utils';

describe('flattenRoutePaths', () => {
  it('should flatten all route paths', () => {
    @Module({})
    class ParentModule {}
    @Module({})
    class ChildModule {}
    @Module({})
    class ChildChildModule {}
    @Module({})
    class ChildModule2 {}
    @Module({})
    class ChildModule3 {}
    @Module({})
    class ChildModule4 {}
    @Module({})
    class ParentChildModule {}
    @Module({})
    class ChildChildModule2 {}
    @Module({})
    class AuthModule {}
    @Module({})
    class CatsModule {}
    @Module({})
    class DogsModule {}

    @Module({})
    class AuthModule2 {}
    @Module({})
    class CatsModule2 {}
    @Module({})
    class CatsModule3 {}
    @Module({})
    class AuthModule3 {}
    const routes = [
      {
        path: '/parent',
        module: ParentModule,
        children: [
          {
            path: '/child',
            module: ChildModule,
            children: [
              { path: '/child2', module: ChildModule2 },
              {
                path: '/parentchild',
                module: ParentChildModule,
                children: [
                  {
                    path: '/childchild',
                    module: ChildChildModule,
                    children: [
                      { path: '/child2child', module: ChildChildModule2 },
                    ],
                  },
                ],
              },
            ],
          },
          {
            path: '/child2',
            children: [
              {
                path: 'child',
                module: ChildModule3,
              },
              ChildModule4,
            ],
          },
        ],
      },
      { path: '/v1', children: [AuthModule, CatsModule, DogsModule] },
      { path: '/v2', children: [AuthModule2, CatsModule2] },
      { path: '/v3', children: [AuthModule3, CatsModule3] },
    ];
    const expectedRoutes = [
      { path: '/parent', module: ParentModule },
      { path: '/parent/child', module: ChildModule },
      { path: '/parent/child/child2', module: ChildModule2 },
      { path: '/parent/child/parentchild', module: ParentChildModule },
      {
        path: '/parent/child/parentchild/childchild',
        module: ChildChildModule,
      },
      {
        path: '/parent/child/parentchild/childchild/child2child',
        module: ChildChildModule2,
      },
      { path: '/parent/child2', module: ChildModule4 },
      { path: '/parent/child2/child', module: ChildModule3 },
      { path: '/v1', module: AuthModule },
      { path: '/v1', module: CatsModule },
      { path: '/v1', module: DogsModule },
      { path: '/v2', module: AuthModule2 },
      { path: '/v2', module: CatsModule2 },
      { path: '/v3', module: AuthModule3 },
      { path: '/v3', module: CatsModule3 },
    ];
    expect(flattenRoutePaths(routes)).to.be.eql(expectedRoutes);
  });
});



================================================
FILE: packages/core/test/services/reflector.service.spec.ts
================================================
import { expect } from 'chai';
import { Reflector } from '../../services/reflector.service';

const transformDecorator = Reflector.createDecorator<string[], number>({
  transform: value => value.length,
});

type TestObject = {
  only1?: string;
  only2?: string;
  both: string;
};

describe('Reflector', () => {
  const key = 'key';
  let reflector: Reflector;

  @transformDecorator(['a', 'b', 'c'])
  class TestTransform {}
  class Test {}
  class Test1 {}
  class Test2 {}

  beforeEach(() => {
    Reflect.deleteMetadata(key, Test1);
    Reflect.deleteMetadata(key, Test2);
    reflector = new Reflector();
  });

  describe('get', () => {
    it('should reflect metadata by key', () => {
      const value = 'value';
      Reflect.defineMetadata(key, value, Test1);
      expect(reflector.get(key, Test1)).to.eql(value);
    });

    it('should reflect metadata by decorator', () => {
      const decorator = Reflector.createDecorator<string>();
      const value = 'value';
      Reflect.defineMetadata(decorator.KEY, value, Test1);

      // string
      let reflectedValue = reflector.get(decorator, Test1);
      expect(reflectedValue).to.eql(value);

      // @ts-expect-error 'value' is not assignable to parameter of type 'string'
      reflectedValue = true;

      reflectedValue satisfies string;
    });

    it('should reflect metadata by decorator (custom key)', () => {
      const decorator = Reflector.createDecorator<string[]>({ key: 'custom' });
      const value = ['value'];
      Reflect.defineMetadata('custom', value, Test1);

      // string[]
      let reflectedValue = reflector.get(decorator, Test1);
      expect(reflectedValue).to.eql(value);

      // @ts-expect-error 'value' is not assignable to parameter of type 'string[]'
      reflectedValue = true;

      reflectedValue satisfies string[];
    });

    it('should reflect metadata by decorator (with transform option)', () => {
      let reflectedValue = reflector.get(transformDecorator, TestTransform);
      expect(reflectedValue).to.eql(3);

      // @ts-expect-error 'value' is not assignable to type 'number'
      reflectedValue = [];

      reflectedValue satisfies number;
    });

    it('should require transform option when second generic type is provided', () => {
      // @ts-expect-error Property 'transform' is missing in type {} but required in type
      const decorator = Reflector.createDecorator<string[], number>({});
    });
  });

  describe('getAll', () => {
    it('should reflect metadata of all targets by key', () => {
      const value1 = 'value1';
      const value2 = 'value2';
      Reflect.defineMetadata(key, value1, Test1);
      Reflect.defineMetadata(key, value2, Test2);
      expect(reflector.getAll(key, [Test1, Test2])).to.eql([value1, value2]);
    });
    it('should reflect metadata of all targets by decorator', () => {
      const decorator = Reflector.createDecorator<string>();
      const value1 = 'value1';
      const value2 = 'value2';
      Reflect.defineMetadata(decorator.KEY, value1, Test1);
      Reflect.defineMetadata(decorator.KEY, value2, Test2);

      // string[]
      const reflectedValue = reflector.getAll(decorator, [Test1, Test2]);
      expect(reflectedValue).to.eql([value1, value2]);

      reflectedValue satisfies string[];
    });
  });

  describe('getAllAndMerge', () => {
    it('should return an empty array when there are no targets', () => {
      expect(reflector.getAllAndMerge(key, [])).to.be.empty;
    });
    it('should reflect metadata of all targets and concat arrays', () => {
      const decorator = Reflector.createDecorator<string[]>();
      const value = 'value';
      Reflect.defineMetadata(decorator.KEY, [value], Test1);

      // string[]
      const reflectedValue = reflector.getAllAndMerge(decorator, [
        Test1,
        Test1,
      ]);
      expect(reflectedValue).to.eql([value, value]);

      reflectedValue satisfies string[];
    });
    it('should reflect metadata of all targets and concat boolean arrays', () => {
      const decorator = Reflector.createDecorator<boolean>();
      const value = true;
      Reflect.defineMetadata(decorator.KEY, [value], Test1);

      // string[]
      const reflectedValue = reflector.getAllAndMerge(decorator, [
        Test1,
        Test1,
      ]);
      expect(reflectedValue).to.eql([value, value]);

      reflectedValue satisfies boolean[];
    });
    it('should reflect metadata of all targets and create an array', () => {
      const decorator = Reflector.createDecorator<string>();
      const value = 'value';
      Reflect.defineMetadata(decorator.KEY, value, Test1);

      // string[]
      const reflectedValue = reflector.getAllAndMerge(decorator, [
        Test1,
        Test1,
      ]);
      expect(reflectedValue).to.eql([value, value]);

      reflectedValue satisfies string[];
    });
    it('should reflect metadata of all targets and merge objects', () => {
      const decorator = Reflector.createDecorator<TestObject>();
      const value1: TestObject = { only1: 'test1', both: 'overriden' };
      const value2: TestObject = { only2: 'test2', both: 'test' };
      Reflect.defineMetadata(decorator.KEY, value1, Test1);
      Reflect.defineMetadata(decorator.KEY, value2, Test2);

      // TestObject
      const reflectedValue = reflector.getAllAndMerge(decorator, [
        Test1,
        Test2,
      ]);
      expect(reflectedValue).to.eql({
        ...value1,
        ...value2,
      });

      reflectedValue satisfies TestObject;
    });
    it('should reflect metadata of all targets and create an array from a single value', () => {
      const value = 'value';
      Reflect.defineMetadata(key, value, Test1);

      const result = reflector.getAllAndMerge(key, [Test1, Test2]);
      expect(result).to.eql([value]);

      result satisfies string[];
    });
    it('should reflect metadata of all targets and return a single array unmodified', () => {
      const value = ['value'];
      Reflect.defineMetadata(key, value, Test1);
      expect(reflector.getAllAndMerge(key, [Test1, Test2])).to.eql(value);
    });
    it('should reflect metadata of all targets and return a single object unmodified', () => {
      const value = { test: 'value' };
      Reflect.defineMetadata(key, value, Test1);
      expect(reflector.getAllAndMerge(key, [Test1, Test2])).to.eql(value);
    });
  });

  describe('getAllAndOverride', () => {
    it('should reflect metadata of all targets and return a first not undefined value', () => {
      const value1 = 'value1';
      const value2 = 'value2';
      Reflect.defineMetadata(key, value1, Test1);
      Reflect.defineMetadata(key, value2, Test2);
      expect(reflector.getAllAndOverride(key, [Test1, Test2])).to.eql(value1);
    });
  });
});



================================================
FILE: packages/core/test/utils/noop-adapter.spec.ts
================================================
import { RequestMethod, VersioningOptions } from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';
import { AbstractHttpAdapter } from '../../adapters';

export class NoopHttpAdapter extends AbstractHttpAdapter {
  constructor(instance: any) {
    super(instance);
  }
  close(): any {}
  initHttpServer(options: any): any {}
  useStaticAssets(...args: any[]): any {}
  setViewEngine(engine: string): any {}
  getRequestHostname(request: any): any {}
  getRequestMethod(request: any): any {}
  getRequestUrl(request: any): any {}
  reply(response: any, body: any): any {}
  end(response: any, message?: any): any {}
  status(response: any, statusCode: number): any {}
  render(response: any, view: string, options: any): any {}
  redirect(response: any, statusCode: number, url: string) {}
  setErrorHandler(handler: Function, prefix = '/'): any {}
  setNotFoundHandler(handler: Function, prefix = '/'): any {}
  isHeadersSent(response: any): any {}
  getHeader?(response: any, name: string) {}
  setHeader(response: any, name: string, value: string): any {}
  appendHeader?(response: any, name: string, value: string) {}
  registerParserMiddleware(): any {}
  enableCors(options: any): any {}
  createMiddlewareFactory(requestMethod: RequestMethod): any {}
  getType() {
    return '';
  }
  applyVersionFilter(
    handler: Function,
    version: VersionValue,
    versioningOptions: VersioningOptions,
  ) {
    return (req, res, next) => {
      return () => {};
    };
  }
}



================================================
FILE: packages/core/test/utils/string.cleaner.ts
================================================
export function stringCleaner(str: string) {
  return str ? str.replace(/\s+/g, '').replace(/\n+/g, '') : str;
}



================================================
FILE: packages/microservices/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/microservices/constants.ts
================================================
import { ROUTE_ARGS_METADATA } from '@nestjs/common/constants';

export const TCP_DEFAULT_PORT = 3000;
export const TCP_DEFAULT_HOST = 'localhost';
export const REDIS_DEFAULT_PORT = 6379;
export const REDIS_DEFAULT_HOST = 'localhost';
export const NATS_DEFAULT_URL = 'nats://localhost:4222';
export const MQTT_DEFAULT_URL = 'mqtt://localhost:1883';
export const GRPC_DEFAULT_URL = 'localhost:5000';
export const RQM_DEFAULT_URL = 'amqp://localhost';
export const KAFKA_DEFAULT_BROKER = 'localhost:9092';
export const KAFKA_DEFAULT_CLIENT = 'nestjs-consumer';
export const KAFKA_DEFAULT_GROUP = 'nestjs-group';
export const MQTT_SEPARATOR = '/';
export const MQTT_WILDCARD_SINGLE = '+';
export const MQTT_WILDCARD_ALL = '#';
export const RQM_DEFAULT_QUEUE = 'default';
export const RQM_DEFAULT_PREFETCH_COUNT = 0;
export const RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT = false;
export const RQM_DEFAULT_QUEUE_OPTIONS = {};
export const RQM_DEFAULT_NOACK = true;
export const RQM_DEFAULT_PERSISTENT = false;
export const RQM_DEFAULT_NO_ASSERT = false;

export const ECONNREFUSED = 'ECONNREFUSED';
export const CONN_ERR = 'CONN_ERR';
export const EADDRINUSE = 'EADDRINUSE';
export const ENOTFOUND = 'ENOTFOUND';

export const PATTERN_METADATA = 'microservices:pattern';
export const PATTERN_EXTRAS_METADATA = 'microservices:pattern_extras';
export const TRANSPORT_METADATA = 'microservices:transport';
export const CLIENT_CONFIGURATION_METADATA = 'microservices:client';
export const PATTERN_HANDLER_METADATA = 'microservices:handler_type';
export const CLIENT_METADATA = 'microservices:is_client_instance';
export const PARAM_ARGS_METADATA = ROUTE_ARGS_METADATA;
export const REQUEST_PATTERN_METADATA = 'microservices:request_pattern';
export const REPLY_PATTERN_METADATA = 'microservices:reply_pattern';

export const RQM_NO_EVENT_HANDLER = (
  text: TemplateStringsArray,
  pattern: string,
) =>
  `An unsupported event was received. It has been negative acknowledged, so it will not be re-delivered. Pattern: ${pattern}`;
export const RQM_NO_MESSAGE_HANDLER = (
  text: TemplateStringsArray,
  pattern: string,
) =>
  `An unsupported message was received. It has been negative acknowledged, so it will not be re-delivered. Pattern: ${pattern}`;
export const GRPC_DEFAULT_PROTO_LOADER = '@grpc/proto-loader';

export const NO_EVENT_HANDLER = (text: TemplateStringsArray, pattern: string) =>
  `There is no matching event handler defined in the remote service. Event pattern: ${pattern}`;
export const NO_MESSAGE_HANDLER = `There is no matching message handler defined in the remote service.`;
export const DISCONNECTED_RMQ_MESSAGE = `Disconnected from RMQ. Trying to reconnect.`;
export const CONNECTION_FAILED_MESSAGE =
  'Connection to transport failed. Trying to reconnect...';

export const NATS_DEFAULT_GRACE_PERIOD = 10000;



================================================
FILE: packages/microservices/container.ts
================================================
import { ClientProxy } from './client/client-proxy';

export class ClientsContainer {
  private clients: ClientProxy[] = [];

  public getAllClients(): ClientProxy[] {
    return this.clients;
  }

  public addClient(client: ClientProxy) {
    this.clients.push(client);
  }

  public clear() {
    this.clients = [];
  }
}



================================================
FILE: packages/microservices/index.ts
================================================
/*
 * Nest @microservices
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */
import 'reflect-metadata';

export * from './client';
export * from './ctx-host';
export * from './decorators';
export * from './enums';
export * from './events';
export * from './exceptions';
export * from './helpers';
export * from './interfaces';
export * from './module';
export * from './nest-microservice';
export * from './record-builders';
export * from './server';
export * from './tokens';



================================================
FILE: packages/microservices/listener-metadata-explorer.ts
================================================
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { isFunction, isUndefined } from '@nestjs/common/utils/shared.utils';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import {
  CLIENT_CONFIGURATION_METADATA,
  CLIENT_METADATA,
  PATTERN_EXTRAS_METADATA,
  PATTERN_HANDLER_METADATA,
  PATTERN_METADATA,
  TRANSPORT_METADATA,
} from './constants';
import { Transport } from './enums';
import { PatternHandler } from './enums/pattern-handler.enum';
import { ClientOptions, PatternMetadata } from './interfaces';

export interface ClientProperties {
  property: string;
  metadata: ClientOptions;
}

export interface EventOrMessageListenerDefinition {
  patterns: PatternMetadata[];
  methodKey: string;
  isEventHandler: boolean;
  targetCallback: (...args: any[]) => any;
  transport?: Transport;
  extras?: Record<string, any>;
}

export interface MessageRequestProperties {
  requestPattern: PatternMetadata;
  replyPattern: PatternMetadata;
}

export class ListenerMetadataExplorer {
  constructor(private readonly metadataScanner: MetadataScanner) {}

  public explore(instance: Controller): EventOrMessageListenerDefinition[] {
    const instancePrototype = Object.getPrototypeOf(instance);
    return this.metadataScanner
      .getAllMethodNames(instancePrototype)
      .map(
        method =>
          this.exploreMethodMetadata(instance, instancePrototype, method)!,
      )
      .filter(metadata => metadata);
  }

  public exploreMethodMetadata(
    instance: Controller,
    instancePrototype: object,
    methodKey: string,
  ): EventOrMessageListenerDefinition | undefined {
    const prototypeCallback = instancePrototype[methodKey];
    const handlerType = Reflect.getMetadata(
      PATTERN_HANDLER_METADATA,
      prototypeCallback,
    );
    if (isUndefined(handlerType)) {
      return;
    }
    const patterns = Reflect.getMetadata(PATTERN_METADATA, prototypeCallback);
    const transport = Reflect.getMetadata(
      TRANSPORT_METADATA,
      prototypeCallback,
    );
    const extras = Reflect.getMetadata(
      PATTERN_EXTRAS_METADATA,
      prototypeCallback,
    );

    const targetCallback = instance[methodKey];
    return {
      methodKey,
      targetCallback,
      patterns,
      transport,
      extras,
      isEventHandler: handlerType === PatternHandler.EVENT,
    };
  }

  public *scanForClientHooks(
    instance: Controller,
  ): IterableIterator<ClientProperties> {
    for (const propertyKey in instance) {
      if (isFunction(propertyKey)) {
        continue;
      }
      const property = String(propertyKey);
      const isClient = Reflect.getMetadata(CLIENT_METADATA, instance, property);
      if (isUndefined(isClient)) {
        continue;
      }
      const metadata = Reflect.getMetadata(
        CLIENT_CONFIGURATION_METADATA,
        instance,
        property,
      );
      yield { property, metadata };
    }
  }
}



================================================
FILE: packages/microservices/listeners-controller.ts
================================================
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import { ContextIdFactory } from '@nestjs/core/helpers/context-id-factory';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { STATIC_CONTEXT } from '@nestjs/core/injector/constants';
import { NestContainer } from '@nestjs/core/injector/container';
import { Injector } from '@nestjs/core/injector/injector';
import {
  ContextId,
  InstanceWrapper,
} from '@nestjs/core/injector/instance-wrapper';
import { Module } from '@nestjs/core/injector/module';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import { REQUEST_CONTEXT_ID } from '@nestjs/core/router/request/request-constants';
import {
  forkJoin,
  from as fromPromise,
  isObservable,
  mergeMap,
  Observable,
  ObservedValueOf,
  of,
} from 'rxjs';
import { IClientProxyFactory } from './client/client-proxy-factory';
import { ClientsContainer } from './container';
import { ExceptionFiltersContext } from './context/exception-filters-context';
import { RequestContextHost } from './context/request-context-host';
import { RpcContextCreator } from './context/rpc-context-creator';
import {
  DEFAULT_CALLBACK_METADATA,
  DEFAULT_GRPC_CALLBACK_METADATA,
} from './context/rpc-metadata-constants';
import { BaseRpcContext } from './ctx-host/base-rpc.context';
import { Transport } from './enums';
import { MessageHandler, PatternMetadata, RequestContext } from './interfaces';
import { MicroserviceEntrypointMetadata } from './interfaces/microservice-entrypoint-metadata.interface';
import {
  EventOrMessageListenerDefinition,
  ListenerMetadataExplorer,
} from './listener-metadata-explorer';
import { ServerGrpc } from './server';
import { Server } from './server/server';

export class ListenersController {
  private readonly metadataExplorer = new ListenerMetadataExplorer(
    new MetadataScanner(),
  );
  private readonly exceptionFiltersCache = new WeakMap();

  constructor(
    private readonly clientsContainer: ClientsContainer,
    private readonly contextCreator: RpcContextCreator,
    private readonly container: NestContainer,
    private readonly injector: Injector,
    private readonly clientFactory: IClientProxyFactory,
    private readonly exceptionFiltersContext: ExceptionFiltersContext,
    private readonly graphInspector: GraphInspector,
  ) {}

  public registerPatternHandlers(
    instanceWrapper: InstanceWrapper<Controller>,
    serverInstance: Server,
    moduleKey: string,
  ) {
    const { instance } = instanceWrapper;

    const isStatic = instanceWrapper.isDependencyTreeStatic();
    const patternHandlers = this.metadataExplorer.explore(instance);
    const moduleRef = this.container.getModuleByKey(moduleKey);
    const defaultCallMetadata =
      serverInstance instanceof ServerGrpc
        ? DEFAULT_GRPC_CALLBACK_METADATA
        : DEFAULT_CALLBACK_METADATA;

    patternHandlers
      .filter(
        ({ transport }) =>
          isUndefined(transport) ||
          isUndefined(serverInstance.transportId) ||
          transport === serverInstance.transportId,
      )
      .reduce((acc, handler) => {
        handler.patterns.forEach(pattern =>
          acc.push({ ...handler, patterns: [pattern] }),
        );
        return acc;
      }, [] as EventOrMessageListenerDefinition[])
      .forEach((definition: EventOrMessageListenerDefinition) => {
        const {
          patterns: [pattern],
          targetCallback,
          methodKey,
          extras,
          isEventHandler,
        } = definition;

        this.insertEntrypointDefinition(
          instanceWrapper,
          definition,
          serverInstance.transportId!,
        );

        if (isStatic) {
          const proxy = this.contextCreator.create(
            instance,
            targetCallback,
            moduleKey,
            methodKey,
            STATIC_CONTEXT,
            undefined,
            defaultCallMetadata,
          );
          if (isEventHandler) {
            const eventHandler: MessageHandler = async (...args: unknown[]) => {
              const originalArgs = args;
              const [dataOrContextHost] = originalArgs;
              if (dataOrContextHost instanceof RequestContextHost) {
                args = args.slice(1, args.length);
              }
              const returnValue = proxy(...args);
              return this.forkJoinHandlersIfAttached(
                returnValue,
                originalArgs,
                eventHandler,
              );
            };
            return serverInstance.addHandler(
              pattern,
              eventHandler,
              isEventHandler,
              extras,
            );
          } else {
            return serverInstance.addHandler(
              pattern,
              proxy,
              isEventHandler,
              extras,
            );
          }
        }
        const asyncHandler = this.createRequestScopedHandler(
          instanceWrapper,
          pattern,
          moduleRef!,
          moduleKey,
          methodKey,
          defaultCallMetadata,
          isEventHandler,
        );
        serverInstance.addHandler(
          pattern,
          asyncHandler,
          isEventHandler,
          extras,
        );
      });
  }

  public insertEntrypointDefinition(
    instanceWrapper: InstanceWrapper,
    definition: EventOrMessageListenerDefinition,
    transportId: Transport | symbol,
  ) {
    this.graphInspector.insertEntrypointDefinition<MicroserviceEntrypointMetadata>(
      {
        type: 'microservice',
        methodName: definition.methodKey,
        className: instanceWrapper.metatype?.name as string,
        classNodeId: instanceWrapper.id,
        metadata: {
          key: definition.patterns.toString(),
          transportId:
            typeof transportId === 'number'
              ? (Transport[transportId] as keyof typeof Transport)
              : transportId,
          patterns: definition.patterns,
          isEventHandler: definition.isEventHandler,
          extras: definition.extras,
        },
      },
      instanceWrapper.id,
    );
  }

  public forkJoinHandlersIfAttached(
    currentReturnValue: Promise<unknown> | Observable<unknown>,
    originalArgs: unknown[],
    handlerRef: MessageHandler,
  ) {
    if (handlerRef.next) {
      const returnedValueWrapper = handlerRef.next(
        ...(originalArgs as Parameters<MessageHandler>),
      );
      return forkJoin({
        current: this.transformToObservable(currentReturnValue),
        next: this.transformToObservable(returnedValueWrapper),
      });
    }
    return currentReturnValue;
  }

  public assignClientsToProperties(instance: Controller) {
    for (const {
      property,
      metadata,
    } of this.metadataExplorer.scanForClientHooks(instance)) {
      const client = this.clientFactory.create(metadata);
      this.clientsContainer.addClient(client);

      this.assignClientToInstance(instance, property, client);
    }
  }

  public assignClientToInstance<T = any>(
    instance: Controller,
    property: string,
    client: T,
  ) {
    Reflect.set(instance, property, client);
  }

  public createRequestScopedHandler(
    wrapper: InstanceWrapper,
    pattern: PatternMetadata,
    moduleRef: Module,
    moduleKey: string,
    methodKey: string,
    defaultCallMetadata: Record<string, any> = DEFAULT_CALLBACK_METADATA,
    isEventHandler = false,
  ) {
    const collection = moduleRef.controllers;
    const { instance } = wrapper;

    const isTreeDurable = wrapper.isDependencyTreeDurable();

    const requestScopedHandler: MessageHandler = async (...args: unknown[]) => {
      try {
        let contextId: ContextId;

        let [dataOrContextHost] = args;
        if (dataOrContextHost instanceof RequestContextHost) {
          contextId = this.getContextId(dataOrContextHost, isTreeDurable);
          args.shift();
        } else {
          const [data, reqCtx] = args;
          const request = RequestContextHost.create(
            pattern,
            data,
            reqCtx as BaseRpcContext,
          );
          contextId = this.getContextId(request, isTreeDurable);
          dataOrContextHost = request;
        }

        const contextInstance = await this.injector.loadPerContext(
          instance,
          moduleRef,
          collection,
          contextId,
        );
        const proxy = this.contextCreator.create(
          contextInstance,
          contextInstance[methodKey],
          moduleKey,
          methodKey,
          contextId,
          wrapper.id,
          defaultCallMetadata,
        );

        const returnValue = proxy(...args);
        if (isEventHandler) {
          return this.forkJoinHandlersIfAttached(
            returnValue,
            [dataOrContextHost, ...args],
            requestScopedHandler,
          );
        }
        return returnValue;
      } catch (err) {
        let exceptionFilter = this.exceptionFiltersCache.get(
          instance[methodKey],
        );
        if (!exceptionFilter) {
          exceptionFilter = this.exceptionFiltersContext.create(
            instance,
            instance[methodKey],
            moduleKey,
          );
          this.exceptionFiltersCache.set(instance[methodKey], exceptionFilter);
        }
        const host = new ExecutionContextHost(args);
        host.setType('rpc');
        return exceptionFilter.handle(err, host);
      }
    };
    return requestScopedHandler;
  }

  private getContextId<T extends RequestContext = any>(
    request: T,
    isTreeDurable: boolean,
  ): ContextId {
    const contextId = ContextIdFactory.getByRequest(request);
    if (!request[REQUEST_CONTEXT_ID as any]) {
      Object.defineProperty(request, REQUEST_CONTEXT_ID, {
        value: contextId,
        enumerable: false,
        writable: false,
        configurable: false,
      });

      const requestProviderValue = isTreeDurable
        ? contextId.payload
        : Object.assign(request, contextId.payload);
      this.container.registerRequestProvider(requestProviderValue, contextId);
    }
    return contextId;
  }

  public transformToObservable<T>(
    resultOrDeferred: Observable<T> | Promise<T>,
  ): Observable<T>;
  public transformToObservable<T>(
    resultOrDeferred: T,
  ): never extends Observable<ObservedValueOf<T>>
    ? Observable<T>
    : Observable<ObservedValueOf<T>>;
  public transformToObservable(resultOrDeferred: any) {
    if (resultOrDeferred instanceof Promise) {
      return fromPromise(resultOrDeferred).pipe(
        mergeMap(val => (isObservable(val) ? val : of(val))),
      );
    }

    if (isObservable(resultOrDeferred)) {
      return resultOrDeferred;
    }

    return of(resultOrDeferred);
  }
}



================================================
FILE: packages/microservices/microservices-module.ts
================================================
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';
import { GuardsConsumer, GuardsContextCreator } from '@nestjs/core/guards';
import { NestContainer } from '@nestjs/core/injector/container';
import { Injector } from '@nestjs/core/injector/injector';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import {
  InterceptorsConsumer,
  InterceptorsContextCreator,
} from '@nestjs/core/interceptors';
import { PipesConsumer, PipesContextCreator } from '@nestjs/core/pipes';
import { ClientProxyFactory } from './client';
import { ClientsContainer } from './container';
import { ExceptionFiltersContext } from './context/exception-filters-context';
import { RpcContextCreator } from './context/rpc-context-creator';
import { RpcProxy } from './context/rpc-proxy';
import { ListenersController } from './listeners-controller';
import { Server } from './server/server';

export class MicroservicesModule<
  TAppOptions extends
    NestApplicationContextOptions = NestApplicationContextOptions,
> {
  private readonly clientsContainer = new ClientsContainer();
  private listenersController: ListenersController;
  private appOptions: TAppOptions;

  public register(
    container: NestContainer,
    graphInspector: GraphInspector,
    config: ApplicationConfig,
    options: TAppOptions,
  ) {
    this.appOptions = options;
    const exceptionFiltersContext = new ExceptionFiltersContext(
      container,
      config,
    );
    const contextCreator = new RpcContextCreator(
      new RpcProxy(),
      exceptionFiltersContext,
      new PipesContextCreator(container, config),
      new PipesConsumer(),
      new GuardsContextCreator(container, config),
      new GuardsConsumer(),
      new InterceptorsContextCreator(container, config),
      new InterceptorsConsumer(),
    );

    const injector = new Injector();
    this.listenersController = new ListenersController(
      this.clientsContainer,
      contextCreator,
      container,
      injector,
      ClientProxyFactory,
      exceptionFiltersContext,
      graphInspector,
    );
  }

  public setupListeners(container: NestContainer, serverInstance: Server) {
    if (!this.listenersController) {
      throw new RuntimeException();
    }
    const modules = container.getModules();
    modules.forEach(({ controllers }, moduleRef) =>
      this.bindListeners(controllers, serverInstance, moduleRef),
    );
  }

  public setupClients(container: NestContainer) {
    if (!this.listenersController) {
      throw new RuntimeException();
    }
    if (this.appOptions?.preview) {
      return;
    }
    const modules = container.getModules();
    modules.forEach(({ controllers, providers }) => {
      this.bindClients(controllers);
      this.bindClients(providers);
    });
  }

  public bindListeners(
    controllers: Map<string | symbol | Function, InstanceWrapper<Controller>>,
    serverInstance: Server,
    moduleName: string,
  ) {
    controllers.forEach(wrapper =>
      this.listenersController.registerPatternHandlers(
        wrapper,
        serverInstance,
        moduleName,
      ),
    );
  }

  public bindClients(
    items: Map<string | symbol | Function, InstanceWrapper<unknown>>,
  ) {
    items.forEach(({ instance, isNotMetatype }) => {
      !isNotMetatype &&
        this.listenersController.assignClientsToProperties(instance as object);
    });
  }

  public async close() {
    const clients = this.clientsContainer.getAllClients();
    await Promise.all(clients.map(client => client.close()));
    this.clientsContainer.clear();
  }
}



================================================
FILE: packages/microservices/nest-microservice.ts
================================================
import {
  CanActivate,
  ExceptionFilter,
  INestMicroservice,
  NestInterceptor,
  PipeTransform,
  WebSocketAdapter,
} from '@nestjs/common';
import { NestMicroserviceOptions } from '@nestjs/common/interfaces/microservices/nest-microservice-options.interface';
import { Logger } from '@nestjs/common/services/logger.service';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { MESSAGES } from '@nestjs/core/constants';
import { optionalRequire } from '@nestjs/core/helpers/optional-require';
import { NestContainer } from '@nestjs/core/injector/container';
import { Injector } from '@nestjs/core/injector/injector';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import { NestApplicationContext } from '@nestjs/core/nest-application-context';
import { Transport } from './enums/transport.enum';
import {
  AsyncMicroserviceOptions,
  MicroserviceOptions,
} from './interfaces/microservice-configuration.interface';
import { MicroservicesModule } from './microservices-module';
import { Server } from './server/server';
import { ServerFactory } from './server/server-factory';

const { SocketModule } = optionalRequire(
  '@nestjs/websockets/socket-module',
  () => require('@nestjs/websockets/socket-module'),
);

type CompleteMicroserviceOptions = NestMicroserviceOptions &
  (MicroserviceOptions | AsyncMicroserviceOptions);

export class NestMicroservice
  extends NestApplicationContext<NestMicroserviceOptions>
  implements INestMicroservice
{
  protected readonly logger = new Logger(NestMicroservice.name, {
    timestamp: true,
  });
  private readonly microservicesModule = new MicroservicesModule();
  private readonly socketModule = SocketModule ? new SocketModule() : null;
  private microserviceConfig: Exclude<
    CompleteMicroserviceOptions,
    AsyncMicroserviceOptions
  >;
  private serverInstance: Server;
  private isTerminated = false;
  private wasInitHookCalled = false;

  /**
   * Returns an observable that emits status changes.
   */
  get status() {
    return this.serverInstance.status;
  }

  constructor(
    container: NestContainer,
    config: CompleteMicroserviceOptions = {},
    private readonly graphInspector: GraphInspector,
    private readonly applicationConfig: ApplicationConfig,
  ) {
    super(container, config);

    this.injector = new Injector({ preview: config.preview! });
    this.microservicesModule.register(
      container,
      this.graphInspector,
      this.applicationConfig,
      this.appOptions,
    );
    this.createServer(config);
    this.selectContextModule();
  }

  public createServer(config: CompleteMicroserviceOptions) {
    try {
      if ('useFactory' in config) {
        this.microserviceConfig = this.resolveAsyncOptions(config);
      } else {
        this.microserviceConfig = {
          transport: Transport.TCP,
          ...config,
        } as MicroserviceOptions;
      }

      if ('strategy' in config) {
        this.serverInstance = config.strategy as Server;
        return;
      } else {
        this.serverInstance = ServerFactory.create(
          this.microserviceConfig,
        ) as Server;
      }
    } catch (e) {
      this.logger.error(e);
      throw e;
    }
  }

  public async registerModules(): Promise<any> {
    this.socketModule &&
      this.socketModule.register(
        this.container,
        this.applicationConfig,
        this.graphInspector,
        this.appOptions,
      );

    if (!this.appOptions.preview) {
      this.microservicesModule.setupClients(this.container);
      this.registerListeners();
    }

    this.setIsInitialized(true);

    if (!this.wasInitHookCalled) {
      await this.callInitHook();
      await this.callBootstrapHook();
    }
  }

  public registerListeners() {
    this.microservicesModule.setupListeners(
      this.container,
      this.serverInstance,
    );
  }

  /**
   * Registers a web socket adapter that will be used for Gateways.
   * Use to override the default `socket.io` library.
   *
   * @param {WebSocketAdapter} adapter
   * @returns {this}
   */
  public useWebSocketAdapter(adapter: WebSocketAdapter): this {
    this.applicationConfig.setIoAdapter(adapter);
    return this;
  }

  /**
   * Registers global exception filters (will be used for every pattern handler).
   *
   * @param {...ExceptionFilter} filters
   */
  public useGlobalFilters(...filters: ExceptionFilter[]): this {
    this.applicationConfig.useGlobalFilters(...filters);
    filters.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'filter',
        ref: item,
      }),
    );
    return this;
  }

  /**
   * Registers global pipes (will be used for every pattern handler).
   *
   * @param {...PipeTransform} pipes
   */
  public useGlobalPipes(...pipes: PipeTransform<any>[]): this {
    this.applicationConfig.useGlobalPipes(...pipes);
    pipes.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'pipe',
        ref: item,
      }),
    );
    return this;
  }

  /**
   * Registers global interceptors (will be used for every pattern handler).
   *
   * @param {...NestInterceptor} interceptors
   */
  public useGlobalInterceptors(...interceptors: NestInterceptor[]): this {
    this.applicationConfig.useGlobalInterceptors(...interceptors);
    interceptors.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'interceptor',
        ref: item,
      }),
    );
    return this;
  }

  public useGlobalGuards(...guards: CanActivate[]): this {
    this.applicationConfig.useGlobalGuards(...guards);
    guards.forEach(item =>
      this.graphInspector.insertOrphanedEnhancer({
        subtype: 'guard',
        ref: item,
      }),
    );
    return this;
  }

  public async init(): Promise<this> {
    if (this.isInitialized) {
      return this;
    }
    await super.init();
    await this.registerModules();
    return this;
  }

  /**
   * Starts the microservice.
   *
   * @returns {void}
   */
  public async listen(): Promise<any> {
    this.assertNotInPreviewMode('listen');
    !this.isInitialized && (await this.registerModules());

    return new Promise<any>((resolve, reject) => {
      this.serverInstance.listen((err, info) => {
        if (this.microserviceConfig?.autoFlushLogs ?? true) {
          this.flushLogs();
        }
        if (err) {
          return reject(err as Error);
        }
        this.logger.log(MESSAGES.MICROSERVICE_READY);
        resolve(info);
      });
    });
  }

  /**
   * Terminates the application.
   *
   * @returns {Promise<void>}
   */
  public async close(): Promise<any> {
    await this.serverInstance.close();
    if (this.isTerminated) {
      return;
    }
    this.setIsTerminated(true);
    await this.closeApplication();
  }

  /**
   * Sets the flag indicating that the application is initialized.
   * @param isInitialized Value to set
   */
  public setIsInitialized(isInitialized: boolean) {
    this.isInitialized = isInitialized;
  }

  /**
   * Sets the flag indicating that the application is terminated.
   * @param isTerminated Value to set
   */
  public setIsTerminated(isTerminated: boolean) {
    this.isTerminated = isTerminated;
  }

  /**
   * Sets the flag indicating that the init hook was called.
   * @param isInitHookCalled Value to set
   */
  public setIsInitHookCalled(isInitHookCalled: boolean) {
    this.wasInitHookCalled = isInitHookCalled;
  }

  /**
   * Registers an event listener for the given event.
   * @param event Event name
   * @param callback Callback to be executed when the event is emitted
   */
  public on(event: string | number | symbol, callback: Function) {
    if ('on' in this.serverInstance) {
      return this.serverInstance.on(event as string, callback);
    }
    throw new Error('"on" method not supported by the underlying server');
  }

  /**
   * Returns an instance of the underlying server/broker instance,
   * or a group of servers if there are more than one.
   */
  public unwrap<T>(): T {
    if ('unwrap' in this.serverInstance) {
      return this.serverInstance.unwrap();
    }
    throw new Error('"unwrap" method not supported by the underlying server');
  }

  protected async closeApplication(): Promise<any> {
    this.socketModule && (await this.socketModule.close());
    this.microservicesModule && (await this.microservicesModule.close());

    await super.close();
    this.setIsTerminated(true);
  }

  protected async dispose(): Promise<void> {
    if (this.isTerminated) {
      return;
    }
    await this.serverInstance.close();
    this.socketModule && (await this.socketModule.close());
    this.microservicesModule && (await this.microservicesModule.close());
  }

  protected resolveAsyncOptions(config: AsyncMicroserviceOptions) {
    const args = config.inject?.map(token =>
      this.get(token, { strict: false }),
    );
    return config.useFactory(...args);
  }
}



================================================
FILE: packages/microservices/package.json
================================================
{
  "name": "@nestjs/microservices",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@microservices)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/microservices"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "iterare": "1.2.1",
    "tslib": "2.8.1"
  },
  "devDependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13"
  },
  "peerDependencies": {
    "@grpc/grpc-js": "*",
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/websockets": "^11.0.0",
    "amqp-connection-manager": "*",
    "amqplib": "*",
    "cache-manager": "*",
    "ioredis": "*",
    "kafkajs": "*",
    "mqtt": "*",
    "nats": "*",
    "reflect-metadata": "^0.1.12 || ^0.2.0",
    "rxjs": "^7.1.0"
  },
  "peerDependenciesMeta": {
    "@grpc/grpc-js": {
      "optional": true
    },
    "@nestjs/websockets": {
      "optional": true
    },
    "cache-manager": {
      "optional": true
    },
    "kafkajs": {
      "optional": true
    },
    "mqtt": {
      "optional": true
    },
    "nats": {
      "optional": true
    },
    "ioredis": {
      "optional": true
    },
    "amqplib": {
      "optional": true
    },
    "amqp-connection-manager": {
      "optional": true
    }
  }
}



================================================
FILE: packages/microservices/tokens.ts
================================================
import { REQUEST } from '@nestjs/core';

export const CONTEXT = REQUEST;



================================================
FILE: packages/microservices/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/core": ["../core"],
      "@nestjs/core/*": ["../core/*"],
      "@nestjs/websockets": ["../websockets"],
      "@nestjs/websockets/*": ["../websockets/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../core/tsconfig.build.json"
    },
    {
      "path": "../websockets/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/microservices/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/microservices/client/client-grpc.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isFunction, isObject } from '@nestjs/common/utils/shared.utils';
import { Observable, Subscription } from 'rxjs';
import { GRPC_DEFAULT_PROTO_LOADER, GRPC_DEFAULT_URL } from '../constants';
import { InvalidGrpcPackageException } from '../errors/invalid-grpc-package.exception';
import { InvalidGrpcServiceException } from '../errors/invalid-grpc-service.exception';
import { InvalidProtoDefinitionException } from '../errors/invalid-proto-definition.exception';
import { ChannelOptions } from '../external/grpc-options.interface';
import { getGrpcPackageDefinition } from '../helpers';
import { ClientGrpc, GrpcOptions } from '../interfaces';
import { ClientProxy } from './client-proxy';

const GRPC_CANCELLED = 'Cancelled';

// To enable type safety for gRPC. This cant be uncommented by default
// because it would require the user to install the @grpc/grpc-js package even if they dont use gRPC
// Otherwise, TypeScript would fail to compile the code.
//
// type GrpcClient = import('@grpc/grpc-js').Client;
// let grpcPackage = {} as typeof import('@grpc/grpc-js');
// let grpcProtoLoaderPackage = {} as typeof import('@grpc/proto-loader');

type GrpcClient = any;
let grpcPackage = {} as any;
let grpcProtoLoaderPackage = {} as any;

/**
 * @publicApi
 */
export class ClientGrpcProxy
  extends ClientProxy<never, never>
  implements ClientGrpc
{
  protected readonly logger = new Logger(ClientProxy.name);
  protected readonly clients = new Map<string, any>();
  protected readonly url: string;
  protected grpcClients: GrpcClient[] = [];

  get status(): never {
    throw new Error(
      'The "status" attribute is not supported by the gRPC transport',
    );
  }

  constructor(protected readonly options: Required<GrpcOptions>['options']) {
    super();
    this.url = this.getOptionsProp(options, 'url') || GRPC_DEFAULT_URL;

    const protoLoader =
      this.getOptionsProp(options, 'protoLoader') || GRPC_DEFAULT_PROTO_LOADER;

    grpcPackage = loadPackage('@grpc/grpc-js', ClientGrpcProxy.name, () =>
      require('@grpc/grpc-js'),
    );

    grpcProtoLoaderPackage = loadPackage(
      protoLoader,
      ClientGrpcProxy.name,
      () =>
        protoLoader === GRPC_DEFAULT_PROTO_LOADER
          ? require('@grpc/proto-loader')
          : require(protoLoader),
    );
    this.grpcClients = this.createClients();
  }

  public getService<T extends object>(name: string): T {
    const grpcClient = this.getClientByServiceName(name);
    const clientRef = this.getClient(name);
    if (!clientRef) {
      throw new InvalidGrpcServiceException(name);
    }

    const protoMethods = Object.keys(clientRef[name].prototype);
    const grpcService = {} as T;

    protoMethods.forEach(m => {
      grpcService[m] = this.createServiceMethod(grpcClient, m);
    });
    return grpcService;
  }

  public getClientByServiceName<T = unknown>(name: string): T {
    return this.clients.get(name) || this.createClientByServiceName(name);
  }

  public createClientByServiceName(name: string) {
    const clientRef = this.getClient(name);
    if (!clientRef) {
      throw new InvalidGrpcServiceException(name);
    }

    const channelOptions: ChannelOptions =
      this.options && this.options.channelOptions
        ? this.options.channelOptions
        : {};
    if (this.options && this.options.maxSendMessageLength) {
      channelOptions['grpc.max_send_message_length'] =
        this.options.maxSendMessageLength;
    }
    if (this.options && this.options.maxReceiveMessageLength) {
      channelOptions['grpc.max_receive_message_length'] =
        this.options.maxReceiveMessageLength;
    }
    if (this.options && this.options.maxMetadataSize) {
      channelOptions['grpc.max_metadata_size'] = this.options.maxMetadataSize;
    }

    const keepaliveOptions = this.getKeepaliveOptions();
    const options: Record<string, string | number> = {
      ...channelOptions,
      ...keepaliveOptions,
    };

    const credentials =
      this.options.credentials || grpcPackage.credentials.createInsecure();

    const grpcClient = new clientRef[name](this.url, credentials, options);
    this.clients.set(name, grpcClient);
    return grpcClient;
  }

  public getKeepaliveOptions() {
    if (!isObject(this.options.keepalive)) {
      return {};
    }
    const keepaliveKeys: Record<
      keyof GrpcOptions['options']['keepalive'],
      string
    > = {
      keepaliveTimeMs: 'grpc.keepalive_time_ms',
      keepaliveTimeoutMs: 'grpc.keepalive_timeout_ms',
      keepalivePermitWithoutCalls: 'grpc.keepalive_permit_without_calls',
      http2MaxPingsWithoutData: 'grpc.http2.max_pings_without_data',
      http2MinTimeBetweenPingsMs: 'grpc.http2.min_time_between_pings_ms',
      http2MinPingIntervalWithoutDataMs:
        'grpc.http2.min_ping_interval_without_data_ms',
      http2MaxPingStrikes: 'grpc.http2.max_ping_strikes',
    };

    const keepaliveOptions = {};
    for (const [optionKey, optionValue] of Object.entries(
      this.options.keepalive,
    )) {
      const key = keepaliveKeys[optionKey];
      if (key === undefined) {
        continue;
      }
      keepaliveOptions[key] = optionValue;
    }
    return keepaliveOptions;
  }

  public createServiceMethod(
    client: any,
    methodName: string,
  ): (...args: unknown[]) => Observable<unknown> {
    return client[methodName].responseStream
      ? this.createStreamServiceMethod(client, methodName)
      : this.createUnaryServiceMethod(client, methodName);
  }

  public createStreamServiceMethod(
    client: unknown,
    methodName: string,
  ): (...args: any[]) => Observable<any> {
    return (...args: any[]) => {
      const isRequestStream = client![methodName].requestStream;
      const stream = new Observable(observer => {
        let isClientCanceled = false;
        let upstreamSubscription: Subscription | null = null;

        const upstreamSubjectOrData = args[0];
        const maybeMetadata = args[1];

        const isUpstreamSubject =
          upstreamSubjectOrData && isFunction(upstreamSubjectOrData.subscribe);

        const call =
          isRequestStream && isUpstreamSubject
            ? client![methodName](maybeMetadata)
            : client![methodName](...args);

        if (isRequestStream && isUpstreamSubject) {
          upstreamSubscription = upstreamSubjectOrData.subscribe(
            (val: unknown) => call.write(val),
            (err: unknown) => call.emit('error', err),
            () => call.end(),
          );
        }
        call.on('data', (data: any) => observer.next(data));
        call.on('error', (error: any) => {
          if (error.details === GRPC_CANCELLED) {
            call.destroy();
            if (isClientCanceled) {
              return;
            }
          }
          observer.error(this.serializeError(error));
        });
        call.on('end', () => {
          if (upstreamSubscription) {
            upstreamSubscription.unsubscribe();
            upstreamSubscription = null;
          }
          call.removeAllListeners();
          observer.complete();
        });
        return () => {
          if (upstreamSubscription) {
            upstreamSubscription.unsubscribe();
            upstreamSubscription = null;
          }

          if (call.finished) {
            return undefined;
          }
          isClientCanceled = true;
          call.cancel();
        };
      });
      return stream;
    };
  }

  public createUnaryServiceMethod(
    client: any,
    methodName: string,
  ): (...args: any[]) => Observable<any> {
    return (...args: any[]) => {
      const isRequestStream = client[methodName].requestStream;
      const upstreamSubjectOrData = args[0];
      const isUpstreamSubject =
        upstreamSubjectOrData && isFunction(upstreamSubjectOrData.subscribe);

      if (isRequestStream && isUpstreamSubject) {
        return new Observable(observer => {
          let isClientCanceled = false;
          const callArgs = [
            (error: any, data: unknown) => {
              if (error) {
                if (error.details === GRPC_CANCELLED || error.code === 1) {
                  call.destroy();
                  if (isClientCanceled) {
                    return;
                  }
                }
                return observer.error(this.serializeError(error));
              }
              observer.next(data);
              observer.complete();
            },
          ];
          const maybeMetadata = args[1];
          if (maybeMetadata) {
            callArgs.unshift(maybeMetadata);
          }
          const call = client[methodName](...callArgs);

          const upstreamSubscription: Subscription =
            upstreamSubjectOrData.subscribe(
              (val: unknown) => call.write(val),
              (err: unknown) => call.emit('error', err),
              () => call.end(),
            );

          return () => {
            upstreamSubscription.unsubscribe();
            if (!call.finished) {
              isClientCanceled = true;
              call.cancel();
            }
          };
        });
      }
      return new Observable(observer => {
        const call = client[methodName](...args, (error: any, data: any) => {
          if (error) {
            return observer.error(this.serializeError(error));
          }
          observer.next(data);
          observer.complete();
        });

        return () => {
          if (!call.finished) {
            call.cancel();
          }
        };
      });
    };
  }

  public createClients(): any[] {
    const grpcContext = this.loadProto();
    const packageOption = this.getOptionsProp(this.options, 'package');
    const grpcPackages: any[] = [];
    const packageNames = Array.isArray(packageOption)
      ? packageOption
      : [packageOption];

    for (const packageName of packageNames) {
      const grpcPkg = this.lookupPackage(grpcContext, packageName);

      if (!grpcPkg) {
        const invalidPackageError = new InvalidGrpcPackageException(
          packageName,
        );
        this.logger.error(
          invalidPackageError.message,
          invalidPackageError.stack,
        );
        throw invalidPackageError;
      }
      grpcPackages.push(grpcPkg);
    }
    return grpcPackages;
  }

  public loadProto(): any {
    try {
      const packageDefinition = getGrpcPackageDefinition(
        this.options,
        grpcProtoLoaderPackage,
      );
      return grpcPackage.loadPackageDefinition(packageDefinition);
    } catch (err) {
      const invalidProtoError = new InvalidProtoDefinitionException(err.path);
      const message =
        err && err.message ? err.message : invalidProtoError.message;

      this.logger.error(message, invalidProtoError.stack);
      throw invalidProtoError;
    }
  }

  public lookupPackage(root: any, packageName: string) {
    /** Reference: https://github.com/kondi/rxjs-grpc */
    let pkg = root;

    if (packageName) {
      for (const name of packageName.split('.')) {
        pkg = pkg[name];
      }
    }

    return pkg;
  }

  public close() {
    this.clients.forEach(client => {
      if (client && isFunction(client.close)) {
        client.close();
      }
    });
    this.clients.clear();
    this.grpcClients = [];
  }

  public async connect(): Promise<any> {
    throw new Error('The "connect()" method is not supported in gRPC mode.');
  }

  public send<TResult = any, TInput = any>(
    pattern: any,
    data: TInput,
  ): Observable<TResult> {
    throw new Error(
      'Method is not supported in gRPC mode. Use ClientGrpc instead (learn more in the documentation).',
    );
  }

  protected getClient(name: string): any {
    return this.grpcClients.find(client =>
      Object.hasOwnProperty.call(client, name),
    );
  }

  protected publish(packet: any, callback: (packet: any) => any): any {
    throw new Error(
      'Method is not supported in gRPC mode. Use ClientGrpc instead (learn more in the documentation).',
    );
  }

  protected async dispatchEvent(packet: any): Promise<any> {
    throw new Error(
      'Method is not supported in gRPC mode. Use ClientGrpc instead (learn more in the documentation).',
    );
  }

  public on<EventKey extends never = never, EventCallback = any>(
    event: EventKey,
    callback: EventCallback,
  ) {
    throw new Error('Method is not supported in gRPC mode.');
  }

  public unwrap<T>(): T {
    throw new Error('Method is not supported in gRPC mode.');
  }
}



================================================
FILE: packages/microservices/client/client-kafka.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isNil, isUndefined } from '@nestjs/common/utils/shared.utils';
import {
  throwError as _throw,
  connectable,
  defer,
  Observable,
  Subject,
} from 'rxjs';
import { mergeMap } from 'rxjs/operators';
import {
  KAFKA_DEFAULT_BROKER,
  KAFKA_DEFAULT_CLIENT,
  KAFKA_DEFAULT_GROUP,
} from '../constants';
import { KafkaResponseDeserializer } from '../deserializers/kafka-response.deserializer';
import { KafkaHeaders } from '../enums';
import { InvalidKafkaClientTopicException } from '../errors/invalid-kafka-client-topic.exception';
import { InvalidMessageException } from '../errors/invalid-message.exception';
import { KafkaStatus } from '../events';
import {
  BrokersFunction,
  Consumer,
  ConsumerConfig,
  ConsumerGroupJoinEvent,
  EachMessagePayload,
  Kafka,
  KafkaConfig,
  KafkaMessage,
  Producer,
  TopicPartitionOffsetAndMetadata,
} from '../external/kafka.interface';
import {
  KafkaLogger,
  KafkaParser,
  KafkaReplyPartitionAssigner,
} from '../helpers';
import {
  ClientKafkaProxy,
  KafkaOptions,
  MsPattern,
  OutgoingEvent,
  ReadPacket,
  WritePacket,
} from '../interfaces';
import {
  KafkaRequest,
  KafkaRequestSerializer,
} from '../serializers/kafka-request.serializer';
import { ClientProxy } from './client-proxy';

let kafkaPackage: any = {};

/**
 * @publicApi
 */
export class ClientKafka
  extends ClientProxy<never, KafkaStatus>
  implements ClientKafkaProxy
{
  protected logger = new Logger(ClientKafka.name);
  protected client: Kafka | null = null;
  protected parser: KafkaParser | null = null;
  protected initialized: Promise<void> | null = null;
  protected responsePatterns: string[] = [];
  protected consumerAssignments: { [key: string]: number } = {};
  protected brokers: string[] | BrokersFunction;
  protected clientId: string;
  protected groupId: string;
  protected producerOnlyMode: boolean;
  protected _consumer: Consumer | null = null;
  protected _producer: Producer | null = null;

  get consumer(): Consumer {
    if (!this._consumer) {
      throw new Error(
        'No consumer initialized. Please, call the "connect" method first.',
      );
    }
    return this._consumer;
  }

  get producer(): Producer {
    if (!this._producer) {
      throw new Error(
        'No producer initialized. Please, call the "connect" method first.',
      );
    }
    return this._producer;
  }

  constructor(protected readonly options: Required<KafkaOptions>['options']) {
    super();

    const clientOptions = this.getOptionsProp(
      this.options,
      'client',
      {} as KafkaConfig,
    );
    const consumerOptions = this.getOptionsProp(
      this.options,
      'consumer',
      {} as ConsumerConfig,
    );
    const postfixId = this.getOptionsProp(this.options, 'postfixId', '-client');
    this.producerOnlyMode = this.getOptionsProp(
      this.options,
      'producerOnlyMode',
      false,
    );

    this.brokers = clientOptions.brokers || [KAFKA_DEFAULT_BROKER];

    // Append a unique id to the clientId and groupId
    // so they don't collide with a microservices client
    this.clientId =
      (clientOptions.clientId || KAFKA_DEFAULT_CLIENT) + postfixId;
    this.groupId = (consumerOptions.groupId || KAFKA_DEFAULT_GROUP) + postfixId;

    kafkaPackage = loadPackage('kafkajs', ClientKafka.name, () =>
      require('kafkajs'),
    );

    this.parser = new KafkaParser((options && options.parser) || undefined);

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public subscribeToResponseOf(pattern: unknown): void {
    const request = this.normalizePattern(pattern as MsPattern);
    this.responsePatterns.push(this.getResponsePatternName(request));
  }

  public async close(): Promise<void> {
    this._producer && (await this._producer.disconnect());
    this._consumer && (await this._consumer.disconnect());
    this._producer = null;
    this._consumer = null;
    this.initialized = null;
    this.client = null;
  }

  public async connect(): Promise<Producer> {
    if (this.initialized) {
      return this.initialized.then(() => this._producer!);
    }
    /* eslint-disable-next-line no-async-promise-executor */
    this.initialized = new Promise(async (resolve, reject) => {
      try {
        this.client = this.createClient();
        if (!this.producerOnlyMode) {
          const partitionAssigners = [
            (
              config: ConstructorParameters<
                typeof KafkaReplyPartitionAssigner
              >[1],
            ) => new KafkaReplyPartitionAssigner(this, config),
          ];

          const consumerOptions = Object.assign(
            {
              partitionAssigners,
            },
            this.options.consumer || {},
            {
              groupId: this.groupId,
            },
          );

          this._consumer = this.client!.consumer(consumerOptions);
          this.registerConsumerEventListeners();

          // Set member assignments on join and rebalance
          this._consumer.on(
            this._consumer.events.GROUP_JOIN,
            this.setConsumerAssignments.bind(this),
          );
          await this._consumer.connect();
          await this.bindTopics();
        }

        this._producer = this.client!.producer(this.options.producer || {});
        this.registerProducerEventListeners();
        await this._producer.connect();

        resolve();
      } catch (err) {
        reject(err);
      }
    });
    return this.initialized.then(() => this._producer!);
  }

  public async bindTopics(): Promise<void> {
    if (!this._consumer) {
      throw Error('No consumer initialized');
    }

    const consumerSubscribeOptions = this.options.subscribe || {};

    if (this.responsePatterns.length > 0) {
      await this._consumer.subscribe({
        ...consumerSubscribeOptions,
        topics: this.responsePatterns,
      });
    }

    await this._consumer.run(
      Object.assign(this.options.run || {}, {
        eachMessage: this.createResponseCallback(),
      }),
    );
  }

  public createClient<T = any>(): T {
    const kafkaConfig: KafkaConfig = Object.assign(
      { logCreator: KafkaLogger.bind(null, this.logger) },
      this.options.client,
      { brokers: this.brokers, clientId: this.clientId },
    );

    return new kafkaPackage.Kafka(kafkaConfig);
  }

  public createResponseCallback(): (payload: EachMessagePayload) => any {
    return async (payload: EachMessagePayload) => {
      const rawMessage = this.parser!.parse<KafkaMessage>(
        Object.assign(payload.message, {
          topic: payload.topic,
          partition: payload.partition,
        }),
      );
      if (isUndefined(rawMessage.headers![KafkaHeaders.CORRELATION_ID])) {
        return;
      }
      const { err, response, isDisposed, id } =
        await this.deserializer.deserialize(rawMessage);
      const callback = this.routingMap.get(id);
      if (!callback) {
        return;
      }
      if (err || isDisposed) {
        return callback({
          err,
          response,
          isDisposed,
        });
      }
      callback({
        err,
        response,
      });
    };
  }

  public getConsumerAssignments() {
    return this.consumerAssignments;
  }

  public emitBatch<TResult = any, TInput = any>(
    pattern: any,
    data: { messages: TInput[] },
  ): Observable<TResult> {
    if (isNil(pattern) || isNil(data)) {
      return _throw(() => new InvalidMessageException());
    }
    const source = defer(async () => this.connect()).pipe(
      mergeMap(() => this.dispatchBatchEvent({ pattern, data })),
    );
    const connectableSource = connectable(source, {
      connector: () => new Subject(),
      resetOnDisconnect: false,
    });
    connectableSource.connect();
    return connectableSource;
  }

  public commitOffsets(
    topicPartitions: TopicPartitionOffsetAndMetadata[],
  ): Promise<void> {
    if (this._consumer) {
      return this._consumer.commitOffsets(topicPartitions);
    } else {
      throw new Error('No consumer initialized');
    }
  }

  public unwrap<T>(): T {
    if (!this.client) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return this.client as T;
  }

  public on<
    EventKey extends string | number | symbol = string | number | symbol,
    EventCallback = any,
  >(event: EventKey, callback: EventCallback) {
    throw new Error('Method is not supported for Kafka client');
  }

  protected registerConsumerEventListeners() {
    if (!this._consumer) {
      return;
    }
    this._consumer.on(this._consumer.events.CONNECT, () =>
      this._status$.next(KafkaStatus.CONNECTED),
    );
    this._consumer.on(this._consumer.events.DISCONNECT, () =>
      this._status$.next(KafkaStatus.DISCONNECTED),
    );
    this._consumer.on(this._consumer.events.REBALANCING, () =>
      this._status$.next(KafkaStatus.REBALANCING),
    );
    this._consumer.on(this._consumer.events.STOP, () =>
      this._status$.next(KafkaStatus.STOPPED),
    );
    this.consumer.on(this._consumer.events.CRASH, () =>
      this._status$.next(KafkaStatus.CRASHED),
    );
  }

  protected registerProducerEventListeners() {
    if (!this._producer) {
      return;
    }
    this._producer.on(this._producer.events.CONNECT, () =>
      this._status$.next(KafkaStatus.CONNECTED),
    );
    this._producer.on(this._producer.events.DISCONNECT, () =>
      this._status$.next(KafkaStatus.DISCONNECTED),
    );
  }

  protected async dispatchBatchEvent<TInput = any>(
    packets: ReadPacket<{ messages: TInput[] }>,
  ): Promise<any> {
    if (packets.data.messages.length === 0) {
      return;
    }
    const pattern = this.normalizePattern(packets.pattern);
    const outgoingEvents = await Promise.all(
      packets.data.messages.map(message => {
        return this.serializer.serialize(message as any, { pattern });
      }),
    );

    const message = Object.assign(
      {
        topic: pattern,
        messages: outgoingEvents,
      },
      this.options.send || {},
    );

    return this.producer.send(message);
  }

  protected async dispatchEvent(packet: OutgoingEvent): Promise<any> {
    const pattern = this.normalizePattern(packet.pattern);
    const outgoingEvent = await this.serializer.serialize(packet.data, {
      pattern,
    });
    const message = Object.assign(
      {
        topic: pattern,
        messages: [outgoingEvent],
      },
      this.options.send || {},
    );

    return this._producer!.send(message);
  }

  protected getReplyTopicPartition(topic: string): string {
    const minimumPartition = this.consumerAssignments[topic];
    if (isUndefined(minimumPartition)) {
      throw new InvalidKafkaClientTopicException(topic);
    }

    // Get the minimum partition
    return minimumPartition.toString();
  }

  protected publish(
    partialPacket: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    const packet = this.assignPacketId(partialPacket);
    this.routingMap.set(packet.id, callback);

    const cleanup = () => this.routingMap.delete(packet.id);
    const errorCallback = (err: unknown) => {
      cleanup();
      callback({ err });
    };

    try {
      const pattern = this.normalizePattern(partialPacket.pattern);
      const replyTopic = this.getResponsePatternName(pattern);
      const replyPartition = this.getReplyTopicPartition(replyTopic);

      Promise.resolve(this.serializer.serialize(packet.data, { pattern }))
        .then((serializedPacket: KafkaRequest) => {
          serializedPacket.headers[KafkaHeaders.CORRELATION_ID] = packet.id;
          serializedPacket.headers[KafkaHeaders.REPLY_TOPIC] = replyTopic;
          serializedPacket.headers[KafkaHeaders.REPLY_PARTITION] =
            replyPartition;

          const message = Object.assign(
            {
              topic: pattern,
              messages: [serializedPacket],
            },
            this.options.send || {},
          );

          return this._producer!.send(message);
        })
        .catch(err => errorCallback(err));

      return cleanup;
    } catch (err) {
      errorCallback(err);
      return () => null;
    }
  }

  protected getResponsePatternName(pattern: string): string {
    return `${pattern}.reply`;
  }

  protected setConsumerAssignments(data: ConsumerGroupJoinEvent): void {
    const consumerAssignments: { [key: string]: number } = {};

    // Only need to set the minimum
    Object.keys(data.payload.memberAssignment).forEach(topic => {
      const memberPartitions = data.payload.memberAssignment[topic];

      if (memberPartitions.length) {
        consumerAssignments[topic] = Math.min(...memberPartitions);
      }
    });

    this.consumerAssignments = consumerAssignments;
  }

  protected initializeSerializer(options: KafkaOptions['options']) {
    this.serializer =
      (options && options.serializer) || new KafkaRequestSerializer();
  }

  protected initializeDeserializer(options: KafkaOptions['options']) {
    this.deserializer =
      (options && options.deserializer) || new KafkaResponseDeserializer();
  }
}



================================================
FILE: packages/microservices/client/client-mqtt.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { EmptyError, fromEvent, lastValueFrom, merge, Observable } from 'rxjs';
import { first, map, share, tap } from 'rxjs/operators';
import { ECONNREFUSED, ENOTFOUND, MQTT_DEFAULT_URL } from '../constants';
import { MqttEvents, MqttEventsMap, MqttStatus } from '../events/mqtt.events';
import { MqttOptions, ReadPacket, WritePacket } from '../interfaces';
import {
  MqttRecord,
  MqttRecordOptions,
} from '../record-builders/mqtt.record-builder';
import { MqttRecordSerializer } from '../serializers/mqtt-record.serializer';
import { ClientProxy } from './client-proxy';

let mqttPackage: any = {};

// To enable type safety for MQTT. This cant be uncommented by default
// because it would require the user to install the mqtt package even if they dont use MQTT
// Otherwise, TypeScript would fail to compile the code.
//
// type MqttClient = import('mqtt').MqttClient;
type MqttClient = any;

/**
 * @publicApi
 */
export class ClientMqtt extends ClientProxy<MqttEvents, MqttStatus> {
  protected readonly logger = new Logger(ClientProxy.name);
  protected readonly subscriptionsCount = new Map<string, number>();
  protected readonly url: string;
  /* eslint-disable @typescript-eslint/no-redundant-type-constituents */
  protected mqttClient: MqttClient | null = null;
  protected connectionPromise: Promise<any> | null = null;
  protected isInitialConnection = false;
  protected isReconnecting = false;
  protected pendingEventListeners: Array<{
    event: keyof MqttEvents;
    callback: MqttEvents[keyof MqttEvents];
  }> = [];

  constructor(protected readonly options: Required<MqttOptions>['options']) {
    super();
    this.url = this.getOptionsProp(this.options, 'url') ?? MQTT_DEFAULT_URL;

    mqttPackage = loadPackage('mqtt', ClientMqtt.name, () => require('mqtt'));

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public getRequestPattern(pattern: string): string {
    return pattern;
  }

  public getResponsePattern(pattern: string): string {
    return `${pattern}/reply`;
  }

  public async close() {
    if (this.mqttClient) {
      await this.mqttClient.endAsync();
    }
    this.mqttClient = null;
    this.connectionPromise = null;
    this.pendingEventListeners = [];
  }

  public connect(): Promise<any> {
    if (this.mqttClient) {
      return this.connectionPromise!;
    }
    this.mqttClient = this.createClient();
    this.registerErrorListener(this.mqttClient);
    this.registerOfflineListener(this.mqttClient);
    this.registerReconnectListener(this.mqttClient);
    this.registerConnectListener(this.mqttClient);
    this.registerDisconnectListener(this.mqttClient);
    this.registerCloseListener(this.mqttClient);

    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.mqttClient!.on(event, callback),
    );
    this.pendingEventListeners = [];

    const connect$ = this.connect$(this.mqttClient);
    this.connectionPromise = lastValueFrom(
      this.mergeCloseEvent(this.mqttClient, connect$).pipe(share()),
    ).catch(err => {
      if (err instanceof EmptyError) {
        return;
      }
      throw err;
    });
    return this.connectionPromise;
  }

  public mergeCloseEvent<T = any>(
    instance: MqttClient,
    source$: Observable<T>,
  ): Observable<T> {
    const close$ = fromEvent(instance, MqttEventsMap.CLOSE).pipe(
      tap({
        next: () => {
          this._status$.next(MqttStatus.CLOSED);
        },
      }),
      map((err: any) => {
        throw err;
      }),
    );
    return merge(source$, close$).pipe(first());
  }

  public createClient(): MqttClient {
    return mqttPackage.connect(this.url, this.options as MqttOptions);
  }

  public registerErrorListener(client: MqttClient) {
    client.on(MqttEventsMap.ERROR, (err: any) => {
      if (err.code === ECONNREFUSED || err.code === ENOTFOUND) {
        return;
      }
      this.logger.error(err);
    });
  }

  public registerOfflineListener(client: MqttClient) {
    client.on(MqttEventsMap.OFFLINE, () => {
      this.connectionPromise = Promise.reject(
        'Error: Connection lost. Trying to reconnect...',
      );

      // Prevent unhandled rejections
      this.connectionPromise.catch(() => {});
      this.logger.error('MQTT broker went offline.');
    });
  }

  public registerReconnectListener(client: MqttClient) {
    client.on(MqttEventsMap.RECONNECT, () => {
      this.isReconnecting = true;
      this._status$.next(MqttStatus.RECONNECTING);

      this.logger.log('MQTT connection lost. Trying to reconnect...');
    });
  }

  public registerDisconnectListener(client: MqttClient) {
    client.on(MqttEventsMap.DISCONNECT, () => {
      this._status$.next(MqttStatus.DISCONNECTED);
    });
  }

  public registerCloseListener(client: MqttClient) {
    client.on(MqttEventsMap.CLOSE, () => {
      this._status$.next(MqttStatus.CLOSED);
    });
  }

  public registerConnectListener(client: MqttClient) {
    client.on(MqttEventsMap.CONNECT, () => {
      this.isReconnecting = false;
      this._status$.next(MqttStatus.CONNECTED);

      this.logger.log('Connected to MQTT broker');
      this.connectionPromise = Promise.resolve();

      if (!this.isInitialConnection) {
        this.isInitialConnection = true;
        client.on('message', this.createResponseCallback());
      }
    });
  }

  public on<
    EventKey extends keyof MqttEvents = keyof MqttEvents,
    EventCallback extends MqttEvents[EventKey] = MqttEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.mqttClient) {
      this.mqttClient.on(event, callback as any);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  public unwrap<T>(): T {
    if (!this.mqttClient) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return this.mqttClient as T;
  }

  public createResponseCallback(): (channel: string, buffer: Buffer) => any {
    return async (channel: string, buffer: Buffer) => {
      const packet = JSON.parse(buffer.toString());
      const { err, response, isDisposed, id } =
        await this.deserializer.deserialize(packet);

      const callback = this.routingMap.get(id);
      if (!callback) {
        return undefined;
      }
      if (isDisposed || err) {
        return callback({
          err,
          response,
          isDisposed: true,
        });
      }
      callback({
        err,
        response,
      });
    };
  }

  protected publish(
    partialPacket: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    try {
      const packet = this.assignPacketId(partialPacket);
      const pattern = this.normalizePattern(partialPacket.pattern);
      const responseChannel = this.getResponsePattern(pattern);

      let subscriptionsCount =
        this.subscriptionsCount.get(responseChannel) || 0;

      const publishPacket = () => {
        subscriptionsCount = this.subscriptionsCount.get(responseChannel) || 0;
        this.subscriptionsCount.set(responseChannel, subscriptionsCount + 1);
        this.routingMap.set(packet.id, callback);

        const options =
          isObject(packet?.data) && packet.data instanceof MqttRecord
            ? packet.data.options
            : undefined;
        delete packet?.data?.options;
        const serializedPacket: string | Buffer =
          this.serializer.serialize(packet);

        this.mqttClient!.publish(
          this.getRequestPattern(pattern),
          serializedPacket,
          this.mergePacketOptions(options),
        );
      };

      if (subscriptionsCount <= 0) {
        this.mqttClient!.subscribe(
          responseChannel,
          (err: any) => !err && publishPacket(),
        );
      } else {
        publishPacket();
      }

      return () => {
        this.unsubscribeFromChannel(responseChannel);
        this.routingMap.delete(packet.id);
      };
    } catch (err) {
      callback({ err });
      return () => {};
    }
  }

  protected dispatchEvent(packet: ReadPacket): Promise<any> {
    const pattern = this.normalizePattern(packet.pattern);
    const options =
      isObject(packet?.data) && packet.data instanceof MqttRecord
        ? packet.data.options
        : undefined;
    delete packet?.data?.options;

    const serializedPacket: string | Buffer = this.serializer.serialize(packet);
    return new Promise<void>((resolve, reject) =>
      this.mqttClient!.publish(
        pattern,
        serializedPacket,
        this.mergePacketOptions(options),
        (err: any) => (err ? reject(err) : resolve()),
      ),
    );
  }

  protected unsubscribeFromChannel(channel: string) {
    const subscriptionCount = this.subscriptionsCount.get(channel)!;
    this.subscriptionsCount.set(channel, subscriptionCount - 1);

    if (subscriptionCount - 1 <= 0) {
      this.mqttClient!.unsubscribe(channel);
    }
  }

  protected initializeSerializer(options: MqttOptions['options']) {
    this.serializer = options?.serializer ?? new MqttRecordSerializer();
  }

  protected mergePacketOptions(
    requestOptions?: MqttRecordOptions,
  ): MqttRecordOptions | undefined {
    if (!requestOptions && !this.options?.userProperties) {
      return undefined;
    }

    // Cant just spread objects as MQTT won't deliver
    // any message with empty object as "userProperties" field
    // @url https://github.com/nestjs/nest/issues/14079
    let options: MqttRecordOptions = {};
    if (requestOptions) {
      options = { ...requestOptions };
    }
    if (this.options?.userProperties) {
      options.properties = {
        ...options.properties,
        userProperties: {
          ...this.options?.userProperties,
          ...options.properties?.userProperties,
        },
      };
    }
    return options;
  }
}



================================================
FILE: packages/microservices/client/client-nats.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { EventEmitter } from 'stream';
import { NATS_DEFAULT_URL } from '../constants';
import { NatsResponseJSONDeserializer } from '../deserializers/nats-response-json.deserializer';
import { EmptyResponseException } from '../errors/empty-response.exception';
import { NatsEvents, NatsEventsMap, NatsStatus } from '../events/nats.events';
import { NatsOptions, PacketId, ReadPacket, WritePacket } from '../interfaces';
import { NatsRecord } from '../record-builders';
import { NatsRecordSerializer } from '../serializers/nats-record.serializer';
import { ClientProxy } from './client-proxy';

let natsPackage = {} as any;

// To enable type safety for Nats. This cant be uncommented by default
// because it would require the user to install the nats package even if they dont use Nats
// Otherwise, TypeScript would fail to compile the code.
//
// type Client = import('nats').NatsConnection;
// type NatsMsg = import('nats').Msg;

type Client = Record<string, any>;
type NatsMsg = Record<string, any>;

/**
 * @publicApi
 */
export class ClientNats extends ClientProxy<NatsEvents, NatsStatus> {
  protected readonly logger = new Logger(ClientNats.name);

  protected natsClient: Client | null = null;
  protected connectionPromise: Promise<Client> | null = null;
  protected statusEventEmitter = new EventEmitter<{
    [key in keyof NatsEvents]: Parameters<NatsEvents[key]>;
  }>();

  constructor(protected readonly options: Required<NatsOptions>['options']) {
    super();
    natsPackage = loadPackage('nats', ClientNats.name, () => require('nats'));

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public async close() {
    await this.natsClient?.close();
    this.statusEventEmitter.removeAllListeners();

    this.natsClient = null;
    this.connectionPromise = null;
  }

  public async connect(): Promise<any> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }
    this.connectionPromise = this.createClient();
    this.natsClient = await this.connectionPromise.catch(err => {
      this.connectionPromise = null;
      throw err;
    });

    this._status$.next(NatsStatus.CONNECTED);
    void this.handleStatusUpdates(this.natsClient);
    return this.natsClient;
  }

  public createClient(): Promise<Client> {
    const options = this.options || ({} as NatsOptions);
    return natsPackage.connect({
      servers: NATS_DEFAULT_URL,
      ...options,
    });
  }

  public async handleStatusUpdates(client: Client) {
    for await (const status of client.status()) {
      const data =
        status.data && isObject(status.data)
          ? JSON.stringify(status.data)
          : status.data;

      switch (status.type) {
        case 'error':
          this.logger.error(
            `NatsError: type: "${status.type}", data: "${data}".`,
          );
          break;

        case 'disconnect':
          this.connectionPromise = Promise.reject(
            'Error: Connection lost. Trying to reconnect...',
          );
          // Prevent unhandled promise rejection
          this.connectionPromise.catch(() => {});

          this.logger.error(
            `NatsError: type: "${status.type}", data: "${data}".`,
          );

          this._status$.next(NatsStatus.DISCONNECTED);
          this.statusEventEmitter.emit(
            NatsEventsMap.DISCONNECT,
            status.data as string,
          );
          break;

        case 'reconnecting':
          this._status$.next(NatsStatus.RECONNECTING);
          break;

        case 'reconnect':
          this.connectionPromise = Promise.resolve(client);
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );

          this._status$.next(NatsStatus.CONNECTED);
          this.statusEventEmitter.emit(
            NatsEventsMap.RECONNECT,
            status.data as string,
          );
          break;

        case 'pingTimer':
          if (this.options.debug) {
            this.logger.debug(
              `NatsStatus: type: "${status.type}", data: "${data}".`,
            );
          }
          break;

        case 'update':
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );
          this.statusEventEmitter.emit(NatsEventsMap.UPDATE, status.data);
          break;

        default:
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );
          break;
      }
    }
  }

  public on<
    EventKey extends keyof NatsEvents = keyof NatsEvents,
    EventCallback extends NatsEvents[EventKey] = NatsEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    this.statusEventEmitter.on(event, callback as any);
  }

  public unwrap<T>(): T {
    if (!this.natsClient) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return this.natsClient as T;
  }

  public createSubscriptionHandler(
    packet: ReadPacket & PacketId,
    callback: (packet: WritePacket) => any,
  ) {
    return async (error: string | Error | undefined, natsMsg: NatsMsg) => {
      if (error) {
        return callback({
          err: error,
        });
      }
      const rawPacket = natsMsg.data;
      if (rawPacket?.length === 0) {
        return callback({
          err: new EmptyResponseException(
            this.normalizePattern(packet.pattern),
          ),
          isDisposed: true,
        });
      }
      const message = await this.deserializer.deserialize(rawPacket);
      if (message.id && message.id !== packet.id) {
        return undefined;
      }
      const { err, response, isDisposed } = message;
      if (isDisposed || err) {
        return callback({
          err,
          response,
          isDisposed: true,
        });
      }
      callback({
        err,
        response,
      });
    };
  }

  protected publish(
    partialPacket: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    try {
      const packet = this.assignPacketId(partialPacket);
      const channel = this.normalizePattern(partialPacket.pattern);
      const serializedPacket: NatsRecord = this.serializer.serialize(packet);
      const inbox = natsPackage.createInbox(this.options.inboxPrefix);

      const subscriptionHandler = this.createSubscriptionHandler(
        packet,
        callback,
      );

      const subscription = this.natsClient!.subscribe(inbox, {
        callback: subscriptionHandler,
      });

      const headers = this.mergeHeaders(serializedPacket.headers);
      this.natsClient!.publish(channel, serializedPacket.data, {
        reply: inbox,
        headers,
      });

      return () => subscription.unsubscribe();
    } catch (err) {
      callback({ err });
      return () => {};
    }
  }

  protected dispatchEvent(packet: ReadPacket): Promise<any> {
    const pattern = this.normalizePattern(packet.pattern);
    const serializedPacket: NatsRecord = this.serializer.serialize(packet);
    const headers = this.mergeHeaders(serializedPacket.headers);

    return new Promise<void>((resolve, reject) => {
      try {
        this.natsClient!.publish(pattern, serializedPacket.data, {
          headers,
        });
        resolve();
      } catch (err) {
        reject(err);
      }
    });
  }

  protected initializeSerializer(options: NatsOptions['options']) {
    this.serializer = options?.serializer ?? new NatsRecordSerializer();
  }

  protected initializeDeserializer(options: NatsOptions['options']) {
    this.deserializer =
      options?.deserializer ?? new NatsResponseJSONDeserializer();
  }

  protected mergeHeaders<THeaders = any>(requestHeaders?: THeaders) {
    if (!requestHeaders && !this.options?.headers) {
      return undefined;
    }

    const headers = requestHeaders ?? natsPackage.headers();

    for (const [key, value] of Object.entries(this.options?.headers || {})) {
      if (!headers.has(key)) {
        headers.set(key, value);
      }
    }

    return headers;
  }
}



================================================
FILE: packages/microservices/client/client-proxy-factory.ts
================================================
import { Transport } from '../enums/transport.enum';
import { ClientKafkaProxy } from '../interfaces';
import {
  ClientOptions,
  CustomClientOptions,
  TcpClientOptions,
} from '../interfaces/client-metadata.interface';
import {
  GrpcOptions,
  KafkaOptions,
  MqttOptions,
  NatsOptions,
  RedisOptions,
  RmqOptions,
} from '../interfaces/microservice-configuration.interface';
import { ClientGrpcProxy } from './client-grpc';
import { ClientKafka } from './client-kafka';
import { ClientMqtt } from './client-mqtt';
import { ClientNats } from './client-nats';
import { ClientProxy } from './client-proxy';
import { ClientRedis } from './client-redis';
import { ClientRMQ } from './client-rmq';
import { ClientTCP } from './client-tcp';

export interface IClientProxyFactory {
  create(clientOptions: ClientOptions): ClientProxy;
}

/**
 * @publicApi
 */
export class ClientProxyFactory {
  public static create(
    clientOptions: { transport: Transport.GRPC } & ClientOptions,
  ): ClientGrpcProxy;
  public static create(
    clientOptions: { transport: Transport.KAFKA } & ClientOptions,
  ): ClientKafkaProxy;
  public static create(clientOptions: ClientOptions): ClientProxy;
  public static create(clientOptions: CustomClientOptions): ClientProxy;
  public static create(
    clientOptions: ClientOptions | CustomClientOptions,
  ): ClientProxy | ClientGrpcProxy | ClientKafkaProxy {
    if (this.isCustomClientOptions(clientOptions)) {
      const { customClass, options } = clientOptions;
      return new customClass(options);
    }
    const { transport, options = {} } = clientOptions ?? { options: {} };
    switch (transport) {
      case Transport.REDIS:
        return new ClientRedis(
          options as Required<RedisOptions>['options'],
        ) as ClientProxy;
      case Transport.NATS:
        return new ClientNats(
          options as Required<NatsOptions>['options'],
        ) as ClientProxy;
      case Transport.MQTT:
        return new ClientMqtt(
          options as Required<MqttOptions>['options'],
        ) as ClientProxy;
      case Transport.GRPC:
        return new ClientGrpcProxy(options as GrpcOptions['options']);
      case Transport.RMQ:
        return new ClientRMQ(
          options as Required<RmqOptions>['options'],
        ) as ClientProxy;
      case Transport.KAFKA:
        return new ClientKafka(options as Required<KafkaOptions>['options']);
      default:
        return new ClientTCP(
          options as Required<TcpClientOptions>['options'],
        ) as ClientProxy;
    }
  }

  private static isCustomClientOptions(
    options: ClientOptions | CustomClientOptions,
  ): options is CustomClientOptions {
    return !!(options as CustomClientOptions).customClass;
  }
}



================================================
FILE: packages/microservices/client/client-proxy.ts
================================================
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { isNil } from '@nestjs/common/utils/shared.utils';
import {
  throwError as _throw,
  connectable,
  defer,
  fromEvent,
  merge,
  Observable,
  Observer,
  ReplaySubject,
  Subject,
} from 'rxjs';
import { distinctUntilChanged, map, mergeMap, take } from 'rxjs/operators';
import { IncomingResponseDeserializer } from '../deserializers/incoming-response.deserializer';
import { InvalidMessageException } from '../errors/invalid-message.exception';
import {
  ClientOptions,
  KafkaOptions,
  MqttOptions,
  MsPattern,
  NatsOptions,
  PacketId,
  ReadPacket,
  RedisOptions,
  RmqOptions,
  TcpClientOptions,
  WritePacket,
} from '../interfaces';
import { ProducerDeserializer } from '../interfaces/deserializer.interface';
import { ProducerSerializer } from '../interfaces/serializer.interface';
import { IdentitySerializer } from '../serializers/identity.serializer';
import { transformPatternToRoute } from '../utils';

/**
 * @publicApi
 */
export abstract class ClientProxy<
  EventsMap extends Record<never, Function> = Record<never, Function>,
  Status extends string = string,
> {
  protected routingMap = new Map<string, Function>();
  protected serializer: ProducerSerializer;
  protected deserializer: ProducerDeserializer;
  protected _status$ = new ReplaySubject<Status>(1);

  /**
   * Returns an observable that emits status changes.
   */
  public get status(): Observable<Status> {
    return this._status$.asObservable().pipe(distinctUntilChanged());
  }

  /**
   * Establishes the connection to the underlying server/broker.
   */
  public abstract connect(): Promise<any>;
  /**
   * Closes the underlying connection to the server/broker.
   */
  public abstract close(): any;
  /**
   * Registers an event listener for the given event.
   * @param event Event name
   * @param callback Callback to be executed when the event is emitted
   */
  public on<
    EventKey extends keyof EventsMap = keyof EventsMap,
    EventCallback extends EventsMap[EventKey] = EventsMap[EventKey],
  >(event: EventKey, callback: EventCallback) {
    throw new Error('Method not implemented.');
  }
  /**
   * Returns an instance of the underlying server/broker instance,
   * or a group of servers if there are more than one.
   */
  public abstract unwrap<T>(): T;

  /**
   * Send a message to the server/broker.
   * Used for message-driven communication style between microservices.
   * @param pattern Pattern to identify the message
   * @param data Data to be sent
   * @returns Observable with the result
   */
  public send<TResult = any, TInput = any>(
    pattern: any,
    data: TInput,
  ): Observable<TResult> {
    if (isNil(pattern) || isNil(data)) {
      return _throw(() => new InvalidMessageException());
    }
    return defer(async () => this.connect()).pipe(
      mergeMap(
        () =>
          new Observable((observer: Observer<TResult>) => {
            const callback = this.createObserver(observer);
            return this.publish({ pattern, data }, callback);
          }),
      ),
    );
  }

  /**
   * Emits an event to the server/broker.
   * Used for event-driven communication style between microservices.
   * @param pattern Pattern to identify the event
   * @param data Data to be sent
   * @returns Observable that completes when the event is successfully emitted
   */
  public emit<TResult = any, TInput = any>(
    pattern: any,
    data: TInput,
  ): Observable<TResult> {
    if (isNil(pattern) || isNil(data)) {
      return _throw(() => new InvalidMessageException());
    }
    const source = defer(async () => this.connect()).pipe(
      mergeMap(() => this.dispatchEvent({ pattern, data })),
    );
    const connectableSource = connectable(source, {
      connector: () => new Subject(),
      resetOnDisconnect: false,
    });
    connectableSource.connect();
    return connectableSource;
  }

  protected abstract publish(
    packet: ReadPacket,
    callback: (packet: WritePacket) => void,
  ): () => void;

  protected abstract dispatchEvent<T = any>(packet: ReadPacket): Promise<T>;

  protected createObserver<T>(
    observer: Observer<T>,
  ): (packet: WritePacket) => void {
    return ({ err, response, isDisposed }: WritePacket) => {
      if (err) {
        return observer.error(this.serializeError(err));
      } else if (response !== undefined && isDisposed) {
        observer.next(this.serializeResponse(response));
        return observer.complete();
      } else if (isDisposed) {
        return observer.complete();
      }
      observer.next(this.serializeResponse(response));
    };
  }

  protected serializeError(err: any): any {
    return err;
  }

  protected serializeResponse(response: any): any {
    return response;
  }

  protected assignPacketId(packet: ReadPacket): ReadPacket & PacketId {
    const id = randomStringGenerator();
    return Object.assign(packet, { id });
  }

  protected connect$(
    instance: any,
    errorEvent = 'error',
    connectEvent = 'connect',
  ): Observable<any> {
    const error$ = fromEvent(instance, errorEvent).pipe(
      map((err: any) => {
        throw err;
      }),
    );
    const connect$ = fromEvent(instance, connectEvent);
    return merge(error$, connect$).pipe(take(1));
  }

  protected getOptionsProp<
    Options extends ClientOptions['options'],
    Attribute extends keyof Options,
  >(obj: Options, prop: Attribute): Options[Attribute];
  protected getOptionsProp<
    Options extends ClientOptions['options'],
    Attribute extends keyof Options,
    DefaultValue extends Options[Attribute] = Options[Attribute],
  >(
    obj: Options,
    prop: Attribute,
    defaultValue: DefaultValue,
  ): Required<Options>[Attribute];
  protected getOptionsProp<
    Options extends ClientOptions['options'],
    Attribute extends keyof Options,
    DefaultValue extends Options[Attribute] = Options[Attribute],
  >(
    obj: Options,
    prop: Attribute,
    defaultValue: DefaultValue = undefined as DefaultValue,
  ) {
    return obj && prop in obj ? (obj as any)[prop] : defaultValue;
  }

  protected normalizePattern(pattern: MsPattern): string {
    return transformPatternToRoute(pattern);
  }

  protected initializeSerializer(options: ClientOptions['options']) {
    this.serializer =
      (options &&
        (options as
          | RedisOptions['options']
          | NatsOptions['options']
          | MqttOptions['options']
          | TcpClientOptions['options']
          | RmqOptions['options']
          | KafkaOptions['options'])!.serializer) ||
      new IdentitySerializer();
  }

  protected initializeDeserializer(options: ClientOptions['options']) {
    this.deserializer =
      (options &&
        (options as
          | RedisOptions['options']
          | NatsOptions['options']
          | MqttOptions['options']
          | TcpClientOptions['options']
          | RmqOptions['options']
          | KafkaOptions['options'])!.deserializer) ||
      new IncomingResponseDeserializer();
  }
}



================================================
FILE: packages/microservices/client/client-redis.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { REDIS_DEFAULT_HOST, REDIS_DEFAULT_PORT } from '../constants';
import {
  RedisEvents,
  RedisEventsMap,
  RedisStatus,
} from '../events/redis.events';
import { ReadPacket, RedisOptions, WritePacket } from '../interfaces';
import { ClientProxy } from './client-proxy';

// To enable type safety for Redis. This cant be uncommented by default
// because it would require the user to install the ioredis package even if they dont use Redis
// Otherwise, TypeScript would fail to compile the code.
//
// type Redis = import('ioredis').Redis;
type Redis = any;

let redisPackage = {} as any;

/**
 * @publicApi
 */
export class ClientRedis extends ClientProxy<RedisEvents, RedisStatus> {
  protected readonly logger = new Logger(ClientProxy.name);
  protected readonly subscriptionsCount = new Map<string, number>();
  protected pubClient: Redis;
  protected subClient: Redis;
  protected connectionPromise: Promise<any>;
  protected isManuallyClosed = false;
  protected wasInitialConnectionSuccessful = false;
  protected pendingEventListeners: Array<{
    event: keyof RedisEvents;
    callback: RedisEvents[keyof RedisEvents];
  }> = [];

  constructor(protected readonly options: Required<RedisOptions>['options']) {
    super();

    redisPackage = loadPackage('ioredis', ClientRedis.name, () =>
      require('ioredis'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public getRequestPattern(pattern: string): string {
    return pattern;
  }

  public getReplyPattern(pattern: string): string {
    return `${pattern}.reply`;
  }

  public close() {
    this.pubClient && this.pubClient.quit();
    this.subClient && this.subClient.quit();
    this.pubClient = this.subClient = null;
    this.isManuallyClosed = true;
    this.pendingEventListeners = [];
  }

  public async connect(): Promise<any> {
    if (this.pubClient && this.subClient) {
      return this.connectionPromise;
    }
    this.pubClient = this.createClient();
    this.subClient = this.createClient();

    [this.pubClient, this.subClient].forEach((client, index) => {
      const type = index === 0 ? 'pub' : 'sub';
      this.registerErrorListener(client);
      this.registerReconnectListener(client);
      this.registerReadyListener(client);
      this.registerEndListener(client);
      this.pendingEventListeners.forEach(({ event, callback }) =>
        client.on(event, (...args: [any]) => callback(type, ...args)),
      );
    });
    this.pendingEventListeners = [];

    this.connectionPromise = Promise.all([
      this.subClient.connect(),
      this.pubClient.connect(),
    ]);
    await this.connectionPromise;
    return this.connectionPromise;
  }

  public createClient(): Redis {
    return new redisPackage({
      host: REDIS_DEFAULT_HOST,
      port: REDIS_DEFAULT_PORT,
      ...this.getClientOptions(),
      lazyConnect: true,
    });
  }

  public registerErrorListener(client: Redis) {
    client.addListener(RedisEventsMap.ERROR, (err: any) =>
      this.logger.error(err),
    );
  }

  public registerReconnectListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on(RedisEventsMap.RECONNECTING, () => {
      if (this.isManuallyClosed) {
        return;
      }

      this.connectionPromise = Promise.reject(
        'Error: Connection lost. Trying to reconnect...',
      );

      // Prevent unhandled rejections
      this.connectionPromise.catch(() => {});

      this._status$.next(RedisStatus.RECONNECTING);

      if (this.wasInitialConnectionSuccessful) {
        this.logger.log('Reconnecting to Redis...');
      }
    });
  }

  public registerReadyListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on(RedisEventsMap.READY, () => {
      this.connectionPromise = Promise.resolve();
      this._status$.next(RedisStatus.CONNECTED);

      this.logger.log('Connected to Redis. Subscribing to channels...');

      if (!this.wasInitialConnectionSuccessful) {
        this.wasInitialConnectionSuccessful = true;
        this.subClient.on('message', this.createResponseCallback());
      }
    });
  }

  public registerEndListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on('end', () => {
      if (this.isManuallyClosed) {
        return;
      }
      this._status$.next(RedisStatus.DISCONNECTED);

      if (this.getOptionsProp(this.options, 'retryAttempts') === undefined) {
        // When retryAttempts is not specified, the connection will not be re-established
        this.logger.error('Disconnected from Redis.');

        // Clean up client instances and just recreate them when connect is called
        this.pubClient = this.subClient = null;
      } else {
        this.logger.error('Disconnected from Redis.');
        this.connectionPromise = Promise.reject(
          'Error: Connection lost. Trying to reconnect...',
        );

        // Prevent unhandled rejections
        this.connectionPromise.catch(() => {});
      }
    });
  }

  public getClientOptions(): Partial<RedisOptions['options']> {
    const retryStrategy = (times: number) => this.createRetryStrategy(times);

    return {
      ...(this.options || {}),
      retryStrategy,
    };
  }

  public on<
    EventKey extends keyof RedisEvents = keyof RedisEvents,
    EventCallback extends RedisEvents[EventKey] = RedisEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.subClient && this.pubClient) {
      this.subClient.on(event, (...args: [any]) => callback('sub', ...args));
      this.pubClient.on(event, (...args: [any]) => callback('pub', ...args));
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  public unwrap<T>(): T {
    if (!this.pubClient || !this.subClient) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return [this.pubClient, this.subClient] as T;
  }

  public createRetryStrategy(times: number): undefined | number {
    if (this.isManuallyClosed) {
      return undefined;
    }
    if (!this.getOptionsProp(this.options, 'retryAttempts')) {
      this.logger.error(
        'Redis connection closed and retry attempts not specified',
      );
      return;
    }
    if (times > this.getOptionsProp(this.options, 'retryAttempts', 0)) {
      this.logger.error('Retry time exhausted');
      return;
    }
    return this.getOptionsProp(this.options, 'retryDelay', 5000);
  }

  public createResponseCallback(): (
    channel: string,
    buffer: string,
  ) => Promise<void> {
    return async (channel: string, buffer: string) => {
      const packet = JSON.parse(buffer);
      const { err, response, isDisposed, id } =
        await this.deserializer.deserialize(packet);

      const callback = this.routingMap.get(id);
      if (!callback) {
        return;
      }
      if (isDisposed || err) {
        return callback({
          err,
          response,
          isDisposed: true,
        });
      }
      callback({
        err,
        response,
      });
    };
  }

  protected publish(
    partialPacket: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    try {
      const packet = this.assignPacketId(partialPacket);
      const pattern = this.normalizePattern(partialPacket.pattern);
      const serializedPacket = this.serializer.serialize(packet);
      const responseChannel = this.getReplyPattern(pattern);
      let subscriptionsCount =
        this.subscriptionsCount.get(responseChannel) || 0;

      const publishPacket = () => {
        subscriptionsCount = this.subscriptionsCount.get(responseChannel) || 0;
        this.subscriptionsCount.set(responseChannel, subscriptionsCount + 1);
        this.routingMap.set(packet.id, callback);
        this.pubClient.publish(
          this.getRequestPattern(pattern),
          JSON.stringify(serializedPacket),
        );
      };

      if (subscriptionsCount <= 0) {
        this.subClient.subscribe(
          responseChannel,
          (err: any) => !err && publishPacket(),
        );
      } else {
        publishPacket();
      }

      return () => {
        this.unsubscribeFromChannel(responseChannel);
        this.routingMap.delete(packet.id);
      };
    } catch (err) {
      callback({ err });
      return () => {};
    }
  }

  protected dispatchEvent(packet: ReadPacket): Promise<any> {
    const pattern = this.normalizePattern(packet.pattern);
    const serializedPacket = this.serializer.serialize(packet);

    return new Promise<void>((resolve, reject) =>
      this.pubClient.publish(pattern, JSON.stringify(serializedPacket), err =>
        err ? reject(err) : resolve(),
      ),
    );
  }

  protected unsubscribeFromChannel(channel: string) {
    const subscriptionCount = this.subscriptionsCount.get(channel)!;
    this.subscriptionsCount.set(channel, subscriptionCount - 1);

    if (subscriptionCount - 1 <= 0) {
      this.subClient.unsubscribe(channel);
    }
  }
}



================================================
FILE: packages/microservices/client/client-rmq.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { isFunction } from '@nestjs/common/utils/shared.utils';
import { EventEmitter } from 'events';
import {
  EmptyError,
  firstValueFrom,
  fromEvent,
  merge,
  Observable,
  ReplaySubject,
} from 'rxjs';
import { first, map, retryWhen, scan, skip, switchMap } from 'rxjs/operators';
import {
  DISCONNECTED_RMQ_MESSAGE,
  RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT,
  RQM_DEFAULT_NO_ASSERT,
  RQM_DEFAULT_NOACK,
  RQM_DEFAULT_PERSISTENT,
  RQM_DEFAULT_PREFETCH_COUNT,
  RQM_DEFAULT_QUEUE,
  RQM_DEFAULT_QUEUE_OPTIONS,
  RQM_DEFAULT_URL,
} from '../constants';
import { RmqEvents, RmqEventsMap, RmqStatus } from '../events/rmq.events';
import { ReadPacket, RmqOptions, WritePacket } from '../interfaces';
import { RmqRecord } from '../record-builders';
import { RmqRecordSerializer } from '../serializers/rmq-record.serializer';
import { ClientProxy } from './client-proxy';

// To enable type safety for RMQ. This cant be uncommented by default
// because it would require the user to install the amqplib package even if they dont use RabbitMQ
// Otherwise, TypeScript would fail to compile the code.
//
// type AmqpConnectionManager =
//   import('amqp-connection-manager').AmqpConnectionManager;
// type ChannelWrapper = import('amqp-connection-manager').ChannelWrapper;
// type Channel = import('amqplib').Channel;
// type ConsumeMessage = import('amqplib').ConsumeMessage;

type Channel = any;
type ChannelWrapper = any;
type ConsumeMessage = any;
type AmqpConnectionManager = any;

let rmqPackage = {} as any; // typeof import('amqp-connection-manager');

const REPLY_QUEUE = 'amq.rabbitmq.reply-to';

/**
 * @publicApi
 */
export class ClientRMQ extends ClientProxy<RmqEvents, RmqStatus> {
  protected readonly logger = new Logger(ClientProxy.name);
  protected connection$: ReplaySubject<any>;
  protected connectionPromise: Promise<void>;
  protected client: AmqpConnectionManager = null;
  protected channel: ChannelWrapper = null;
  protected pendingEventListeners: Array<{
    event: keyof RmqEvents;
    callback: RmqEvents[keyof RmqEvents];
  }> = [];
  protected isInitialConnect = true;
  protected responseEmitter: EventEmitter;
  protected queue: string;
  protected queueOptions: Record<string, any>;
  protected replyQueue: string;
  protected noAssert: boolean;

  constructor(protected readonly options: Required<RmqOptions>['options']) {
    super();
    this.queue = this.getOptionsProp(this.options, 'queue', RQM_DEFAULT_QUEUE);
    this.queueOptions = this.getOptionsProp(
      this.options,
      'queueOptions',
      RQM_DEFAULT_QUEUE_OPTIONS,
    );
    this.replyQueue = this.getOptionsProp(
      this.options,
      'replyQueue',
      REPLY_QUEUE,
    );
    this.noAssert =
      this.getOptionsProp(this.options, 'noAssert') ??
      this.queueOptions.noAssert ??
      RQM_DEFAULT_NO_ASSERT;

    loadPackage('amqplib', ClientRMQ.name, () => require('amqplib'));
    rmqPackage = loadPackage('amqp-connection-manager', ClientRMQ.name, () =>
      require('amqp-connection-manager'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public close(): void {
    this.channel && this.channel.close();
    this.client && this.client.close();
    this.channel = null;
    this.client = null;
    this.pendingEventListeners = [];
  }

  public connect(): Promise<any> {
    if (this.client) {
      return this.connectionPromise;
    }
    this.client = this.createClient();

    this.registerErrorListener(this.client);
    this.registerDisconnectListener(this.client);
    this.registerConnectListener(this.client);
    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.client.on(event, callback),
    );
    this.pendingEventListeners = [];

    this.responseEmitter = new EventEmitter();
    this.responseEmitter.setMaxListeners(0);

    const connect$ = this.connect$(this.client);
    const withDisconnect$ = this.mergeDisconnectEvent(
      this.client,
      connect$,
    ).pipe(switchMap(() => this.createChannel()));

    const withReconnect$ = fromEvent(this.client, RmqEventsMap.CONNECT).pipe(
      skip(1),
    );
    const source$ = merge(withDisconnect$, withReconnect$);

    this.connection$ = new ReplaySubject(1);
    source$.subscribe(this.connection$);
    this.connectionPromise = this.convertConnectionToPromise();

    return this.connectionPromise;
  }

  public createChannel(): Promise<void> {
    return new Promise(resolve => {
      this.channel = this.client.createChannel({
        json: false,
        setup: (channel: Channel) => this.setupChannel(channel, resolve),
      });
    });
  }

  public createClient(): AmqpConnectionManager {
    const socketOptions = this.getOptionsProp(this.options, 'socketOptions');
    const urls = this.getOptionsProp(this.options, 'urls') || [RQM_DEFAULT_URL];
    return rmqPackage.connect(urls, socketOptions);
  }

  public mergeDisconnectEvent<T = any>(
    instance: any,
    source$: Observable<T>,
  ): Observable<T> {
    const eventToError = (eventType: string) =>
      fromEvent(instance, eventType).pipe(
        map((err: unknown) => {
          throw err;
        }),
      );
    const disconnect$ = eventToError(RmqEventsMap.DISCONNECT);

    const urls = this.getOptionsProp(this.options, 'urls', []);
    const connectFailedEventKey = 'connectFailed';
    const connectFailed$ = eventToError(connectFailedEventKey).pipe(
      retryWhen(e =>
        e.pipe(
          scan((errorCount, error: any) => {
            if (urls.indexOf(error.url) >= urls.length - 1) {
              throw error;
            }
            return errorCount + 1;
          }, 0),
        ),
      ),
    );
    // If we ever decide to propagate all disconnect errors & re-emit them through
    // the "connection" stream then comment out "first()" operator.
    return merge(source$, disconnect$, connectFailed$).pipe(first());
  }

  public async convertConnectionToPromise() {
    try {
      return await firstValueFrom(this.connection$);
    } catch (err) {
      if (err instanceof EmptyError) {
        return;
      }
      throw err;
    }
  }

  public async setupChannel(channel: Channel, resolve: Function) {
    const prefetchCount =
      this.getOptionsProp(this.options, 'prefetchCount') ||
      RQM_DEFAULT_PREFETCH_COUNT;
    const isGlobalPrefetchCount =
      this.getOptionsProp(this.options, 'isGlobalPrefetchCount') ||
      RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT;

    if (!this.noAssert) {
      await channel.assertQueue(this.queue, this.queueOptions);
    }

    if (this.options.exchange && this.options.routingKey) {
      await channel.bindQueue(
        this.queue,
        this.options.exchange,
        this.options.routingKey,
      );
    }

    await channel.prefetch(prefetchCount, isGlobalPrefetchCount);
    await this.consumeChannel(channel);
    resolve();
  }

  public async consumeChannel(channel: Channel) {
    const noAck = this.getOptionsProp(this.options, 'noAck', RQM_DEFAULT_NOACK);
    await channel.consume(
      this.replyQueue,
      (msg: ConsumeMessage) =>
        this.responseEmitter.emit(msg.properties.correlationId, msg),
      {
        noAck,
      },
    );
  }

  public registerErrorListener(client: AmqpConnectionManager): void {
    client.addListener(RmqEventsMap.ERROR, (err: any) =>
      this.logger.error(err),
    );
  }

  public registerDisconnectListener(client: AmqpConnectionManager): void {
    client.addListener(RmqEventsMap.DISCONNECT, (err: any) => {
      this._status$.next(RmqStatus.DISCONNECTED);

      if (!this.isInitialConnect) {
        this.connectionPromise = Promise.reject(
          'Error: Connection lost. Trying to reconnect...',
        );

        // Prevent unhandled promise rejection
        this.connectionPromise.catch(() => {});
      }

      this.logger.error(DISCONNECTED_RMQ_MESSAGE);
      this.logger.error(err);
    });
  }

  private registerConnectListener(client: AmqpConnectionManager): void {
    client.addListener(RmqEventsMap.CONNECT, () => {
      this._status$.next(RmqStatus.CONNECTED);
      this.logger.log('Successfully connected to RMQ broker');

      if (this.isInitialConnect) {
        this.isInitialConnect = false;

        if (!this.channel) {
          this.connectionPromise = this.createChannel();
        }
      } else {
        this.connectionPromise = Promise.resolve();
      }
    });
  }

  public on<
    EventKey extends keyof RmqEvents = keyof RmqEvents,
    EventCallback extends RmqEvents[EventKey] = RmqEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.client) {
      this.client.addListener(event, callback);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  public unwrap<T>(): T {
    if (!this.client) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return this.client as T;
  }

  public async handleMessage(
    packet: unknown,
    callback: (packet: WritePacket) => any,
  ): Promise<void>;
  public async handleMessage(
    packet: unknown,
    options: Record<string, unknown>,
    callback: (packet: WritePacket) => any,
  ): Promise<void>;
  public async handleMessage(
    packet: unknown,
    options:
      | Record<string, unknown>
      | ((packet: WritePacket) => any)
      | undefined,
    callback?: (packet: WritePacket) => any,
  ): Promise<void> {
    if (isFunction(options)) {
      callback = options as (packet: WritePacket) => any;
      options = undefined;
    }

    const { err, response, isDisposed } = await this.deserializer.deserialize(
      packet,
      options,
    );
    if (isDisposed || err) {
      callback?.({
        err,
        response,
        isDisposed: true,
      });
    }
    callback?.({
      err,
      response,
    });
  }

  protected publish(
    message: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    try {
      const correlationId = randomStringGenerator();
      const listener = ({
        content,
        options,
      }: {
        content: Buffer;
        options: Record<string, unknown>;
      }) =>
        this.handleMessage(
          this.parseMessageContent(content),
          options,
          callback,
        );

      Object.assign(message, { id: correlationId });
      const serializedPacket: ReadPacket & Partial<RmqRecord> =
        this.serializer.serialize(message);

      const options = serializedPacket.options;
      delete serializedPacket.options;

      this.responseEmitter.on(correlationId, listener);
      this.channel
        .sendToQueue(
          this.queue,
          Buffer.from(JSON.stringify(serializedPacket)),
          {
            replyTo: this.replyQueue,
            persistent: this.getOptionsProp(
              this.options,
              'persistent',
              RQM_DEFAULT_PERSISTENT,
            ),
            ...options,
            headers: this.mergeHeaders(options?.headers),
            correlationId,
          },
        )
        .catch(err => callback({ err }));
      return () => this.responseEmitter.removeListener(correlationId, listener);
    } catch (err) {
      callback({ err });
      return () => {};
    }
  }

  protected dispatchEvent(packet: ReadPacket): Promise<any> {
    const serializedPacket: ReadPacket & Partial<RmqRecord> =
      this.serializer.serialize(packet);

    const options = serializedPacket.options;
    delete serializedPacket.options;

    return new Promise<void>((resolve, reject) =>
      this.channel.sendToQueue(
        this.queue,
        Buffer.from(JSON.stringify(serializedPacket)),
        {
          persistent: this.getOptionsProp(
            this.options,
            'persistent',
            RQM_DEFAULT_PERSISTENT,
          ),
          ...options,
          headers: this.mergeHeaders(options?.headers),
        },
        (err: unknown) => (err ? reject(err as Error) : resolve()),
      ),
    );
  }

  protected initializeSerializer(options: RmqOptions['options']) {
    this.serializer = options?.serializer ?? new RmqRecordSerializer();
  }

  protected mergeHeaders(
    requestHeaders?: Record<string, string>,
  ): Record<string, string> | undefined {
    if (!requestHeaders && !this.options?.headers) {
      return undefined;
    }

    return {
      ...this.options?.headers,
      ...requestHeaders,
    };
  }

  protected parseMessageContent(content: Buffer) {
    const rawContent = content.toString();
    try {
      return JSON.parse(rawContent);
    } catch {
      return rawContent;
    }
  }
}



================================================
FILE: packages/microservices/client/client-tcp.ts
================================================
import { Logger, Type } from '@nestjs/common';
import * as net from 'net';
import { EmptyError, lastValueFrom } from 'rxjs';
import { share, tap } from 'rxjs/operators';
import { ConnectionOptions, connect as tlsConnect, TLSSocket } from 'tls';
import { ECONNREFUSED, TCP_DEFAULT_HOST, TCP_DEFAULT_PORT } from '../constants';
import { TcpEvents, TcpEventsMap, TcpStatus } from '../events/tcp.events';
import { JsonSocket, TcpSocket } from '../helpers';
import { PacketId, ReadPacket, WritePacket } from '../interfaces';
import { TcpClientOptions } from '../interfaces/client-metadata.interface';
import { ClientProxy } from './client-proxy';

/**
 * @publicApi
 */
export class ClientTCP extends ClientProxy<TcpEvents, TcpStatus> {
  protected readonly logger = new Logger(ClientTCP.name);
  protected readonly port: number;
  protected readonly host: string;
  protected readonly socketClass: Type<TcpSocket>;
  protected readonly tlsOptions?: ConnectionOptions;
  protected socket: TcpSocket | null = null;
  protected connectionPromise: Promise<any> | null = null;
  protected pendingEventListeners: Array<{
    event: keyof TcpEvents;
    callback: TcpEvents[keyof TcpEvents];
  }> = [];

  constructor(options: Required<TcpClientOptions>['options']) {
    super();
    this.port = this.getOptionsProp(options, 'port', TCP_DEFAULT_PORT);
    this.host = this.getOptionsProp(options, 'host', TCP_DEFAULT_HOST);
    this.socketClass = this.getOptionsProp(options, 'socketClass', JsonSocket);
    this.tlsOptions = this.getOptionsProp(options, 'tlsOptions');

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public connect(): Promise<any> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }
    this.socket = this.createSocket();
    this.registerConnectListener(this.socket);
    this.registerCloseListener(this.socket);
    this.registerErrorListener(this.socket);

    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.socket!.on(event, callback as any),
    );
    this.pendingEventListeners = [];

    const source$ = this.connect$(this.socket.netSocket).pipe(
      tap(() => {
        this.socket!.on('message', (buffer: WritePacket & PacketId) =>
          this.handleResponse(buffer),
        );
      }),
      share(),
    );

    // For TLS connections, the connection is initiated when the socket is created
    if (!this.tlsOptions) {
      this.socket.connect(this.port, this.host);
    }
    this.connectionPromise = lastValueFrom(source$).catch(err => {
      if (err instanceof EmptyError) {
        return;
      }
      throw err;
    });

    return this.connectionPromise;
  }

  public async handleResponse(buffer: unknown): Promise<void> {
    const { err, response, isDisposed, id } =
      await this.deserializer.deserialize(buffer);
    const callback = this.routingMap.get(id);
    if (!callback) {
      return undefined;
    }
    if (isDisposed || err) {
      return callback({
        err,
        response,
        isDisposed: true,
      });
    }
    callback({
      err,
      response,
    });
  }

  public createSocket(): TcpSocket {
    let socket: net.Socket | TLSSocket;
    /**
     * TLS enabled, "upgrade" the TCP Socket to TLS
     */
    if (this.tlsOptions) {
      socket = tlsConnect({
        ...this.tlsOptions,
        port: this.port,
        host: this.host,
      });
    } else {
      socket = new net.Socket();
    }
    return new this.socketClass(socket);
  }

  public close() {
    this.socket && this.socket.end();
    this.handleClose();
    this.pendingEventListeners = [];
  }

  public registerConnectListener(socket: TcpSocket) {
    socket.on(TcpEventsMap.CONNECT, () => {
      this._status$.next(TcpStatus.CONNECTED);
    });
  }

  public registerErrorListener(socket: TcpSocket) {
    socket.on(TcpEventsMap.ERROR, err => {
      if (err.code !== ECONNREFUSED) {
        this.handleError(err);
      } else {
        this._status$.next(TcpStatus.DISCONNECTED);
      }
    });
  }

  public registerCloseListener(socket: TcpSocket) {
    socket.on(TcpEventsMap.CLOSE, () => {
      this._status$.next(TcpStatus.DISCONNECTED);
      this.handleClose();
    });
  }

  public handleError(err: any) {
    this.logger.error(err);
  }

  public handleClose() {
    this.socket = null;
    this.connectionPromise = null;

    if (this.routingMap.size > 0) {
      const err = new Error('Connection closed');
      for (const callback of this.routingMap.values()) {
        callback({ err });
      }
      this.routingMap.clear();
    }
  }

  public on<
    EventKey extends keyof TcpEvents = keyof TcpEvents,
    EventCallback extends TcpEvents[EventKey] = TcpEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.socket) {
      this.socket.on(event, callback as any);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  public unwrap<T>(): T {
    if (!this.socket) {
      throw new Error(
        'Not initialized. Please call the "connect" method first.',
      );
    }
    return this.socket.netSocket as T;
  }

  protected publish(
    partialPacket: ReadPacket,
    callback: (packet: WritePacket) => any,
  ): () => void {
    try {
      const packet = this.assignPacketId(partialPacket);
      const serializedPacket = this.serializer.serialize(packet);

      this.routingMap.set(packet.id, callback);
      this.socket!.sendMessage(serializedPacket);

      return () => this.routingMap.delete(packet.id);
    } catch (err) {
      callback({ err });
      return () => {};
    }
  }

  protected async dispatchEvent(packet: ReadPacket): Promise<any> {
    const pattern = this.normalizePattern(packet.pattern);
    const serializedPacket = this.serializer.serialize({
      ...packet,
      pattern,
    });
    return this.socket!.sendMessage(serializedPacket);
  }
}



================================================
FILE: packages/microservices/client/index.ts
================================================
export * from './client-grpc';
export * from './client-kafka';
export * from './client-mqtt';
export * from './client-nats';
export * from './client-proxy';
export { ClientProxyFactory } from './client-proxy-factory';
export * from './client-redis';
export * from './client-rmq';
export * from './client-tcp';



================================================
FILE: packages/microservices/context/exception-filters-context.ts
================================================
import { EXCEPTION_FILTERS_METADATA } from '@nestjs/common/constants';
import { Controller } from '@nestjs/common/interfaces/controllers/controller.interface';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { BaseExceptionFilterContext } from '@nestjs/core/exceptions/base-exception-filter-context';
import { STATIC_CONTEXT } from '@nestjs/core/injector/constants';
import { NestContainer } from '@nestjs/core/injector/container';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { iterate } from 'iterare';
import { Observable } from 'rxjs';
import { RpcExceptionsHandler } from '../exceptions/rpc-exceptions-handler';

/**
 * @publicApi
 */
export class ExceptionFiltersContext extends BaseExceptionFilterContext {
  constructor(
    container: NestContainer,
    private readonly config: ApplicationConfig,
  ) {
    super(container);
  }

  public create(
    instance: Controller,
    callback: <T = any>(data: T) => Observable<any>,
    module: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): RpcExceptionsHandler {
    this.moduleContext = module;

    const exceptionHandler = new RpcExceptionsHandler();
    const filters = this.createContext(
      instance,
      callback,
      EXCEPTION_FILTERS_METADATA,
      contextId,
      inquirerId,
    );
    if (isEmpty(filters)) {
      return exceptionHandler;
    }
    exceptionHandler.setCustomFilters(filters.reverse());
    return exceptionHandler;
  }

  public getGlobalMetadata<T extends any[]>(
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
  ): T {
    const globalFilters = this.config.getGlobalFilters() as T;
    if (contextId === STATIC_CONTEXT && !inquirerId) {
      return globalFilters;
    }
    const scopedFilterWrappers =
      this.config.getGlobalRequestFilters() as InstanceWrapper[];
    const scopedFilters = iterate(scopedFilterWrappers)
      .map(wrapper =>
        wrapper.getInstanceByContextId(
          this.getContextId(contextId, wrapper),
          inquirerId,
        ),
      )
      .filter(host => !!host)
      .map(host => host.instance)
      .toArray();

    return globalFilters.concat(scopedFilters) as T;
  }
}



================================================
FILE: packages/microservices/context/request-context-host.ts
================================================
import { BaseRpcContext } from '../ctx-host/base-rpc.context';
import { RequestContext } from '../interfaces';

/**
 * @publicApi
 */
export class RequestContextHost<
  TData = any,
  TContext extends BaseRpcContext = any,
> implements RequestContext<TData>
{
  constructor(
    public readonly pattern: string | Record<string, any>,
    public readonly data: TData,
    public readonly context: TContext,
  ) {}

  static create<TData, TContext extends BaseRpcContext>(
    pattern: string | Record<string, any>,
    data: TData,
    context: TContext,
  ): RequestContext<TData, TContext> {
    const host = new RequestContextHost(pattern, data, context);
    return host;
  }

  public getData(): TData {
    return this.data;
  }

  public getPattern(): string | Record<string, any> {
    return this.pattern;
  }

  public getContext(): TContext {
    return this.context;
  }
}



================================================
FILE: packages/microservices/context/rpc-context-creator.ts
================================================
import {
  CUSTOM_ROUTE_ARGS_METADATA,
  PARAMTYPES_METADATA,
} from '@nestjs/common/constants';
import {
  ContextType,
  Controller,
  PipeTransform,
} from '@nestjs/common/interfaces';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { FORBIDDEN_MESSAGE } from '@nestjs/core/guards/constants';
import { GuardsConsumer } from '@nestjs/core/guards/guards-consumer';
import { GuardsContextCreator } from '@nestjs/core/guards/guards-context-creator';
import {
  ContextUtils,
  ParamProperties,
} from '@nestjs/core/helpers/context-utils';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { HandlerMetadataStorage } from '@nestjs/core/helpers/handler-metadata-storage';
import { ParamsMetadata } from '@nestjs/core/helpers/interfaces';
import { STATIC_CONTEXT } from '@nestjs/core/injector/constants';
import { InterceptorsConsumer } from '@nestjs/core/interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '@nestjs/core/interceptors/interceptors-context-creator';
import { PipesConsumer } from '@nestjs/core/pipes/pipes-consumer';
import { PipesContextCreator } from '@nestjs/core/pipes/pipes-context-creator';
import { Observable } from 'rxjs';
import { PARAM_ARGS_METADATA } from '../constants';
import { RpcException } from '../exceptions';
import { RpcParamsFactory } from '../factories/rpc-params-factory';
import { ExceptionFiltersContext } from './exception-filters-context';
import { DEFAULT_CALLBACK_METADATA } from './rpc-metadata-constants';
import { RpcProxy } from './rpc-proxy';

type RpcParamProperties = ParamProperties & { metatype?: any };
export interface RpcHandlerMetadata {
  argsLength: number;
  paramtypes: any[];
  getParamsMetadata: (moduleKey: string) => RpcParamProperties[];
}

export class RpcContextCreator {
  private readonly contextUtils = new ContextUtils();
  private readonly rpcParamsFactory = new RpcParamsFactory();
  private readonly handlerMetadataStorage =
    new HandlerMetadataStorage<RpcHandlerMetadata>();

  constructor(
    private readonly rpcProxy: RpcProxy,
    private readonly exceptionFiltersContext: ExceptionFiltersContext,
    private readonly pipesContextCreator: PipesContextCreator,
    private readonly pipesConsumer: PipesConsumer,
    private readonly guardsContextCreator: GuardsContextCreator,
    private readonly guardsConsumer: GuardsConsumer,
    private readonly interceptorsContextCreator: InterceptorsContextCreator,
    private readonly interceptorsConsumer: InterceptorsConsumer,
  ) {}

  public create<T extends ParamsMetadata = ParamsMetadata>(
    instance: Controller,
    callback: (...args: unknown[]) => Observable<any>,
    moduleKey: string,
    methodName: string,
    contextId = STATIC_CONTEXT,
    inquirerId?: string,
    defaultCallMetadata: Record<string, any> = DEFAULT_CALLBACK_METADATA,
  ): (...args: any[]) => Promise<Observable<any>> {
    const contextType: ContextType = 'rpc';
    const { argsLength, paramtypes, getParamsMetadata } = this.getMetadata<T>(
      instance,
      methodName,
      defaultCallMetadata,
      contextType,
    );

    const exceptionHandler = this.exceptionFiltersContext.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const pipes = this.pipesContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const guards = this.guardsContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );
    const interceptors = this.interceptorsContextCreator.create(
      instance,
      callback,
      moduleKey,
      contextId,
      inquirerId,
    );

    const paramsMetadata = getParamsMetadata(moduleKey);
    const paramsOptions = paramsMetadata
      ? this.contextUtils.mergeParamsMetatypes(paramsMetadata, paramtypes)
      : [];
    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);

    const fnCanActivate = this.createGuardsFn(
      guards,
      instance,
      callback,
      contextType,
    );

    const handler = (initialArgs: unknown[], args: unknown[]) => async () => {
      if (fnApplyPipes) {
        await fnApplyPipes(initialArgs, ...args);
        return callback.apply(instance, initialArgs);
      }
      return callback.apply(instance, args);
    };

    return this.rpcProxy.create(async (...args: unknown[]) => {
      const initialArgs = this.contextUtils.createNullArray(argsLength);
      fnCanActivate && (await fnCanActivate(args));

      return this.interceptorsConsumer.intercept(
        interceptors,
        args,
        instance,
        callback,
        handler(initialArgs, args),
        contextType,
      ) as Promise<Observable<unknown>>;
    }, exceptionHandler);
  }

  public reflectCallbackParamtypes(
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
  ): unknown[] {
    return Reflect.getMetadata(PARAMTYPES_METADATA, instance, callback.name);
  }

  public createGuardsFn<TContext extends string = ContextType>(
    guards: any[],
    instance: Controller,
    callback: (...args: unknown[]) => unknown,
    contextType?: TContext,
  ): Function | null {
    const canActivateFn = async (args: any[]) => {
      const canActivate = await this.guardsConsumer.tryActivate<TContext>(
        guards,
        args,
        instance,
        callback,
        contextType,
      );
      if (!canActivate) {
        throw new RpcException(FORBIDDEN_MESSAGE);
      }
    };
    return guards.length ? canActivateFn : null;
  }

  public getMetadata<TMetadata, TContext extends ContextType = ContextType>(
    instance: Controller,
    methodName: string,
    defaultCallMetadata: Record<string, any>,
    contextType: TContext,
  ): RpcHandlerMetadata {
    const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
    if (cacheMetadata) {
      return cacheMetadata;
    }
    const metadata =
      this.contextUtils.reflectCallbackMetadata<TMetadata>(
        instance,
        methodName,
        PARAM_ARGS_METADATA,
      ) || defaultCallMetadata;
    const keys = Object.keys(metadata);
    const argsLength = this.contextUtils.getArgumentsLength(keys, metadata);
    const paramtypes = this.contextUtils.reflectCallbackParamtypes(
      instance,
      methodName,
    );
    const contextFactory = this.contextUtils.getContextFactory(
      contextType,
      instance,
      instance[methodName],
    );
    const getParamsMetadata = (moduleKey: string) =>
      this.exchangeKeysForValues(
        keys,
        metadata,
        moduleKey,
        this.rpcParamsFactory,
        contextFactory,
      );

    const handlerMetadata: RpcHandlerMetadata = {
      argsLength,
      paramtypes,
      getParamsMetadata,
    };
    this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
    return handlerMetadata;
  }

  public exchangeKeysForValues<TMetadata = any>(
    keys: string[],
    metadata: TMetadata,
    moduleContext: string,
    paramsFactory: RpcParamsFactory,
    contextFactory: (args: unknown[]) => ExecutionContextHost,
  ): ParamProperties[] {
    this.pipesContextCreator.setModuleContext(moduleContext);

    return keys.map(key => {
      const { index, data, pipes: pipesCollection } = metadata[key];
      const pipes =
        this.pipesContextCreator.createConcreteContext(pipesCollection);
      const type = this.contextUtils.mapParamType(key);

      if (key.includes(CUSTOM_ROUTE_ARGS_METADATA)) {
        const { factory } = metadata[key];
        const customExtractValue = this.contextUtils.getCustomFactory(
          factory,
          data,
          contextFactory,
        );
        return { index, extractValue: customExtractValue, type, data, pipes };
      }
      const numericType = Number(type);
      const extractValue = (...args: unknown[]) =>
        paramsFactory.exchangeKeyForValue(numericType, data, args);

      return { index, extractValue, type: numericType, data, pipes };
    });
  }

  public createPipesFn(
    pipes: PipeTransform[],
    paramsOptions: (ParamProperties & { metatype?: unknown })[],
  ) {
    const pipesFn = async (args: unknown[], ...params: unknown[]) => {
      const resolveParamValue = async (
        param: ParamProperties & { metatype?: unknown },
      ) => {
        const {
          index,
          extractValue,
          type,
          data,
          metatype,
          pipes: paramPipes,
        } = param;
        const value = extractValue(...params);

        args[index] = await this.getParamValue(
          value,
          { metatype, type, data },
          pipes.concat(paramPipes),
        );
      };
      await Promise.all(paramsOptions.map(resolveParamValue));
    };
    return paramsOptions.length ? pipesFn : null;
  }

  public async getParamValue<T>(
    value: T,
    { metatype, type, data }: { metatype: any; type: any; data: any },
    pipes: PipeTransform[],
  ): Promise<any> {
    return isEmpty(pipes)
      ? value
      : this.pipesConsumer.apply(value, { metatype, type, data }, pipes);
  }
}



================================================
FILE: packages/microservices/context/rpc-metadata-constants.ts
================================================
import { RpcParamtype } from '../enums/rpc-paramtype.enum';

export const DEFAULT_CALLBACK_METADATA = {
  [`${RpcParamtype.PAYLOAD}:0`]: { index: 0, data: undefined, pipes: [] },
};
export const DEFAULT_GRPC_CALLBACK_METADATA = {
  [`${RpcParamtype.CONTEXT}:1`]: { index: 1, data: undefined, pipes: [] },
  [`${RpcParamtype.GRPC_CALL}:2`]: { index: 2, data: undefined, pipes: [] },
  ...DEFAULT_CALLBACK_METADATA,
};



================================================
FILE: packages/microservices/context/rpc-proxy.ts
================================================
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { isObservable, Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { RpcExceptionsHandler } from '../exceptions/rpc-exceptions-handler';

export class RpcProxy {
  public create(
    targetCallback: (...args: unknown[]) => Promise<Observable<any>>,
    exceptionsHandler: RpcExceptionsHandler,
  ): (...args: unknown[]) => Promise<Observable<unknown>> {
    return async (...args: unknown[]) => {
      try {
        const result = await targetCallback(...args);
        return !isObservable(result)
          ? result
          : result.pipe(
              catchError(error =>
                this.handleError(exceptionsHandler, args, error),
              ),
            );
      } catch (error) {
        return this.handleError(exceptionsHandler, args, error);
      }
    };
  }

  handleError<T>(
    exceptionsHandler: RpcExceptionsHandler,
    args: unknown[],
    error: T,
  ): Observable<unknown> {
    const host = new ExecutionContextHost(args);
    host.setType('rpc');
    return exceptionsHandler.handle(error as Error, host);
  }
}



================================================
FILE: packages/microservices/ctx-host/base-rpc.context.ts
================================================
/**
 * @publicApi
 */
export class BaseRpcContext<T = unknown[]> {
  constructor(protected readonly args: T) {}

  /**
   * Returns the array of arguments being passed to the handler.
   */
  getArgs(): T {
    return this.args;
  }

  /**
   * Returns a particular argument by index.
   * @param index index of argument to retrieve
   */
  getArgByIndex(index: number) {
    return this.args[index];
  }
}



================================================
FILE: packages/microservices/ctx-host/index.ts
================================================
export * from './kafka.context';
export * from './mqtt.context';
export * from './nats.context';
export * from './redis.context';
export * from './rmq.context';
export * from './tcp.context';
export * from './base-rpc.context';



================================================
FILE: packages/microservices/ctx-host/kafka.context.ts
================================================
import { Consumer, KafkaMessage, Producer } from '../external/kafka.interface';
import { BaseRpcContext } from './base-rpc.context';

type KafkaContextArgs = [
  message: KafkaMessage,
  partition: number,
  topic: string,
  consumer: Consumer,
  heartbeat: () => Promise<void>,
  producer: Producer,
];

/**
 * @publicApi
 */
export class KafkaContext extends BaseRpcContext<KafkaContextArgs> {
  constructor(args: KafkaContextArgs) {
    super(args);
  }

  /**
   * Returns the reference to the original message.
   */
  getMessage() {
    return this.args[0];
  }

  /**
   * Returns the partition.
   */
  getPartition() {
    return this.args[1];
  }

  /**
   * Returns the name of the topic.
   */
  getTopic() {
    return this.args[2];
  }

  /**
   * Returns the Kafka consumer reference.
   */
  getConsumer() {
    return this.args[3];
  }

  /**
   * Returns the Kafka heartbeat callback.
   */
  getHeartbeat() {
    return this.args[4];
  }

  /**
   * Returns the Kafka producer reference,
   */
  getProducer() {
    return this.args[5];
  }
}



================================================
FILE: packages/microservices/ctx-host/mqtt.context.ts
================================================
import { BaseRpcContext } from './base-rpc.context';

type MqttContextArgs = [string, Record<string, any>];

/**
 * @publicApi
 */
export class MqttContext extends BaseRpcContext<MqttContextArgs> {
  constructor(args: MqttContextArgs) {
    super(args);
  }

  /**
   * Returns the name of the topic.
   */
  getTopic() {
    return this.args[0];
  }

  /**
   * Returns the reference to the original MQTT packet.
   */
  getPacket() {
    return this.args[1];
  }
}



================================================
FILE: packages/microservices/ctx-host/nats.context.ts
================================================
import { BaseRpcContext } from './base-rpc.context';

type NatsContextArgs = [string, any];

/**
 * @publicApi
 */
export class NatsContext extends BaseRpcContext<NatsContextArgs> {
  constructor(args: NatsContextArgs) {
    super(args);
  }

  /**
   * Returns the name of the subject.
   */
  getSubject() {
    return this.args[0];
  }

  /**
   * Returns message headers (if exist).
   */
  getHeaders() {
    return this.args[1];
  }
}



================================================
FILE: packages/microservices/ctx-host/redis.context.ts
================================================
import { BaseRpcContext } from './base-rpc.context';

type RedisContextArgs = [string];

/**
 * @publicApi
 */
export class RedisContext extends BaseRpcContext<RedisContextArgs> {
  constructor(args: RedisContextArgs) {
    super(args);
  }

  /**
   * Returns the name of the channel.
   */
  getChannel() {
    return this.args[0];
  }
}



================================================
FILE: packages/microservices/ctx-host/rmq.context.ts
================================================
import { BaseRpcContext } from './base-rpc.context';

type RmqContextArgs = [Record<string, any>, any, string];

/**
 * @publicApi
 */
export class RmqContext extends BaseRpcContext<RmqContextArgs> {
  constructor(args: RmqContextArgs) {
    super(args);
  }

  /**
   * Returns the original message (with properties, fields, and content).
   */
  getMessage() {
    return this.args[0];
  }

  /**
   * Returns the reference to the original RMQ channel.
   */
  getChannelRef() {
    return this.args[1];
  }

  /**
   * Returns the name of the pattern.
   */
  getPattern() {
    return this.args[2];
  }
}



================================================
FILE: packages/microservices/ctx-host/tcp.context.ts
================================================
import { TcpSocket } from '../helpers';
import { BaseRpcContext } from './base-rpc.context';

type TcpContextArgs = [TcpSocket, string];

/**
 * @publicApi
 */
export class TcpContext extends BaseRpcContext<TcpContextArgs> {
  constructor(args: TcpContextArgs) {
    super(args);
  }

  /**
   * Returns the underlying JSON socket.
   */
  getSocketRef() {
    return this.args[0];
  }

  /**
   * Returns the name of the pattern.
   */
  getPattern() {
    return this.args[1];
  }
}



================================================
FILE: packages/microservices/decorators/client.decorator.ts
================================================
import { CLIENT_CONFIGURATION_METADATA, CLIENT_METADATA } from '../constants';
import { ClientOptions } from '../interfaces/client-metadata.interface';

/**
 * Attaches the `ClientProxy` instance to the given property
 *
 * @param  {ClientOptions} metadata optional client metadata
 *
 * @publicApi
 *
 */
export function Client(metadata?: ClientOptions): PropertyDecorator {
  return (target: object, propertyKey: string | symbol): void => {
    Reflect.set(target, propertyKey, null);
    Reflect.defineMetadata(CLIENT_METADATA, true, target, propertyKey);
    Reflect.defineMetadata(
      CLIENT_CONFIGURATION_METADATA,
      metadata,
      target,
      propertyKey,
    );
  };
}



================================================
FILE: packages/microservices/decorators/ctx.decorator.ts
================================================
import { RpcParamtype } from '../enums/rpc-paramtype.enum';
import { createRpcParamDecorator } from '../utils/param.utils';

export const Ctx: () => ParameterDecorator = createRpcParamDecorator(
  RpcParamtype.CONTEXT,
);



================================================
FILE: packages/microservices/decorators/event-pattern.decorator.ts
================================================
import {
  isNil,
  isNumber,
  isObject,
  isSymbol,
} from '@nestjs/common/utils/shared.utils';
import {
  PATTERN_EXTRAS_METADATA,
  PATTERN_HANDLER_METADATA,
  PATTERN_METADATA,
  TRANSPORT_METADATA,
} from '../constants';
import { Transport } from '../enums';
import { PatternHandler } from '../enums/pattern-handler.enum';

/**
 * Subscribes to incoming events which fulfils chosen pattern.
 *
 * @publicApi
 */
export const EventPattern: {
  <T = string>(metadata?: T): MethodDecorator;
  <T = string>(metadata?: T, transport?: Transport | symbol): MethodDecorator;
  <T = string>(metadata?: T, extras?: Record<string, any>): MethodDecorator;
  <T = string>(
    metadata?: T,
    transport?: Transport | symbol,
    extras?: Record<string, any>,
  ): MethodDecorator;
} = <T = string>(
  metadata?: T,
  transportOrExtras?: Transport | symbol | Record<string, any>,
  maybeExtras?: Record<string, any>,
): MethodDecorator => {
  let transport: Transport | symbol;
  let extras: Record<string, any>;
  if (
    (isNumber(transportOrExtras) || isSymbol(transportOrExtras)) &&
    isNil(maybeExtras)
  ) {
    transport = transportOrExtras;
  } else if (isObject(transportOrExtras) && isNil(maybeExtras)) {
    extras = transportOrExtras;
  } else {
    transport = transportOrExtras as Transport | symbol;
    extras = maybeExtras!;
  }
  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    Reflect.defineMetadata(
      PATTERN_METADATA,
      ([] as any[]).concat(metadata),
      descriptor.value,
    );
    Reflect.defineMetadata(
      PATTERN_HANDLER_METADATA,
      PatternHandler.EVENT,
      descriptor.value,
    );
    Reflect.defineMetadata(TRANSPORT_METADATA, transport, descriptor.value);
    Reflect.defineMetadata(
      PATTERN_EXTRAS_METADATA,
      {
        ...Reflect.getMetadata(PATTERN_EXTRAS_METADATA, descriptor.value),
        ...extras,
      },
      descriptor.value,
    );
    return descriptor;
  };
};



================================================
FILE: packages/microservices/decorators/grpc-service.decorator.ts
================================================
import { Controller } from '@nestjs/common';

/**
 * Defines the GrpcService. The service can inject dependencies through constructor.
 * Those dependencies have to belong to the same module.
 */
export const GrpcService = Controller;



================================================
FILE: packages/microservices/decorators/index.ts
================================================
export * from './client.decorator';
export * from './ctx.decorator';
export * from './event-pattern.decorator';
export * from './grpc-service.decorator';
export * from './message-pattern.decorator';
export * from './payload.decorator';



================================================
FILE: packages/microservices/decorators/message-pattern.decorator.ts
================================================
import {
  isNil,
  isNumber,
  isObject,
  isSymbol,
} from '@nestjs/common/utils/shared.utils';

import {
  PATTERN_EXTRAS_METADATA,
  PATTERN_HANDLER_METADATA,
  PATTERN_METADATA,
  TRANSPORT_METADATA,
} from '../constants';
import { Transport } from '../enums';
import { PatternHandler } from '../enums/pattern-handler.enum';
import {
  InvalidGrpcDecoratorException,
  RpcDecoratorMetadata,
} from '../errors/invalid-grpc-message-decorator.exception';
import { PatternMetadata } from '../interfaces/pattern-metadata.interface';

export enum GrpcMethodStreamingType {
  NO_STREAMING = 'no_stream',
  RX_STREAMING = 'rx_stream',
  PT_STREAMING = 'pt_stream',
}

/**
 * Subscribes to incoming messages which fulfils chosen pattern.
 *
 * @publicApi
 */
export const MessagePattern: {
  <T = PatternMetadata | string>(metadata?: T): MethodDecorator;
  <T = PatternMetadata | string>(
    metadata?: T,
    transport?: Transport | symbol,
  ): MethodDecorator;
  <T = PatternMetadata | string>(
    metadata?: T,
    extras?: Record<string, any>,
  ): MethodDecorator;
  <T = PatternMetadata | string>(
    metadata?: T,
    transport?: Transport | symbol,
    extras?: Record<string, any>,
  ): MethodDecorator;
} = <T = PatternMetadata | string>(
  metadata?: T,
  transportOrExtras?: Transport | symbol | Record<string, any>,
  maybeExtras?: Record<string, any>,
): MethodDecorator => {
  let transport: Transport | symbol;
  let extras: Record<string, any>;
  if (
    (isNumber(transportOrExtras) || isSymbol(transportOrExtras)) &&
    isNil(maybeExtras)
  ) {
    transport = transportOrExtras;
  } else if (isObject(transportOrExtras) && isNil(maybeExtras)) {
    extras = transportOrExtras;
  } else {
    transport = transportOrExtras as Transport | symbol;
    extras = maybeExtras!;
  }

  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    try {
      Reflect.defineMetadata(
        PATTERN_METADATA,
        ([] as any[]).concat(metadata),
        descriptor.value,
      );
      Reflect.defineMetadata(
        PATTERN_HANDLER_METADATA,
        PatternHandler.MESSAGE,
        descriptor.value,
      );
      Reflect.defineMetadata(TRANSPORT_METADATA, transport, descriptor.value);
      Reflect.defineMetadata(
        PATTERN_EXTRAS_METADATA,
        {
          ...Reflect.getMetadata(PATTERN_EXTRAS_METADATA, descriptor.value),
          ...extras,
        },
        descriptor.value,
      );
      return descriptor;
    } catch (err) {
      throw new InvalidGrpcDecoratorException(metadata as RpcDecoratorMetadata);
    }
  };
};

/**
 * Registers gRPC method handler for specified service.
 */
export function GrpcMethod(service?: string): MethodDecorator;
export function GrpcMethod(service: string, method?: string): MethodDecorator;
export function GrpcMethod(
  service: string | undefined,
  method?: string,
): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    const metadata = createGrpcMethodMetadata(target, key, service, method);
    return MessagePattern(metadata, Transport.GRPC)(target, key, descriptor);
  };
}

/**
 * Registers gRPC call through RX handler for service and method
 *
 * @param service String parameter reflecting the name of service definition from proto file
 */
export function GrpcStreamMethod(service?: string): MethodDecorator;
/**
 * @param service String parameter reflecting the name of service definition from proto file
 * @param method Optional string parameter reflecting the name of method inside of a service definition coming after rpc keyword
 */
export function GrpcStreamMethod(
  service: string,
  method?: string,
): MethodDecorator;
export function GrpcStreamMethod(
  service: string | undefined,
  method?: string,
): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    const metadata = createGrpcMethodMetadata(
      target,
      key,
      service,
      method,
      GrpcMethodStreamingType.RX_STREAMING,
    );

    MessagePattern(metadata, Transport.GRPC)(target, key, descriptor);

    const originalMethod = descriptor.value;

    // Override original method to call the "drainBuffer" method on the first parameter
    // This is required to avoid premature message emission
    descriptor.value = async function (
      this: any,
      observable: any,
      ...args: any[]
    ) {
      const result = await Promise.resolve(
        originalMethod.apply(this, [observable, ...args]),
      );

      // Drain buffer if "drainBuffer" method is available
      if (observable && observable.drainBuffer) {
        observable.drainBuffer();
      }
      return result;
    };

    // Copy all metadata from the original method to the new one
    const metadataKeys = Reflect.getMetadataKeys(originalMethod);
    metadataKeys.forEach(metadataKey => {
      const metadataValue = Reflect.getMetadata(metadataKey, originalMethod);
      Reflect.defineMetadata(metadataKey, metadataValue, descriptor.value);
    });
  };
}

/**
 * Registers gRPC call pass through handler for service and method
 *
 * @param service String parameter reflecting the name of service definition from proto file
 */
export function GrpcStreamCall(service?: string): MethodDecorator;
/**
 * @param service String parameter reflecting the name of service definition from proto file
 * @param method Optional string parameter reflecting the name of method inside of a service definition coming after rpc keyword
 */
export function GrpcStreamCall(
  service: string,
  method?: string,
): MethodDecorator;
export function GrpcStreamCall(
  service: string | undefined,
  method?: string,
): MethodDecorator {
  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    const metadata = createGrpcMethodMetadata(
      target,
      key,
      service,
      method,
      GrpcMethodStreamingType.PT_STREAMING,
    );
    return MessagePattern(metadata, Transport.GRPC)(target, key, descriptor);
  };
}

export function createGrpcMethodMetadata(
  target: object,
  key: string | symbol,
  service: string | undefined,
  method: string | undefined,
  streaming = GrpcMethodStreamingType.NO_STREAMING,
) {
  const capitalizeFirstLetter = (str: string) =>
    str.charAt(0).toUpperCase() + str.slice(1);

  if (!service) {
    const { name } = target.constructor;
    return {
      service: name,
      rpc: capitalizeFirstLetter(key as string),
      streaming,
    };
  }
  if (service && !method) {
    return { service, rpc: capitalizeFirstLetter(key as string), streaming };
  }
  return { service, rpc: method, streaming };
}



================================================
FILE: packages/microservices/decorators/payload.decorator.ts
================================================
import { PipeTransform, Type } from '@nestjs/common';
import { RpcParamtype } from '../enums/rpc-paramtype.enum';
import { createPipesRpcParamDecorator } from '../utils/param.utils';

/**
 * Microservice message pattern payload parameter decorator.
 *
 * @publicApi
 */
export function Payload(): ParameterDecorator;
/**
 * Microservice message pattern payload parameter decorator.
 *
 * Example:
 * ```typescript
 * create(@Payload(new ValidationPipe()) createDto: CreateCatDto)
 * ```
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @publicApi
 */
export function Payload(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * Microservice message pattern payload parameter decorator. Extracts a property from the
 * payload object. May also apply pipes to the bound parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findMany(@Payload() ids: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * create(@Payload('data') createDto: { data: string })
 * ```
 *
 * For example, extracting a single param with pipe:
 * ```typescript
 * create(@Payload('data', new ValidationPipe()) createDto: { data: string })
 * ```
 * @param propertyKey name of single property to extract from the message payload
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @publicApi
 */
export function Payload(
  propertyKey?: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
export function Payload(
  propertyOrPipe?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesRpcParamDecorator(RpcParamtype.PAYLOAD)(
    propertyOrPipe,
    ...pipes,
  );
}



================================================
FILE: packages/microservices/deserializers/identity.deserializer.ts
================================================
import { Deserializer } from '../interfaces/deserializer.interface';

/**
 * @publicApi
 */
export class IdentityDeserializer implements Deserializer {
  deserialize(value: any) {
    return value;
  }
}



================================================
FILE: packages/microservices/deserializers/incoming-request.deserializer.ts
================================================
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import {
  ConsumerDeserializer,
  IncomingEvent,
  IncomingRequest,
} from '../interfaces';

/**
 * @publicApi
 */
export class IncomingRequestDeserializer implements ConsumerDeserializer {
  deserialize(
    value: any,
    options?: Record<string, any>,
  ): IncomingRequest | IncomingEvent {
    return this.isExternal(value) ? this.mapToSchema(value, options) : value;
  }

  isExternal(value: any): boolean {
    if (!value) {
      return true;
    }
    if (
      !isUndefined((value as IncomingRequest).pattern) ||
      !isUndefined((value as IncomingRequest).data)
    ) {
      return false;
    }
    return true;
  }

  mapToSchema(
    value: any,
    options?: Record<string, any>,
  ): IncomingRequest | IncomingEvent {
    if (!options) {
      return {
        pattern: undefined,
        data: undefined,
      };
    }
    return {
      pattern: options.channel,
      data: value,
    };
  }
}



================================================
FILE: packages/microservices/deserializers/incoming-response.deserializer.ts
================================================
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import { IncomingResponse, ProducerDeserializer } from '../interfaces';

/**
 * @publicApi
 */
export class IncomingResponseDeserializer implements ProducerDeserializer {
  deserialize(value: any, options?: Record<string, any>): IncomingResponse {
    return this.isExternal(value) ? this.mapToSchema(value) : value;
  }

  isExternal(value: any): boolean {
    if (!value) {
      return true;
    }
    if (
      !isUndefined((value as IncomingResponse).err) ||
      !isUndefined((value as IncomingResponse).response) ||
      !isUndefined((value as IncomingResponse).isDisposed)
    ) {
      return false;
    }
    return true;
  }

  mapToSchema(value: any): IncomingResponse {
    return {
      id: value && value.id,
      response: value,
      isDisposed: true,
    };
  }
}



================================================
FILE: packages/microservices/deserializers/index.ts
================================================
export * from './identity.deserializer';
export * from './incoming-request.deserializer';
export * from './incoming-response.deserializer';
export * from './kafka-request.deserializer';
export * from './kafka-response.deserializer';
export * from './nats-request-json.deserializer';
export * from './nats-response-json.deserializer';



================================================
FILE: packages/microservices/deserializers/kafka-request.deserializer.ts
================================================
import { IncomingEvent, IncomingRequest } from '../interfaces';
import { KafkaRequest } from '../serializers/kafka-request.serializer';
import { IncomingRequestDeserializer } from './incoming-request.deserializer';

/**
 * @publicApi
 */
export class KafkaRequestDeserializer extends IncomingRequestDeserializer {
  mapToSchema(
    data: KafkaRequest,
    options?: Record<string, any>,
  ): IncomingRequest | IncomingEvent {
    if (!options) {
      return {
        pattern: undefined,
        data: undefined,
      };
    }
    return {
      pattern: options.channel,
      data: data?.value ?? data,
    };
  }
}



================================================
FILE: packages/microservices/deserializers/kafka-response.deserializer.ts
================================================
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import { KafkaHeaders } from '../enums/kafka-headers.enum';
import { Deserializer, IncomingResponse } from '../interfaces';

/**
 * @publicApi
 */
export class KafkaResponseDeserializer
  implements Deserializer<any, IncomingResponse>
{
  deserialize(message: any, options?: Record<string, any>): IncomingResponse {
    const id = message.headers[KafkaHeaders.CORRELATION_ID].toString();
    if (!isUndefined(message.headers[KafkaHeaders.NEST_ERR])) {
      return {
        id,
        err: message.headers[KafkaHeaders.NEST_ERR],
        isDisposed: true,
      };
    }
    if (!isUndefined(message.headers[KafkaHeaders.NEST_IS_DISPOSED])) {
      return {
        id,
        response: message.value,
        isDisposed: true,
      };
    }
    return {
      id,
      response: message.value,
      isDisposed: false,
    };
  }
}



================================================
FILE: packages/microservices/deserializers/nats-request-json.deserializer.ts
================================================
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { NatsCodec } from '../external/nats-codec.interface';
import { IncomingEvent, IncomingRequest } from '../interfaces';
import { IncomingRequestDeserializer } from './incoming-request.deserializer';

let natsPackage = {} as any;

/**
 * @publicApi
 */
export class NatsRequestJSONDeserializer extends IncomingRequestDeserializer {
  private readonly jsonCodec: NatsCodec<unknown>;

  constructor() {
    super();

    natsPackage = loadPackage('nats', NatsRequestJSONDeserializer.name, () =>
      require('nats'),
    );
    this.jsonCodec = natsPackage.JSONCodec();
  }

  deserialize(
    value: Uint8Array,
    options?: Record<string, any>,
  ): IncomingRequest | IncomingEvent {
    const decodedRequest = this.jsonCodec.decode(value);
    return super.deserialize(decodedRequest, options);
  }
}



================================================
FILE: packages/microservices/deserializers/nats-response-json.deserializer.ts
================================================
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { NatsCodec } from '../external/nats-codec.interface';
import { IncomingResponse } from '../interfaces';
import { IncomingResponseDeserializer } from './incoming-response.deserializer';
import { NatsRequestJSONDeserializer } from './nats-request-json.deserializer';

let natsPackage = {} as any;

/**
 * @publicApi
 */
export class NatsResponseJSONDeserializer extends IncomingResponseDeserializer {
  private readonly jsonCodec: NatsCodec<unknown>;

  constructor() {
    super();

    natsPackage = loadPackage('nats', NatsRequestJSONDeserializer.name, () =>
      require('nats'),
    );
    this.jsonCodec = natsPackage.JSONCodec();
  }

  deserialize(
    value: Uint8Array,
    options?: Record<string, any>,
  ): IncomingResponse {
    const decodedRequest = this.jsonCodec.decode(value);
    return super.deserialize(decodedRequest, options);
  }
}



================================================
FILE: packages/microservices/enums/index.ts
================================================
export * from './transport.enum';
export * from './kafka-headers.enum';



================================================
FILE: packages/microservices/enums/kafka-headers.enum.ts
================================================
/**
 * @see https://docs.spring.io/spring-kafka/api/org/springframework/kafka/support/KafkaHeaders.html
 *
 * @publicApi
 */
export enum KafkaHeaders {
  ACKNOWLEDGMENT = 'kafka_acknowledgment',
  BATCH_CONVERTED_HEADERS = 'kafka_batchConvertedHeaders',
  CONSUMER = 'kafka_consumer',
  CORRELATION_ID = 'kafka_correlationId',
  DELIVERY_ATTEMPT = 'kafka_deliveryAttempt',
  DLT_EXCEPTION_FQCN = 'kafka_dlt-exception-fqcn',
  DLT_EXCEPTION_MESSAGE = 'kafka_dlt-exception-message',
  DLT_EXCEPTION_STACKTRACE = 'kafka_dlt-exception-stacktrace',
  DLT_ORIGINAL_OFFSET = 'kafka_dlt-original-offset',
  DLT_ORIGINAL_PARTITION = 'kafka_dlt-original-partition',
  DLT_ORIGINAL_TIMESTAMP = 'kafka_dlt-original-timestamp',
  DLT_ORIGINAL_TIMESTAMP_TYPE = 'kafka_dlt-original-timestamp-type',
  DLT_ORIGINAL_TOPIC = 'kafka_dlt-original-topic',
  GROUP_ID = 'kafka_groupId',
  MESSAGE_KEY = 'kafka_messageKey',
  NATIVE_HEADERS = 'kafka_nativeHeaders',
  OFFSET = 'kafka_offset',
  PARTITION_ID = 'kafka_partitionId',
  PREFIX = 'kafka_',
  RAW_DATA = 'kafka_data',
  RECEIVED = 'kafka_received',
  RECEIVED_MESSAGE_KEY = 'kafka_receivedMessageKey',
  RECEIVED_PARTITION_ID = 'kafka_receivedPartitionId',
  RECEIVED_TIMESTAMP = 'kafka_receivedTimestamp',
  RECEIVED_TOPIC = 'kafka_receivedTopic',
  RECORD_METADATA = 'kafka_recordMetadata',
  REPLY_PARTITION = 'kafka_replyPartition',
  REPLY_TOPIC = 'kafka_replyTopic',
  TIMESTAMP = 'kafka_timestamp',
  TIMESTAMP_TYPE = 'kafka_timestampType',
  TOPIC = 'kafka_topic',

  // framework specific headers
  NEST_ERR = 'kafka_nest-err',
  NEST_IS_DISPOSED = 'kafka_nest-is-disposed',
}



================================================
FILE: packages/microservices/enums/pattern-handler.enum.ts
================================================
export enum PatternHandler {
  MESSAGE = 1,
  EVENT = 2,
}



================================================
FILE: packages/microservices/enums/rpc-paramtype.enum.ts
================================================
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';

export enum RpcParamtype {
  PAYLOAD = RouteParamtypes.BODY,
  CONTEXT = RouteParamtypes.HEADERS,
  GRPC_CALL = RouteParamtypes.FILES,
}



================================================
FILE: packages/microservices/enums/transport.enum.ts
================================================
export enum Transport {
  TCP,
  REDIS,
  NATS,
  MQTT,
  GRPC,
  RMQ,
  KAFKA,
}



================================================
FILE: packages/microservices/errors/corrupted-packet-length.exception.ts
================================================
/**
 * @publicApi
 */
export class CorruptedPacketLengthException extends Error {
  constructor(rawContentLength: string) {
    super(`Corrupted length value "${rawContentLength}" supplied in a packet`);
  }
}



================================================
FILE: packages/microservices/errors/empty-response.exception.ts
================================================
/**
 * @publicApi
 */
export class EmptyResponseException extends Error {
  constructor(pattern: string) {
    super(
      `Empty response. There are no subscribers listening to that message ("${pattern}")`,
    );
  }
}



================================================
FILE: packages/microservices/errors/invalid-grpc-message-decorator.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

export interface RpcDecoratorMetadata {
  service: string;
  rpc: string;
  streaming: string;
}

/**
 * @publicApi
 */
export class InvalidGrpcDecoratorException extends RuntimeException {
  constructor(metadata: RpcDecoratorMetadata) {
    super(
      `The invalid gRPC decorator (method "${metadata.rpc}" in service "${metadata.service}")`,
    );
  }
}



================================================
FILE: packages/microservices/errors/invalid-grpc-package-definition-missing-package-definition.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

export class InvalidGrpcPackageDefinitionMissingPackageDefinitionException extends RuntimeException {
  constructor() {
    super(
      `Invalid gRPC configuration. protoPath or packageDefinition must be defined.`,
    );
  }
}



================================================
FILE: packages/microservices/errors/invalid-grpc-package-definition-mutex.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

export class InvalidGrpcPackageDefinitionMutexException extends RuntimeException {
  constructor() {
    super(
      `Invalid gRPC configuration. Both protoPath and packageDefinition cannot be defined at the same time.`,
    );
  }
}



================================================
FILE: packages/microservices/errors/invalid-grpc-package.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

/**
 * @publicApi
 */
export class InvalidGrpcPackageException extends RuntimeException {
  constructor(name: string) {
    super(`The invalid gRPC package (package "${name}" not found)`);
  }
}



================================================
FILE: packages/microservices/errors/invalid-grpc-service.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

/**
 * @publicApi
 */
export class InvalidGrpcServiceException extends RuntimeException {
  constructor(name: string) {
    super(`The invalid gRPC service (service "${name}" not found)`);
  }
}



================================================
FILE: packages/microservices/errors/invalid-json-format.exception.ts
================================================
/**
 * @publicApi
 */
export class InvalidJSONFormatException extends Error {
  constructor(err: Error, data: string) {
    super(`Could not parse JSON: ${err.message}\nRequest data: ${data}`);
  }
}



================================================
FILE: packages/microservices/errors/invalid-kafka-client-topic.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

/**
 * @publicApi
 */
export class InvalidKafkaClientTopicException extends RuntimeException {
  constructor(topic?: string) {
    super(
      `The client consumer did not subscribe to the corresponding reply topic (${topic}).`,
    );
  }
}



================================================
FILE: packages/microservices/errors/invalid-message.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

/**
 * @publicApi
 */
export class InvalidMessageException extends RuntimeException {
  constructor() {
    super(`The invalid data or message pattern (undefined/null)`);
  }
}



================================================
FILE: packages/microservices/errors/invalid-proto-definition.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

/**
 * @publicApi
 */
export class InvalidProtoDefinitionException extends RuntimeException {
  constructor(path: string) {
    super(`The invalid .proto definition (file at "${path}" not found)`);
  }
}



================================================
FILE: packages/microservices/errors/max-packet-length-exceeded.exception.ts
================================================
/**
 * @publicApi
 */
export class MaxPacketLengthExceededException extends Error {
  constructor(length: number) {
    super(`The packet length (${length}) exceeds the maximum allowed length`);
  }
}



================================================
FILE: packages/microservices/errors/net-socket-closed.exception.ts
================================================
/**
 * @publicApi
 */
export class NetSocketClosedException extends Error {
  constructor() {
    super(`The net socket is closed.`);
  }
}



================================================
FILE: packages/microservices/events/index.ts
================================================
export { KafkaStatus } from './kafka.events';
export { MqttEvents, MqttStatus } from './mqtt.events';
export { NatsEvents, NatsStatus } from './nats.events';
export { RedisEvents, RedisStatus } from './redis.events';
export { RmqEvents, RmqStatus } from './rmq.events';
export { TcpEvents, TcpStatus } from './tcp.events';



================================================
FILE: packages/microservices/events/kafka.events.ts
================================================
export const enum KafkaStatus {
  DISCONNECTED = 'disconnected',
  CONNECTED = 'connected',
  CRASHED = 'crashed',
  STOPPED = 'stopped',
  REBALANCING = 'rebalancing',
}



================================================
FILE: packages/microservices/events/mqtt.events.ts
================================================
type VoidCallback = () => void;
type OnPacketCallback = (packet: any) => void;
type OnErrorCallback = (error: Error) => void;

export const enum MqttStatus {
  DISCONNECTED = 'disconnected',
  RECONNECTING = 'reconnecting',
  CONNECTED = 'connected',
  CLOSED = 'closed',
}

export const enum MqttEventsMap {
  CONNECT = 'connect',
  RECONNECT = 'reconnect',
  DISCONNECT = 'disconnect',
  CLOSE = 'close',
  OFFLINE = 'offline',
  END = 'end',
  ERROR = 'error',
  PACKETRECEIVE = 'packetreceive',
  PACKETSEND = 'packetsend',
}

/**
 * MQTT events map for the MQTT client.
 * Key is the event name and value is the corresponding callback function.
 * @publicApi
 */
export type MqttEvents = {
  connect: OnPacketCallback;
  reconnect: VoidCallback;
  disconnect: OnPacketCallback;
  close: VoidCallback;
  offline: VoidCallback;
  end: VoidCallback;
  error: OnErrorCallback;
  packetreceive: OnPacketCallback;
  packetsend: OnPacketCallback;
};



================================================
FILE: packages/microservices/events/nats.events.ts
================================================
type DefaultCallback = (data?: string | number) => any;

export type ServersChangedEvent = {
  added: string[];
  deleted: string[];
};

export const enum NatsStatus {
  DISCONNECTED = 'disconnected',
  RECONNECTING = 'reconnecting',
  CONNECTED = 'connected',
}

export const enum NatsEventsMap {
  DISCONNECT = 'disconnect',
  RECONNECT = 'reconnect',
  UPDATE = 'update',
}

/**
 * Nats events map for the Nats client.
 * Key is the event name and value is the corresponding callback function.
 * @publicApi
 */
export type NatsEvents = {
  disconnect: DefaultCallback;
  reconnect: DefaultCallback;
  update: (data?: string | number | ServersChangedEvent) => any;
};



================================================
FILE: packages/microservices/events/redis.events.ts
================================================
type VoidCallback = (client: 'pub' | 'sub') => void;
type OnErrorCallback = (client: 'pub' | 'sub', error: Error) => void;
type OnWarningCallback = (client: 'pub' | 'sub', warning: any) => void;

export const enum RedisStatus {
  DISCONNECTED = 'disconnected',
  RECONNECTING = 'reconnecting',
  CONNECTED = 'connected',
}

export const enum RedisEventsMap {
  CONNECT = 'connect',
  READY = 'ready',
  ERROR = 'error',
  CLOSE = 'close',
  RECONNECTING = 'reconnecting',
  END = 'end',
  WARNING = 'warning',
}

/**
 * Redis events map for the Redis client.
 * Key is the event name and value is the corresponding callback function.
 * @publicApi
 */
export type RedisEvents = {
  connect: VoidCallback;
  ready: VoidCallback;
  error: OnErrorCallback;
  close: VoidCallback;
  reconnecting: VoidCallback;
  end: VoidCallback;
  warning: OnWarningCallback;
};



================================================
FILE: packages/microservices/events/rmq.events.ts
================================================
type VoidCallback = () => void;
type OnErrorCallback = (error: Error) => void;

export const enum RmqStatus {
  DISCONNECTED = 'disconnected',
  CONNECTED = 'connected',
}

export const enum RmqEventsMap {
  ERROR = 'error',
  DISCONNECT = 'disconnect',
  CONNECT = 'connect',
}

/**
 * RabbitMQ events map for the ampqlip client.
 * Key is the event name and value is the corresponding callback function.
 * @publicApi
 */
export type RmqEvents = {
  error: OnErrorCallback;
  disconnect: VoidCallback;
  connect: VoidCallback;
};



================================================
FILE: packages/microservices/events/tcp.events.ts
================================================
type VoidCallback = () => void;
type OnErrorCallback = (error: Error) => void;
type OnLookupCallback = (
  err: Error,
  address: string,
  family: string,
  host: string,
) => void;

export const enum TcpStatus {
  DISCONNECTED = 'disconnected',
  CONNECTED = 'connected',
}

export const enum TcpEventsMap {
  ERROR = 'error',
  CONNECT = 'connect',
  END = 'end',
  CLOSE = 'close',
  TIMEOUT = 'timeout',
  DRAIN = 'drain',
  LOOKUP = 'lookup',
  LISTENING = 'listening',
}

/**
 * TCP events map for the net TCP socket.
 * Key is the event name and value is the corresponding callback function.
 * @publicApi
 */
export type TcpEvents = {
  error: OnErrorCallback;
  connect: VoidCallback;
  end: VoidCallback;
  close: VoidCallback;
  timeout: VoidCallback;
  drain: VoidCallback;
  lookup: OnLookupCallback;
};



================================================
FILE: packages/microservices/exceptions/base-rpc-exception-filter.ts
================================================
import {
  ArgumentsHost,
  IntrinsicException,
  Logger,
  RpcExceptionFilter,
} from '@nestjs/common';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { MESSAGES } from '@nestjs/core/constants';
import { Observable, throwError as _throw } from 'rxjs';
import { RpcException } from './rpc-exception';

/**
 * @publicApi
 */
export class BaseRpcExceptionFilter<T = any, R = any>
  implements RpcExceptionFilter<T>
{
  private static readonly logger = new Logger('RpcExceptionsHandler');

  public catch(exception: T, host: ArgumentsHost): Observable<R> {
    const status = 'error';
    if (!(exception instanceof RpcException)) {
      return this.handleUnknownError(exception, status);
    }
    const res = exception.getError();
    const message = isObject(res) ? res : { status, message: res };
    return _throw(() => message);
  }

  public handleUnknownError(exception: T, status: string) {
    const errorMessage = MESSAGES.UNKNOWN_EXCEPTION_MESSAGE;

    if (!(exception instanceof IntrinsicException)) {
      const logger = BaseRpcExceptionFilter.logger;
      logger.error(exception);
    }

    return _throw(() => ({ status, message: errorMessage }));
  }

  public isError(exception: any): exception is Error {
    return !!(isObject(exception) && (exception as Error).message);
  }
}



================================================
FILE: packages/microservices/exceptions/index.ts
================================================
export * from './base-rpc-exception-filter';
export * from './kafka-retriable-exception';
export * from './rpc-exception';



================================================
FILE: packages/microservices/exceptions/kafka-retriable-exception.ts
================================================
import { RpcException } from './rpc-exception';

/**
 * Exception that instructs Kafka driver to instead of introspecting
 * error processing flow and sending serialized error message to the consumer,
 * force bubble it up to the "eachMessage" callback of the underlying "kafkajs" package
 * (even if interceptors are applied, or an observable stream is returned from the message handler).
 *
 * A transient exception that if retried may succeed.
 *
 * @publicApi
 */
export class KafkaRetriableException extends RpcException {
  public getError(): string | object {
    return this;
  }
}



================================================
FILE: packages/microservices/exceptions/rpc-exception.ts
================================================
import { isObject, isString } from '@nestjs/common/utils/shared.utils';

/**
 * @publicApi
 */
export class RpcException extends Error {
  constructor(private readonly error: string | object) {
    super();
    this.initMessage();
  }

  public initMessage() {
    if (isString(this.error)) {
      this.message = this.error;
    } else if (
      isObject(this.error) &&
      isString((this.error as Record<string, any>).message)
    ) {
      this.message = (this.error as Record<string, any>).message;
    } else if (this.constructor) {
      this.message = this.constructor.name
        .match(/[A-Z][a-z]+|[0-9]+/g)!
        .join(' ');
    }
  }

  public getError(): string | object {
    return this.error;
  }
}



================================================
FILE: packages/microservices/exceptions/rpc-exceptions-handler.ts
================================================
import { RpcExceptionFilterMetadata } from '@nestjs/common/interfaces/exceptions';
import { ArgumentsHost } from '@nestjs/common/interfaces/features/arguments-host.interface';
import { selectExceptionFilterMetadata } from '@nestjs/common/utils/select-exception-filter-metadata.util';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { InvalidExceptionFilterException } from '@nestjs/core/errors/exceptions/invalid-exception-filter.exception';
import { Observable } from 'rxjs';
import { BaseRpcExceptionFilter } from './base-rpc-exception-filter';
import { RpcException } from './rpc-exception';

/**
 * @publicApi
 */
export class RpcExceptionsHandler extends BaseRpcExceptionFilter {
  private filters: RpcExceptionFilterMetadata[] = [];

  public handle(
    exception: Error | RpcException,
    host: ArgumentsHost,
  ): Observable<any> {
    const filterResult$ = this.invokeCustomFilters(exception, host);
    if (filterResult$) {
      return filterResult$;
    }
    return super.catch(exception, host);
  }

  public setCustomFilters(filters: RpcExceptionFilterMetadata[]) {
    if (!Array.isArray(filters)) {
      throw new InvalidExceptionFilterException();
    }
    this.filters = filters;
  }

  public invokeCustomFilters<T = any>(
    exception: T,
    host: ArgumentsHost,
  ): Observable<any> | null {
    if (isEmpty(this.filters)) {
      return null;
    }

    const filter = selectExceptionFilterMetadata(this.filters, exception);
    return filter ? filter.func(exception, host) : null;
  }
}



================================================
FILE: packages/microservices/external/grpc-options.interface.ts
================================================
/**
 * An interface that contains options used when initializing a Channel instance.
 * This listing is incomplete. Full reference: https://grpc.github.io/grpc/core/group__grpc__arg__keys.html
 *
 * @publicApi
 */
export interface ChannelOptions {
  'grpc.max_send_message_length'?: number;
  'grpc.max_receive_message_length'?: number;
  'grpc.max_metadata_size'?: number;
  'grpc.ssl_target_name_override'?: string;
  'grpc.primary_user_agent'?: string;
  'grpc.secondary_user_agent'?: string;
  'grpc.default_authority'?: string;
  'grpc.service_config'?: string;
  'grpc.max_concurrent_streams'?: number;
  'grpc.initial_reconnect_backoff_ms'?: number;
  'grpc.max_reconnect_backoff_ms'?: number;
  'grpc.use_local_subchannel_pool'?: number;
  'grpc-node.max_session_memory'?: number;
  [key: string]: any;
}



================================================
FILE: packages/microservices/external/kafka.interface.ts
================================================
/**
 * Do NOT add NestJS logic to this interface.  It is meant to ONLY represent the types for the kafkajs package.
 *
 * @see https://github.com/tulios/kafkajs/blob/master/types/index.d.ts
 *
 * @publicApi
 *
 */

/// <reference types="node" />
import * as net from 'net';
import * as tls from 'tls';

type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };
type XOR<T, U> = T | U extends object
  ? (Without<T, U> & U) | (Without<U, T> & T)
  : T | U;

export declare class Kafka {
  constructor(config: KafkaConfig);
  producer(config?: ProducerConfig): Producer;
  consumer(config: ConsumerConfig): Consumer;
  admin(config?: AdminConfig): Admin;
  logger(): Logger;
}

export type BrokersFunction = () => string[] | Promise<string[]>;

type SaslAuthenticationRequest = {
  encode: () => Buffer | Promise<Buffer>;
};
type SaslAuthenticationResponse<ParseResult> = {
  decode: (rawResponse: Buffer) => Buffer | Promise<Buffer>;
  parse: (data: Buffer) => ParseResult;
};

type Authenticator = {
  authenticate: () => Promise<void>;
};

export type SaslAuthenticateArgs<ParseResult> = {
  request: SaslAuthenticationRequest;
  response?: SaslAuthenticationResponse<ParseResult>;
};

type AuthenticationProviderArgs = {
  host: string;
  port: number;
  logger: Logger;
  saslAuthenticate: <ParseResult>(
    args: SaslAuthenticateArgs<ParseResult>,
  ) => Promise<ParseResult | void>;
};

type Mechanism = {
  mechanism: string;
  authenticationProvider: (args: AuthenticationProviderArgs) => Authenticator;
};

export interface KafkaConfig {
  brokers: string[] | BrokersFunction;
  ssl?: tls.ConnectionOptions | boolean;
  sasl?: SASLOptions | Mechanism;
  clientId?: string;
  connectionTimeout?: number;
  authenticationTimeout?: number;
  reauthenticationThreshold?: number;
  requestTimeout?: number;
  enforceRequestTimeout?: boolean;
  retry?: RetryOptions;
  socketFactory?: ISocketFactory;
  logLevel?: logLevel;
  logCreator?: logCreator;
}

export interface ISocketFactoryArgs {
  host: string;
  port: number;
  ssl: tls.ConnectionOptions;
  onConnect: () => void;
}

export type ISocketFactory = (args: ISocketFactoryArgs) => net.Socket;

export interface OauthbearerProviderResponse {
  value: string;
}

type SASLMechanismOptionsMap = {
  plain: { username: string; password: string };
  'scram-sha-256': { username: string; password: string };
  'scram-sha-512': { username: string; password: string };
  aws: {
    authorizationIdentity: string;
    accessKeyId: string;
    secretAccessKey: string;
    sessionToken?: string;
  };
  oauthbearer: {
    oauthBearerProvider: () => Promise<OauthbearerProviderResponse>;
  };
};

export type SASLMechanism = keyof SASLMechanismOptionsMap;
type SASLMechanismOptions<T> = T extends SASLMechanism
  ? { mechanism: T } & SASLMechanismOptionsMap[T]
  : never;
export type SASLOptions = SASLMechanismOptions<SASLMechanism>;

export interface ProducerConfig {
  createPartitioner?: ICustomPartitioner;
  retry?: RetryOptions;
  metadataMaxAge?: number;
  allowAutoTopicCreation?: boolean;
  idempotent?: boolean;
  transactionalId?: string;
  transactionTimeout?: number;
  maxInFlightRequests?: number;
}

export interface Message {
  key?: Buffer | string | null;
  value: Buffer | string | null;
  partition?: number;
  headers?: IHeaders;
  timestamp?: string;
}

export interface PartitionerArgs {
  topic: string;
  partitionMetadata: PartitionMetadata[];
  message: Message;
}

export type ICustomPartitioner = () => (args: PartitionerArgs) => number;
export type DefaultPartitioner = ICustomPartitioner;
export type LegacyPartitioner = ICustomPartitioner;

export let Partitioners: {
  DefaultPartitioner: DefaultPartitioner;
  LegacyPartitioner: LegacyPartitioner;
  /**
   * @deprecated Use DefaultPartitioner instead
   *
   * The JavaCompatiblePartitioner was renamed DefaultPartitioner
   * and made to be the default in 2.0.0.
   */
  JavaCompatiblePartitioner: DefaultPartitioner;
};

export type PartitionMetadata = {
  partitionErrorCode: number;
  partitionId: number;
  leader: number;
  replicas: number[];
  isr: number[];
  offlineReplicas?: number[];
};

export interface IHeaders {
  [key: string]: Buffer | string | (Buffer | string)[] | undefined;
}

export interface ConsumerConfig {
  groupId: string;
  partitionAssigners?: PartitionAssigner[];
  metadataMaxAge?: number;
  sessionTimeout?: number;
  rebalanceTimeout?: number;
  heartbeatInterval?: number;
  maxBytesPerPartition?: number;
  minBytes?: number;
  maxBytes?: number;
  maxWaitTimeInMs?: number;
  retry?: RetryOptions & {
    restartOnFailure?: (err: Error) => Promise<boolean>;
  };
  allowAutoTopicCreation?: boolean;
  maxInFlightRequests?: number;
  readUncommitted?: boolean;
  rackId?: string;
}

export type PartitionAssigner = (config: {
  cluster: Cluster;
  groupId: string;
  logger: Logger;
}) => Assigner;

export interface CoordinatorMetadata {
  errorCode: number;
  coordinator: {
    nodeId: number;
    host: string;
    port: number;
  };
}

export type Cluster = {
  getNodeIds(): number[];
  metadata(): Promise<BrokerMetadata>;
  removeBroker(options: { host: string; port: number }): void;
  addMultipleTargetTopics(topics: string[]): Promise<void>;
  isConnected(): boolean;
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  refreshMetadata(): Promise<void>;
  refreshMetadataIfNecessary(): Promise<void>;
  addTargetTopic(topic: string): Promise<void>;
  findBroker(node: { nodeId: string }): Promise<Broker>;
  findControllerBroker(): Promise<Broker>;
  findTopicPartitionMetadata(topic: string): PartitionMetadata[];
  findLeaderForPartitions(
    topic: string,
    partitions: number[],
  ): { [leader: string]: number[] };
  findGroupCoordinator(group: { groupId: string }): Promise<Broker>;
  findGroupCoordinatorMetadata(group: {
    groupId: string;
  }): Promise<CoordinatorMetadata>;
  defaultOffset(config: { fromBeginning: boolean }): number;
  fetchTopicsOffset(
    topics: Array<
      {
        topic: string;
        partitions: Array<{ partition: number }>;
      } & XOR<{ fromBeginning: boolean }, { fromTimestamp: number }>
    >,
  ): Promise<TopicOffsets[]>;
};

export type Assignment = { [topic: string]: number[] };

export type GroupMember = { memberId: string; memberMetadata: Buffer };

export type GroupMemberAssignment = {
  memberId: string;
  memberAssignment: Buffer;
};

export type GroupState = { name: string; metadata: Buffer };

export type Assigner = {
  name: string;
  version: number;
  assign(group: {
    members: GroupMember[];
    topics: string[];
  }): Promise<GroupMemberAssignment[]>;
  protocol(subscription: { topics: string[] }): GroupState;
};

export interface RetryOptions {
  maxRetryTime?: number;
  initialRetryTime?: number;
  factor?: number;
  multiplier?: number;
  retries?: number;
  restartOnFailure?: (e: Error) => Promise<boolean>;
}

export interface AdminConfig {
  retry?: RetryOptions;
}

export interface ITopicConfig {
  topic: string;
  numPartitions?: number;
  replicationFactor?: number;
  replicaAssignment?: object[];
  configEntries?: IResourceConfigEntry[];
}

export interface ITopicPartitionConfig {
  topic: string;
  count: number;
  assignments?: Array<Array<number>>;
}

export interface ITopicMetadata {
  name: string;
  partitions: PartitionMetadata[];
}

export enum AclResourceTypes {
  UNKNOWN = 0,
  ANY = 1,
  TOPIC = 2,
  GROUP = 3,
  CLUSTER = 4,
  TRANSACTIONAL_ID = 5,
  DELEGATION_TOKEN = 6,
}

export enum ConfigResourceTypes {
  UNKNOWN = 0,
  TOPIC = 2,
  BROKER = 4,
  BROKER_LOGGER = 8,
}

export enum ConfigSource {
  UNKNOWN = 0,
  TOPIC_CONFIG = 1,
  DYNAMIC_BROKER_CONFIG = 2,
  DYNAMIC_DEFAULT_BROKER_CONFIG = 3,
  STATIC_BROKER_CONFIG = 4,
  DEFAULT_CONFIG = 5,
  DYNAMIC_BROKER_LOGGER_CONFIG = 6,
}

export enum AclPermissionTypes {
  UNKNOWN = 0,
  ANY = 1,
  DENY = 2,
  ALLOW = 3,
}

export enum AclOperationTypes {
  UNKNOWN = 0,
  ANY = 1,
  ALL = 2,
  READ = 3,
  WRITE = 4,
  CREATE = 5,
  DELETE = 6,
  ALTER = 7,
  DESCRIBE = 8,
  CLUSTER_ACTION = 9,
  DESCRIBE_CONFIGS = 10,
  ALTER_CONFIGS = 11,
  IDEMPOTENT_WRITE = 12,
}

export enum ResourcePatternTypes {
  UNKNOWN = 0,
  ANY = 1,
  MATCH = 2,
  LITERAL = 3,
  PREFIXED = 4,
}

export interface ResourceConfigQuery {
  type: ConfigResourceTypes;
  name: string;
  configNames?: string[];
}

export interface ConfigEntries {
  configName: string;
  configValue: string;
  isDefault: boolean;
  configSource: ConfigSource;
  isSensitive: boolean;
  readOnly: boolean;
  configSynonyms: ConfigSynonyms[];
}

export interface ConfigSynonyms {
  configName: string;
  configValue: string;
  configSource: ConfigSource;
}

export interface DescribeConfigResponse {
  resources: {
    configEntries: ConfigEntries[];
    errorCode: number;
    errorMessage: string;
    resourceName: string;
    resourceType: ConfigResourceTypes;
  }[];
  throttleTime: number;
}

export interface IResourceConfigEntry {
  name: string;
  value: string;
}

export interface IResourceConfig {
  type: ConfigResourceTypes;
  name: string;
  configEntries: IResourceConfigEntry[];
}

type ValueOf<T> = T[keyof T];

export type AdminEvents = {
  CONNECT: 'admin.connect';
  DISCONNECT: 'admin.disconnect';
  REQUEST: 'admin.network.request';
  REQUEST_TIMEOUT: 'admin.network.request_timeout';
  REQUEST_QUEUE_SIZE: 'admin.network.request_queue_size';
};

export interface InstrumentationEvent<T> {
  id: string;
  type: string;
  timestamp: number;
  payload: T;
}

export type RemoveInstrumentationEventListener<T> = () => void;

export type ConnectEvent = InstrumentationEvent<null>;
export type DisconnectEvent = InstrumentationEvent<null>;
export type RequestEvent = InstrumentationEvent<{
  apiKey: number;
  apiName: string;
  apiVersion: number;
  broker: string;
  clientId: string;
  correlationId: number;
  createdAt: number;
  duration: number;
  pendingDuration: number;
  sentAt: number;
  size: number;
}>;
export type RequestTimeoutEvent = InstrumentationEvent<{
  apiKey: number;
  apiName: string;
  apiVersion: number;
  broker: string;
  clientId: string;
  correlationId: number;
  createdAt: number;
  pendingDuration: number;
  sentAt: number;
}>;
export type RequestQueueSizeEvent = InstrumentationEvent<{
  broker: string;
  clientId: string;
  queueSize: number;
}>;

export type SeekEntry = PartitionOffset;

export type FetchOffsetsPartition = PartitionOffset & {
  metadata: string | null;
};
export interface Acl {
  principal: string;
  host: string;
  operation: AclOperationTypes;
  permissionType: AclPermissionTypes;
}

export interface AclResource {
  resourceType: AclResourceTypes;
  resourceName: string;
  resourcePatternType: ResourcePatternTypes;
}

export type AclEntry = Acl & AclResource;

export type DescribeAclResource = AclResource & {
  acls: Acl[];
};

export interface DescribeAclResponse {
  throttleTime: number;
  errorCode: number;
  errorMessage?: string;
  resources: DescribeAclResource[];
}

export interface AclFilter {
  resourceType: AclResourceTypes;
  resourceName?: string;
  resourcePatternType: ResourcePatternTypes;
  principal?: string;
  host?: string;
  operation: AclOperationTypes;
  permissionType: AclPermissionTypes;
}

export interface MatchingAcl {
  errorCode: number;
  errorMessage?: string;
  resourceType: AclResourceTypes;
  resourceName: string;
  resourcePatternType: ResourcePatternTypes;
  principal: string;
  host: string;
  operation: AclOperationTypes;
  permissionType: AclPermissionTypes;
}

export interface DeleteAclFilterResponses {
  errorCode: number;
  errorMessage?: string;
  matchingAcls: MatchingAcl[];
}

export interface DeleteAclResponse {
  throttleTime: number;
  filterResponses: DeleteAclFilterResponses[];
}

export type Admin = {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  listTopics(): Promise<string[]>;
  createTopics(options: {
    validateOnly?: boolean;
    waitForLeaders?: boolean;
    timeout?: number;
    topics: ITopicConfig[];
  }): Promise<boolean>;
  deleteTopics(options: { topics: string[]; timeout?: number }): Promise<void>;
  createPartitions(options: {
    validateOnly?: boolean;
    timeout?: number;
    topicPartitions: ITopicPartitionConfig[];
  }): Promise<boolean>;
  fetchTopicMetadata(options?: {
    topics: string[];
  }): Promise<{ topics: Array<ITopicMetadata> }>;
  fetchOffsets(options: {
    groupId: string;
    topics?: string[];
    resolveOffsets?: boolean;
  }): Promise<Array<{ topic: string; partitions: FetchOffsetsPartition[] }>>;
  fetchTopicOffsets(
    topic: string,
  ): Promise<Array<SeekEntry & { high: string; low: string }>>;
  fetchTopicOffsetsByTimestamp(
    topic: string,
    timestamp?: number,
  ): Promise<Array<SeekEntry>>;
  describeCluster(): Promise<{
    brokers: Array<{ nodeId: number; host: string; port: number }>;
    controller: number | null;
    clusterId: string;
  }>;
  setOffsets(options: {
    groupId: string;
    topic: string;
    partitions: SeekEntry[];
  }): Promise<void>;
  resetOffsets(options: {
    groupId: string;
    topic: string;
    earliest: boolean;
  }): Promise<void>;
  describeConfigs(configs: {
    resources: ResourceConfigQuery[];
    includeSynonyms: boolean;
  }): Promise<DescribeConfigResponse>;
  alterConfigs(configs: {
    validateOnly: boolean;
    resources: IResourceConfig[];
  }): Promise<any>;
  listGroups(): Promise<{ groups: GroupOverview[] }>;
  deleteGroups(groupIds: string[]): Promise<DeleteGroupsResult[]>;
  describeGroups(groupIds: string[]): Promise<GroupDescriptions>;
  describeAcls(options: AclFilter): Promise<DescribeAclResponse>;
  deleteAcls(options: { filters: AclFilter[] }): Promise<DeleteAclResponse>;
  createAcls(options: { acl: AclEntry[] }): Promise<boolean>;
  deleteTopicRecords(options: {
    topic: string;
    partitions: SeekEntry[];
  }): Promise<void>;
  logger(): Logger;
  on(
    eventName: AdminEvents['CONNECT'],
    listener: (event: ConnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: AdminEvents['DISCONNECT'],
    listener: (event: DisconnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: AdminEvents['REQUEST'],
    listener: (event: RequestEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: AdminEvents['REQUEST_QUEUE_SIZE'],
    listener: (event: RequestQueueSizeEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: AdminEvents['REQUEST_TIMEOUT'],
    listener: (event: RequestTimeoutEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ValueOf<AdminEvents>,
    listener: (event: InstrumentationEvent<any>) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  readonly events: AdminEvents;
};

export let PartitionAssigners: { roundRobin: PartitionAssigner };

export interface ISerializer<T> {
  encode(value: T): Buffer;
  decode(buffer: Buffer): T | null;
}

export type MemberMetadata = {
  version: number;
  topics: string[];
  userData: Buffer;
};

export type MemberAssignment = {
  version: number;
  assignment: Assignment;
  userData: Buffer;
};

export let AssignerProtocol: {
  MemberMetadata: ISerializer<MemberMetadata>;
  MemberAssignment: ISerializer<MemberAssignment>;
};

export enum logLevel {
  NOTHING = 0,
  ERROR = 1,
  WARN = 2,
  INFO = 4,
  DEBUG = 5,
}

export interface LogEntry {
  namespace: string;
  level: logLevel;
  label: string;
  log: LoggerEntryContent;
}

export interface LoggerEntryContent {
  readonly timestamp: string;
  readonly message: string;
  [key: string]: any;
}

export type logCreator = (logLevel: logLevel) => (entry: LogEntry) => void;

export type Logger = {
  info: (message: string, extra?: object) => void;
  error: (message: string, extra?: object) => void;
  warn: (message: string, extra?: object) => void;
  debug: (message: string, extra?: object) => void;

  namespace: (namespace: string, logLevel?: logLevel) => Logger;
  setLogLevel: (logLevel: logLevel) => void;
};

export interface BrokerMetadata {
  brokers: Array<{ nodeId: number; host: string; port: number; rack?: string }>;
  topicMetadata: Array<{
    topicErrorCode: number;
    topic: string;
    partitionMetadata: PartitionMetadata[];
  }>;
}

export interface ApiVersions {
  [apiKey: number]: {
    minVersion: number;
    maxVersion: number;
  };
}

export type Broker = {
  isConnected(): boolean;
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  apiVersions(): Promise<ApiVersions>;
  metadata(topics: string[]): Promise<BrokerMetadata>;
  describeGroups: (options: { groupIds: string[] }) => Promise<any>;
  offsetCommit(request: {
    groupId: string;
    groupGenerationId: number;
    memberId: string;
    retentionTime?: number;
    topics: TopicOffsets[];
  }): Promise<any>;
  offsetFetch(request: { groupId: string; topics: TopicOffsets[] }): Promise<{
    responses: TopicOffsets[];
  }>;
  fetch(request: {
    replicaId?: number;
    isolationLevel?: number;
    maxWaitTime?: number;
    minBytes?: number;
    maxBytes?: number;
    topics: Array<{
      topic: string;
      partitions: Array<{
        partition: number;
        fetchOffset: string;
        maxBytes: number;
      }>;
    }>;
    rackId?: string;
  }): Promise<any>;
  produce(request: {
    topicData: Array<{
      topic: string;
      partitions: Array<{
        partition: number;
        firstSequence?: number;
        messages: Message[];
      }>;
    }>;
    transactionalId?: string;
    producerId?: number;
    producerEpoch?: number;
    acks?: number;
    timeout?: number;
    compression?: CompressionTypes;
  }): Promise<any>;
};

interface MessageSetEntry {
  key: Buffer | null;
  value: Buffer | null;
  timestamp: string;
  attributes: number;
  offset: string;
  size: number;
  headers?: never;
}

interface RecordBatchEntry {
  key: Buffer | null;
  value: Buffer | null;
  timestamp: string;
  attributes: number;
  offset: string;
  headers: IHeaders;
  size?: never;
}

export type KafkaMessage = MessageSetEntry | RecordBatchEntry;

export interface ProducerRecord {
  topic: string;
  messages: Message[];
  acks?: number;
  timeout?: number;
  compression?: CompressionTypes;
}

export type RecordMetadata = {
  topicName: string;
  partition: number;
  errorCode: number;
  offset?: string;
  timestamp?: string;
  baseOffset?: string;
  logAppendTime?: string;
  logStartOffset?: string;
};

export interface TopicMessages {
  topic: string;
  messages: Message[];
}

export interface ProducerBatch {
  acks?: number;
  timeout?: number;
  compression?: CompressionTypes;
  topicMessages?: TopicMessages[];
}

export interface PartitionOffset {
  partition: number;
  offset: string;
}

export interface TopicOffsets {
  topic: string;
  partitions: PartitionOffset[];
}

export interface Offsets {
  topics: TopicOffsets[];
}

type Sender = {
  send(record: ProducerRecord): Promise<RecordMetadata[]>;
  sendBatch(batch: ProducerBatch): Promise<RecordMetadata[]>;
};

export type ProducerEvents = {
  CONNECT: 'producer.connect';
  DISCONNECT: 'producer.disconnect';
  REQUEST: 'producer.network.request';
  REQUEST_TIMEOUT: 'producer.network.request_timeout';
  REQUEST_QUEUE_SIZE: 'producer.network.request_queue_size';
};

export type Producer = Sender & {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  isIdempotent(): boolean;
  readonly events: ProducerEvents;
  on(
    eventName: ProducerEvents['CONNECT'],
    listener: (event: ConnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ProducerEvents['DISCONNECT'],
    listener: (event: DisconnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ProducerEvents['REQUEST'],
    listener: (event: RequestEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ProducerEvents['REQUEST_QUEUE_SIZE'],
    listener: (event: RequestQueueSizeEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ProducerEvents['REQUEST_TIMEOUT'],
    listener: (event: RequestTimeoutEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ValueOf<ProducerEvents>,
    listener: (event: InstrumentationEvent<any>) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  transaction(): Promise<Transaction>;
  logger(): Logger;
};

export type Transaction = Sender & {
  sendOffsets(offsets: Offsets & { consumerGroupId: string }): Promise<void>;
  commit(): Promise<void>;
  abort(): Promise<void>;
  isActive(): boolean;
};

export type ConsumerGroup = {
  groupId: string;
  generationId: number;
  memberId: string;
  coordinator: Broker;
};

export type MemberDescription = {
  clientHost: string;
  clientId: string;
  memberId: string;
  memberAssignment: Buffer;
  memberMetadata: Buffer;
};

// See https://github.com/apache/kafka/blob/2.4.0/clients/src/main/java/org/apache/kafka/common/ConsumerGroupState.java#L25
export type ConsumerGroupState =
  | 'Unknown'
  | 'PreparingRebalance'
  | 'CompletingRebalance'
  | 'Stable'
  | 'Dead'
  | 'Empty';

export type GroupDescription = {
  groupId: string;
  members: MemberDescription[];
  protocol: string;
  protocolType: string;
  state: ConsumerGroupState;
};

export type GroupDescriptions = {
  groups: GroupDescription[];
};

export type TopicPartitions = { topic: string; partitions: number[] };

export type TopicPartition = {
  topic: string;
  partition: number;
};
export type TopicPartitionOffset = TopicPartition & {
  offset: string;
};
export type TopicPartitionOffsetAndMetadata = TopicPartitionOffset & {
  metadata?: string | null;
};

export type Batch = {
  topic: string;
  partition: number;
  highWatermark: string;
  messages: KafkaMessage[];
  isEmpty(): boolean;
  firstOffset(): string | null;
  lastOffset(): string;
  offsetLag(): string;
  offsetLagLow(): string;
};

export type GroupOverview = {
  groupId: string;
  protocolType: string;
};

export type DeleteGroupsResult = {
  groupId: string;
  errorCode?: number;
  error?: KafkaJSProtocolError;
};

export type ConsumerEvents = {
  HEARTBEAT: 'consumer.heartbeat';
  COMMIT_OFFSETS: 'consumer.commit_offsets';
  GROUP_JOIN: 'consumer.group_join';
  FETCH_START: 'consumer.fetch_start';
  FETCH: 'consumer.fetch';
  START_BATCH_PROCESS: 'consumer.start_batch_process';
  END_BATCH_PROCESS: 'consumer.end_batch_process';
  CONNECT: 'consumer.connect';
  DISCONNECT: 'consumer.disconnect';
  STOP: 'consumer.stop';
  CRASH: 'consumer.crash';
  REBALANCING: 'consumer.rebalancing';
  RECEIVED_UNSUBSCRIBED_TOPICS: 'consumer.received_unsubscribed_topics';
  REQUEST: 'consumer.network.request';
  REQUEST_TIMEOUT: 'consumer.network.request_timeout';
  REQUEST_QUEUE_SIZE: 'consumer.network.request_queue_size';
};
export type ConsumerHeartbeatEvent = InstrumentationEvent<{
  groupId: string;
  memberId: string;
  groupGenerationId: number;
}>;
export type ConsumerCommitOffsetsEvent = InstrumentationEvent<{
  groupId: string;
  memberId: string;
  groupGenerationId: number;
  topics: TopicOffsets[];
}>;
export interface IMemberAssignment {
  [key: string]: number[];
}
export type ConsumerGroupJoinEvent = InstrumentationEvent<{
  duration: number;
  groupId: string;
  isLeader: boolean;
  leaderId: string;
  groupProtocol: string;
  memberId: string;
  memberAssignment: IMemberAssignment;
}>;
export type ConsumerFetchStartEvent = InstrumentationEvent<{ nodeId: number }>;
export type ConsumerFetchEvent = InstrumentationEvent<{
  numberOfBatches: number;
  duration: number;
  nodeId: number;
}>;
interface IBatchProcessEvent {
  topic: string;
  partition: number;
  highWatermark: string;
  offsetLag: string;
  offsetLagLow: string;
  batchSize: number;
  firstOffset: string;
  lastOffset: string;
}
export type ConsumerStartBatchProcessEvent =
  InstrumentationEvent<IBatchProcessEvent>;
export type ConsumerEndBatchProcessEvent = InstrumentationEvent<
  IBatchProcessEvent & { duration: number }
>;
export type ConsumerCrashEvent = InstrumentationEvent<{
  error: Error;
  groupId: string;
  restart: boolean;
}>;
export type ConsumerRebalancingEvent = InstrumentationEvent<{
  groupId: string;
  memberId: string;
}>;
export type ConsumerReceivedUnsubscribedTopicsEvent = InstrumentationEvent<{
  groupId: string;
  generationId: number;
  memberId: string;
  assignedTopics: string[];
  topicsSubscribed: string[];
  topicsNotSubscribed: string[];
}>;

export interface OffsetsByTopicPartition {
  topics: TopicOffsets[];
}

export interface EachMessagePayload {
  topic: string;
  partition: number;
  message: KafkaMessage;
  heartbeat(): Promise<void>;
  pause(): () => void;
}

export interface EachBatchPayload {
  batch: Batch;
  resolveOffset(offset: string): void;
  heartbeat(): Promise<void>;
  pause(): () => void;
  commitOffsetsIfNecessary(offsets?: Offsets): Promise<void>;
  uncommittedOffsets(): OffsetsByTopicPartition;
  isRunning(): boolean;
  isStale(): boolean;
}

/**
 * Type alias to keep compatibility with @types/kafkajs
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/712ad9d59ccca6a3cc92f347fea0d1c7b02f5eeb/types/kafkajs/index.d.ts#L321-L325
 */
export type ConsumerEachMessagePayload = EachMessagePayload;

/**
 * Type alias to keep compatibility with @types/kafkajs
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/712ad9d59ccca6a3cc92f347fea0d1c7b02f5eeb/types/kafkajs/index.d.ts#L327-L336
 */
export type ConsumerEachBatchPayload = EachBatchPayload;

export type EachBatchHandler = (payload: EachBatchPayload) => Promise<void>;
export type EachMessageHandler = (payload: EachMessagePayload) => Promise<void>;

export type ConsumerRunConfig = {
  autoCommit?: boolean;
  autoCommitInterval?: number | null;
  autoCommitThreshold?: number | null;
  eachBatchAutoResolve?: boolean;
  partitionsConsumedConcurrently?: number;
  eachBatch?: EachBatchHandler;
  eachMessage?: EachMessageHandler;
};

export type ConsumerSubscribeTopics = {
  topics: (string | RegExp)[];
  fromBeginning?: boolean;
};

export type Consumer = {
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  subscribe(subscription: ConsumerSubscribeTopics): Promise<void>;
  stop(): Promise<void>;
  run(config?: ConsumerRunConfig): Promise<void>;
  commitOffsets(
    topicPartitions: Array<TopicPartitionOffsetAndMetadata>,
  ): Promise<void>;
  seek(topicPartitionOffset: TopicPartitionOffset): void;
  describeGroup(): Promise<GroupDescription>;
  pause(topics: Array<{ topic: string; partitions?: number[] }>): void;
  paused(): TopicPartitions[];
  resume(topics: Array<{ topic: string; partitions?: number[] }>): void;
  on(
    eventName: ConsumerEvents['HEARTBEAT'],
    listener: (event: ConsumerHeartbeatEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['COMMIT_OFFSETS'],
    listener: (event: ConsumerCommitOffsetsEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['GROUP_JOIN'],
    listener: (event: ConsumerGroupJoinEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['FETCH_START'],
    listener: (event: ConsumerFetchStartEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['FETCH'],
    listener: (event: ConsumerFetchEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['START_BATCH_PROCESS'],
    listener: (event: ConsumerStartBatchProcessEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['END_BATCH_PROCESS'],
    listener: (event: ConsumerEndBatchProcessEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['CONNECT'],
    listener: (event: ConnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['DISCONNECT'],
    listener: (event: DisconnectEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['STOP'],
    listener: (event: InstrumentationEvent<null>) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['CRASH'],
    listener: (event: ConsumerCrashEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['REBALANCING'],
    listener: (event: ConsumerRebalancingEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['RECEIVED_UNSUBSCRIBED_TOPICS'],
    listener: (event: ConsumerReceivedUnsubscribedTopicsEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['REQUEST'],
    listener: (event: RequestEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['REQUEST_TIMEOUT'],
    listener: (event: RequestTimeoutEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ConsumerEvents['REQUEST_QUEUE_SIZE'],
    listener: (event: RequestQueueSizeEvent) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  on(
    eventName: ValueOf<ConsumerEvents>,
    listener: (event: InstrumentationEvent<any>) => void,
  ): RemoveInstrumentationEventListener<typeof eventName>;
  logger(): Logger;
  readonly events: ConsumerEvents;
};

export enum CompressionTypes {
  None = 0,
  GZIP = 1,
  Snappy = 2,
  LZ4 = 3,
  ZSTD = 4,
}

export let CompressionCodecs: {
  [CompressionTypes.GZIP]: () => any;
  [CompressionTypes.Snappy]: () => any;
  [CompressionTypes.LZ4]: () => any;
  [CompressionTypes.ZSTD]: () => any;
};

export declare class KafkaJSError extends Error {
  readonly message: Error['message'];
  readonly name: string;
  readonly retriable: boolean;
  readonly helpUrl?: string;
  readonly cause?: Error;

  constructor(e: Error | string, metadata?: KafkaJSErrorMetadata);
}

export declare class KafkaJSNonRetriableError extends KafkaJSError {
  constructor(e: Error | string);
}

export declare class KafkaJSProtocolError extends KafkaJSError {
  readonly code: number;
  readonly type: string;
  constructor(e: Error | string);
}

export declare class KafkaJSOffsetOutOfRange extends KafkaJSProtocolError {
  readonly topic: string;
  readonly partition: number;
  constructor(e: Error | string, metadata?: KafkaJSOffsetOutOfRangeMetadata);
}

export declare class KafkaJSNumberOfRetriesExceeded extends KafkaJSNonRetriableError {
  readonly stack: string;
  readonly retryCount: number;
  readonly retryTime: number;
  constructor(
    e: Error | string,
    metadata?: KafkaJSNumberOfRetriesExceededMetadata,
  );
}

export declare class KafkaJSConnectionError extends KafkaJSError {
  readonly broker: string;
  constructor(e: Error | string, metadata?: KafkaJSConnectionErrorMetadata);
}

export declare class KafkaJSRequestTimeoutError extends KafkaJSError {
  readonly broker: string;
  readonly correlationId: number;
  readonly createdAt: number;
  readonly sentAt: number;
  readonly pendingDuration: number;
  constructor(e: Error | string, metadata?: KafkaJSRequestTimeoutErrorMetadata);
}

export declare class KafkaJSMetadataNotLoaded extends KafkaJSError {
  constructor();
}

export declare class KafkaJSTopicMetadataNotLoaded extends KafkaJSMetadataNotLoaded {
  readonly topic: string;
  constructor(
    e: Error | string,
    metadata?: KafkaJSTopicMetadataNotLoadedMetadata,
  );
}

export declare class KafkaJSStaleTopicMetadataAssignment extends KafkaJSError {
  readonly topic: string;
  readonly unknownPartitions: number;
  constructor(
    e: Error | string,
    metadata?: KafkaJSStaleTopicMetadataAssignmentMetadata,
  );
}

export declare class KafkaJSServerDoesNotSupportApiKey extends KafkaJSNonRetriableError {
  readonly apiKey: number;
  readonly apiName: string;
  constructor(
    e: Error | string,
    metadata?: KafkaJSServerDoesNotSupportApiKeyMetadata,
  );
}

export declare class KafkaJSBrokerNotFound extends KafkaJSError {
  constructor();
}

export declare class KafkaJSPartialMessageError extends KafkaJSError {
  constructor();
}

export declare class KafkaJSSASLAuthenticationError extends KafkaJSError {
  constructor();
}

export declare class KafkaJSGroupCoordinatorNotFound extends KafkaJSError {
  constructor();
}

export declare class KafkaJSNotImplemented extends KafkaJSError {
  constructor();
}

export declare class KafkaJSTimeout extends KafkaJSError {
  constructor();
}

export declare class KafkaJSLockTimeout extends KafkaJSError {
  constructor();
}

export declare class KafkaJSUnsupportedMagicByteInMessageSet extends KafkaJSError {
  constructor();
}

export declare class KafkaJSDeleteGroupsError extends KafkaJSError {
  readonly groups: DeleteGroupsResult[];
  constructor(e: Error | string, groups?: KafkaJSDeleteGroupsErrorGroups[]);
}

export declare class KafkaJSDeleteTopicRecordsError extends KafkaJSError {
  constructor(metadata: KafkaJSDeleteTopicRecordsErrorTopic);
}

export interface KafkaJSDeleteGroupsErrorGroups {
  groupId: string;
  errorCode: number;
  error: KafkaJSError;
}

export interface KafkaJSDeleteTopicRecordsErrorTopic {
  topic: string;
  partitions: KafkaJSDeleteTopicRecordsErrorPartition[];
}

export interface KafkaJSDeleteTopicRecordsErrorPartition {
  partition: number;
  offset: string;
  error: KafkaJSError;
}

export interface KafkaJSErrorMetadata {
  retriable?: boolean;
  topic?: string;
  partitionId?: number;
  metadata?: PartitionMetadata;
}

export interface KafkaJSOffsetOutOfRangeMetadata {
  topic: string;
  partition: number;
}

export interface KafkaJSNumberOfRetriesExceededMetadata {
  retryCount: number;
  retryTime: number;
}

export interface KafkaJSConnectionErrorMetadata {
  broker?: string;
  code?: string;
}

export interface KafkaJSRequestTimeoutErrorMetadata {
  broker: string;
  clientId: string;
  correlationId: number;
  createdAt: number;
  sentAt: number;
  pendingDuration: number;
}

export interface KafkaJSTopicMetadataNotLoadedMetadata {
  topic: string;
}

export interface KafkaJSStaleTopicMetadataAssignmentMetadata {
  topic: string;
  unknownPartitions: PartitionMetadata[];
}

export interface KafkaJSServerDoesNotSupportApiKeyMetadata {
  apiKey: number;
  apiName: string;
}



================================================
FILE: packages/microservices/external/mqtt-options.interface.ts
================================================
/**
 * @see https://github.com/mqttjs/MQTT.js/
 *
 * @publicApi
 */
export declare type QoS = 0 | 1 | 2;

export interface MqttClientOptions extends ISecureClientOptions {
  port?: number; // port is made into a number subsequently
  host?: string; // host does NOT include port
  hostname?: string;
  path?: string;
  protocol?: 'wss' | 'ws' | 'mqtt' | 'mqtts' | 'tcp' | 'ssl' | 'wx' | 'wxs';

  wsOptions?: {
    [x: string]: any;
  };
  /**
   *  10 seconds, set to 0 to disable
   */
  keepalive?: number;
  /**
   * 'mqttjs_' + Math.random().toString(16).substr(2, 8)
   */
  clientId?: string;
  /**
   * 'MQTT'
   */
  protocolId?: string;
  /**
   * 4
   */
  protocolVersion?: number;
  /**
   * true, set to false to receive QoS 1 and 2 messages while offline
   */
  clean?: boolean;
  /**
   * 1000 milliseconds, interval between two reconnections
   */
  reconnectPeriod?: number;
  /**
   * 30 * 1000 milliseconds, time to wait before a CONNACK is received
   */
  connectTimeout?: number;
  /**
   * the username required by your broker, if any
   */
  username?: string;
  /**
   * the password required by your broker, if any
   */
  password?: string;
  /**
   * a any for the incoming packets
   */
  incomingStore?: any;
  /**
   * a any for the outgoing packets
   */
  outgoingStore?: any;
  queueQoSZero?: boolean;
  /**
   *  properties MQTT 5.0.
   */
  properties?: {
    /**
     * representing the Session Expiry Interval in seconds
     */
    sessionExpiryInterval?: number;
    /**
     * representing the Receive Maximum
     */
    receiveMaximum?: number;
    /**
     * representing the Maximum Packet Size the Client is willing to accept
     */
    maximumPacketSize?: number;
    /**
     * representing the Topic Alias Maximum value indicates the highest value that the Client will accept as a Topic Alias sent by the Server
     */
    topicAliasMaximum?: number;
    /**
     * The Client uses this value to request the Server to return Response Information in the CONNACK
     */
    requestResponseInformation?: boolean;
    /**
     * The Client uses this value to indicate whether the Reason String or User Properties are sent in the case of failures
     */
    requestProblemInformation?: boolean;
    /**
     * The User Property is allowed to appear multiple times to represent multiple name, value pairs
     */
    userProperties?: object;
    /**
     * the name of the authentication method used for extended authentication
     */
    authenticationMethod?: string;
    /**
     * * Binary Data containing authentication data (binary type)
     * */
    authenticationData?: any;
  };
  reschedulePings?: boolean;
  servers?: Array<{
    host: string;
    port: number;
  }>;
  /**
   * true, set to false to disable re-subscribe functionality
   */
  resubscribe?: boolean;
  /**
   * a message that will sent by the broker automatically when the client disconnect badly.
   */
  will?: {
    /**
     * the topic to publish
     */
    topic: string;
    /**
     * the message to publish
     */
    payload: string;
    /**
     * the QoS
     */
    qos: QoS;
    /**
     * the retain flag
     */
    retain: boolean;
  };
  transformWsUrl?: (url: string, options: any, client: any) => string;
}
export interface ISecureClientOptions {
  /**
   * optional private keys in PEM format
   */
  key?: string | string[] | Buffer | Buffer[] | Record<string, any>[];
  /**
   * optional cert chains in PEM format
   */
  cert?: string | string[] | Buffer | Buffer[];
  /**
   * Optionally override the trusted CA certificates in PEM format
   */
  ca?: string | string[] | Buffer | Buffer[];
  rejectUnauthorized?: boolean;
}
export interface IClientPublishOptions {
  /**
   * the QoS
   */
  qos: QoS;
  /**
   * the retain flag
   */
  retain?: boolean;
  /**
   * whether or not mark a message as duplicate
   */
  dup?: boolean;
}
export interface IClientSubscribeOptions {
  /**
   * the QoS
   */
  qos: QoS;
}
export interface IClientReconnectOptions {
  /**
   * a any for the incoming packets
   */
  incomingStore?: any;
  /**
   * a any for the outgoing packets
   */
  outgoingStore?: any;
}



================================================
FILE: packages/microservices/external/nats-codec.interface.ts
================================================
/**
 * @see https://github.com/nats-io/nats.js
 *
 * @publicApi
 */
export interface NatsCodec<T> {
  encode(d: T): Uint8Array;
  decode(a: Uint8Array): T;
}



================================================
FILE: packages/microservices/external/redis.interface.ts
================================================
import { ConnectionOptions } from 'tls';

/**
 * @see https://github.dev/luin/ioredis/blob/df04dd8d87a44d3b64b385c86581915248554508/lib/redis/RedisOptions.ts#L184
 *
 * @publicApi
 */
export interface IORedisOptions {
  Connector?: any;
  retryStrategy?: (times: number) => number | void | null;

  /**
   * If a command does not return a reply within a set number of milliseconds,
   * a "Command timed out" error will be thrown.
   */
  commandTimeout?: number;
  /**
   * Enable/disable keep-alive functionality.
   * @link https://nodejs.org/api/net.html#socketsetkeepaliveenable-initialdelay
   * @default 0
   */
  keepAlive?: number;

  /**
   * Enable/disable the use of Nagle's algorithm.
   * @link https://nodejs.org/api/net.html#socketsetnodelaynodelay
   * @default true
   */
  noDelay?: boolean;

  /**
   * Set the name of the connection to make it easier to identity the connection
   * in client list.
   * @link https://redis.io/commands/client-setname
   */
  connectionName?: string;

  /**
   * If set, client will send AUTH command with the value of this option as the first argument when connected.
   * This is supported since Redis 6.
   */
  username?: string;

  /**
   * If set, client will send AUTH command with the value of this option when connected.
   */
  password?: string;

  /**
   * Database index to use.
   *
   * @default 0
   */
  db?: number;

  /**
   * When the client reconnects, channels subscribed in the previous connection will be
   * resubscribed automatically if `autoResubscribe` is `true`.
   * @default true
   */
  autoResubscribe?: boolean;

  /**
   * Whether or not to resend unfulfilled commands on reconnect.
   * Unfulfilled commands are most likely to be blocking commands such as `brpop` or `blpop`.
   * @default true
   */
  autoResendUnfulfilledCommands?: boolean;
  /**
   * Whether or not to reconnect on certain Redis errors.
   * This options by default is `null`, which means it should never reconnect on Redis errors.
   * You can pass a function that accepts an Redis error, and returns:
   * - `true` or `1` to trigger a reconnection.
   * - `false` or `0` to not reconnect.
   * - `2` to reconnect and resend the failed command (who triggered the error) after reconnection.
   * @example
   * ```js
   * const redis = new Redis({
   *   reconnectOnError(err) {
   *     const targetError = "READONLY";
   *     if (err.message.includes(targetError)) {
   *       // Only reconnect when the error contains "READONLY"
   *       return true; // or `return 1;`
   *     }
   *   },
   * });
   * ```
   * @default null
   */
  reconnectOnError?: ((err: Error) => boolean | 1 | 2) | null;

  /**
   * @default false
   */
  readOnly?: boolean;
  /**
   * When enabled, numbers returned by Redis will be converted to JavaScript strings instead of numbers.
   * This is necessary if you want to handle big numbers (above `Number.MAX_SAFE_INTEGER` === 2^53).
   * @default false
   */
  stringNumbers?: boolean;

  /**
   * How long the client will wait before killing a socket due to inactivity during initial connection.
   * @default 10000
   */
  connectTimeout?: number;

  /**
   * This option is used internally when you call `redis.monitor()` to tell Redis
   * to enter the monitor mode when the connection is established.
   *
   * @default false
   */
  monitor?: boolean;

  /**
   * The commands that don't get a reply due to the connection to the server is lost are
   * put into a queue and will be resent on reconnect (if allowed by the `retryStrategy` option).
   * This option is used to configure how many reconnection attempts should be allowed before
   * the queue is flushed with a `MaxRetriesPerRequestError` error.
   * Set this options to `null` instead of a number to let commands wait forever
   * until the connection is alive again.
   *
   * @default 20
   */
  maxRetriesPerRequest?: number | null;

  /**
   * @default 10000
   */
  maxLoadingRetryTime?: number;
  /**
   * @default false
   */
  enableAutoPipelining?: boolean;
  /**
   * @default []
   */
  autoPipeliningIgnoredCommands?: string[];
  offlineQueue?: boolean;
  commandQueue?: boolean;

  /**
   *
   * By default, if the connection to Redis server has not been established, commands are added to a queue
   * and are executed once the connection is "ready" (when `enableReadyCheck` is true, "ready" means
   * the Redis server has loaded the database from disk, otherwise means the connection to the Redis
   * server has been established). If this option is false, when execute the command when the connection
   * isn't ready, an error will be returned.
   *
   * @default true
   */
  enableOfflineQueue?: boolean;

  /**
   * The client will sent an INFO command to check whether the server is still loading data from the disk (
   * which happens when the server is just launched) when the connection is established, and only wait until
   * the loading process is finished before emitting the `ready` event.
   *
   * @default true
   */
  enableReadyCheck?: boolean;

  /**
   * When a Redis instance is initialized, a connection to the server is immediately established. Set this to
   * true will delay the connection to the server until the first command is sent or `redis.connect()` is called
   * explicitly.
   *
   * @default false
   */

  lazyConnect?: boolean;

  /**
   * @default undefined
   */
  scripts?: Record<
    string,
    { lua: string; numberOfKeys?: number; readOnly?: boolean }
  >;

  keyPrefix?: string;
  showFriendlyErrorStack?: boolean;

  // StandaloneConnectionOptions
  disconnectTimeout?: number;
  tls?: ConnectionOptions;

  // SentinelConnectionOptions
  /**
   * Master group name of the Sentinel
   */
  name?: string;
  /**
   * @default "master"
   */
  role?: 'master' | 'slave';
  sentinelUsername?: string;
  sentinelPassword?: string;
  sentinels?: Array<Partial<any>>;
  sentinelRetryStrategy?: (retryAttempts: number) => number | void | null;
  sentinelReconnectStrategy?: (retryAttempts: number) => number | void | null;
  preferredSlaves?: any;
  sentinelCommandTimeout?: number;
  enableTLSForSentinelMode?: boolean;
  sentinelTLS?: ConnectionOptions;
  natMap?: any;
  updateSentinels?: boolean;
  /**
   * @default 10
   */
  sentinelMaxConnections?: number;
  failoverDetector?: boolean;
}



================================================
FILE: packages/microservices/external/rmq-url.interface.ts
================================================
import { ConnectionOptions } from 'tls';
import { TcpSocketConnectOpts } from 'net';

/**
 * @publicApi
 */
export interface RmqUrl {
  protocol?: string;
  hostname?: string;
  port?: number;
  username?: string;
  password?: string;
  locale?: string;
  frameMax?: number;
  heartbeat?: number;
  vhost?: string;
}

interface ClientProperties {
  connectionName?: string;
  [key: string]: any;
}

type AmqpConnectionOptions = (ConnectionOptions | TcpSocketConnectOpts) & {
  noDelay?: boolean;
  timeout?: number;
  keepAlive?: boolean;
  keepAliveDelay?: number;
  clientProperties?: any;
  credentials?:
    | {
        mechanism: string;
        username: string;
        password: string;
        response: () => Buffer;
      }
    | {
        mechanism: string;
        response: () => Buffer;
      }
    | undefined;
};

/**
 * @publicApi
 */
export interface AmqpConnectionManagerSocketOptions {
  reconnectTimeInSeconds?: number;
  heartbeatIntervalInSeconds?: number;
  findServers?: () => string | string[];
  connectionOptions?: AmqpConnectionOptions;
  clientProperties?: ClientProperties;
  [key: string]: any;
}

/**
 * @publicApi
 */
export interface AmqplibQueueOptions {
  durable?: boolean;
  autoDelete?: boolean;
  arguments?: any;
  messageTtl?: number;
  expires?: number;
  deadLetterExchange?: string;
  deadLetterRoutingKey?: string;
  maxLength?: number;
  maxPriority?: number;
  [key: string]: any;
}



================================================
FILE: packages/microservices/factories/rpc-params-factory.ts
================================================
import { RpcParamtype } from '../enums/rpc-paramtype.enum';

export class RpcParamsFactory {
  public exchangeKeyForValue(
    type: number,
    data: string | undefined,
    args: unknown[],
  ) {
    if (!args) {
      return null;
    }
    switch (type as RpcParamtype) {
      case RpcParamtype.PAYLOAD:
        return data ? args[0]?.[data] : args[0];
      case RpcParamtype.CONTEXT:
        return args[1];
      case RpcParamtype.GRPC_CALL:
        return args[2];
      default:
        return null;
    }
  }
}



================================================
FILE: packages/microservices/helpers/grpc-helpers.ts
================================================
import { InvalidGrpcPackageDefinitionMissingPackageDefinitionException } from '../errors/invalid-grpc-package-definition-missing-package-definition.exception';
import { InvalidGrpcPackageDefinitionMutexException } from '../errors/invalid-grpc-package-definition-mutex.exception';
import { GrpcOptions } from '../interfaces';

export function getGrpcPackageDefinition(
  options: GrpcOptions['options'],
  grpcProtoLoaderPackage: any,
) {
  const file = options['protoPath'];
  const packageDefinition = options['packageDefinition'];

  if (file && packageDefinition) {
    throw new InvalidGrpcPackageDefinitionMutexException();
  }
  if (!file && !packageDefinition) {
    throw new InvalidGrpcPackageDefinitionMissingPackageDefinitionException();
  }

  return (
    packageDefinition ||
    grpcProtoLoaderPackage.loadSync(file, options['loader'])
  );
}



================================================
FILE: packages/microservices/helpers/index.ts
================================================
export * from './json-socket';
export * from './kafka-logger';
export * from './kafka-parser';
export * from './kafka-reply-partition-assigner';
export * from './tcp-socket';
export * from './grpc-helpers';



================================================
FILE: packages/microservices/helpers/json-socket.ts
================================================
import { Buffer } from 'buffer';
import { StringDecoder } from 'string_decoder';
import { CorruptedPacketLengthException } from '../errors/corrupted-packet-length.exception';
import { MaxPacketLengthExceededException } from '../errors/max-packet-length-exceeded.exception';
import { TcpSocket } from './tcp-socket';

const MAX_BUFFER_SIZE = (512 * 1024 * 1024) / 4; // 512 MBs in characters with 4 bytes per character (32-bit)

export class JsonSocket extends TcpSocket {
  private contentLength: number | null = null;
  private buffer = '';

  private readonly stringDecoder = new StringDecoder();
  private readonly delimiter = '#';

  protected handleSend(message: any, callback?: (err?: any) => void) {
    this.socket.write(this.formatMessageData(message), 'utf-8', callback);
  }

  protected handleData(dataRaw: Buffer | string) {
    const data = Buffer.isBuffer(dataRaw)
      ? this.stringDecoder.write(dataRaw)
      : dataRaw;
    this.buffer += data;

    if (this.buffer.length > MAX_BUFFER_SIZE) {
      this.buffer = '';
      throw new MaxPacketLengthExceededException(this.buffer.length);
    }

    if (this.contentLength === null) {
      const i = this.buffer.indexOf(this.delimiter);
      /**
       * Check if the buffer has the delimiter (#),
       * if not, the end of the buffer string might be in the middle of a content length string
       */
      if (i !== -1) {
        const rawContentLength = this.buffer.substring(0, i);
        this.contentLength = parseInt(rawContentLength, 10);

        if (isNaN(this.contentLength)) {
          this.contentLength = null;
          this.buffer = '';
          throw new CorruptedPacketLengthException(rawContentLength);
        }
        this.buffer = this.buffer.substring(i + 1);
      }
    }

    if (this.contentLength !== null) {
      const length = this.buffer.length;
      if (length === this.contentLength) {
        this.handleMessage(this.buffer);
      } else if (length > this.contentLength) {
        const message = this.buffer.substring(0, this.contentLength);
        const rest = this.buffer.substring(this.contentLength);
        this.handleMessage(message);
        this.handleData(rest);
      }
    }
  }

  private handleMessage(message: any) {
    this.contentLength = null;
    this.buffer = '';
    this.emitMessage(message);
  }

  private formatMessageData(message: any) {
    const messageData = JSON.stringify(message);
    const length = messageData.length;
    const data = length + this.delimiter + messageData;
    return data;
  }
}



================================================
FILE: packages/microservices/helpers/kafka-logger.ts
================================================
import { logLevel } from '../external/kafka.interface';

export const KafkaLogger =
  (logger: any) =>
  ({ namespace, level, label, log }) => {
    let loggerMethod: string;

    switch (level) {
      case logLevel.ERROR:
      case logLevel.NOTHING:
        loggerMethod = 'error';
        break;
      case logLevel.WARN:
        loggerMethod = 'warn';
        break;
      case logLevel.INFO:
        loggerMethod = 'log';
        break;
      case logLevel.DEBUG:
      default:
        loggerMethod = 'debug';
        break;
    }

    const { message, ...others } = log;
    if (logger[loggerMethod]) {
      logger[loggerMethod](
        `${label} [${namespace}] ${message} ${JSON.stringify(others)}`,
      );
    }
  };



================================================
FILE: packages/microservices/helpers/kafka-parser.ts
================================================
import { isNil } from '@nestjs/common/utils/shared.utils';
import { KafkaParserConfig } from '../interfaces';

export class KafkaParser {
  protected readonly keepBinary: boolean;

  constructor(config?: KafkaParserConfig) {
    this.keepBinary = (config && config.keepBinary) || false;
  }

  public parse<T = any>(data: any): T {
    // Clone object to as modifying the original one would break KafkaJS retries
    const result = {
      ...data,
      headers: { ...data.headers },
    };

    if (!this.keepBinary) {
      result.value = this.decode(data.value);
    }

    if (!isNil(data.key)) {
      result.key = this.decode(data.key);
    }
    if (!isNil(data.headers)) {
      const decodeHeaderByKey = (key: string) => {
        result.headers[key] = this.decode(data.headers[key]);
      };
      Object.keys(data.headers).forEach(decodeHeaderByKey);
    } else {
      result.headers = {};
    }
    return result;
  }

  public decode(value: Buffer): object | string | null | Buffer {
    if (isNil(value)) {
      return null;
    }
    // A value with the "leading zero byte" indicates the schema payload.
    // The "content" is possibly binary and should not be touched & parsed.
    if (
      Buffer.isBuffer(value) &&
      value.length > 0 &&
      value.readUInt8(0) === 0
    ) {
      return value;
    }

    let result = value.toString();
    const startChar = result.charAt(0);

    // Only try to parse objects and arrays
    if (startChar === '{' || startChar === '[') {
      try {
        result = JSON.parse(value.toString());
      } catch (e) {
        // Do nothing
      }
    }
    return result;
  }
}



================================================
FILE: packages/microservices/helpers/kafka-reply-partition-assigner.ts
================================================
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import { ClientKafka } from '../client/client-kafka';
import {
  Cluster,
  GroupMember,
  GroupMemberAssignment,
  GroupState,
  MemberMetadata,
} from '../external/kafka.interface';

let kafkaPackage: any = {};

export class KafkaReplyPartitionAssigner {
  readonly name = 'NestReplyPartitionAssigner';
  readonly version = 1;

  constructor(
    private readonly clientKafka: ClientKafka,
    private readonly config: {
      cluster: Cluster;
    },
  ) {
    kafkaPackage = loadPackage(
      'kafkajs',
      KafkaReplyPartitionAssigner.name,
      () => require('kafkajs'),
    );
  }

  /**
   * This process can result in imbalanced assignments
   * @param {array} members array of members, e.g: [{ memberId: 'test-5f93f5a3' }]
   * @param {array} topics
   * @param {Buffer} userData
   * @returns {array} object partitions per topic per member
   */
  public async assign(group: {
    members: GroupMember[];
    topics: string[];
  }): Promise<GroupMemberAssignment[]> {
    const assignment = {};
    const previousAssignment = {};

    const membersCount = group.members.length;
    const decodedMembers = group.members.map(member =>
      this.decodeMember(member),
    );
    const sortedMemberIds = decodedMembers
      .map(member => member.memberId)
      .sort();

    // build the previous assignment and an inverse map of topic > partition > memberId for lookup
    decodedMembers.forEach(member => {
      if (
        !previousAssignment[member.memberId] &&
        Object.keys(member.previousAssignment).length > 0
      ) {
        previousAssignment[member.memberId] = member.previousAssignment;
      }
    });

    // build a collection of topics and partitions
    const topicsPartitions = group.topics
      .map(topic => {
        const partitionMetadata =
          this.config.cluster.findTopicPartitionMetadata(topic);
        return partitionMetadata.map(m => {
          return {
            topic,
            partitionId: m.partitionId,
          };
        });
      })
      .reduce((acc, val) => acc.concat(val), []);

    // create the new assignment by populating the members with the first partition of the topics
    sortedMemberIds.forEach(assignee => {
      if (!assignment[assignee]) {
        assignment[assignee] = {};
      }

      // add topics to each member
      group.topics.forEach(topic => {
        if (!assignment[assignee][topic]) {
          assignment[assignee][topic] = [];
        }

        // see if the topic and partition belong to a previous assignment
        if (
          previousAssignment[assignee] &&
          !isUndefined(previousAssignment[assignee][topic])
        ) {
          // take the minimum partition since replies will be sent to the minimum partition
          const firstPartition = previousAssignment[assignee][topic];

          // create the assignment with the first partition
          assignment[assignee][topic].push(firstPartition);

          // find and remove this topic and partition from the topicPartitions to be assigned later
          const topicsPartitionsIndex = topicsPartitions.findIndex(
            topicPartition => {
              return (
                topicPartition.topic === topic &&
                topicPartition.partitionId === firstPartition
              );
            },
          );

          // only continue if we found a partition matching this topic
          if (topicsPartitionsIndex !== -1) {
            // remove inline
            topicsPartitions.splice(topicsPartitionsIndex, 1);
          }
        }
      });
    });

    // check for member topics that have a partition length of 0
    sortedMemberIds.forEach(assignee => {
      group.topics.forEach(topic => {
        // only continue if there are no partitions for assignee's topic
        if (assignment[assignee][topic].length === 0) {
          // find the first partition for this topic
          const topicsPartitionsIndex = topicsPartitions.findIndex(
            topicPartition => {
              return topicPartition.topic === topic;
            },
          );

          if (topicsPartitionsIndex !== -1) {
            // find and set the topic partition
            const partition =
              topicsPartitions[topicsPartitionsIndex].partitionId;

            assignment[assignee][topic].push(partition);

            // remove this partition from the topics partitions collection
            topicsPartitions.splice(topicsPartitionsIndex, 1);
          }
        }
      });
    });

    // then balance out the rest of the topic partitions across the members
    const insertAssignmentsByTopic = (topicPartition, i) => {
      const assignee = sortedMemberIds[i % membersCount];

      assignment[assignee][topicPartition.topic].push(
        topicPartition.partitionId,
      );
    };

    // build the assignments
    topicsPartitions.forEach(insertAssignmentsByTopic);

    // encode the end result
    return Object.keys(assignment).map(memberId => ({
      memberId,
      memberAssignment: kafkaPackage.AssignerProtocol.MemberAssignment.encode({
        version: this.version,
        assignment: assignment[memberId],
      }),
    }));
  }

  public protocol(subscription: {
    topics: string[];
    userData: Buffer;
  }): GroupState {
    const stringifiedUserData = JSON.stringify({
      previousAssignment: this.getPreviousAssignment(),
    });
    subscription.userData = Buffer.from(stringifiedUserData);

    return {
      name: this.name,
      metadata: kafkaPackage.AssignerProtocol.MemberMetadata.encode({
        version: this.version,
        topics: subscription.topics,
        userData: subscription.userData,
      }),
    };
  }

  public getPreviousAssignment() {
    return this.clientKafka.getConsumerAssignments();
  }

  public decodeMember(member: GroupMember) {
    const memberMetadata = kafkaPackage.AssignerProtocol.MemberMetadata.decode(
      member.memberMetadata,
    ) as MemberMetadata;
    const memberUserData = JSON.parse(memberMetadata.userData.toString());

    return {
      memberId: member.memberId,
      previousAssignment: memberUserData.previousAssignment,
    };
  }
}



================================================
FILE: packages/microservices/helpers/tcp-socket.ts
================================================
import { Buffer } from 'buffer';
import { Socket } from 'net';
import { InvalidJSONFormatException } from '../errors/invalid-json-format.exception';
import { NetSocketClosedException } from '../errors/net-socket-closed.exception';
import { TcpEventsMap } from '../events/tcp.events';

export abstract class TcpSocket {
  private isClosed = false;

  public get netSocket() {
    return this.socket;
  }

  constructor(public readonly socket: Socket) {
    this.socket.on('data', this.onData.bind(this));
    this.socket.on(TcpEventsMap.CONNECT, () => (this.isClosed = false));
    this.socket.on(TcpEventsMap.CLOSE, () => (this.isClosed = true));
    this.socket.on(TcpEventsMap.ERROR, () => (this.isClosed = true));
  }

  public connect(port: number, host: string) {
    this.socket.connect(port, host);
    return this;
  }

  public on(event: string, callback: (err?: any) => void) {
    this.socket.on(event, callback);
    return this;
  }

  public once(event: string, callback: (err?: any) => void) {
    this.socket.once(event, callback);
    return this;
  }

  public end() {
    this.socket.end();
    return this;
  }

  public sendMessage(message: any, callback?: (err?: any) => void) {
    if (this.isClosed) {
      callback && callback(new NetSocketClosedException());
      return;
    }
    this.handleSend(message, callback);
  }

  protected abstract handleSend(
    message: any,
    callback?: (err?: any) => void,
  ): any;

  private onData(data: Buffer) {
    try {
      this.handleData(data);
    } catch (e) {
      this.socket.emit(TcpEventsMap.ERROR, e.message);
      this.socket.end();
    }
  }

  protected abstract handleData(data: Buffer | string): any;

  protected emitMessage(data: string) {
    let message: Record<string, unknown>;
    try {
      message = JSON.parse(data);
    } catch (e) {
      throw new InvalidJSONFormatException(e, data);
    }
    message = message || {};
    this.socket.emit('message', message);
  }
}



================================================
FILE: packages/microservices/interfaces/client-grpc.interface.ts
================================================
/**
 * @publicApi
 */
export interface ClientGrpc {
  /**
   * Returns an instance of the given gRPC service.
   * @param name Service name
   * @returns gRPC service
   */
  getService<T extends object>(name: string): T;
  /**
   * Returns an instance of the given gRPC client.
   * @param name Service name
   * @returns gRPC client
   */
  getClientByServiceName<T = any>(name: string): T;
}



================================================
FILE: packages/microservices/interfaces/client-kafka-proxy.interface.ts
================================================
import { ClientProxy } from '../client';
import { KafkaStatus } from '../events';
import {
  Consumer,
  Producer,
  TopicPartitionOffsetAndMetadata,
} from '../external/kafka.interface';

export interface ClientKafkaProxy
  extends Omit<ClientProxy<never, KafkaStatus>, 'on'> {
  /**
   * Reference to the Kafka consumer instance.
   */
  consumer: Consumer | null;
  /**
   * Reference to the Kafka producer instance.
   */
  producer: Producer | null;
  /**
   * Subscribes to messages that match the pattern.
   * Required for message-driven communication style between microservices.
   * You can't use `send` without subscribing to the message pattern first.
   * @param pattern Pattern to subscribe to
   */
  subscribeToResponseOf(pattern: unknown): void;
  /**
   * Commits the given offsets.
   * @param topicPartitions Array of topic partitions with their offsets and metadata
   */
  commitOffsets(
    topicPartitions: TopicPartitionOffsetAndMetadata[],
  ): Promise<void>;
}



================================================
FILE: packages/microservices/interfaces/client-metadata.interface.ts
================================================
import { Type } from '@nestjs/common';
import { ConnectionOptions } from 'tls';
import { ClientProxy } from '../client';
import { Transport } from '../enums/transport.enum';
import { TcpSocket } from '../helpers';
import { Deserializer } from './deserializer.interface';
import {
  GrpcOptions,
  KafkaOptions,
  MqttOptions,
  NatsOptions,
  RedisOptions,
  RmqOptions,
} from './microservice-configuration.interface';
import { Serializer } from './serializer.interface';

export type ClientOptions =
  | RedisOptions
  | NatsOptions
  | MqttOptions
  | GrpcOptions
  | KafkaOptions
  | TcpClientOptions
  | RmqOptions;

/**
 * @publicApi
 */
export interface CustomClientOptions {
  customClass: Type<ClientProxy>;
  options?: Record<string, any>;
}

/**
 * @publicApi
 */
export interface TcpClientOptions {
  transport: Transport.TCP;
  options?: {
    host?: string;
    port?: number;
    serializer?: Serializer;
    deserializer?: Deserializer;
    tlsOptions?: ConnectionOptions;
    socketClass?: Type<TcpSocket>;
  };
}



================================================
FILE: packages/microservices/interfaces/custom-transport-strategy.interface.ts
================================================
import { Transport } from '../enums';

/**
 * @publicApi
 */
export interface CustomTransportStrategy {
  /**
   * Unique transport identifier.
   */
  readonly transportId?: Transport | symbol;
  /**
   * Method called when the transport is being initialized.
   * @param callback Function to be called upon initialization
   */
  listen(callback: (...optionalParams: unknown[]) => any): any;
  /**
   * Method called when the transport is being terminated.
   */
  close(): any;
}



================================================
FILE: packages/microservices/interfaces/deserializer.interface.ts
================================================
import {
  IncomingEvent,
  IncomingRequest,
  IncomingResponse,
} from './packet.interface';

/**
 * @publicApi
 */
export interface Deserializer<TInput = any, TOutput = any> {
  deserialize(
    value: TInput,
    options?: Record<string, any>,
  ): TOutput | Promise<TOutput>;
}

export type ProducerDeserializer = Deserializer<any, IncomingResponse>;
export type ConsumerDeserializer = Deserializer<
  any,
  IncomingRequest | IncomingEvent
>;



================================================
FILE: packages/microservices/interfaces/index.ts
================================================
export * from './client-grpc.interface';
export * from './client-kafka-proxy.interface';
export * from './client-metadata.interface';
export * from './custom-transport-strategy.interface';
export * from './deserializer.interface';
export * from './message-handler.interface';
export * from './microservice-configuration.interface';
export * from './packet.interface';
export * from './pattern-metadata.interface';
export * from './pattern.interface';
export * from './request-context.interface';
export * from './serializer.interface';



================================================
FILE: packages/microservices/interfaces/message-handler.interface.ts
================================================
import { Observable } from 'rxjs';

/**
 * @publicApi
 */
export interface MessageHandler<TInput = any, TContext = any, TResult = any> {
  (
    data: TInput,
    ctx?: TContext,
  ): Promise<Observable<TResult>> | Promise<TResult>;
  next?: (
    data: TInput,
    ctx?: TContext,
  ) => Promise<Observable<TResult>> | Promise<TResult>;
  isEventHandler?: boolean;
  extras?: Record<string, any>;
}



================================================
FILE: packages/microservices/interfaces/microservice-configuration.interface.ts
================================================
import { InjectionToken, Type } from '@nestjs/common';
import { TlsOptions } from 'tls';
import { Transport } from '../enums/transport.enum';
import { ChannelOptions } from '../external/grpc-options.interface';
import {
  ConsumerConfig,
  ConsumerRunConfig,
  ConsumerSubscribeTopics,
  KafkaConfig,
  ProducerConfig,
  ProducerRecord,
} from '../external/kafka.interface';
import { MqttClientOptions, QoS } from '../external/mqtt-options.interface';
import { IORedisOptions } from '../external/redis.interface';
import {
  AmqpConnectionManagerSocketOptions,
  AmqplibQueueOptions,
  RmqUrl,
} from '../external/rmq-url.interface';
import { TcpSocket } from '../helpers';
import { CustomTransportStrategy } from './custom-transport-strategy.interface';
import { Deserializer } from './deserializer.interface';
import { Serializer } from './serializer.interface';

export type MicroserviceOptions =
  | GrpcOptions
  | TcpOptions
  | RedisOptions
  | NatsOptions
  | MqttOptions
  | RmqOptions
  | KafkaOptions
  | CustomStrategy;

export type AsyncMicroserviceOptions = {
  inject: InjectionToken[];
  useFactory: (...args: any[]) => MicroserviceOptions;
};

export type AsyncOptions<T extends object> = {
  inject: InjectionToken[];
  useFactory: (...args: any[]) => T;
};

/**
 * @publicApi
 */
export interface CustomStrategy {
  strategy: CustomTransportStrategy;
  options?: Record<string, any>;
}

/**
 * @publicApi
 */
export interface GrpcOptions {
  transport?: Transport.GRPC;
  options: {
    url?: string;
    maxSendMessageLength?: number;
    maxReceiveMessageLength?: number;
    maxMetadataSize?: number;
    keepalive?: {
      keepaliveTimeMs?: number;
      keepaliveTimeoutMs?: number;
      keepalivePermitWithoutCalls?: number;
      http2MaxPingsWithoutData?: number;
      http2MinTimeBetweenPingsMs?: number;
      http2MinPingIntervalWithoutDataMs?: number;
      http2MaxPingStrikes?: number;
    };
    channelOptions?: ChannelOptions;
    credentials?: any;
    protoPath?: string | string[];
    package: string | string[];
    protoLoader?: string;
    packageDefinition?: any;
    gracefulShutdown?: boolean;
    onLoadPackageDefinition?: (pkg: any, server: any) => void;
    loader?: {
      keepCase?: boolean;
      alternateCommentMode?: boolean;
      longs?: Function;
      enums?: Function;
      bytes?: Function;
      defaults?: boolean;
      arrays?: boolean;
      objects?: boolean;
      oneofs?: boolean;
      json?: boolean;
      includeDirs?: string[];
    };
  };
}

/**
 * @publicApi
 */
export interface TcpOptions {
  transport?: Transport.TCP;
  options?: {
    host?: string;
    port?: number;
    retryAttempts?: number;
    retryDelay?: number;
    serializer?: Serializer;
    tlsOptions?: TlsOptions;
    deserializer?: Deserializer;
    socketClass?: Type<TcpSocket>;
  };
}

/**
 * @publicApi
 */
export interface RedisOptions {
  transport?: Transport.REDIS;
  options?: {
    host?: string;
    port?: number;
    retryAttempts?: number;
    retryDelay?: number;
    /**
     * Use `psubscribe`/`pmessage` to enable wildcards in the patterns
     */
    wildcards?: boolean;
    serializer?: Serializer;
    deserializer?: Deserializer;
  } & IORedisOptions;
}

/**
 * @publicApi
 */
export interface MqttOptions {
  transport?: Transport.MQTT;
  options?: MqttClientOptions & {
    url?: string;
    serializer?: Serializer;
    deserializer?: Deserializer;
    subscribeOptions?: {
      /**
       * The QoS
       */
      qos: QoS;
      /*
       * No local flag
       * */
      nl?: boolean;
      /*
       * Retain as Published flag
       * */
      rap?: boolean;
      /*
       * Retain Handling option
       * */
      rh?: number;
    };
    userProperties?: Record<string, string | string[]>;
  };
}

/**
 * @publicApi
 */
export interface NatsOptions {
  transport?: Transport.NATS;
  options?: {
    headers?: Record<string, string>;
    authenticator?: any;
    debug?: boolean;
    ignoreClusterUpdates?: boolean;
    inboxPrefix?: string;
    encoding?: string;
    name?: string;
    user?: string;
    pass?: string;
    maxPingOut?: number;
    maxReconnectAttempts?: number;
    reconnectTimeWait?: number;
    reconnectJitter?: number;
    reconnectJitterTLS?: number;
    reconnectDelayHandler?: any;
    servers?: string[] | string;
    nkey?: any;
    reconnect?: boolean;
    pedantic?: boolean;
    tls?: any;
    queue?: string;
    serializer?: Serializer;
    deserializer?: Deserializer;
    userJWT?: string;
    nonceSigner?: any;
    userCreds?: any;
    useOldRequestStyle?: boolean;
    pingInterval?: number;
    preserveBuffers?: boolean;
    waitOnFirstConnect?: boolean;
    verbose?: boolean;
    noEcho?: boolean;
    noRandomize?: boolean;
    timeout?: number;
    token?: string;
    yieldTime?: number;
    tokenHandler?: any;
    gracefulShutdown?: boolean;
    gracePeriod?: number;
    [key: string]: any;
  };
}

/**
 * @publicApi
 */
export interface RmqOptions {
  transport?: Transport.RMQ;
  options?: {
    urls?: string[] | RmqUrl[];
    queue?: string;
    prefetchCount?: number;
    isGlobalPrefetchCount?: boolean;
    queueOptions?: AmqplibQueueOptions;
    socketOptions?: AmqpConnectionManagerSocketOptions;
    exchange?: string;
    routingKey?: string;
    noAck?: boolean;
    consumerTag?: string;
    serializer?: Serializer;
    deserializer?: Deserializer;
    replyQueue?: string;
    persistent?: boolean;
    headers?: Record<string, string>;
    noAssert?: boolean;
    /**
     * Maximum number of connection attempts.
     * Applies only to the consumer configuration.
     * -1 === infinite
     * @default -1
     */
    maxConnectionAttempts?: number;
  };
}

/**
 * @publicApi
 */
export interface KafkaParserConfig {
  keepBinary?: boolean;
}

/**
 * @publicApi
 */
export interface KafkaOptions {
  transport?: Transport.KAFKA;
  options?: {
    /**
     * Defaults to `"-server"` on server side and `"-client"` on client side.
     */
    postfixId?: string;
    client?: KafkaConfig;
    consumer?: ConsumerConfig;
    run?: Omit<ConsumerRunConfig, 'eachBatch' | 'eachMessage'>;
    subscribe?: Omit<ConsumerSubscribeTopics, 'topics'>;
    producer?: ProducerConfig;
    send?: Omit<ProducerRecord, 'topic' | 'messages'>;
    serializer?: Serializer;
    deserializer?: Deserializer;
    parser?: KafkaParserConfig;
    producerOnlyMode?: boolean;
  };
}



================================================
FILE: packages/microservices/interfaces/microservice-entrypoint-metadata.interface.ts
================================================
import { Transport } from '../enums';
import { PatternMetadata } from './pattern-metadata.interface';

export type MicroserviceEntrypointMetadata = {
  transportId: keyof typeof Transport | symbol;
  patterns: PatternMetadata[];
  isEventHandler: boolean;
  extras?: Record<string, any>;
};



================================================
FILE: packages/microservices/interfaces/packet.interface.ts
================================================
export interface PacketId {
  id: string;
}

export interface ReadPacket<T = any> {
  pattern: any;
  data: T;
}

export interface WritePacket<T = any> {
  err?: any;
  response?: T;
  isDisposed?: boolean;
  status?: string;
}

export type OutgoingRequest = ReadPacket & PacketId;
export type IncomingRequest = ReadPacket & PacketId;
export type OutgoingEvent = ReadPacket;
export type IncomingEvent = ReadPacket;
export type IncomingResponse = WritePacket & PacketId;
export type OutgoingResponse = WritePacket & PacketId;



================================================
FILE: packages/microservices/interfaces/pattern-metadata.interface.ts
================================================
export type PatternMetadata = Record<string, any> | string;



================================================
FILE: packages/microservices/interfaces/pattern.interface.ts
================================================
export type MsFundamentalPattern = string | number;

export interface MsObjectPattern {
  [key: string]: MsFundamentalPattern | MsObjectPattern;
}

export type MsPattern = MsObjectPattern | MsFundamentalPattern;



================================================
FILE: packages/microservices/interfaces/request-context.interface.ts
================================================
import { BaseRpcContext } from '../ctx-host/base-rpc.context';

export interface RequestContext<
  TData = any,
  TContext extends BaseRpcContext = any,
> {
  pattern: string | Record<string, any>;
  data: TData;
  context?: TContext;

  getData(): TData;
  getPattern(): string | Record<string, any>;
  getContext(): TContext;
}



================================================
FILE: packages/microservices/interfaces/serializer.interface.ts
================================================
import {
  OutgoingEvent,
  OutgoingRequest,
  OutgoingResponse,
} from './packet.interface';

/**
 * @publicApi
 */
export interface Serializer<TInput = any, TOutput = any> {
  serialize(value: TInput, options?: Record<string, any>): TOutput;
}

export type ProducerSerializer = Serializer<
  OutgoingEvent | OutgoingRequest,
  any
>;
export type ConsumerSerializer = Serializer<OutgoingResponse, any>;



================================================
FILE: packages/microservices/module/clients.module.ts
================================================
import {
  DynamicModule,
  ForwardReference,
  Module,
  OnApplicationShutdown,
  Provider,
  Type,
} from '@nestjs/common';
import { ClientProxy, ClientProxyFactory } from '../client';
import {
  ClientsModuleAsyncOptions,
  ClientsModuleOptions,
  ClientsModuleOptionsFactory,
  ClientsProviderAsyncOptions,
} from './interfaces';

@Module({})
export class ClientsModule {
  static register(options: ClientsModuleOptions): DynamicModule {
    const clientsOptions = !Array.isArray(options) ? options.clients : options;
    const clients = (clientsOptions || []).map(item => {
      return {
        provide: item.name,
        useValue: this.assignOnAppShutdownHook(ClientProxyFactory.create(item)),
      };
    });
    return {
      module: ClientsModule,
      global: !Array.isArray(options) && options.isGlobal,
      providers: clients,
      exports: clients,
    };
  }

  static registerAsync(options: ClientsModuleAsyncOptions): DynamicModule {
    const clientsOptions = !Array.isArray(options) ? options.clients : options;
    const providers: Provider[] = clientsOptions.reduce(
      (accProviders: Provider[], item) =>
        accProviders
          .concat(this.createAsyncProviders(item))
          .concat(item.extraProviders || []),
      [],
    );
    const imports = clientsOptions.reduce(
      (accImports, option) => {
        if (!option.imports) {
          return accImports;
        }
        const toInsert = option.imports.filter(
          item => !accImports.includes(item),
        );
        return accImports.concat(toInsert);
      },
      [] as Array<
        DynamicModule | Promise<DynamicModule> | ForwardReference | Type
      >,
    );
    return {
      module: ClientsModule,
      global: !Array.isArray(options) && options.isGlobal,
      imports,
      providers: providers,
      exports: providers,
    };
  }

  private static createAsyncProviders(
    options: ClientsProviderAsyncOptions,
  ): Provider[] {
    if (options.useExisting || options.useFactory) {
      return [this.createAsyncOptionsProvider(options)];
    }
    return [
      this.createAsyncOptionsProvider(options),
      {
        provide: options.useClass!,
        useClass: options.useClass!,
      },
    ];
  }

  private static createAsyncOptionsProvider(
    options: ClientsProviderAsyncOptions,
  ): Provider {
    if (options.useFactory) {
      return {
        provide: options.name,
        useFactory: this.createFactoryWrapper(options.useFactory),
        inject: options.inject || [],
      };
    }
    return {
      provide: options.name,
      useFactory: this.createFactoryWrapper(
        (optionsFactory: ClientsModuleOptionsFactory) =>
          optionsFactory.createClientOptions(),
      ),
      inject: [options.useExisting || options.useClass!],
    };
  }

  private static createFactoryWrapper(
    useFactory: ClientsProviderAsyncOptions['useFactory'],
  ) {
    return async (...args: any[]) => {
      const clientOptions = await useFactory!(...args);
      const clientProxyRef = ClientProxyFactory.create(clientOptions);
      return this.assignOnAppShutdownHook(clientProxyRef);
    };
  }

  private static assignOnAppShutdownHook(client: ClientProxy) {
    (client as unknown as OnApplicationShutdown).onApplicationShutdown =
      client.close;
    return client;
  }
}



================================================
FILE: packages/microservices/module/index.ts
================================================
export * from './clients.module';
export * from './interfaces';



================================================
FILE: packages/microservices/module/interfaces/clients-module.interface.ts
================================================
import { ClientOptions, CustomClientOptions } from '../../interfaces';
import { Type, Provider, ModuleMetadata } from '@nestjs/common/interfaces';

export type ClientProvider = ClientOptions | CustomClientOptions;

export type ClientProviderOptions = ClientProvider & {
  name: string | symbol;
};

export type ClientsModuleOptions =
  | Array<ClientProviderOptions>
  | {
      clients: Array<ClientProviderOptions>;
      isGlobal?: boolean;
    };

export interface ClientsModuleOptionsFactory {
  createClientOptions(): Promise<ClientProvider> | ClientProvider;
}

export interface ClientsProviderAsyncOptions
  extends Pick<ModuleMetadata, 'imports'> {
  useExisting?: Type<ClientsModuleOptionsFactory>;
  useClass?: Type<ClientsModuleOptionsFactory>;
  useFactory?: (...args: any[]) => Promise<ClientProvider> | ClientProvider;
  inject?: any[];
  extraProviders?: Provider[];
  name: string | symbol;
}

export type ClientsModuleAsyncOptions =
  | Array<ClientsProviderAsyncOptions>
  | {
      clients: Array<ClientsProviderAsyncOptions>;
      isGlobal?: boolean;
    };



================================================
FILE: packages/microservices/module/interfaces/index.ts
================================================
export * from './clients-module.interface';



================================================
FILE: packages/microservices/record-builders/index.ts
================================================
export * from './mqtt.record-builder';
export * from './nats.record-builder';
export * from './rmq.record-builder';



================================================
FILE: packages/microservices/record-builders/mqtt.record-builder.ts
================================================
/**
 * @publicApi
 */
export interface MqttRecordOptions {
  /**
   * The QoS
   */
  qos?: 0 | 1 | 2;
  /**
   * The retain flag
   */
  retain?: boolean;
  /**
   * Whether or not mark a message as duplicate
   */
  dup?: boolean;
  /*
   *  MQTT 5.0 properties object
   */
  properties?: {
    payloadFormatIndicator?: boolean;
    messageExpiryInterval?: number;
    topicAlias?: number;
    responseTopic?: string;
    correlationData?: Buffer;
    userProperties?: Record<string, string | string[]>;
    subscriptionIdentifier?: number;
    contentType?: string;
  };
}

/**
 * @publicApi
 */
export class MqttRecord<TData = any> {
  constructor(
    public readonly data: TData,
    public options?: MqttRecordOptions,
  ) {}
}

/**
 * @publicApi
 */
export class MqttRecordBuilder<TData> {
  private options?: MqttRecordOptions;

  constructor(private data?: TData) {}

  public setData(data: TData): this {
    this.data = data;
    return this;
  }

  public setQoS(qos: MqttRecordOptions['qos']): this {
    this.options = {
      ...this.options,
      qos,
    };
    return this;
  }

  public setRetain(retain: MqttRecordOptions['retain']): this {
    this.options = {
      ...this.options,
      retain,
    };
    return this;
  }

  public setDup(dup: MqttRecordOptions['dup']): this {
    this.options = {
      ...this.options,
      dup,
    };
    return this;
  }

  public setProperties(properties: MqttRecordOptions['properties']): this {
    this.options = {
      ...this.options,
      properties,
    };
    return this;
  }

  public build(): MqttRecord {
    return new MqttRecord(this.data, this.options);
  }
}



================================================
FILE: packages/microservices/record-builders/nats.record-builder.ts
================================================
/**
 * @publicApi
 */
export class NatsRecord<TData = any, THeaders = any> {
  constructor(
    public readonly data: TData,
    public readonly headers?: THeaders,
  ) {}
}

/**
 * @publicApi
 */
export class NatsRecordBuilder<TData> {
  private headers?: any;

  constructor(private data?: TData) {}

  public setHeaders<THeaders = any>(headers: THeaders): this {
    this.headers = headers;
    return this;
  }

  public setData(data: TData): this {
    this.data = data;
    return this;
  }

  public build(): NatsRecord {
    return new NatsRecord(this.data, this.headers);
  }
}



================================================
FILE: packages/microservices/record-builders/rmq.record-builder.ts
================================================
/**
 * @publicApi
 */
export interface RmqRecordOptions {
  expiration?: string | number;
  userId?: string;
  CC?: string | string[];
  mandatory?: boolean;
  persistent?: boolean;
  deliveryMode?: boolean | number;
  BCC?: string | string[];
  contentType?: string;
  contentEncoding?: string;
  headers?: Record<string, string>;
  priority?: number;
  messageId?: string;
  timestamp?: number;
  type?: string;
  appId?: string;
}

/**
 * @publicApi
 */
export class RmqRecord<TData = any> {
  constructor(
    public readonly data: TData,
    public options?: RmqRecordOptions,
  ) {}
}

/**
 * @publicApi
 */
export class RmqRecordBuilder<TData> {
  private options?: RmqRecordOptions;

  constructor(private data?: TData) {}

  public setOptions(options: RmqRecordOptions): this {
    this.options = options;
    return this;
  }

  public setData(data: TData): this {
    this.data = data;
    return this;
  }

  public build(): RmqRecord {
    return new RmqRecord(this.data, this.options);
  }
}



================================================
FILE: packages/microservices/serializers/identity.serializer.ts
================================================
import { Serializer } from '../interfaces/serializer.interface';

export class IdentitySerializer implements Serializer {
  serialize(value: any) {
    return value;
  }
}



================================================
FILE: packages/microservices/serializers/index.ts
================================================
export * from './identity.serializer';
export * from './kafka-request.serializer';
export * from './mqtt-record.serializer';
export * from './nats-record.serializer';
export * from './rmq-record.serializer';



================================================
FILE: packages/microservices/serializers/kafka-request.serializer.ts
================================================
import {
  isNil,
  isObject,
  isPlainObject,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { Serializer } from '../interfaces/serializer.interface';

export interface KafkaRequest<T = any> {
  key: Buffer | string | null;
  value: T;
  headers: Record<string, any>;
}

/**
 * @publicApi
 */
export class KafkaRequestSerializer
  implements Serializer<any, KafkaRequest | Promise<KafkaRequest>>
{
  serialize(value: any) {
    const isNotKafkaMessage =
      isNil(value) ||
      !isObject(value) ||
      (!('key' in value) && !('value' in value));

    if (isNotKafkaMessage) {
      value = { value };
    }
    value.value = this.encode(value.value);
    if (!isNil(value.key)) {
      value.key = this.encode(value.key);
    }
    if (isNil(value.headers)) {
      value.headers = {};
    }
    return value;
  }

  public encode(value: any): Buffer | string | null {
    const isObjectOrArray =
      !isNil(value) && !isString(value) && !Buffer.isBuffer(value);

    if (isObjectOrArray) {
      return isPlainObject(value) || Array.isArray(value)
        ? JSON.stringify(value)
        : value.toString();
    } else if (isUndefined(value)) {
      return null;
    }
    return value;
  }
}



================================================
FILE: packages/microservices/serializers/mqtt-record.serializer.ts
================================================
import { isObject } from '@nestjs/common/utils/shared.utils';
import { ReadPacket, Serializer } from '../interfaces';
import { MqttRecord } from '../record-builders';

export class MqttRecordSerializer implements Serializer<ReadPacket, string> {
  serialize(packet: ReadPacket): string {
    if (isObject(packet?.data) && packet.data instanceof MqttRecord) {
      const record = packet.data;
      return JSON.stringify({
        ...packet,
        data: record.data,
      });
    }
    return JSON.stringify(packet);
  }
}



================================================
FILE: packages/microservices/serializers/nats-record.serializer.ts
================================================
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { NatsCodec } from '../external/nats-codec.interface';
import { ReadPacket } from '../interfaces';
import { Serializer } from '../interfaces/serializer.interface';
import { NatsRecord, NatsRecordBuilder } from '../record-builders';

let natsPackage = {} as any;

export class NatsRecordSerializer
  implements Serializer<ReadPacket, NatsRecord>
{
  private readonly jsonCodec: NatsCodec<unknown>;

  constructor() {
    natsPackage = loadPackage('nats', NatsRecordSerializer.name, () =>
      require('nats'),
    );
    this.jsonCodec = natsPackage.JSONCodec();
  }

  serialize(packet: any): NatsRecord {
    const natsMessage =
      packet?.data && isObject(packet.data) && packet.data instanceof NatsRecord
        ? packet.data
        : new NatsRecordBuilder(packet?.data).build();

    return {
      data: this.jsonCodec.encode({ ...packet, data: natsMessage.data }),
      headers: natsMessage.headers,
    };
  }
}



================================================
FILE: packages/microservices/serializers/rmq-record.serializer.ts
================================================
import { isObject } from '@nestjs/common/utils/shared.utils';
import { ReadPacket } from '../interfaces';
import { Serializer } from '../interfaces/serializer.interface';
import { RmqRecord } from '../record-builders';

export class RmqRecordSerializer
  implements Serializer<ReadPacket, ReadPacket & Partial<RmqRecord>>
{
  serialize(packet: ReadPacket): ReadPacket & Partial<RmqRecord> {
    if (
      packet?.data &&
      isObject(packet.data) &&
      packet.data instanceof RmqRecord
    ) {
      const record = packet.data;
      return {
        ...packet,
        data: record.data,
        options: record.options,
      };
    }
    return packet;
  }
}



================================================
FILE: packages/microservices/server/index.ts
================================================
export * from './server';
export * from './server-grpc';
export * from './server-kafka';
export * from './server-mqtt';
export * from './server-nats';
export * from './server-redis';
export * from './server-rmq';
export * from './server-tcp';



================================================
FILE: packages/microservices/server/server-factory.ts
================================================
import { Transport } from '../enums/transport.enum';
import {
  CustomStrategy,
  GrpcOptions,
  KafkaOptions,
  MicroserviceOptions,
  MqttOptions,
  NatsOptions,
  RedisOptions,
  RmqOptions,
  TcpOptions,
} from '../interfaces';
import { ServerGrpc } from './server-grpc';
import { ServerKafka } from './server-kafka';
import { ServerMqtt } from './server-mqtt';
import { ServerNats } from './server-nats';
import { ServerRedis } from './server-redis';
import { ServerRMQ } from './server-rmq';
import { ServerTCP } from './server-tcp';

export class ServerFactory {
  public static create(microserviceOptions: MicroserviceOptions) {
    const { transport, options } = microserviceOptions as Exclude<
      MicroserviceOptions,
      CustomStrategy
    >;
    switch (transport) {
      case Transport.REDIS:
        return new ServerRedis(options as Required<RedisOptions>['options']);
      case Transport.NATS:
        return new ServerNats(options as Required<NatsOptions>['options']);
      case Transport.MQTT:
        return new ServerMqtt(options as Required<MqttOptions>['options']);
      case Transport.GRPC:
        return new ServerGrpc(options);
      case Transport.KAFKA:
        return new ServerKafka(options as Required<KafkaOptions>['options']);
      case Transport.RMQ:
        return new ServerRMQ(options as Required<RmqOptions>['options']);
      default:
        return new ServerTCP(options as Required<TcpOptions>['options']);
    }
  }
}



================================================
FILE: packages/microservices/server/server-grpc.ts
================================================
import {
  isObject,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import {
  EMPTY,
  Observable,
  ReplaySubject,
  Subject,
  Subscription,
  defaultIfEmpty,
  fromEvent,
  lastValueFrom,
} from 'rxjs';
import { catchError, takeUntil } from 'rxjs/operators';
import { GRPC_DEFAULT_PROTO_LOADER, GRPC_DEFAULT_URL } from '../constants';
import { GrpcMethodStreamingType } from '../decorators';
import { Transport } from '../enums';
import { InvalidGrpcPackageException } from '../errors/invalid-grpc-package.exception';
import { InvalidProtoDefinitionException } from '../errors/invalid-proto-definition.exception';
import { ChannelOptions } from '../external/grpc-options.interface';
import { getGrpcPackageDefinition } from '../helpers';
import { MessageHandler } from '../interfaces';
import { GrpcOptions } from '../interfaces/microservice-configuration.interface';
import { Server } from './server';

const CANCELLED_EVENT = 'cancelled';

// To enable type safety for gRPC. This cant be uncommented by default
// because it would require the user to install the @grpc/grpc-js package even if they dont use gRPC
// Otherwise, TypeScript would fail to compile the code.
//
// type GrpcServer = import('@grpc/grpc-js').Server;
// let grpcPackage = {} as typeof import('@grpc/grpc-js');
// let grpcProtoLoaderPackage = {} as typeof import('@grpc/proto-loader');

type GrpcServer = any;
let grpcPackage = {} as any;
let grpcProtoLoaderPackage = {} as any;

interface GrpcCall<TRequest = any, TMetadata = any> {
  request: TRequest;
  metadata: TMetadata;
  sendMetadata: Function;
  end: Function;
  write: Function;
  on: Function;
  off: Function;
  emit: Function;
}

/**
 * @publicApi
 */
export class ServerGrpc extends Server<never, never> {
  public readonly transportId = Transport.GRPC;
  protected readonly url: string;
  protected grpcClient: GrpcServer;

  get status(): never {
    throw new Error(
      'The "status" attribute is not supported by the gRPC transport',
    );
  }

  constructor(private readonly options: Readonly<GrpcOptions>['options']) {
    super();
    this.url = this.getOptionsProp(options, 'url') || GRPC_DEFAULT_URL;

    const protoLoader =
      this.getOptionsProp(options, 'protoLoader') || GRPC_DEFAULT_PROTO_LOADER;

    grpcPackage = this.loadPackage('@grpc/grpc-js', ServerGrpc.name, () =>
      require('@grpc/grpc-js'),
    );
    grpcProtoLoaderPackage = this.loadPackage(
      protoLoader,
      ServerGrpc.name,
      () =>
        protoLoader === GRPC_DEFAULT_PROTO_LOADER
          ? require('@grpc/proto-loader')
          : require(protoLoader),
    );
  }

  public async listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    try {
      this.grpcClient = await this.createClient();
      await this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public async start(callback?: () => void) {
    await this.bindEvents();
    callback?.();
  }

  public async bindEvents() {
    const grpcContext = this.loadProto();
    const packageOption = this.getOptionsProp(this.options, 'package');
    const packageNames = Array.isArray(packageOption)
      ? packageOption
      : [packageOption];

    for (const packageName of packageNames) {
      const grpcPkg = this.lookupPackage(grpcContext, packageName);
      await this.createServices(grpcPkg, packageName);
    }
  }

  /**
   * Will return all of the services along with their fully namespaced
   * names as an array of objects.
   * This method initiates recursive scan of grpcPkg object
   */
  public getServiceNames(grpcPkg: any): { name: string; service: any }[] {
    // Define accumulator to collect all of the services available to load
    const services: { name: string; service: any }[] = [];
    // Initiate recursive services collector starting with empty name
    this.collectDeepServices('', grpcPkg, services);
    return services;
  }

  /**
   * Will create service mapping from gRPC generated Object to handlers
   * defined with @GrpcMethod or @GrpcStreamMethod annotations
   *
   * @param grpcService
   * @param name
   */
  public async createService(grpcService: any, name: string) {
    const service = {};

    for (const methodName in grpcService.prototype) {
      let methodHandler: MessageHandler | null = null;
      let streamingType = GrpcMethodStreamingType.NO_STREAMING;

      const methodFunction = grpcService.prototype[methodName];
      const methodReqStreaming = methodFunction.requestStream;

      if (!isUndefined(methodReqStreaming) && methodReqStreaming) {
        // Try first pattern to be presented, RX streaming pattern would be
        // a preferable pattern to select among a few defined
        methodHandler = this.getMessageHandler(
          name,
          methodName,
          GrpcMethodStreamingType.RX_STREAMING,
          methodFunction,
        );
        streamingType = GrpcMethodStreamingType.RX_STREAMING;
        // If first pattern didn't match to any of handlers then try
        // pass-through handler to be presented
        if (!methodHandler) {
          methodHandler = this.getMessageHandler(
            name,
            methodName,
            GrpcMethodStreamingType.PT_STREAMING,
            methodFunction,
          );
          streamingType = GrpcMethodStreamingType.PT_STREAMING;
        }
      } else {
        // Select handler if any presented for No-Streaming pattern
        methodHandler = this.getMessageHandler(
          name,
          methodName,
          GrpcMethodStreamingType.NO_STREAMING,
          methodFunction,
        );
        streamingType = GrpcMethodStreamingType.NO_STREAMING;
      }
      if (!methodHandler) {
        continue;
      }
      service[methodName] = this.createServiceMethod(
        methodHandler,
        grpcService.prototype[methodName],
        streamingType,
      );
    }
    return service;
  }

  public getMessageHandler(
    serviceName: string,
    methodName: string,
    streaming: GrpcMethodStreamingType,
    grpcMethod: { path?: string },
  ): MessageHandler {
    let pattern = this.createPattern(serviceName, methodName, streaming);
    let methodHandler = this.messageHandlers.get(pattern)!;
    if (!methodHandler) {
      const packageServiceName = grpcMethod.path?.split?.('/')[1];
      pattern = this.createPattern(packageServiceName!, methodName, streaming);
      methodHandler = this.messageHandlers.get(pattern)!;
    }
    return methodHandler;
  }

  /**
   * Will create a string of a JSON serialized format
   *
   * @param service name of the service which should be a match to gRPC service definition name
   * @param methodName name of the method which is coming after rpc keyword
   * @param streaming GrpcMethodStreamingType parameter which should correspond to
   * stream keyword in gRPC service request part
   */
  public createPattern(
    service: string,
    methodName: string,
    streaming: GrpcMethodStreamingType,
  ): string {
    return JSON.stringify({
      service,
      rpc: methodName,
      streaming,
    });
  }

  /**
   * Will return async function which will handle gRPC call
   * with Rx streams or as a direct call passthrough
   *
   * @param methodHandler
   * @param protoNativeHandler
   * @param streamType
   */
  public createServiceMethod(
    methodHandler: Function,
    protoNativeHandler: any,
    streamType: GrpcMethodStreamingType,
  ): Function {
    // If proto handler has request stream as "true" then we expect it to have
    // streaming from the side of requester
    if (protoNativeHandler.requestStream) {
      // If any handlers were defined with GrpcStreamMethod annotation use RX
      if (streamType === GrpcMethodStreamingType.RX_STREAMING) {
        return this.createRequestStreamMethod(
          methodHandler,
          protoNativeHandler.responseStream,
        );
      }
      // If any handlers were defined with GrpcStreamCall annotation
      else if (streamType === GrpcMethodStreamingType.PT_STREAMING) {
        return this.createStreamCallMethod(
          methodHandler,
          protoNativeHandler.responseStream,
        );
      }
    }
    return protoNativeHandler.responseStream
      ? this.createStreamServiceMethod(methodHandler)
      : this.createUnaryServiceMethod(methodHandler);
  }

  public createUnaryServiceMethod(methodHandler: Function): Function {
    return async (call: GrpcCall, callback: Function) => {
      const handler = methodHandler(call.request, call.metadata, call);
      this.transformToObservable(await handler).subscribe({
        next: async data => callback(null, await data),
        error: (err: any) => callback(err),
      });
    };
  }

  public createStreamServiceMethod(methodHandler: Function): Function {
    return async (call: GrpcCall, callback: Function) => {
      const handler = methodHandler(call.request, call.metadata, call);
      const result$ = this.transformToObservable(await handler);
      await this.writeObservableToGrpc(result$, call);
    };
  }

  public unwrap<T>(): T {
    throw new Error('Method is not supported for gRPC transport');
  }

  public on<
    EventKey extends string | number | symbol = string | number | symbol,
    EventCallback = any,
  >(event: EventKey, callback: EventCallback) {
    throw new Error('Method is not supported in gRPC mode.');
  }

  /**
   * Writes an observable to a GRPC call.
   *
   * This function will ensure that backpressure is managed while writing values
   * that come from an observable to a GRPC call.
   *
   * @param source The observable we want to write out to the GRPC call.
   * @param call The GRPC call we want to write to.
   * @returns A promise that resolves when we're done writing to the call.
   */
  private writeObservableToGrpc<T>(
    source: Observable<T>,
    call: GrpcCall<T>,
  ): Promise<void> {
    // This promise should **not** reject, as we're handling errors in the observable for the Call
    // the promise is only needed to signal when writing/draining has been completed
    return new Promise((resolve, _doNotUse) => {
      const valuesWaitingToBeDrained: T[] = [];
      let shouldErrorAfterDraining = false;
      let error: any;
      let shouldResolveAfterDraining = false;
      let writing = true;

      // Used to manage finalization
      const subscription = new Subscription();

      // If the call is cancelled, unsubscribe from the source
      const cancelHandler = () => {
        subscription.unsubscribe();
        // Calls that are cancelled by the client should be successfully resolved here
        resolve();
      };
      call.on(CANCELLED_EVENT, cancelHandler);
      subscription.add(() => call.off(CANCELLED_EVENT, cancelHandler));

      // In all cases, when we finalize, end the writable stream
      // being careful that errors and writes must be emitted _before_ this call is ended
      subscription.add(() => call.end());

      const drain = () => {
        writing = true;
        while (valuesWaitingToBeDrained.length > 0) {
          const value = valuesWaitingToBeDrained.shift();
          if (writing) {
            // The first time `call.write` returns false, we need to stop.
            // It wrote the value, but it won't write anything else.
            writing = call.write(value);
            if (!writing) {
              // We can't write anymore so we need to wait for the drain event
              return;
            }
          }
        }

        if (shouldResolveAfterDraining) {
          subscription.unsubscribe();
          resolve();
        } else if (shouldErrorAfterDraining) {
          call.emit('error', error);
          subscription.unsubscribe();
          resolve();
        }
      };

      call.on('drain', drain);
      subscription.add(() => call.off('drain', drain));

      subscription.add(
        source.subscribe({
          next(value) {
            if (writing) {
              writing = call.write(value);
            } else {
              // If we can't write, that's because we need to
              // wait for the drain event before we can write again
              // buffer the value and wait for the drain event
              valuesWaitingToBeDrained.push(value);
            }
          },
          error(err) {
            if (valuesWaitingToBeDrained.length === 0) {
              // We're not waiting for a drain event, so we can just
              // reject and teardown.
              call.emit('error', err);
              subscription.unsubscribe();
              resolve();
            } else {
              // We're waiting for a drain event, record the
              // error so it can be handled after everything is drained.
              shouldErrorAfterDraining = true;
              error = err;
            }
          },
          complete() {
            if (valuesWaitingToBeDrained.length === 0) {
              // We're not waiting for a drain event, so we can just
              // resolve and teardown.
              subscription.unsubscribe();
              resolve();
            } else {
              shouldResolveAfterDraining = true;
            }
          },
        }),
      );
    });
  }

  public createRequestStreamMethod(
    methodHandler: Function,
    isResponseStream: boolean,
  ) {
    return async (
      call: GrpcCall,
      callback: (err: unknown, value: unknown) => void,
    ) => {
      // Needs to be a Proxy in order to buffer messages that come before handler is executed
      // This could happen if handler has any async guards or interceptors registered that would delay
      // the execution.
      const { subject, next, error, complete, cleanup } =
        this.bufferUntilDrained();
      call.on('data', (m: any) => next(m));
      call.on('error', (e: any) => {
        // Check if error means that stream ended on other end
        const isCancelledError = String(e).toLowerCase().indexOf('cancelled');

        if (isCancelledError) {
          call.end();
          return;
        }
        // If another error then just pass it along
        error(e);
      });
      call.on('end', () => {
        complete();
        cleanup();
      });

      const handler = methodHandler(
        subject.asObservable(),
        call.metadata,
        call,
      );
      const res = this.transformToObservable(await handler);
      if (isResponseStream) {
        await this.writeObservableToGrpc(res, call);
      } else {
        const response = await lastValueFrom(
          res.pipe(
            takeUntil(fromEvent(call as any, CANCELLED_EVENT)),
            catchError(err => {
              callback(err, null);
              return EMPTY;
            }),
            defaultIfEmpty(undefined),
          ),
        );

        if (!isUndefined(response)) {
          callback(null, response);
        }
      }
    };
  }

  public createStreamCallMethod(
    methodHandler: Function,
    isResponseStream: boolean,
  ) {
    return async (
      call: GrpcCall,
      callback: (err: unknown, value: unknown) => void,
    ) => {
      let handlerStream: Observable<any>;
      if (isResponseStream) {
        handlerStream = this.transformToObservable(await methodHandler(call));
      } else {
        handlerStream = this.transformToObservable(
          await methodHandler(call, callback),
        );
      }
      await lastValueFrom(handlerStream);
    };
  }

  public async close(): Promise<void> {
    if (this.grpcClient) {
      const graceful = this.getOptionsProp(this.options, 'gracefulShutdown');
      if (graceful) {
        await new Promise<void>((resolve, reject) => {
          this.grpcClient.tryShutdown((error: Error) => {
            if (error) reject(error);
            else resolve();
          });
        });
      } else {
        this.grpcClient.forceShutdown();
      }
    }
    this.grpcClient = null;
  }

  public deserialize(obj: any): any {
    try {
      return JSON.parse(obj);
    } catch (e) {
      return obj;
    }
  }

  public addHandler(
    pattern: unknown,
    callback: MessageHandler,
    isEventHandler = false,
  ) {
    const route = isString(pattern) ? pattern : JSON.stringify(pattern);
    callback.isEventHandler = isEventHandler;
    this.messageHandlers.set(route, callback);
  }

  public async createClient() {
    const channelOptions: ChannelOptions =
      this.options && this.options.channelOptions
        ? this.options.channelOptions
        : {};
    if (this.options && this.options.maxSendMessageLength) {
      channelOptions['grpc.max_send_message_length'] =
        this.options.maxSendMessageLength;
    }
    if (this.options && this.options.maxReceiveMessageLength) {
      channelOptions['grpc.max_receive_message_length'] =
        this.options.maxReceiveMessageLength;
    }
    if (this.options && this.options.maxMetadataSize) {
      channelOptions['grpc.max_metadata_size'] = this.options.maxMetadataSize;
    }
    const server = new grpcPackage.Server(channelOptions);
    const credentials = this.getOptionsProp(this.options, 'credentials');

    await new Promise((resolve, reject) => {
      server.bindAsync(
        this.url,
        credentials || grpcPackage.ServerCredentials.createInsecure(),
        (error: Error | null, port: number) =>
          error ? reject(error) : resolve(port),
      );
    });

    return server;
  }

  public lookupPackage(root: any, packageName: string) {
    /** Reference: https://github.com/kondi/rxjs-grpc */
    let pkg = root;
    for (const name of packageName.split(/\./)) {
      pkg = pkg[name];
    }
    return pkg;
  }

  public loadProto(): any {
    try {
      const packageDefinition = getGrpcPackageDefinition(
        this.options,
        grpcProtoLoaderPackage,
      );

      if (this.options.onLoadPackageDefinition) {
        this.options.onLoadPackageDefinition(
          packageDefinition,
          this.grpcClient,
        );
      }

      return grpcPackage.loadPackageDefinition(packageDefinition);
    } catch (err) {
      const invalidProtoError = new InvalidProtoDefinitionException(err.path);
      const message =
        err && err.message ? err.message : invalidProtoError.message;

      this.logger.error(message, invalidProtoError.stack);
      throw invalidProtoError;
    }
  }

  /**
   * Recursively fetch all of the service methods available on loaded
   * protobuf descriptor object, and collect those as an objects with
   * dot-syntax full-path names.
   *
   * Example:
   *  for proto package Bundle.FirstService with service Events { rpc...
   *  will be resolved to object of (while loaded for Bundle package):
   *    {
   *      name: "FirstService.Events",
   *      service: {Object}
   *    }
   */
  private collectDeepServices(
    name: string,
    grpcDefinition: any,
    accumulator: { name: string; service: any }[],
  ) {
    if (!isObject(grpcDefinition)) {
      return;
    }
    const keysToTraverse = Object.keys(grpcDefinition);
    // Traverse definitions or namespace extensions
    for (const key of keysToTraverse) {
      const nameExtended = this.parseDeepServiceName(name, key);
      const deepDefinition = grpcDefinition[key];

      const isServiceDefined =
        deepDefinition && !isUndefined(deepDefinition.service);
      const isServiceBoolean = isServiceDefined
        ? deepDefinition.service !== false
        : false;

      // grpc namespace object does not have 'format' or 'service' properties defined
      const isFormatDefined =
        deepDefinition && !isUndefined(deepDefinition.format);

      if (isServiceDefined && isServiceBoolean) {
        accumulator.push({
          name: nameExtended,
          service: deepDefinition,
        });
      } else if (isFormatDefined) {
        // Do nothing
      } else {
        // Continue recursion for namespace object until objects end or service definition found
        this.collectDeepServices(nameExtended, deepDefinition, accumulator);
      }
    }
  }

  private parseDeepServiceName(name: string, key: string): string {
    // If depth is zero then just return key
    if (name.length === 0) {
      return key;
    }
    // Otherwise add next through dot syntax
    return name + '.' + key;
  }

  private async createServices(grpcPkg: any, packageName: string) {
    if (!grpcPkg) {
      const invalidPackageError = new InvalidGrpcPackageException(packageName);
      this.logger.error(invalidPackageError);
      throw invalidPackageError;
    }

    // Take all of the services defined in grpcPkg and assign them to
    // method handlers defined in Controllers
    for (const definition of this.getServiceNames(grpcPkg)) {
      this.grpcClient.addService(
        // First parameter requires exact service definition from proto
        definition.service.service,
        // Here full proto definition required along with namespaced pattern name
        await this.createService(definition.service, definition.name),
      );
    }
  }

  private bufferUntilDrained<T>() {
    type DrainableSubject<T> = Subject<T> & { drainBuffer: () => void };

    const subject = new Subject<T>();
    let replayBuffer: ReplaySubject<T> | null = new ReplaySubject<T>();
    let hasDrained = false;

    function drainBuffer(this: DrainableSubject<T>) {
      if (hasDrained || !replayBuffer) {
        return;
      }
      hasDrained = true;

      // Replay buffered values to the new subscriber
      setImmediate(() => {
        const subcription = replayBuffer!.subscribe(subject);
        subcription.unsubscribe();
        replayBuffer = null;
      });
    }

    return {
      subject: new Proxy<DrainableSubject<T>>(subject as DrainableSubject<T>, {
        get(target, prop, receiver) {
          if (prop === 'asObservable') {
            return () => {
              const stream = subject.asObservable();

              // "drainBuffer" will be called before the evaluation of the handler
              // but after any enhancers have been applied (e.g., `interceptors`)
              Object.defineProperty(stream, drainBuffer.name, {
                value: drainBuffer,
              });
              return stream;
            };
          }
          if (hasDrained) {
            return Reflect.get(target, prop, receiver);
          }
          return Reflect.get(replayBuffer!, prop, receiver);
        },
      }),
      next: (value: T) => {
        if (!hasDrained) {
          replayBuffer!.next(value);
        }
        subject.next(value);
      },
      error: (err: any) => {
        if (!hasDrained) {
          replayBuffer!.error(err);
        }
        subject.error(err);
      },
      complete: () => {
        if (!hasDrained) {
          replayBuffer!.complete();
          // Replay buffer is no longer needed
          // Return early to allow subject to complete later, after the replay buffer
          // has been drained
          return;
        }
        subject.complete();
      },
      cleanup: () => {
        if (hasDrained) {
          return;
        }
        replayBuffer = null;
      },
    };
  }
}



================================================
FILE: packages/microservices/server/server-kafka.ts
================================================
import { Logger } from '@nestjs/common/services/logger.service';
import { isNil } from '@nestjs/common/utils/shared.utils';
import { isObservable, lastValueFrom, Observable, ReplaySubject } from 'rxjs';
import {
  KAFKA_DEFAULT_BROKER,
  KAFKA_DEFAULT_CLIENT,
  KAFKA_DEFAULT_GROUP,
  NO_EVENT_HANDLER,
  NO_MESSAGE_HANDLER,
} from '../constants';
import { KafkaContext } from '../ctx-host';
import { KafkaRequestDeserializer } from '../deserializers/kafka-request.deserializer';
import { KafkaHeaders, Transport } from '../enums';
import { KafkaStatus } from '../events';
import { KafkaRetriableException } from '../exceptions';
import {
  BrokersFunction,
  Consumer,
  ConsumerConfig,
  EachMessagePayload,
  Kafka,
  KafkaConfig,
  KafkaMessage,
  Message,
  Producer,
  RecordMetadata,
} from '../external/kafka.interface';
import { KafkaLogger, KafkaParser } from '../helpers';
import { KafkaOptions, OutgoingResponse, ReadPacket } from '../interfaces';
import { KafkaRequestSerializer } from '../serializers/kafka-request.serializer';
import { Server } from './server';

let kafkaPackage: any = {};

/**
 * @publicApi
 */
export class ServerKafka extends Server<never, KafkaStatus> {
  public readonly transportId = Transport.KAFKA;

  protected logger = new Logger(ServerKafka.name);
  protected client: Kafka | null = null;
  protected consumer: Consumer | null = null;
  protected producer: Producer | null = null;
  protected parser: KafkaParser | null = null;
  protected brokers: string[] | BrokersFunction;
  protected clientId: string;
  protected groupId: string;

  constructor(protected readonly options: Required<KafkaOptions>['options']) {
    super();

    const clientOptions = this.getOptionsProp(
      this.options,
      'client',
      {} as KafkaConfig,
    );
    const consumerOptions = this.getOptionsProp(
      this.options,
      'consumer',
      {} as ConsumerConfig,
    );
    const postfixId = this.getOptionsProp(this.options, 'postfixId', '-server');

    this.brokers = clientOptions.brokers || [KAFKA_DEFAULT_BROKER];

    // Append a unique id to the clientId and groupId
    // so they don't collide with a microservices client
    this.clientId =
      (clientOptions.clientId || KAFKA_DEFAULT_CLIENT) + postfixId;
    this.groupId = (consumerOptions.groupId || KAFKA_DEFAULT_GROUP) + postfixId;

    kafkaPackage = this.loadPackage('kafkajs', ServerKafka.name, () =>
      require('kafkajs'),
    );

    this.parser = new KafkaParser((options && options.parser) || undefined);

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public async listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ): Promise<void> {
    try {
      this.client = this.createClient();
      await this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public async close(): Promise<void> {
    this.consumer && (await this.consumer.disconnect());
    this.producer && (await this.producer.disconnect());
    this.consumer = null;
    this.producer = null;
    this.client = null;
  }

  public async start(callback: () => void): Promise<void> {
    const consumerOptions = Object.assign(this.options.consumer || {}, {
      groupId: this.groupId,
    });
    this.consumer = this.client!.consumer(consumerOptions);
    this.producer = this.client!.producer(this.options.producer);
    this.registerConsumerEventListeners();
    this.registerProducerEventListeners();

    await this.consumer.connect();
    await this.producer.connect();
    await this.bindEvents(this.consumer);
    callback();
  }

  protected registerConsumerEventListeners() {
    if (!this.consumer) {
      return;
    }
    this.consumer.on(this.consumer.events.CONNECT, () =>
      this._status$.next(KafkaStatus.CONNECTED),
    );
    this.consumer.on(this.consumer.events.DISCONNECT, () =>
      this._status$.next(KafkaStatus.DISCONNECTED),
    );
    this.consumer.on(this.consumer.events.REBALANCING, () =>
      this._status$.next(KafkaStatus.REBALANCING),
    );
    this.consumer.on(this.consumer.events.STOP, () =>
      this._status$.next(KafkaStatus.STOPPED),
    );
    this.consumer.on(this.consumer.events.CRASH, () =>
      this._status$.next(KafkaStatus.CRASHED),
    );
  }

  protected registerProducerEventListeners() {
    if (!this.producer) {
      return;
    }
    this.producer.on(this.producer.events.CONNECT, () =>
      this._status$.next(KafkaStatus.CONNECTED),
    );
    this.producer.on(this.producer.events.DISCONNECT, () =>
      this._status$.next(KafkaStatus.DISCONNECTED),
    );
  }

  public createClient<T = any>(): T {
    return new kafkaPackage.Kafka(
      Object.assign(
        { logCreator: KafkaLogger.bind(null, this.logger) },
        this.options.client,
        { clientId: this.clientId, brokers: this.brokers },
      ) as KafkaConfig,
    );
  }

  public async bindEvents(consumer: Consumer) {
    const registeredPatterns = [...this.messageHandlers.keys()];
    const consumerSubscribeOptions = this.options.subscribe || {};

    if (registeredPatterns.length > 0) {
      await this.consumer!.subscribe({
        ...consumerSubscribeOptions,
        topics: registeredPatterns,
      });
    }

    const consumerRunOptions = Object.assign(this.options.run || {}, {
      eachMessage: this.getMessageHandler(),
    });
    await consumer.run(consumerRunOptions);
  }

  public getMessageHandler() {
    return async (payload: EachMessagePayload) => this.handleMessage(payload);
  }

  public getPublisher(
    replyTopic: string,
    replyPartition: string,
    correlationId: string,
  ): (data: any) => Promise<RecordMetadata[]> {
    return (data: any) =>
      this.sendMessage(data, replyTopic, replyPartition, correlationId);
  }

  public async handleMessage(payload: EachMessagePayload) {
    const channel = payload.topic;
    const rawMessage = this.parser!.parse<KafkaMessage>(
      Object.assign(payload.message, {
        topic: payload.topic,
        partition: payload.partition,
      }),
    );
    const headers = rawMessage.headers as unknown as Record<string, any>;
    const correlationId = headers[KafkaHeaders.CORRELATION_ID];
    const replyTopic = headers[KafkaHeaders.REPLY_TOPIC];
    const replyPartition = headers[KafkaHeaders.REPLY_PARTITION];

    const packet = await this.deserializer.deserialize(rawMessage, { channel });
    const kafkaContext = new KafkaContext([
      rawMessage,
      payload.partition,
      payload.topic,
      this.consumer!,
      payload.heartbeat,
      this.producer!,
    ]);
    const handler = this.getHandlerByPattern(packet.pattern);
    // if the correlation id or reply topic is not set
    // then this is an event (events could still have correlation id)
    if (handler?.isEventHandler || !correlationId || !replyTopic) {
      return this.handleEvent(packet.pattern, packet, kafkaContext);
    }

    const publish = this.getPublisher(
      replyTopic,
      replyPartition,
      correlationId,
    );

    if (!handler) {
      return publish({
        id: correlationId,
        err: NO_MESSAGE_HANDLER,
      });
    }

    const response$ = this.transformToObservable(
      handler(packet.data, kafkaContext),
    );

    const replayStream$ = new ReplaySubject();
    await this.combineStreamsAndThrowIfRetriable(response$, replayStream$);

    this.send(replayStream$, publish);
  }

  public unwrap<T>(): T {
    if (!this.client) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return [this.client, this.consumer, this.producer] as T;
  }

  public on<
    EventKey extends string | number | symbol = string | number | symbol,
    EventCallback = any,
  >(event: EventKey, callback: EventCallback) {
    throw new Error('Method is not supported for Kafka server');
  }

  private combineStreamsAndThrowIfRetriable(
    response$: Observable<any>,
    replayStream$: ReplaySubject<unknown>,
  ) {
    return new Promise<void>((resolve, reject) => {
      let isPromiseResolved = false;
      response$.subscribe({
        next: val => {
          replayStream$.next(val);
          if (!isPromiseResolved) {
            isPromiseResolved = true;
            resolve();
          }
        },
        error: err => {
          if (err instanceof KafkaRetriableException && !isPromiseResolved) {
            isPromiseResolved = true;
            reject(err);
          } else {
            resolve();
          }
          replayStream$.error(err);
        },
        complete: () => replayStream$.complete(),
      });
    });
  }

  public async sendMessage(
    message: OutgoingResponse,
    replyTopic: string,
    replyPartition: string | undefined | null,
    correlationId: string,
  ): Promise<RecordMetadata[]> {
    const outgoingMessage = await this.serializer.serialize(message.response);
    this.assignReplyPartition(replyPartition, outgoingMessage);
    this.assignCorrelationIdHeader(correlationId, outgoingMessage);
    this.assignErrorHeader(message, outgoingMessage);
    this.assignIsDisposedHeader(message, outgoingMessage);

    const replyMessage = Object.assign(
      {
        topic: replyTopic,
        messages: [outgoingMessage],
      },
      this.options.send || {},
    );
    return this.producer!.send(replyMessage);
  }

  public assignIsDisposedHeader(
    outgoingResponse: OutgoingResponse,
    outgoingMessage: Message,
  ) {
    if (!outgoingResponse.isDisposed) {
      return;
    }
    outgoingMessage.headers![KafkaHeaders.NEST_IS_DISPOSED] = Buffer.alloc(1);
  }

  public assignErrorHeader(
    outgoingResponse: OutgoingResponse,
    outgoingMessage: Message,
  ) {
    if (!outgoingResponse.err) {
      return;
    }
    const stringifiedError =
      typeof outgoingResponse.err === 'object'
        ? JSON.stringify(outgoingResponse.err)
        : outgoingResponse.err;
    outgoingMessage.headers![KafkaHeaders.NEST_ERR] =
      Buffer.from(stringifiedError);
  }

  public assignCorrelationIdHeader(
    correlationId: string,
    outgoingMessage: Message,
  ) {
    outgoingMessage.headers![KafkaHeaders.CORRELATION_ID] =
      Buffer.from(correlationId);
  }

  public assignReplyPartition(
    replyPartition: string | null | undefined,
    outgoingMessage: Message,
  ) {
    if (isNil(replyPartition)) {
      return;
    }
    outgoingMessage.partition = parseFloat(replyPartition);
  }

  public async handleEvent(
    pattern: string,
    packet: ReadPacket,
    context: KafkaContext,
  ): Promise<any> {
    const handler = this.getHandlerByPattern(pattern);
    if (!handler) {
      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
    }
    const resultOrStream = await handler(packet.data, context);
    if (isObservable(resultOrStream)) {
      await lastValueFrom(resultOrStream);
    }
  }

  protected initializeSerializer(options: KafkaOptions['options']) {
    this.serializer =
      (options && options.serializer) || new KafkaRequestSerializer();
  }

  protected initializeDeserializer(options: KafkaOptions['options']) {
    this.deserializer = options?.deserializer ?? new KafkaRequestDeserializer();
  }
}



================================================
FILE: packages/microservices/server/server-mqtt.ts
================================================
import { isObject, isUndefined } from '@nestjs/common/utils/shared.utils';
import {
  MQTT_DEFAULT_URL,
  MQTT_SEPARATOR,
  MQTT_WILDCARD_ALL,
  MQTT_WILDCARD_SINGLE,
  NO_MESSAGE_HANDLER,
} from '../constants';
import { MqttContext } from '../ctx-host/mqtt.context';
import { Transport } from '../enums';
import { MqttEvents, MqttEventsMap, MqttStatus } from '../events/mqtt.events';
import {
  IncomingRequest,
  MessageHandler,
  PacketId,
  ReadPacket,
} from '../interfaces';
import { MqttOptions } from '../interfaces/microservice-configuration.interface';
import { MqttRecord } from '../record-builders/mqtt.record-builder';
import { MqttRecordSerializer } from '../serializers/mqtt-record.serializer';
import { Server } from './server';

let mqttPackage: any = {};

// To enable type safety for MQTT. This cant be uncommented by default
// because it would require the user to install the mqtt package even if they dont use MQTT
// Otherwise, TypeScript would fail to compile the code.
//
// type MqttClient = import('mqtt').MqttClient;
type MqttClient = any;

/**
 * @publicApi
 */
export class ServerMqtt extends Server<MqttEvents, MqttStatus> {
  public readonly transportId = Transport.MQTT;
  protected readonly url: string;
  protected mqttClient: MqttClient;
  protected pendingEventListeners: Array<{
    event: keyof MqttEvents;
    callback: MqttEvents[keyof MqttEvents];
  }> = [];

  constructor(private readonly options: Required<MqttOptions>['options']) {
    super();
    this.url = this.getOptionsProp(options, 'url', MQTT_DEFAULT_URL);

    mqttPackage = this.loadPackage('mqtt', ServerMqtt.name, () =>
      require('mqtt'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public async listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    try {
      this.mqttClient = this.createMqttClient();
      this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public start(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    this.registerErrorListener(this.mqttClient);
    this.registerReconnectListener(this.mqttClient);
    this.registerDisconnectListener(this.mqttClient);
    this.registerCloseListener(this.mqttClient);
    this.registerConnectListener(this.mqttClient);

    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.mqttClient.on(event, callback),
    );
    this.pendingEventListeners = [];
    this.bindEvents(this.mqttClient);

    this.mqttClient.on(MqttEventsMap.CONNECT, () => callback());
  }

  public bindEvents(mqttClient: MqttClient) {
    mqttClient.on('message', this.getMessageHandler(mqttClient).bind(this));

    const registeredPatterns = [...this.messageHandlers.keys()];
    registeredPatterns.forEach(pattern => {
      const { isEventHandler } = this.messageHandlers.get(pattern)!;
      mqttClient.subscribe(
        isEventHandler ? pattern : this.getRequestPattern(pattern),
        this.getOptionsProp(this.options, 'subscribeOptions'),
      );
    });
  }

  public close() {
    this.mqttClient && this.mqttClient.end();
    this.pendingEventListeners = [];
  }

  public createMqttClient(): MqttClient {
    return mqttPackage.connect(this.url, this.options as MqttOptions);
  }

  public getMessageHandler(pub: MqttClient) {
    return async (
      channel: string,
      buffer: Buffer,
      originalPacket?: Record<string, any>,
    ) => this.handleMessage(channel, buffer, pub, originalPacket);
  }

  public async handleMessage(
    channel: string,
    buffer: Buffer,
    pub: MqttClient,
    originalPacket?: Record<string, any>,
  ): Promise<any> {
    const rawPacket = this.parseMessage(buffer.toString());
    const packet = await this.deserializer.deserialize(rawPacket, { channel });
    const mqttContext = new MqttContext([channel, originalPacket!]);
    if (isUndefined((packet as IncomingRequest).id)) {
      return this.handleEvent(channel, packet, mqttContext);
    }
    const publish = this.getPublisher(
      pub,
      channel,
      (packet as IncomingRequest).id,
    );
    const handler = this.getHandlerByPattern(channel);

    if (!handler) {
      const status = 'error';
      const noHandlerPacket = {
        id: (packet as IncomingRequest).id,
        status,
        err: NO_MESSAGE_HANDLER,
      };
      return publish(noHandlerPacket);
    }
    const response$ = this.transformToObservable(
      await handler(packet.data, mqttContext),
    );
    response$ && this.send(response$, publish);
  }

  public getPublisher(client: MqttClient, pattern: any, id: string): any {
    return (response: any) => {
      Object.assign(response, { id });

      const options =
        isObject(response?.data) && response.data instanceof MqttRecord
          ? (response.data as MqttRecord)?.options
          : {};
      delete response?.data?.options;

      const outgoingResponse: string | Buffer =
        this.serializer.serialize(response);
      return client.publish(
        this.getReplyPattern(pattern),
        outgoingResponse,
        options,
      );
    };
  }

  public parseMessage(content: any): ReadPacket & PacketId {
    try {
      return JSON.parse(content);
    } catch (e) {
      return content;
    }
  }

  public matchMqttPattern(pattern: string, topic: string) {
    const patternSegments = pattern.split(MQTT_SEPARATOR);
    const topicSegments = topic.split(MQTT_SEPARATOR);

    const patternSegmentsLength = patternSegments.length;
    const topicSegmentsLength = topicSegments.length;
    const lastIndex = patternSegmentsLength - 1;

    for (let i = 0; i < patternSegmentsLength; i++) {
      const currentPattern = patternSegments[i];
      const patternChar = currentPattern[0];
      const currentTopic = topicSegments[i];

      if (!currentTopic && !currentPattern) {
        continue;
      }
      if (!currentTopic && currentPattern !== MQTT_WILDCARD_ALL) {
        return false;
      }
      if (patternChar === MQTT_WILDCARD_ALL) {
        return i === lastIndex;
      }
      if (
        patternChar !== MQTT_WILDCARD_SINGLE &&
        currentPattern !== currentTopic
      ) {
        return false;
      }
    }
    return patternSegmentsLength === topicSegmentsLength;
  }

  public getHandlerByPattern(pattern: string): MessageHandler | null {
    const route = this.getRouteFromPattern(pattern);
    if (this.messageHandlers.has(route)) {
      return this.messageHandlers.get(route) || null;
    }

    for (const [key, value] of this.messageHandlers) {
      const keyWithoutSharedPrefix = this.removeHandlerKeySharedPrefix(key);
      if (this.matchMqttPattern(keyWithoutSharedPrefix, route)) {
        return value;
      }
    }
    return null;
  }

  public removeHandlerKeySharedPrefix(handlerKey: string) {
    return handlerKey && handlerKey.startsWith('$share')
      ? handlerKey.split('/').slice(2).join('/')
      : handlerKey;
  }

  public getRequestPattern(pattern: string): string {
    return pattern;
  }

  public getReplyPattern(pattern: string): string {
    return `${pattern}/reply`;
  }

  public registerErrorListener(client: MqttClient) {
    client.on(MqttEventsMap.ERROR, (err: unknown) => this.logger.error(err));
  }

  public registerReconnectListener(client: MqttClient) {
    client.on(MqttEventsMap.RECONNECT, () => {
      this._status$.next(MqttStatus.RECONNECTING);

      this.logger.log('MQTT connection lost. Trying to reconnect...');
    });
  }

  public registerDisconnectListener(client: MqttClient) {
    client.on(MqttEventsMap.DISCONNECT, () => {
      this._status$.next(MqttStatus.DISCONNECTED);
    });
  }

  public registerCloseListener(client: MqttClient) {
    client.on(MqttEventsMap.CLOSE, () => {
      this._status$.next(MqttStatus.CLOSED);
    });
  }

  public registerConnectListener(client: MqttClient) {
    client.on(MqttEventsMap.CONNECT, () => {
      this._status$.next(MqttStatus.CONNECTED);
    });
  }

  public unwrap<T>(): T {
    if (!this.mqttClient) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return this.mqttClient as T;
  }

  public on<
    EventKey extends keyof MqttEvents = keyof MqttEvents,
    EventCallback extends MqttEvents[EventKey] = MqttEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.mqttClient) {
      this.mqttClient.on(event, callback as any);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  protected initializeSerializer(options: MqttOptions['options']) {
    this.serializer = options?.serializer ?? new MqttRecordSerializer();
  }
}



================================================
FILE: packages/microservices/server/server-nats.ts
================================================
import { isObject, isUndefined } from '@nestjs/common/utils/shared.utils';
import { EventEmitter } from 'events';
import {
  NATS_DEFAULT_GRACE_PERIOD,
  NATS_DEFAULT_URL,
  NO_MESSAGE_HANDLER,
} from '../constants';
import { NatsContext } from '../ctx-host/nats.context';
import { NatsRequestJSONDeserializer } from '../deserializers/nats-request-json.deserializer';
import { Transport } from '../enums';
import { NatsEvents, NatsEventsMap, NatsStatus } from '../events/nats.events';
import { NatsOptions } from '../interfaces/microservice-configuration.interface';
import { IncomingRequest } from '../interfaces/packet.interface';
import { NatsRecord } from '../record-builders';
import { NatsRecordSerializer } from '../serializers/nats-record.serializer';
import { Server } from './server';

let natsPackage = {} as any;

// To enable type safety for Nats. This cant be uncommented by default
// because it would require the user to install the nats package even if they dont use Nats
// Otherwise, TypeScript would fail to compile the code.
//
// type Client = import('nats').NatsConnection;
// type NatsMsg = import('nats').Msg;
// type Subscription = import('nats').Subscription;

type Client = any;
type NatsMsg = any;
type Subscription = any;

/**
 * @publicApi
 */
export class ServerNats<
  E extends NatsEvents = NatsEvents,
  S extends NatsStatus = NatsStatus,
> extends Server<E, S> {
  public readonly transportId = Transport.NATS;

  private natsClient: Client;
  protected statusEventEmitter = new EventEmitter<{
    [key in keyof NatsEvents]: Parameters<NatsEvents[key]>;
  }>();
  private readonly subscriptions: Subscription[] = [];

  constructor(private readonly options: Required<NatsOptions>['options']) {
    super();

    natsPackage = this.loadPackage('nats', ServerNats.name, () =>
      require('nats'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public async listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    try {
      this.natsClient = await this.createNatsClient();

      this._status$.next(NatsStatus.CONNECTED as S);
      void this.handleStatusUpdates(this.natsClient);
      this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public start(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    this.bindEvents(this.natsClient);
    callback();
  }

  public bindEvents(client: Client) {
    const subscribe = (channel: string, queue: string) =>
      client.subscribe(channel, {
        queue,
        callback: this.getMessageHandler(channel).bind(this),
      });

    const defaultQueue = this.getOptionsProp(this.options, 'queue');
    const registeredPatterns = [...this.messageHandlers.keys()];
    for (const channel of registeredPatterns) {
      const handlerRef = this.messageHandlers.get(channel)!;
      const queue = handlerRef.extras?.queue ?? defaultQueue;
      const sub = subscribe(channel, queue);
      this.subscriptions.push(sub);
    }
  }

  private async waitForGracePeriod() {
    const gracePeriod = this.getOptionsProp(
      this.options,
      'gracePeriod',
      NATS_DEFAULT_GRACE_PERIOD,
    );
    await new Promise<void>(res => {
      setTimeout(() => {
        res();
      }, gracePeriod);
    });
  }

  public async close() {
    if (!this.natsClient) {
      return;
    }
    const graceful = this.getOptionsProp(this.options, 'gracefulShutdown');
    if (graceful) {
      this.subscriptions.forEach(sub => sub.unsubscribe());
      await this.waitForGracePeriod();
    }
    await this.natsClient?.close();
    this.statusEventEmitter.removeAllListeners();
    this.natsClient = null;
  }

  public createNatsClient(): Promise<Client> {
    const options = this.options || ({} as NatsOptions);
    return natsPackage.connect({
      servers: NATS_DEFAULT_URL,
      ...options,
    });
  }

  public getMessageHandler(channel: string): Function {
    return async (error: object | undefined, message: NatsMsg) => {
      if (error) {
        return this.logger.error(error);
      }
      return this.handleMessage(channel, message);
    };
  }

  public async handleMessage(channel: string, natsMsg: NatsMsg) {
    const callerSubject = natsMsg.subject;
    const rawMessage = natsMsg.data;
    const replyTo = natsMsg.reply;

    const natsCtx = new NatsContext([callerSubject, natsMsg.headers]);
    const message = await this.deserializer.deserialize(rawMessage, {
      channel,
      replyTo,
    });
    if (isUndefined((message as IncomingRequest).id)) {
      return this.handleEvent(channel, message, natsCtx);
    }
    const publish = this.getPublisher(natsMsg, (message as IncomingRequest).id);
    const handler = this.getHandlerByPattern(channel);
    if (!handler) {
      const status = 'error';
      const noHandlerPacket = {
        id: (message as IncomingRequest).id,
        status,
        err: NO_MESSAGE_HANDLER,
      };
      return publish(noHandlerPacket);
    }
    const response$ = this.transformToObservable(
      await handler(message.data, natsCtx),
    );
    response$ && this.send(response$, publish);
  }

  public getPublisher(natsMsg: NatsMsg, id: string) {
    if (natsMsg.reply) {
      return (response: any) => {
        Object.assign(response, { id });
        const outgoingResponse: NatsRecord =
          this.serializer.serialize(response);
        return natsMsg.respond(outgoingResponse.data, {
          headers: outgoingResponse.headers,
        });
      };
    }

    // In case the "reply" topic is not provided, there's no need for a reply.
    // Method returns a noop function instead

    return () => {};
  }

  public async handleStatusUpdates(client: Client) {
    for await (const status of client.status()) {
      const data =
        status.data && isObject(status.data)
          ? JSON.stringify(status.data)
          : status.data;

      switch (status.type) {
        case 'error':
          this.logger.error(
            `NatsError: type: "${status.type}", data: "${data}".`,
          );
          break;

        case 'disconnect':
          this.logger.error(
            `NatsError: type: "${status.type}", data: "${data}".`,
          );

          this._status$.next(NatsStatus.DISCONNECTED as S);
          this.statusEventEmitter.emit(
            NatsEventsMap.DISCONNECT,
            status.data as string,
          );
          break;

        case 'pingTimer':
          if (this.options.debug) {
            this.logger.debug!(
              `NatsStatus: type: "${status.type}", data: "${data}".`,
            );
          }
          break;

        case 'reconnecting':
          this._status$.next(NatsStatus.RECONNECTING as S);
          break;

        case 'reconnect':
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );

          this._status$.next(NatsStatus.CONNECTED as S);
          this.statusEventEmitter.emit(
            NatsEventsMap.RECONNECT,
            status.data as string,
          );
          break;

        case 'update':
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );
          this.statusEventEmitter.emit(NatsEventsMap.UPDATE, status.data);
          break;

        default:
          this.logger.log(
            `NatsStatus: type: "${status.type}", data: "${data}".`,
          );
          break;
      }
    }
  }

  public unwrap<T>(): T {
    if (!this.natsClient) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return this.natsClient as T;
  }

  public on<
    EventKey extends keyof E = keyof E,
    EventCallback extends E[EventKey] = E[EventKey],
  >(event: EventKey, callback: EventCallback) {
    this.statusEventEmitter.on(event, callback as any);
  }

  protected initializeSerializer(options: NatsOptions['options']) {
    this.serializer = options?.serializer ?? new NatsRecordSerializer();
  }

  protected initializeDeserializer(options: NatsOptions['options']) {
    this.deserializer =
      options?.deserializer ?? new NatsRequestJSONDeserializer();
  }
}



================================================
FILE: packages/microservices/server/server-redis.ts
================================================
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import {
  NO_MESSAGE_HANDLER,
  REDIS_DEFAULT_HOST,
  REDIS_DEFAULT_PORT,
} from '../constants';
import { RedisContext } from '../ctx-host';
import { Transport } from '../enums';
import {
  RedisEvents,
  RedisEventsMap,
  RedisStatus,
} from '../events/redis.events';
import { IncomingRequest, RedisOptions } from '../interfaces';
import { Server } from './server';

// To enable type safety for Redis. This cant be uncommented by default
// because it would require the user to install the ioredis package even if they dont use Redis
// Otherwise, TypeScript would fail to compile the code.
//
// type Redis = import('ioredis').Redis;
type Redis = any;

let redisPackage = {} as any;

/**
 * @publicApi
 */
export class ServerRedis extends Server<RedisEvents, RedisStatus> {
  public readonly transportId = Transport.REDIS;

  protected subClient: Redis;
  protected pubClient: Redis;
  protected isManuallyClosed = false;
  protected wasInitialConnectionSuccessful = false;
  protected pendingEventListeners: Array<{
    event: keyof RedisEvents;
    callback: RedisEvents[keyof RedisEvents];
  }> = [];

  constructor(protected readonly options: Required<RedisOptions>['options']) {
    super();

    redisPackage = this.loadPackage('ioredis', ServerRedis.name, () =>
      require('ioredis'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    try {
      this.subClient = this.createRedisClient();
      this.pubClient = this.createRedisClient();

      [this.subClient, this.pubClient].forEach((client, index) => {
        const type = index === 0 ? 'pub' : 'sub';
        this.registerErrorListener(client);
        this.registerReconnectListener(client);
        this.registerReadyListener(client);
        this.registerEndListener(client);
        this.pendingEventListeners.forEach(({ event, callback }) =>
          client.on(event, (...args: [any]) => callback(type, ...args)),
        );
      });
      this.pendingEventListeners = [];

      this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public start(callback?: () => void) {
    void Promise.all([this.subClient.connect(), this.pubClient.connect()])
      .then(() => {
        this.bindEvents(this.subClient, this.pubClient);
        callback?.();
      })
      .catch(callback);
  }

  public bindEvents(subClient: Redis, pubClient: Redis) {
    subClient.on(
      this.options?.wildcards ? 'pmessage' : 'message',
      this.getMessageHandler(pubClient).bind(this),
    );
    const subscribePatterns = [...this.messageHandlers.keys()];
    subscribePatterns.forEach(pattern => {
      const { isEventHandler } = this.messageHandlers.get(pattern)!;

      const channel = isEventHandler
        ? pattern
        : this.getRequestPattern(pattern);

      if (this.options?.wildcards) {
        subClient.psubscribe(channel);
      } else {
        subClient.subscribe(channel);
      }
    });
  }

  public close() {
    this.isManuallyClosed = true;
    this.pubClient && this.pubClient.quit();
    this.subClient && this.subClient.quit();
    this.pendingEventListeners = [];
  }

  public createRedisClient(): Redis {
    return new redisPackage({
      port: REDIS_DEFAULT_PORT,
      host: REDIS_DEFAULT_HOST,
      ...this.getClientOptions(),
      lazyConnect: true,
    });
  }

  public getMessageHandler(pub: Redis) {
    return this.options?.wildcards
      ? (channel: string, pattern: string, buffer: string) =>
          this.handleMessage(channel, buffer, pub, pattern)
      : (channel: string, buffer: string) =>
          this.handleMessage(channel, buffer, pub, channel);
  }

  public async handleMessage(
    channel: string,
    buffer: string,
    pub: Redis,
    pattern: string,
  ) {
    const rawMessage = this.parseMessage(buffer);
    const packet = await this.deserializer.deserialize(rawMessage, { channel });
    const redisCtx = new RedisContext([pattern]);

    if (isUndefined((packet as IncomingRequest).id)) {
      return this.handleEvent(channel, packet, redisCtx);
    }
    const publish = this.getPublisher(
      pub,
      channel,
      (packet as IncomingRequest).id,
    );
    const handler = this.getHandlerByPattern(channel);

    if (!handler) {
      const status = 'error';
      const noHandlerPacket = {
        id: (packet as IncomingRequest).id,
        status,
        err: NO_MESSAGE_HANDLER,
      };
      return publish(noHandlerPacket);
    }
    const response$ = this.transformToObservable(
      await handler(packet.data, redisCtx),
    );
    response$ && this.send(response$, publish);
  }

  public getPublisher(pub: Redis, pattern: any, id: string) {
    return (response: any) => {
      Object.assign(response, { id });
      const outgoingResponse = this.serializer.serialize(response);

      return pub.publish(
        this.getReplyPattern(pattern),
        JSON.stringify(outgoingResponse),
      );
    };
  }

  public parseMessage(content: any): Record<string, any> {
    try {
      return JSON.parse(content);
    } catch (e) {
      return content;
    }
  }

  public getRequestPattern(pattern: string): string {
    return pattern;
  }

  public getReplyPattern(pattern: string): string {
    return `${pattern}.reply`;
  }

  public registerErrorListener(client: any) {
    client.on(RedisEventsMap.ERROR, (err: any) => this.logger.error(err));
  }

  public registerReconnectListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on(RedisEventsMap.RECONNECTING, () => {
      if (this.isManuallyClosed) {
        return;
      }
      this._status$.next(RedisStatus.RECONNECTING);

      if (this.wasInitialConnectionSuccessful) {
        this.logger.log('Reconnecting to Redis...');
      }
    });
  }

  public registerReadyListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on(RedisEventsMap.READY, () => {
      this._status$.next(RedisStatus.CONNECTED);

      this.logger.log('Connected to Redis. Subscribing to channels...');

      if (!this.wasInitialConnectionSuccessful) {
        this.wasInitialConnectionSuccessful = true;
      }
    });
  }

  public registerEndListener(client: {
    on: (event: string, fn: () => void) => void;
  }) {
    client.on('end', () => {
      if (this.isManuallyClosed) {
        return;
      }
      this._status$.next(RedisStatus.DISCONNECTED);

      this.logger.error(
        'Disconnected from Redis. No further reconnection attempts will be made.',
      );
    });
  }

  public getClientOptions(): Partial<RedisOptions['options']> {
    const retryStrategy = (times: number) => this.createRetryStrategy(times);

    return {
      ...(this.options || {}),
      retryStrategy,
    };
  }

  public createRetryStrategy(times: number): undefined | number | void {
    if (this.isManuallyClosed) {
      return undefined;
    }
    if (!this.getOptionsProp(this.options, 'retryAttempts')) {
      this.logger.error(
        'Redis connection closed and retry attempts not specified',
      );
      return;
    }
    if (times > this.getOptionsProp(this.options, 'retryAttempts', 0)) {
      this.logger.error(`Retry time exhausted`);
      return;
    }
    return this.getOptionsProp(this.options, 'retryDelay', 5000);
  }

  public unwrap<T>(): T {
    if (!this.pubClient || !this.subClient) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return [this.pubClient, this.subClient] as T;
  }

  public on<
    EventKey extends keyof RedisEvents = keyof RedisEvents,
    EventCallback extends RedisEvents[EventKey] = RedisEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.subClient && this.pubClient) {
      this.subClient.on(event, (...args: [any]) => callback('sub', ...args));
      this.pubClient.on(event, (...args: [any]) => callback('pub', ...args));
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }
}



================================================
FILE: packages/microservices/server/server-rmq.ts
================================================
import {
  isNil,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import {
  CONNECTION_FAILED_MESSAGE,
  DISCONNECTED_RMQ_MESSAGE,
  NO_MESSAGE_HANDLER,
  RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT,
  RQM_DEFAULT_NOACK,
  RQM_DEFAULT_NO_ASSERT,
  RQM_DEFAULT_PREFETCH_COUNT,
  RQM_DEFAULT_QUEUE,
  RQM_DEFAULT_QUEUE_OPTIONS,
  RQM_DEFAULT_URL,
  RQM_NO_EVENT_HANDLER,
  RQM_NO_MESSAGE_HANDLER,
} from '../constants';
import { RmqContext } from '../ctx-host';
import { Transport } from '../enums';
import { RmqEvents, RmqEventsMap, RmqStatus } from '../events/rmq.events';
import { RmqUrl } from '../external/rmq-url.interface';
import { RmqOptions } from '../interfaces';
import {
  IncomingRequest,
  OutgoingResponse,
  ReadPacket,
} from '../interfaces/packet.interface';
import { RmqRecordSerializer } from '../serializers/rmq-record.serializer';
import { Server } from './server';

// To enable type safety for RMQ. This cant be uncommented by default
// because it would require the user to install the amqplib package even if they dont use RabbitMQ
// Otherwise, TypeScript would fail to compile the code.
//
// type AmqpConnectionManager =
//   import('amqp-connection-manager').AmqpConnectionManager;
// type ChannelWrapper = import('amqp-connection-manager').ChannelWrapper;
// type Message = import('amqplib').Message;

type AmqpConnectionManager = any;
type ChannelWrapper = any;
type Message = any;

let rmqPackage = {} as any; // as typeof import('amqp-connection-manager');

const INFINITE_CONNECTION_ATTEMPTS = -1;

/**
 * @publicApi
 */
export class ServerRMQ extends Server<RmqEvents, RmqStatus> {
  public readonly transportId = Transport.RMQ;

  protected server: AmqpConnectionManager = null;
  protected channel: ChannelWrapper = null;
  protected connectionAttempts = 0;
  protected readonly urls: string[] | RmqUrl[];
  protected readonly queue: string;
  protected readonly noAck: boolean;
  protected readonly queueOptions: any;
  protected pendingEventListeners: Array<{
    event: keyof RmqEvents;
    callback: RmqEvents[keyof RmqEvents];
  }> = [];

  constructor(protected readonly options: Required<RmqOptions>['options']) {
    super();
    this.urls = this.getOptionsProp(this.options, 'urls') || [RQM_DEFAULT_URL];
    this.queue =
      this.getOptionsProp(this.options, 'queue') || RQM_DEFAULT_QUEUE;
    this.noAck = this.getOptionsProp(this.options, 'noAck', RQM_DEFAULT_NOACK);
    this.queueOptions =
      this.getOptionsProp(this.options, 'queueOptions') ||
      RQM_DEFAULT_QUEUE_OPTIONS;

    this.loadPackage('amqplib', ServerRMQ.name, () => require('amqplib'));
    rmqPackage = this.loadPackage(
      'amqp-connection-manager',
      ServerRMQ.name,
      () => require('amqp-connection-manager'),
    );

    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public async listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ): Promise<void> {
    try {
      await this.start(callback);
    } catch (err) {
      callback(err);
    }
  }

  public close(): void {
    this.channel && this.channel.close();
    this.server && this.server.close();
    this.pendingEventListeners = [];
  }

  public async start(
    callback?: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    this.server = this.createClient();
    this.server.once(RmqEventsMap.CONNECT, () => {
      if (this.channel) {
        return;
      }
      this._status$.next(RmqStatus.CONNECTED);
      this.channel = this.server.createChannel({
        json: false,
        setup: (channel: any) => this.setupChannel(channel, callback!),
      });
    });

    const maxConnectionAttempts = this.getOptionsProp(
      this.options,
      'maxConnectionAttempts',
      INFINITE_CONNECTION_ATTEMPTS,
    );

    this.registerConnectListener();
    this.registerDisconnectListener();
    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.server.on(event, callback),
    );
    this.pendingEventListeners = [];

    const connectFailedEvent = 'connectFailed';
    this.server.once(connectFailedEvent, (error: Record<string, unknown>) => {
      this._status$.next(RmqStatus.DISCONNECTED);

      this.logger.error(CONNECTION_FAILED_MESSAGE);
      if (error?.err) {
        this.logger.error(error.err);
      }
      const isReconnecting = !!this.channel;
      if (
        maxConnectionAttempts === INFINITE_CONNECTION_ATTEMPTS ||
        isReconnecting
      ) {
        return;
      }
      if (++this.connectionAttempts === maxConnectionAttempts) {
        this.close();
        callback?.(error.err ?? new Error(CONNECTION_FAILED_MESSAGE));
      }
    });
  }

  public createClient<T = any>(): T {
    const socketOptions = this.getOptionsProp(this.options, 'socketOptions');
    return rmqPackage.connect(this.urls, {
      connectionOptions: socketOptions?.connectionOptions,
      heartbeatIntervalInSeconds: socketOptions?.heartbeatIntervalInSeconds,
      reconnectTimeInSeconds: socketOptions?.reconnectTimeInSeconds,
    });
  }

  private registerConnectListener() {
    this.server.on(RmqEventsMap.CONNECT, (err: any) => {
      this._status$.next(RmqStatus.CONNECTED);
    });
  }

  private registerDisconnectListener() {
    this.server.on(RmqEventsMap.DISCONNECT, (err: any) => {
      this._status$.next(RmqStatus.DISCONNECTED);
      this.logger.error(DISCONNECTED_RMQ_MESSAGE);
      this.logger.error(err);
    });
  }

  public async setupChannel(channel: any, callback: Function) {
    const noAssert =
      this.getOptionsProp(this.options, 'noAssert') ??
      this.queueOptions.noAssert ??
      RQM_DEFAULT_NO_ASSERT;

    if (!noAssert) {
      await channel.assertQueue(this.queue, this.queueOptions);
    }

    const isGlobalPrefetchCount = this.getOptionsProp(
      this.options,
      'isGlobalPrefetchCount',
      RQM_DEFAULT_IS_GLOBAL_PREFETCH_COUNT,
    );
    const prefetchCount = this.getOptionsProp(
      this.options,
      'prefetchCount',
      RQM_DEFAULT_PREFETCH_COUNT,
    );

    if (this.options.exchange && this.options.routingKey) {
      await channel.assertExchange(this.options.exchange, 'topic', {
        durable: true,
      });
      await channel.bindQueue(
        this.queue,
        this.options.exchange,
        this.options.routingKey,
      );
    }

    await channel.prefetch(prefetchCount, isGlobalPrefetchCount);
    channel.consume(
      this.queue,
      (msg: Record<string, any>) => this.handleMessage(msg, channel),
      {
        noAck: this.noAck,
        consumerTag: this.getOptionsProp(
          this.options,
          'consumerTag',
          undefined,
        ),
      },
    );
    callback();
  }

  public async handleMessage(
    message: Record<string, any>,
    channel: any,
  ): Promise<void> {
    if (isNil(message)) {
      return;
    }
    const { content, properties } = message;
    const rawMessage = this.parseMessageContent(content);
    const packet = await this.deserializer.deserialize(rawMessage, properties);
    const pattern = isString(packet.pattern)
      ? packet.pattern
      : JSON.stringify(packet.pattern);

    const rmqContext = new RmqContext([message, channel, pattern]);
    if (isUndefined((packet as IncomingRequest).id)) {
      return this.handleEvent(pattern, packet, rmqContext);
    }
    const handler = this.getHandlerByPattern(pattern);

    if (!handler) {
      if (!this.noAck) {
        this.logger.warn(RQM_NO_MESSAGE_HANDLER`${pattern}`);
        this.channel.nack(rmqContext.getMessage() as Message, false, false);
      }
      const status = 'error';
      const noHandlerPacket = {
        id: (packet as IncomingRequest).id,
        err: NO_MESSAGE_HANDLER,
        status,
      };
      return this.sendMessage(
        noHandlerPacket,
        properties.replyTo,
        properties.correlationId,
      );
    }
    const response$ = this.transformToObservable(
      await handler(packet.data, rmqContext),
    );

    const publish = <T>(data: T) =>
      this.sendMessage(data, properties.replyTo, properties.correlationId);

    response$ && this.send(response$, publish);
  }

  public async handleEvent(
    pattern: string,
    packet: ReadPacket,
    context: RmqContext,
  ): Promise<any> {
    const handler = this.getHandlerByPattern(pattern);
    if (!handler && !this.noAck) {
      this.channel.nack(context.getMessage() as Message, false, false);
      return this.logger.warn(RQM_NO_EVENT_HANDLER`${pattern}`);
    }
    return super.handleEvent(pattern, packet, context);
  }

  public sendMessage<T = any>(
    message: T,
    replyTo: any,
    correlationId: string,
  ): void {
    const outgoingResponse = this.serializer.serialize(
      message as unknown as OutgoingResponse,
    );
    const options = outgoingResponse.options;
    delete outgoingResponse.options;

    const buffer = Buffer.from(JSON.stringify(outgoingResponse));
    this.channel.sendToQueue(replyTo, buffer, { correlationId, ...options });
  }

  public unwrap<T>(): T {
    if (!this.server) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return this.server as T;
  }

  public on<
    EventKey extends keyof RmqEvents = keyof RmqEvents,
    EventCallback extends RmqEvents[EventKey] = RmqEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.server) {
      this.server.addListener(event, callback);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  protected initializeSerializer(options: RmqOptions['options']) {
    this.serializer = options?.serializer ?? new RmqRecordSerializer();
  }

  private parseMessageContent(content: Buffer) {
    try {
      return JSON.parse(content.toString());
    } catch {
      return content.toString();
    }
  }
}



================================================
FILE: packages/microservices/server/server-tcp.ts
================================================
import { Type } from '@nestjs/common';
import { isString, isUndefined } from '@nestjs/common/utils/shared.utils';
import * as net from 'net';
import { Server as NetSocket, Socket } from 'net';
import { createServer as tlsCreateServer, TlsOptions } from 'tls';
import {
  EADDRINUSE,
  ECONNREFUSED,
  NO_MESSAGE_HANDLER,
  TCP_DEFAULT_HOST,
  TCP_DEFAULT_PORT,
} from '../constants';
import { TcpContext } from '../ctx-host/tcp.context';
import { Transport } from '../enums';
import { TcpEvents, TcpEventsMap, TcpStatus } from '../events/tcp.events';
import { JsonSocket, TcpSocket } from '../helpers';
import {
  IncomingRequest,
  PacketId,
  ReadPacket,
  WritePacket,
} from '../interfaces';
import { TcpOptions } from '../interfaces/microservice-configuration.interface';
import { Server } from './server';

/**
 * @publicApi
 */
export class ServerTCP extends Server<TcpEvents, TcpStatus> {
  public readonly transportId = Transport.TCP;

  protected server: NetSocket;
  protected readonly port: number;
  protected readonly host: string;
  protected readonly socketClass: Type<TcpSocket>;
  protected isManuallyTerminated = false;
  protected retryAttemptsCount = 0;
  protected tlsOptions?: TlsOptions;
  protected pendingEventListeners: Array<{
    event: keyof TcpEvents;
    callback: TcpEvents[keyof TcpEvents];
  }> = [];

  constructor(private readonly options: Required<TcpOptions>['options']) {
    super();
    this.port = this.getOptionsProp(options, 'port', TCP_DEFAULT_PORT);
    this.host = this.getOptionsProp(options, 'host', TCP_DEFAULT_HOST);
    this.socketClass = this.getOptionsProp(options, 'socketClass', JsonSocket);
    this.tlsOptions = this.getOptionsProp(options, 'tlsOptions');

    this.init();
    this.initializeSerializer(options);
    this.initializeDeserializer(options);
  }

  public listen(
    callback: (err?: unknown, ...optionalParams: unknown[]) => void,
  ) {
    this.server.once(TcpEventsMap.ERROR, (err: Record<string, unknown>) => {
      if (err?.code === EADDRINUSE || err?.code === ECONNREFUSED) {
        this._status$.next(TcpStatus.DISCONNECTED);

        return callback(err);
      }
    });
    this.server.listen(this.port, this.host, callback as () => void);
  }

  public close() {
    this.isManuallyTerminated = true;

    this.server.close();
    this.pendingEventListeners = [];
  }

  public bindHandler(socket: Socket) {
    const readSocket = this.getSocketInstance(socket);
    readSocket.on('message', async (msg: ReadPacket & PacketId) =>
      this.handleMessage(readSocket, msg),
    );
    readSocket.on(TcpEventsMap.ERROR, this.handleError.bind(this));
  }

  public async handleMessage(socket: TcpSocket, rawMessage: unknown) {
    const packet = await this.deserializer.deserialize(rawMessage);
    const pattern = !isString(packet.pattern)
      ? JSON.stringify(packet.pattern)
      : packet.pattern;

    const tcpContext = new TcpContext([socket, pattern]);
    if (isUndefined((packet as IncomingRequest).id)) {
      return this.handleEvent(pattern, packet, tcpContext);
    }

    const handler = this.getHandlerByPattern(pattern);
    if (!handler) {
      const status = 'error';
      const noHandlerPacket = this.serializer.serialize({
        id: (packet as IncomingRequest).id,
        status,
        err: NO_MESSAGE_HANDLER,
      });
      return socket.sendMessage(noHandlerPacket);
    }
    const response$ = this.transformToObservable(
      await handler(packet.data, tcpContext),
    );

    response$ &&
      this.send(response$, data => {
        Object.assign(data, { id: (packet as IncomingRequest).id });
        const outgoingResponse = this.serializer.serialize(
          data as WritePacket & PacketId,
        );
        socket.sendMessage(outgoingResponse);
      });
  }

  public handleClose(): undefined | number | NodeJS.Timer {
    if (
      this.isManuallyTerminated ||
      !this.getOptionsProp(this.options, 'retryAttempts') ||
      this.retryAttemptsCount >=
        this.getOptionsProp(this.options, 'retryAttempts', 0)
    ) {
      return undefined;
    }
    ++this.retryAttemptsCount;
    return setTimeout(
      () => this.server.listen(this.port, this.host),
      this.getOptionsProp(this.options, 'retryDelay', 0),
    );
  }

  public unwrap<T>(): T {
    if (!this.server) {
      throw new Error(
        'Not initialized. Please call the "listen"/"startAllMicroservices" method before accessing the server.',
      );
    }
    return this.server as T;
  }

  public on<
    EventKey extends keyof TcpEvents = keyof TcpEvents,
    EventCallback extends TcpEvents[EventKey] = TcpEvents[EventKey],
  >(event: EventKey, callback: EventCallback) {
    if (this.server) {
      this.server.on(event, callback as any);
    } else {
      this.pendingEventListeners.push({ event, callback });
    }
  }

  protected init() {
    if (this.tlsOptions) {
      // TLS enabled, use tls server
      this.server = tlsCreateServer(
        this.tlsOptions,
        this.bindHandler.bind(this),
      );
    } else {
      // TLS disabled, use net server
      this.server = net.createServer(this.bindHandler.bind(this));
    }
    this.registerListeningListener(this.server);
    this.registerErrorListener(this.server);
    this.registerCloseListener(this.server);

    this.pendingEventListeners.forEach(({ event, callback }) =>
      this.server.on(event, callback),
    );
    this.pendingEventListeners = [];
  }

  protected registerListeningListener(socket: net.Server) {
    socket.on(TcpEventsMap.LISTENING, () => {
      this._status$.next(TcpStatus.CONNECTED);
    });
  }

  protected registerErrorListener(socket: net.Server) {
    socket.on(TcpEventsMap.ERROR, err => {
      if ('code' in err && err.code === ECONNREFUSED) {
        this._status$.next(TcpStatus.DISCONNECTED);
      }
      this.handleError(err as any);
    });
  }

  protected registerCloseListener(socket: net.Server) {
    socket.on(TcpEventsMap.CLOSE, () => {
      this._status$.next(TcpStatus.DISCONNECTED);
      this.handleClose();
    });
  }

  protected getSocketInstance(socket: Socket): TcpSocket {
    return new this.socketClass(socket);
  }
}



================================================
FILE: packages/microservices/server/server.ts
================================================
import { Logger, LoggerService } from '@nestjs/common/services/logger.service';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import {
  connectable,
  EMPTY,
  from as fromPromise,
  isObservable,
  Observable,
  ObservedValueOf,
  of,
  ReplaySubject,
  Subject,
  Subscription,
} from 'rxjs';
import {
  catchError,
  distinctUntilChanged,
  finalize,
  mergeMap,
} from 'rxjs/operators';
import { NO_EVENT_HANDLER } from '../constants';
import { BaseRpcContext } from '../ctx-host/base-rpc.context';
import { IncomingRequestDeserializer } from '../deserializers/incoming-request.deserializer';
import { Transport } from '../enums';
import {
  ClientOptions,
  KafkaOptions,
  MessageHandler,
  MicroserviceOptions,
  MqttOptions,
  MsPattern,
  NatsOptions,
  ReadPacket,
  RedisOptions,
  RmqOptions,
  TcpOptions,
  WritePacket,
} from '../interfaces';
import { ConsumerDeserializer } from '../interfaces/deserializer.interface';
import { ConsumerSerializer } from '../interfaces/serializer.interface';
import { IdentitySerializer } from '../serializers/identity.serializer';
import { transformPatternToRoute } from '../utils';

/**
 * @publicApi
 */
export abstract class Server<
  EventsMap extends Record<string, Function> = Record<string, Function>,
  Status extends string = string,
> {
  /**
   * Unique transport identifier.
   */
  readonly transportId?: Transport | symbol;

  protected readonly messageHandlers = new Map<string, MessageHandler>();
  protected readonly logger: LoggerService = new Logger(Server.name);
  protected serializer: ConsumerSerializer;
  protected deserializer: ConsumerDeserializer;
  protected _status$ = new ReplaySubject<Status>(1);

  /**
   * Returns an observable that emits status changes.
   */
  public get status(): Observable<Status> {
    return this._status$.asObservable().pipe(distinctUntilChanged());
  }

  /**
   * Registers an event listener for the given event.
   * @param event Event name
   * @param callback Callback to be executed when the event is emitted
   */
  public abstract on<
    EventKey extends keyof EventsMap = keyof EventsMap,
    EventCallback extends EventsMap[EventKey] = EventsMap[EventKey],
  >(event: EventKey, callback: EventCallback): any;
  /**
   * Returns an instance of the underlying server/broker instance,
   * or a group of servers if there are more than one.
   */
  public abstract unwrap<T>(): T;

  /**
   * Method called when server is being initialized.
   * @param callback Function to be called upon initialization
   */
  public abstract listen(callback: (...optionalParams: unknown[]) => any): any;
  /**
   * Method called when server is being terminated.
   */
  public abstract close(): any;

  public addHandler(
    pattern: any,
    callback: MessageHandler,
    isEventHandler = false,
    extras: Record<string, any> = {},
  ) {
    const normalizedPattern = this.normalizePattern(pattern);
    callback.isEventHandler = isEventHandler;
    callback.extras = extras;

    if (this.messageHandlers.has(normalizedPattern) && isEventHandler) {
      const headRef = this.messageHandlers.get(normalizedPattern)!;
      const getTail = (handler: MessageHandler) =>
        handler?.next ? getTail(handler.next) : handler;

      const tailRef = getTail(headRef);
      tailRef.next = callback;
    } else {
      this.messageHandlers.set(normalizedPattern, callback);
    }
  }

  public getHandlers(): Map<string, MessageHandler> {
    return this.messageHandlers;
  }

  public getHandlerByPattern(pattern: string): MessageHandler | null {
    const route = this.getRouteFromPattern(pattern);
    return this.messageHandlers.has(route)
      ? this.messageHandlers.get(route)!
      : null;
  }

  public send(
    stream$: Observable<any>,
    respond: (data: WritePacket) => Promise<unknown> | void,
  ): Subscription {
    const dataQueue: WritePacket[] = [];
    let isProcessing = false;
    const scheduleOnNextTick = (data: WritePacket) => {
      if (data.isDisposed && dataQueue.length > 0) {
        dataQueue[dataQueue.length - 1].isDisposed = true;
      } else {
        dataQueue.push(data);
      }
      if (!isProcessing) {
        isProcessing = true;
        process.nextTick(async () => {
          while (dataQueue.length > 0) {
            const packet = dataQueue.shift();
            if (packet) {
              await respond(packet);
            }
          }
          isProcessing = false;
        });
      }
    };
    return stream$
      .pipe(
        catchError((err: any) => {
          scheduleOnNextTick({ err });
          return EMPTY;
        }),
        finalize(() => scheduleOnNextTick({ isDisposed: true })),
      )
      .subscribe((response: any) => scheduleOnNextTick({ response }));
  }

  public async handleEvent(
    pattern: string,
    packet: ReadPacket,
    context: BaseRpcContext,
  ): Promise<any> {
    const handler = this.getHandlerByPattern(pattern);
    if (!handler) {
      return this.logger.error(NO_EVENT_HANDLER`${pattern}`);
    }
    const resultOrStream = await handler(packet.data, context);
    if (isObservable(resultOrStream)) {
      const connectableSource = connectable(resultOrStream, {
        connector: () => new Subject(),
        resetOnDisconnect: false,
      });
      connectableSource.connect();
    }
  }

  public transformToObservable<T>(
    resultOrDeferred: Observable<T> | Promise<T>,
  ): Observable<T>;
  public transformToObservable<T>(
    resultOrDeferred: T,
  ): never extends Observable<ObservedValueOf<T>>
    ? Observable<T>
    : Observable<ObservedValueOf<T>>;
  public transformToObservable(resultOrDeferred: any) {
    if (resultOrDeferred instanceof Promise) {
      return fromPromise(resultOrDeferred).pipe(
        mergeMap(val => (isObservable(val) ? val : of(val))),
      );
    }

    if (isObservable(resultOrDeferred)) {
      return resultOrDeferred;
    }

    return of(resultOrDeferred);
  }

  public getOptionsProp<
    Options extends MicroserviceOptions['options'],
    Attribute extends keyof Options,
  >(obj: Options, prop: Attribute): Options[Attribute];
  public getOptionsProp<
    Options extends MicroserviceOptions['options'],
    Attribute extends keyof Options,
    DefaultValue extends Options[Attribute] = Options[Attribute],
  >(
    obj: Options,
    prop: Attribute,
    defaultValue: DefaultValue,
  ): Required<Options>[Attribute];
  public getOptionsProp<
    Options extends MicroserviceOptions['options'],
    Attribute extends keyof Options,
    DefaultValue extends Options[Attribute] = Options[Attribute],
  >(
    obj: Options,
    prop: Attribute,
    defaultValue: DefaultValue = undefined as DefaultValue,
  ) {
    return obj && prop in obj ? (obj as any)[prop] : defaultValue;
  }

  protected handleError(error: string) {
    this.logger.error(error);
  }

  protected loadPackage<T = any>(
    name: string,
    ctx: string,
    loader?: Function,
  ): T {
    return loadPackage(name, ctx, loader);
  }

  protected initializeSerializer(options: ClientOptions['options']) {
    this.serializer =
      (options &&
        (options as
          | RedisOptions['options']
          | NatsOptions['options']
          | MqttOptions['options']
          | TcpOptions['options']
          | RmqOptions['options']
          | KafkaOptions['options'])!.serializer) ||
      new IdentitySerializer();
  }

  protected initializeDeserializer(options: ClientOptions['options']) {
    this.deserializer =
      (options! &&
        (options as
          | RedisOptions['options']
          | NatsOptions['options']
          | MqttOptions['options']
          | TcpOptions['options']
          | RmqOptions['options']
          | KafkaOptions['options'])!.deserializer) ||
      new IncomingRequestDeserializer();
  }

  /**
   * Transforms the server Pattern to valid type and returns a route for him.
   *
   * @param  {string} pattern - server pattern
   * @returns string
   */
  protected getRouteFromPattern(pattern: string): string {
    let validPattern: MsPattern;

    try {
      validPattern = JSON.parse(pattern);
    } catch (error) {
      // Uses a fundamental object (`pattern` variable without any conversion)
      validPattern = pattern;
    }
    return this.normalizePattern(validPattern);
  }

  protected normalizePattern(pattern: MsPattern): string {
    return transformPatternToRoute(pattern);
  }
}



================================================
FILE: packages/microservices/test/container.spec.ts
================================================
import { expect } from 'chai';
import { ClientsContainer } from '../container';

describe('ClientsContainer', () => {
  let instance: ClientsContainer;
  beforeEach(() => {
    instance = new ClientsContainer();
  });
  describe('getAllClients', () => {
    it('should return array of clients', () => {
      const clients = [1, 2, 3];
      (instance as any).clients = clients;
      expect(instance.getAllClients()).to.be.eql(clients);
    });
  });
  describe('addClient', () => {
    it('should push client into clients array', () => {
      const client = 'test';
      instance.addClient(client as any);
      expect(instance.getAllClients()).to.be.deep.equal([client]);
    });
  });
  describe('clear', () => {
    it('should remove all clients', () => {
      const clients = [1, 2, 3];
      (instance as any).clients = clients;
      instance.clear();
      expect(instance.getAllClients()).to.be.deep.equal([]);
    });
  });
});



================================================
FILE: packages/microservices/test/listeners-controller.spec.ts
================================================
import { Scope } from '@nestjs/common';
import { ApplicationConfig } from '@nestjs/core';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { NestContainer } from '@nestjs/core/injector/container';
import { Injector } from '@nestjs/core/injector/injector';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { GraphInspector } from '../../core/inspector/graph-inspector';
import { MetadataScanner } from '../../core/metadata-scanner';
import { ClientProxyFactory } from '../client';
import { ClientsContainer } from '../container';
import { ExceptionFiltersContext } from '../context/exception-filters-context';
import { RpcContextCreator } from '../context/rpc-context-creator';
import { Transport } from '../enums/transport.enum';
import {
  EventOrMessageListenerDefinition,
  ListenerMetadataExplorer,
} from '../listener-metadata-explorer';
import { ListenersController } from '../listeners-controller';

describe('ListenersController', () => {
  let instance: ListenersController,
    explorer: sinon.SinonMock,
    metadataExplorer: ListenerMetadataExplorer,
    server: any,
    serverTCP: any,
    serverCustom: any,
    customTransport: symbol,
    addSpy: sinon.SinonSpy,
    addSpyTCP: sinon.SinonSpy,
    addSpyCustom: sinon.SinonSpy,
    proxySpy: sinon.SinonSpy,
    container: NestContainer,
    graphInspector: GraphInspector,
    injector: Injector,
    rpcContextCreator: RpcContextCreator,
    exceptionFiltersContext: ExceptionFiltersContext;

  before(() => {
    metadataExplorer = new ListenerMetadataExplorer(new MetadataScanner());
    explorer = sinon.mock(metadataExplorer);
  });
  beforeEach(() => {
    container = new NestContainer();
    graphInspector = new GraphInspector(container);
    injector = new Injector();
    exceptionFiltersContext = new ExceptionFiltersContext(
      container,
      new ApplicationConfig(),
    );
    rpcContextCreator = sinon.createStubInstance(RpcContextCreator) as any;
    proxySpy = sinon.spy();
    (rpcContextCreator as any).create.callsFake(() => proxySpy);

    instance = new ListenersController(
      new ClientsContainer(),
      rpcContextCreator,
      container,
      injector,
      ClientProxyFactory,
      exceptionFiltersContext,
      graphInspector,
    );
    (instance as any).metadataExplorer = metadataExplorer;
    addSpy = sinon.spy();
    server = {
      addHandler: addSpy,
    };
    addSpyTCP = sinon.spy();
    serverTCP = {
      addHandler: addSpyTCP,
      transportId: Transport.TCP,
    };
    addSpyCustom = sinon.spy();
    customTransport = Symbol();
    serverCustom = {
      addHandler: addSpyCustom,
      transportId: customTransport,
    };
  });

  describe('registerPatternHandlers', () => {
    const handlers = [
      { patterns: ['test'], targetCallback: 'tt' },
      { patterns: ['test2'], targetCallback: '2', isEventHandler: true },
    ];

    beforeEach(() => {
      sinon.stub(container, 'getModuleByKey').callsFake(() => ({}) as any);
    });
    it(`should call "addHandler" method of server for each pattern handler`, () => {
      explorer.expects('explore').returns(handlers);
      instance.registerPatternHandlers(new InstanceWrapper(), server, '');
      expect(addSpy.calledTwice).to.be.true;
    });
    it(`should call "addHandler" method of server for each pattern handler with same transport`, () => {
      const serverHandlers = [
        {
          patterns: [{ cmd: 'test' }],
          targetCallback: 'tt',
          transport: Transport.TCP,
        },
        { pattern: 'test2', targetCallback: '2', transport: Transport.KAFKA },
      ];
      explorer.expects('explore').returns(serverHandlers);
      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');
      expect(addSpyTCP.calledOnce).to.be.true;
    });
    it(`should call "addHandler" method of server without transportID for each pattern handler with any transport value`, () => {
      const serverHandlers = [
        { patterns: [{ cmd: 'test' }], targetCallback: 'tt' },
        {
          patterns: ['test2'],
          targetCallback: '2',
          transport: Transport.KAFKA,
        },
      ];
      explorer.expects('explore').returns(serverHandlers);
      instance.registerPatternHandlers(new InstanceWrapper(), server, '');
      expect(addSpy.calledTwice).to.be.true;
    });
    it(`should call "addHandler" method of server with transportID for each pattern handler with self transport and without transport`, () => {
      const serverHandlers = [
        { patterns: ['test'], targetCallback: 'tt' },
        {
          patterns: ['test2'],
          targetCallback: '2',
          transport: Transport.KAFKA,
        },
        {
          patterns: [{ cmd: 'test3' }],
          targetCallback: '3',
          transport: Transport.TCP,
        },
      ];
      explorer.expects('explore').returns(serverHandlers);
      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');
      expect(addSpyTCP.calledTwice).to.be.true;
    });
    it(`should call "addHandler" method of server with transportID for each pattern handler without transport`, () => {
      explorer.expects('explore').returns(handlers);
      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');
      expect(addSpyTCP.calledTwice).to.be.true;
    });
    it(`should call "addHandler" method of server with custom transportID for pattern handler with the same custom token`, () => {
      const serverHandlers = [
        {
          patterns: [{ cmd: 'test' }],
          targetCallback: 'tt',
          transport: customTransport,
        },
        {
          patterns: ['test2'],
          targetCallback: '2',
          transport: Transport.KAFKA,
        },
      ];

      explorer.expects('explore').returns(serverHandlers);
      instance.registerPatternHandlers(new InstanceWrapper(), serverCustom, '');
      expect(addSpyCustom.calledOnce).to.be.true;
    });
    it(`should call "addHandler" method of server with extras data`, () => {
      const serverHandlers = [
        {
          patterns: ['test'],
          targetCallback: 'tt',
          extras: { param: 'value' },
        },
      ];
      explorer.expects('explore').returns(serverHandlers);
      instance.registerPatternHandlers(new InstanceWrapper(), serverTCP, '');
      expect(addSpyTCP.calledOnce).to.be.true;
      expect(
        addSpyTCP.calledWith(
          sinon.match.any,
          sinon.match.any,
          sinon.match.any,
          sinon.match({ param: 'value' }),
        ),
      ).to.be.true;
    });
    describe('when request scoped', () => {
      it(`should call "addHandler" with deferred proxy`, () => {
        explorer.expects('explore').returns(handlers);
        instance.registerPatternHandlers(
          new InstanceWrapper({ scope: Scope.REQUEST }),
          server,
          '',
        );
        expect(addSpy.calledTwice).to.be.true;
      });
    });
  });

  describe('createRequestScopedHandler', () => {
    let handleSpy: sinon.SinonSpy;

    beforeEach(() => {
      handleSpy = sinon.spy();
      sinon.stub(exceptionFiltersContext, 'create').callsFake(
        () =>
          ({
            handle: handleSpy,
          }) as any,
      );

      sinon
        .stub((instance as any).container, 'registerRequestProvider')
        .callsFake(() => ({}) as any);
    });

    describe('when "loadPerContext" resolves', () => {
      const moduleKey = 'moduleKey';
      const methodKey = 'methodKey';
      const module = {
        controllers: new Map(),
      } as any;
      const patterns = [{}];
      const wrapper = new InstanceWrapper({ instance: { [methodKey]: {} } });

      it('should pass all arguments to the proxy chain', async () => {
        sinon
          .stub(injector, 'loadPerContext')
          .callsFake(() => Promise.resolve({}));
        const handler = instance.createRequestScopedHandler(
          wrapper,
          patterns,
          module,
          moduleKey,
          methodKey,
        );
        await handler('data', 'metadata');

        expect(proxySpy.called).to.be.true;
        expect(proxySpy.getCall(0).args[0]).to.be.eql('data');
        expect(proxySpy.getCall(0).args[1]).to.be.eql('metadata');
      });
    });

    describe('when "loadPerContext" throws', () => {
      const moduleKey = 'moduleKey';
      const methodKey = 'methodKey';
      const module = {
        controllers: new Map(),
      } as any;
      const patterns = [{}];
      const wrapper = new InstanceWrapper({ instance: { [methodKey]: {} } });

      it('should delegate error to exception filters', async () => {
        sinon.stub(injector, 'loadPerContext').callsFake(() => {
          throw new Error();
        });
        const handler = instance.createRequestScopedHandler(
          wrapper,
          patterns,
          module,
          moduleKey,
          methodKey,
        );
        await handler([]);

        expect(handleSpy.called).to.be.true;
        expect(handleSpy.getCall(0).args[0]).to.be.instanceOf(Error);
        expect(handleSpy.getCall(0).args[1]).to.be.instanceOf(
          ExecutionContextHost,
        );
      });
    });
  });

  describe('insertEntrypointDefinition', () => {
    it('should inspect & insert corresponding entrypoint definitions', () => {
      class TestCtrl {}
      const instanceWrapper = new InstanceWrapper({
        metatype: TestCtrl,
        name: TestCtrl.name,
      });
      const definition: EventOrMessageListenerDefinition = {
        patterns: ['findOne'],
        methodKey: 'find',
        isEventHandler: false,
        targetCallback: null!,
        extras: { qos: 2 },
      };
      const transportId = Transport.MQTT;

      const insertEntrypointDefinitionSpy = sinon.spy(
        graphInspector,
        'insertEntrypointDefinition',
      );
      instance.insertEntrypointDefinition(
        instanceWrapper,
        definition,
        transportId,
      );
      expect(
        insertEntrypointDefinitionSpy.calledWith({
          type: 'microservice',
          methodName: definition.methodKey,
          className: 'TestCtrl',
          classNodeId: instanceWrapper.id,
          metadata: {
            key: definition.patterns.toString(),
            transportId: 'MQTT',
            patterns: definition.patterns,
            isEventHandler: definition.isEventHandler,
            extras: definition.extras,
          } as any,
        }),
      ).to.be.true;
    });
  });

  describe('assignClientToInstance', () => {
    it('should assign client to instance', () => {
      const propertyKey = 'key';
      const object = {};
      const client = { test: true };
      instance.assignClientToInstance(object, propertyKey, client);

      expect(object[propertyKey]).to.be.eql(client);
    });
  });

  describe('assignClientsToProperties', () => {
    class TestClass {}

    it('should bind all clients to properties', () => {
      const controller = new TestClass();
      const metadata = [
        {
          property: 'key',
          metadata: {},
        },
      ];
      sinon
        .stub((instance as any).metadataExplorer, 'scanForClientHooks')
        .callsFake(() => metadata);

      const assignClientToInstanceSpy = sinon.spy(
        instance,
        'assignClientToInstance',
      );
      instance.assignClientsToProperties(controller);

      expect(assignClientToInstanceSpy.calledOnce).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/listeners-metadata-explorer.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { MetadataScanner } from '../../core/metadata-scanner';
import { Client } from '../decorators/client.decorator';
import { EventPattern } from '../decorators/event-pattern.decorator';
import { MessagePattern } from '../decorators/message-pattern.decorator';
import { Transport } from '../enums/transport.enum';
import { ListenerMetadataExplorer } from '../listener-metadata-explorer';

describe('ListenerMetadataExplorer', () => {
  const msgPattern = { pattern: 'testMsg' };
  const firstMultipleMsgPattern = { pattern: 'testMultipleMsg1' };
  const secondMultipleMsgPattern = { pattern: 'testMultipleMsg2' };
  const clientMetadata = {};
  const clientSecMetadata = { transport: Transport.REDIS };
  const evtPattern = { role: 'testEvt' };
  const firstMultipleEvtPattern = { role: 'testMultipleEvt1' };
  const secondMultipleEvtPattern = { role: 'testMultipleEvt2' };

  class Test {
    @Client(clientMetadata as any)
    public client;
    @Client(clientSecMetadata as any)
    public redisClient;

    get testGet() {
      return 0;
    }
    set testSet(val) {}

    constructor() {}

    @MessagePattern(msgPattern)
    public testMessage() {}

    @MessagePattern([firstMultipleMsgPattern, secondMultipleMsgPattern])
    public testMultipleMessage() {}

    @EventPattern(evtPattern)
    public testEvent() {}

    @EventPattern([firstMultipleEvtPattern, secondMultipleEvtPattern])
    public testMultipleEvent() {}

    public noPattern() {}
  }
  let scanner: MetadataScanner;
  let instance: ListenerMetadataExplorer;

  beforeEach(() => {
    scanner = new MetadataScanner();
    instance = new ListenerMetadataExplorer(scanner);
  });
  describe('explore', () => {
    let getAllMethodNames: sinon.SinonSpy;
    beforeEach(() => {
      getAllMethodNames = sinon.spy(scanner, 'getAllMethodNames');
    });
    it(`should call "scanFromPrototype" with expected arguments`, () => {
      const obj = new Test();
      instance.explore(obj);

      const { args } = getAllMethodNames.getCall(0);
      expect(args[0]).to.be.eql(Object.getPrototypeOf(obj));
    });
  });
  describe('exploreMethodMetadata', () => {
    let test: Test;
    beforeEach(() => {
      test = new Test();
    });
    it(`should return undefined when "handlerType" metadata is undefined`, () => {
      const metadata = instance.exploreMethodMetadata(
        test,
        Object.getPrototypeOf(test),
        'noPattern',
      );
      expect(metadata).to.eq(undefined);
    });

    describe('@MessagePattern', () => {
      it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
        const metadata = instance.exploreMethodMetadata(
          test,
          Object.getPrototypeOf(test),
          'testMessage',
        )!;
        expect(metadata).to.have.keys([
          'isEventHandler',
          'methodKey',
          'targetCallback',
          'patterns',
          'transport',
          'extras',
        ]);
        expect(metadata.patterns.length).to.eql(1);
        expect(metadata.patterns[0]).to.eql(msgPattern);
      });
      it(`should return multiple patterns when more than one is declared`, () => {
        const metadata = instance.exploreMethodMetadata(
          test,
          Object.getPrototypeOf(test),
          'testMultipleMessage',
        )!;
        expect(metadata).to.have.keys([
          'isEventHandler',
          'methodKey',
          'targetCallback',
          'patterns',
          'transport',
          'extras',
        ]);
        expect(metadata.patterns.length).to.eql(2);
        expect(metadata.patterns[0]).to.eql(firstMultipleMsgPattern);
        expect(metadata.patterns[1]).to.eql(secondMultipleMsgPattern);
      });
    });

    describe('@EventPattern', () => {
      it(`should return pattern properties when "handlerType" metadata is not undefined`, () => {
        const metadata = instance.exploreMethodMetadata(
          test,
          Object.getPrototypeOf(test),
          'testEvent',
        )!;
        expect(metadata).to.have.keys([
          'isEventHandler',
          'methodKey',
          'targetCallback',
          'patterns',
          'transport',
          'extras',
        ]);
        expect(metadata.patterns.length).to.eql(1);
        expect(metadata.patterns[0]).to.eql(evtPattern);
      });
      it(`should return multiple patterns when more than one is declared`, () => {
        const metadata = instance.exploreMethodMetadata(
          test,
          Object.getPrototypeOf(test),
          'testMultipleEvent',
        )!;
        expect(metadata).to.have.keys([
          'isEventHandler',
          'methodKey',
          'targetCallback',
          'patterns',
          'transport',
          'extras',
        ]);
        expect(metadata.patterns.length).to.eql(2);
        expect(metadata.patterns[0]).to.eql(firstMultipleEvtPattern);
        expect(metadata.patterns[1]).to.eql(secondMultipleEvtPattern);
      });
    });
  });
  describe('scanForClientHooks', () => {
    it(`should return properties with @Client decorator`, () => {
      const obj = new Test();
      const hooks = [...instance.scanForClientHooks(obj)];

      expect(hooks).to.have.length(2);
      expect(hooks[0]).to.deep.eq({
        property: 'client',
        metadata: clientMetadata,
      });
      expect(hooks[1]).to.deep.eq({
        property: 'redisClient',
        metadata: clientSecMetadata,
      });
    });
  });
});



================================================
FILE: packages/microservices/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/microservices/test/client/client-grpc.spec.ts
================================================
import { Logger } from '@nestjs/common';
import { expect } from 'chai';
import { join } from 'path';
import { Observable, Subject } from 'rxjs';
import * as sinon from 'sinon';
import { ClientGrpcProxy } from '../../client';
import { InvalidGrpcPackageException } from '../../errors/invalid-grpc-package.exception';
import { InvalidGrpcServiceException } from '../../errors/invalid-grpc-service.exception';
import { InvalidProtoDefinitionException } from '../../errors/invalid-proto-definition.exception';
import * as grpcHelpers from '../../helpers/grpc-helpers';

class NoopLogger extends Logger {
  log(message: any, context?: string): void {}
  error(message: any, trace?: string, context?: string): void {}
  warn(message: any, context?: string): void {}
}

class GrpcService {
  test = null;
  test2 = null;
}

describe('ClientGrpcProxy', () => {
  let client: ClientGrpcProxy;
  let untypedClient: any;
  let clientMulti: ClientGrpcProxy;

  beforeEach(() => {
    client = new ClientGrpcProxy({
      protoPath: join(__dirname, './test.proto'),
      package: 'test',
    });
    untypedClient = client as any;

    clientMulti = new ClientGrpcProxy({
      protoPath: ['test.proto', 'test2.proto'],
      package: ['test', 'test2'],
      loader: {
        includeDirs: [join(__dirname, '.')],
      },
    });
  });

  describe('getService', () => {
    describe('when "grpcClient[name]" is nil', () => {
      it('should throw "InvalidGrpcServiceException"', () => {
        untypedClient.grpcClient = {};
        expect(() => client.getService('test')).to.throw(
          InvalidGrpcServiceException,
        );
      });

      it('should throw "InvalidGrpcServiceException" (multiple proto)', () => {
        (clientMulti as any).grpcClient = {};

        expect(() => clientMulti.getService('test')).to.throw(
          InvalidGrpcServiceException,
        );

        expect(() => clientMulti.getService('test2')).to.throw(
          InvalidGrpcServiceException,
        );
      });
    });
    describe('when "grpcClient[name]" is not nil', () => {
      it('should create grpcService', () => {
        untypedClient.grpcClients[0] = {
          test: GrpcService,
        };
        expect(() => client.getService('test')).to.not.throw(
          InvalidGrpcServiceException,
        );
      });

      describe('when "grpcClient[name]" is not nil (multiple proto)', () => {
        it('should create grpcService', () => {
          (clientMulti as any).grpcClients[0] = {
            test: GrpcService,
            test2: GrpcService,
          };
          expect(() => clientMulti.getService('test')).to.not.throw(
            InvalidGrpcServiceException,
          );
          expect(() => clientMulti.getService('test2')).to.not.throw(
            InvalidGrpcServiceException,
          );
        });
      });
    });
  });

  describe('createServiceMethod', () => {
    const methodName = 'test';
    describe('when method is a response stream', () => {
      it('should call "createStreamServiceMethod"', () => {
        const cln = { [methodName]: { responseStream: true } };
        const spy = sinon.spy(client, 'createStreamServiceMethod');
        client.createServiceMethod(cln, methodName);

        expect(spy.called).to.be.true;
      });
    });
    describe('when method is not a response stream', () => {
      it('should call "createUnaryServiceMethod"', () => {
        const cln = { [methodName]: { responseStream: false } };
        const spy = sinon.spy(client, 'createUnaryServiceMethod');
        client.createServiceMethod(cln, methodName);

        expect(spy.called).to.be.true;
      });
    });
  });

  describe('createStreamServiceMethod', () => {
    it('should return observable', () => {
      const methodKey = 'method';
      const fn = client.createStreamServiceMethod(
        { [methodKey]: {} },
        methodKey,
      );
      expect(fn()).to.be.instanceof(Observable);
    });
    describe('on subscribe', () => {
      const methodName = 'm';
      const obj = { [methodName]: () => ({ on: (type, fn) => fn() }) };

      let stream$: Observable<any>;

      beforeEach(() => {
        stream$ = client.createStreamServiceMethod(obj, methodName)();
      });

      it('should call native method', () => {
        const spy = sinon.spy(obj, methodName);
        stream$.subscribe({
          next: () => ({}),
          error: () => ({}),
        });

        expect(spy.called).to.be.true;
      });
    });

    describe('when stream request', () => {
      const methodName = 'm';
      const writeSpy = sinon.spy();
      const obj = {
        [methodName]: () => ({ on: (type, fn) => fn(), write: writeSpy }),
      };

      let stream$: Observable<any>;
      let upstream: Subject<unknown>;

      beforeEach(() => {
        upstream = new Subject();
        (obj[methodName] as any).requestStream = true;
        stream$ = client.createStreamServiceMethod(obj, methodName)(upstream);
      });

      it('should subscribe to request upstream', () => {
        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');
        stream$.subscribe({
          next: () => ({}),
          error: () => ({}),
        });
        upstream.next({ test: true });

        expect(writeSpy.called).to.be.true;
        expect(upstreamSubscribe.called).to.be.true;
      });
    });

    describe('flow-control', () => {
      const methodName = 'm';
      type EvtCallback = (...args: any[]) => void;
      let callMock: {
        on: (type: string, fn: EvtCallback) => void;
        cancel: sinon.SinonSpy;
        finished: boolean;
        destroy: sinon.SinonSpy;
        removeAllListeners: sinon.SinonSpy;
      };
      let eventCallbacks: { [type: string]: EvtCallback };
      let obj, dataSpy, errorSpy, completeSpy;

      let stream$: Observable<any>;

      beforeEach(() => {
        dataSpy = sinon.spy();
        errorSpy = sinon.spy();
        completeSpy = sinon.spy();

        eventCallbacks = {};
        callMock = {
          on: (type, fn) => (eventCallbacks[type] = fn),
          cancel: sinon.spy(),
          finished: false,
          destroy: sinon.spy(),
          removeAllListeners: sinon.spy(),
        };
        obj = { [methodName]: () => callMock };
        stream$ = client.createStreamServiceMethod(obj, methodName)();
      });

      it('propagates server errors', () => {
        const err = new Error('something happened');
        stream$.subscribe({
          next: dataSpy,
          error: errorSpy,
          complete: completeSpy,
        });

        eventCallbacks.data('a');
        eventCallbacks.data('b');
        callMock.finished = true;
        eventCallbacks.error(err);
        eventCallbacks.data('c');

        expect(Object.keys(eventCallbacks).length).to.eq(3);
        expect(dataSpy.args).to.eql([['a'], ['b']]);
        expect(errorSpy.args[0][0]).to.eql(err);
        expect(completeSpy.called).to.be.false;
        expect(callMock.cancel.called).to.be.false;
      });

      it('handles client side cancel', () => {
        const grpcServerCancelErrMock = {
          details: 'Cancelled',
        };
        const subscription = stream$.subscribe({
          next: dataSpy,
          error: errorSpy,
        });

        eventCallbacks.data('a');
        eventCallbacks.data('b');
        subscription.unsubscribe();
        eventCallbacks.error(grpcServerCancelErrMock);
        eventCallbacks.end();
        eventCallbacks.data('c');

        expect(callMock.cancel.called, 'should call call.cancel()').to.be.true;
        expect(callMock.destroy.called, 'should call call.destroy()').to.be
          .true;
        expect(dataSpy.args).to.eql([['a'], ['b']]);
        expect(errorSpy.called, 'should not error if client canceled').to.be
          .false;
      });
    });
  });

  describe('createUnaryServiceMethod', () => {
    it('should return observable', () => {
      const methodKey = 'method';
      const fn = client.createUnaryServiceMethod(
        { [methodKey]: {} },
        methodKey,
      );
      expect(fn()).to.be.instanceof(Observable);
    });
    describe('on subscribe', () => {
      const methodName = 'm';
      const obj = {
        [methodName]: callback => {
          callback(null, {});

          return {
            finished: true,
          };
        },
      };

      let stream$: Observable<any>;

      beforeEach(() => {
        stream$ = client.createUnaryServiceMethod(obj, methodName)();
      });

      it('should call native method', () => {
        const spy = sinon.spy(obj, methodName);
        stream$.subscribe({
          next: () => ({}),
          error: () => ({}),
        });

        expect(spy.called).to.be.true;
      });
    });
    describe('when stream request', () => {
      let clientCallback: (
        err: Error | null | undefined,
        response: any,
      ) => void;
      const writeSpy = sinon.spy();
      const methodName = 'm';

      const callMock = {
        cancel: sinon.spy(),
        finished: false,
        write: writeSpy,
      };

      const obj = {
        [methodName]: callback => {
          clientCallback = callback;
          return callMock;
        },
      };

      let stream$: Observable<any>;
      let upstream: Subject<unknown>;

      beforeEach(() => {
        upstream = new Subject();
        (obj[methodName] as any).requestStream = true;
        stream$ = client.createUnaryServiceMethod(obj, methodName)(upstream);
      });

      afterEach(() => {
        clientCallback(null, {});
      });

      it('should subscribe to request upstream', () => {
        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');
        stream$.subscribe({
          next: () => ({}),
          error: () => ({}),
        });
        upstream.next({ test: true });

        expect(writeSpy.called).to.be.true;
        expect(upstreamSubscribe.called).to.be.true;
      });
    });

    describe('flow-control', () => {
      it('should cancel call on client unsubscribe', () => {
        const methodName = 'm';

        const dataSpy = sinon.spy();
        const errorSpy = sinon.spy();
        const completeSpy = sinon.spy();

        const callMock = {
          cancel: sinon.spy(),
          finished: false,
        };

        let handler: (error: any, data: any) => void;

        const obj = {
          [methodName]: (callback, ...args) => {
            handler = callback;

            return callMock;
          },
        };

        const stream$ = client.createUnaryServiceMethod(obj, methodName)();

        const subscription = stream$.subscribe({
          next: dataSpy,
          error: errorSpy,
          complete: completeSpy,
        });

        subscription.unsubscribe();
        handler!(null, 'a');

        expect(dataSpy.called).to.be.false;
        expect(errorSpy.called).to.be.false;
        expect(completeSpy.called).to.be.false;
        expect(callMock.cancel.called).to.be.true;
      });

      it('should cancel call on client unsubscribe case client streaming', () => {
        const methodName = 'm';

        const dataSpy = sinon.spy();
        const errorSpy = sinon.spy();
        const completeSpy = sinon.spy();
        const writeSpy = sinon.spy();

        const callMock = {
          cancel: sinon.spy(),
          finished: false,
          write: writeSpy,
        };

        let handler: (error: any, data: any) => void;
        const obj = {
          [methodName]: callback => {
            handler = callback;
            return callMock;
          },
        };

        (obj[methodName] as any).requestStream = true;
        const upstream: Subject<unknown> = new Subject();
        const stream$: Observable<any> = client.createUnaryServiceMethod(
          obj,
          methodName,
        )(upstream);

        const upstreamSubscribe = sinon.spy(upstream, 'subscribe');
        stream$.subscribe({
          next: () => ({}),
          error: () => ({}),
        });
        upstream.next({ test: true });

        const subscription = stream$.subscribe({
          next: dataSpy,
          error: errorSpy,
          complete: completeSpy,
        });

        subscription.unsubscribe();
        handler!(null, 'a');

        expect(dataSpy.called).to.be.false;
        expect(writeSpy.called).to.be.true;
        expect(errorSpy.called).to.be.false;
        expect(completeSpy.called).to.be.false;
        expect(callMock.cancel.called).to.be.true;
        expect(upstreamSubscribe.called).to.be.true;
      });
    });
  });

  describe('createClients', () => {
    describe('when package does not exist', () => {
      it('should throw "InvalidGrpcPackageException"', () => {
        sinon.stub(client, 'lookupPackage').callsFake(() => null);
        untypedClient.logger = new NoopLogger();

        try {
          client.createClients();
        } catch (err) {
          expect(err).to.be.instanceof(InvalidGrpcPackageException);
        }
      });
    });
  });

  describe('loadProto', () => {
    describe('when proto is invalid', () => {
      it('should throw InvalidProtoDefinitionException', () => {
        const getPackageDefinitionStub = sinon.stub(
          grpcHelpers,
          'getGrpcPackageDefinition' as any,
        );
        getPackageDefinitionStub.callsFake(() => {
          throw new Error();
        });
        untypedClient.logger = new NoopLogger();
        expect(() => client.loadProto()).to.throws(
          InvalidProtoDefinitionException,
        );
        getPackageDefinitionStub.restore();
      });
    });
  });
  describe('close', () => {
    it('should call "close" method', () => {
      const grpcClient = { close: sinon.spy() };
      untypedClient.clients.set('test', grpcClient);
      untypedClient.grpcClients[0] = {};

      client.close();
      expect(grpcClient.close.called).to.be.true;
      expect(untypedClient.clients.size).to.be.eq(0);
      expect(untypedClient.grpcClients.length).to.be.eq(0);
    });
  });

  describe('publish', () => {
    it('should throw exception', () => {
      expect(() => client['publish'](null, null!)).to.throws(Error);
    });
  });

  describe('send', () => {
    it('should throw exception', () => {
      expect(() => client.send(null, null)).to.throws(Error);
    });
  });

  describe('connect', () => {
    it('should throw exception', () => {
      client.connect().catch(error => expect(error).to.be.instanceof(Error));
    });
  });

  describe('dispatchEvent', () => {
    it('should throw exception', () => {
      client['dispatchEvent'](null).catch(error =>
        expect(error).to.be.instanceof(Error),
      );
    });
  });

  describe('lookupPackage', () => {
    it('should return root package in case package name is not defined', () => {
      const root = {};

      expect(client.lookupPackage(root, undefined!)).to.be.equal(root);
      expect(client.lookupPackage(root, '')).to.be.equal(root);
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-kafka.spec.ts
================================================
import { expect } from 'chai';
import { Producer } from 'kafkajs';
import { Observable } from 'rxjs';
import * as sinon from 'sinon';
import { ClientKafka } from '../../client/client-kafka';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { KafkaHeaders } from '../../enums';
import { InvalidKafkaClientTopicException } from '../../errors/invalid-kafka-client-topic.exception';
import {
  ConsumerGroupJoinEvent,
  EachMessagePayload,
  KafkaMessage,
} from '../../external/kafka.interface';

describe('ClientKafka', () => {
  const topic = 'test.topic';
  const partition = 0;
  const replyTopic = 'test.topic.reply';
  const replyPartition = '0';
  const correlationId = '696fa0a9-1827-4e59-baef-f3628173fe4f';
  const key = 'test-key';
  const offset = '0';
  const timestamp = new Date().toISOString();
  const attributes = 1;
  const messageValue = 'test-message';
  const heartbeat = async () => {};
  const pause = () => () => {};

  const message: KafkaMessage = {
    key: Buffer.from(key),
    offset,
    size: messageValue.length,
    value: Buffer.from(messageValue),
    timestamp,
    attributes,
  };

  const deserializedMessage: any = {
    key,
    offset,
    size: messageValue.length,
    value: messageValue,
    timestamp,
    attributes,
    topic,
    partition,
  };

  const payload: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
        },
      },
      message,
    ),
    heartbeat,
    pause,
  };

  const payloadDisposed: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
          [KafkaHeaders.NEST_IS_DISPOSED]: Buffer.alloc(1),
        },
      },
      message,
      {
        size: 0,
        value: Buffer.from(JSON.stringify({ test: true })),
      },
    ),
    heartbeat,
    pause,
  };

  const payloadError: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
          [KafkaHeaders.NEST_ERR]: Buffer.from(NO_MESSAGE_HANDLER),
        },
      },
      message,
      {
        size: 0,
        value: null,
      },
    ),
    heartbeat,
    pause,
  };

  const payloadWithoutCorrelation: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {},
      },
      message,
    ),
    heartbeat,
    pause,
  };

  // deserialized payload
  const deserializedPayload: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: correlationId,
        },
      },
      deserializedMessage,
    ),
    heartbeat,
    pause,
  };

  const deserializedPayloadDisposed: EachMessagePayload = {
    topic,
    partition,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: correlationId,
          [KafkaHeaders.NEST_IS_DISPOSED]: Buffer.alloc(1).toString(),
        },
      },
      deserializedMessage,
      {
        size: 0,
        value: { test: true },
      },
    ),
    heartbeat,
    pause,
  };

  let client: ClientKafka;
  let untypedClient: any;
  let callback: sinon.SinonSpy;
  let connect: sinon.SinonSpy;
  let subscribe: sinon.SinonSpy;
  let run: sinon.SinonSpy;
  let send: sinon.SinonSpy;
  let on: sinon.SinonSpy;
  let consumerStub: sinon.SinonStub;
  let producerStub: sinon.SinonStub;
  let createClientStub: sinon.SinonStub;
  let kafkaClient: any;

  beforeEach(() => {
    client = new ClientKafka({});
    untypedClient = client as any;

    callback = sinon.spy();
    connect = sinon.spy();
    subscribe = sinon.spy();
    run = sinon.spy();
    send = sinon.spy();
    on = sinon.spy();

    consumerStub = sinon.stub(client as any, 'consumer').callsFake(() => {
      return {
        connect,
        subscribe,
        run,
        events: {
          GROUP_JOIN: 'consumer.group_join',
          HEARTBEAT: 'consumer.heartbeat',
          COMMIT_OFFSETS: 'consumer.commit_offsets',
          FETCH_START: 'consumer.fetch_start',
          FETCH: 'consumer.fetch',
          START_BATCH_PROCESS: 'consumer.start_batch_process',
          END_BATCH_PROCESS: 'consumer.end_batch_process',
          CONNECT: 'consumer.connect',
          DISCONNECT: 'consumer.disconnect',
          STOP: 'consumer.stop',
          CRASH: 'consumer.crash',
          REBALANCING: 'consumer.rebalancing',
          RECEIVED_UNSUBSCRIBED_TOPICS: 'consumer.received_unsubscribed_topics',
          REQUEST: 'consumer.network.request',
          REQUEST_TIMEOUT: 'consumer.network.request_timeout',
          REQUEST_QUEUE_SIZE: 'consumer.network.request_queue_size',
        },
        on,
      };
    });
    producerStub = sinon.stub(client as any, 'producer').callsFake(() => {
      return {
        connect,
        send,
        events: {
          CONNECT: 'producer.connect',
          DISCONNECT: 'producer.disconnect',
          REQUEST: 'producer.network.request',
          REQUEST_TIMEOUT: 'producer.network.request_timeout',
          REQUEST_QUEUE_SIZE: 'producer.network.request_queue_size',
        },
        on,
      };
    });
    kafkaClient = {
      consumer: consumerStub,
      producer: producerStub,
    };

    createClientStub = sinon
      .stub(client, 'createClient')
      .callsFake(() => kafkaClient);
  });

  describe('createClient', () => {
    beforeEach(() => {
      client = new ClientKafka({});
    });

    it(`should accept a custom logCreator in client options`, () => {
      const logCreatorSpy = sinon.spy(() => 'test');
      const logCreator = () => logCreatorSpy;

      client = new ClientKafka({
        client: {
          brokers: [],
          logCreator,
        },
      });

      const logger = client.createClient().logger();

      logger.info({ namespace: '', level: 1, log: 'test' });

      expect(logCreatorSpy.called).to.be.true;
    });
  });

  describe('subscribeToResponseOf', () => {
    let normalizePatternSpy: sinon.SinonSpy;
    let getResponsePatternNameSpy: sinon.SinonSpy;

    beforeEach(() => {
      normalizePatternSpy = sinon.spy(client as any, 'normalizePattern');
      getResponsePatternNameSpy = sinon.spy(
        client as any,
        'getResponsePatternName',
      );
    });

    it(`should create an array of response patterns`, () => {
      client.subscribeToResponseOf(topic);

      expect(normalizePatternSpy.calledWith(topic)).to.be.true;
      expect(getResponsePatternNameSpy.calledWith(topic)).to.be.true;
      expect(client['responsePatterns']).to.not.be.empty;
      expect(client['responsePatterns'][0]).to.eq(replyTopic);
    });

    afterEach(() => {
      normalizePatternSpy.restore();
    });
  });

  describe('close', () => {
    const consumer = { disconnect: sinon.stub().resolves() };
    const producer = { disconnect: sinon.stub().resolves() };
    beforeEach(() => {
      untypedClient._consumer = consumer;
      untypedClient._producer = producer;
    });
    it('should close server', async () => {
      await client.close();

      expect(consumer.disconnect.calledOnce).to.be.true;
      expect(producer.disconnect.calledOnce).to.be.true;
      expect(untypedClient._consumer).to.be.null;
      expect(untypedClient._producer).to.be.null;
      expect(untypedClient.client).to.be.null;
    });
  });

  describe('connect', () => {
    let consumerAssignmentsStub: sinon.SinonStub;
    let bindTopicsStub: sinon.SinonStub;

    describe('consumer and producer', () => {
      beforeEach(() => {
        consumerAssignmentsStub = sinon.stub(
          client as any,
          'consumerAssignments',
        );
        bindTopicsStub = sinon
          .stub(client, 'bindTopics')
          .callsFake(async () => {});
      });

      it('should expect the connection to be created', async () => {
        const connection = await client.connect();

        expect(createClientStub.calledOnce).to.be.true;
        expect(producerStub.calledOnce).to.be.true;
        expect(consumerStub.calledOnce).to.be.true;
        expect(on.called).to.be.true;
        expect(client['consumerAssignments']).to.be.empty;
        expect(connect.calledTwice).to.be.true;
        expect(bindTopicsStub.calledOnce).to.be.true;
        expect(connection).to.deep.equal(producerStub());
      });

      it('should expect the connection to be reused', async () => {
        untypedClient.initialized = Promise.resolve({});

        await client.connect();

        expect(createClientStub.calledOnce).to.be.false;
        expect(producerStub.calledOnce).to.be.false;
        expect(consumerStub.calledOnce).to.be.false;

        expect(on.calledOnce).to.be.false;
        expect(client['consumerAssignments']).to.be.empty;

        expect(connect.calledTwice).to.be.false;

        expect(bindTopicsStub.calledOnce).to.be.false;
      });
    });

    describe('producer only mode', () => {
      beforeEach(() => {
        consumerAssignmentsStub = sinon.stub(
          client as any,
          'consumerAssignments',
        );
        bindTopicsStub = sinon
          .stub(client, 'bindTopics')
          .callsFake(async () => {});
        client['producerOnlyMode'] = true;
      });

      it('should expect the connection to be created', async () => {
        const connection = await client.connect();

        expect(createClientStub.calledOnce).to.be.true;
        expect(producerStub.calledOnce).to.be.true;

        expect(consumerStub.calledOnce).to.be.false;

        expect(on.calledOnce).to.be.false;
        expect(client['consumerAssignments']).to.be.empty;

        expect(connect.calledOnce).to.be.true;

        expect(bindTopicsStub.calledOnce).to.be.false;
        expect(connection).to.deep.equal(producerStub());
      });

      it('should expect the connection to be reused', async () => {
        untypedClient.initialized = Promise.resolve({});

        await client.connect();

        expect(createClientStub.calledOnce).to.be.false;
        expect(producerStub.calledOnce).to.be.false;
        expect(consumerStub.calledOnce).to.be.false;

        expect(on.calledOnce).to.be.false;
        expect(client['consumerAssignments']).to.be.empty;

        expect(connect.calledTwice).to.be.false;

        expect(bindTopicsStub.calledOnce).to.be.false;
      });
    });
  });

  describe('setConsumerAssignments', () => {
    it('should update consumer assignments', async () => {
      await client.connect();

      const consumerAssignments: ConsumerGroupJoinEvent = {
        id: 'id',
        type: 'type',
        timestamp: 1234567890,
        payload: {
          duration: 20,
          groupId: 'group-id',
          isLeader: true,
          leaderId: 'member-1',
          groupProtocol: 'RoundRobin',
          memberId: 'member-1',
          memberAssignment: {
            'topic-a': [0, 1, 2],
            'topic-b': [3, 4, 5],
          },
        },
      };

      client['setConsumerAssignments'](consumerAssignments);

      expect(client['consumerAssignments']).to.deep.eq(
        // consumerAssignments.payload.memberAssignment,
        {
          'topic-a': 0,
          'topic-b': 3,
        },
      );
    });

    it('should not update consumer assignments if there are no partitions assigned to consumer', async () => {
      await client.connect();

      const consumerAssignments: ConsumerGroupJoinEvent = {
        id: 'id',
        type: 'type',
        timestamp: 1234567890,
        payload: {
          duration: 20,
          groupId: 'group-id',
          isLeader: true,
          leaderId: 'member-1',
          groupProtocol: 'RoundRobin',
          memberId: 'member-1',
          memberAssignment: {
            'topic-a': [],
            'topic-b': [3, 4, 5],
          },
        },
      };

      client['setConsumerAssignments'](consumerAssignments);

      expect(client['consumerAssignments']).to.deep.eq({
        'topic-b': 3,
      });
    });
  });

  describe('bindTopics', () => {
    it('should bind topics from response patterns', async () => {
      untypedClient.responsePatterns = [replyTopic];
      untypedClient._consumer = kafkaClient.consumer();

      await client.bindTopics();

      expect(subscribe.calledOnce).to.be.true;
      expect(
        subscribe.calledWith({
          topics: [replyTopic],
        }),
      ).to.be.true;
      expect(run.calledOnce).to.be.true;
    });

    it('should bind topics from response patterns with options', async () => {
      untypedClient.responsePatterns = [replyTopic];
      untypedClient._consumer = kafkaClient.consumer();
      untypedClient.options.subscribe = {};
      untypedClient.options.subscribe.fromBeginning = true;

      await client.bindTopics();

      expect(subscribe.calledOnce).to.be.true;
      expect(
        subscribe.calledWith({
          topics: [replyTopic],
          fromBeginning: true,
        }),
      ).to.be.true;
      expect(run.calledOnce).to.be.true;
    });
  });

  describe('createResponseCallback', () => {
    let subscription;

    describe('not completed', () => {
      beforeEach(async () => {
        subscription = client.createResponseCallback();

        client['routingMap'].set(correlationId, callback);
        subscription(payload);
      });
      it('should call callback with expected arguments', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            err: undefined,
            response: messageValue,
          }),
        ).to.be.true;
      });
    });

    describe('disposed and "id" is correct', () => {
      beforeEach(async () => {
        subscription = client.createResponseCallback();

        client['routingMap'].set(correlationId, callback);
        subscription(payloadDisposed);
      });

      it('should call callback with dispose param', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            isDisposed: true,
            response: deserializedPayloadDisposed.message.value,
            err: undefined,
          }),
        ).to.be.true;
      });
    });

    describe('error and "id" is correct', () => {
      beforeEach(async () => {
        subscription = client.createResponseCallback();

        client['routingMap'].set(correlationId, callback);
        subscription(payloadError);
      });

      it('should call callback with error param', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            isDisposed: true,
            response: undefined,
            err: NO_MESSAGE_HANDLER,
          }),
        ).to.be.true;
      });
    });

    describe('without "id"', () => {
      beforeEach(async () => {
        subscription = client.createResponseCallback();

        client['routingMap'].set(correlationId, callback);
        subscription(payloadWithoutCorrelation);
      });

      it('should not call callback', () => {
        expect(callback.called).to.be.false;
      });
    });

    describe('disposed and "id" is incorrect', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();

        client['routingMap'].set('incorrect-correlation-id', callback);
        subscription(payload);
      });

      it('should not call callback', () => {
        expect(callback.called).to.be.false;
      });
    });
  });

  describe('emitBatch', () => {
    it(`should return an observable stream`, () => {
      const stream$ = client.emitBatch(
        {},
        {
          messages: [],
        },
      );
      expect(stream$ instanceof Observable).to.be.true;
    });

    it(`should call "connect" immediately`, () => {
      const connectSpy = sinon.spy(client, 'connect');
      client.emitBatch(
        {},
        {
          messages: [],
        },
      );
      expect(connectSpy.calledOnce).to.be.true;
    });

    describe('when "connect" throws', () => {
      it('should return Observable with error', () => {
        sinon.stub(client, 'connect').callsFake(() => {
          throw new Error();
        });

        const stream$ = client.emitBatch(
          {},
          {
            messages: [],
          },
        );

        stream$.subscribe({
          next: () => {},
          error: err => {
            expect(err).to.be.instanceof(Error);
          },
        });
      });
    });

    describe('when is connected', () => {
      beforeEach(() => {
        sinon
          .stub(client, 'connect')
          .callsFake(() => Promise.resolve({} as Producer));
      });

      it(`should call dispatchBatchEvent`, () => {
        const pattern = { test: 3 };
        const data = { messages: [] };
        const dispatchBatchEventSpy = sinon
          .stub()
          .callsFake(() => Promise.resolve(true));
        const stream$ = client.emitBatch(pattern, data);
        client['dispatchBatchEvent'] = dispatchBatchEventSpy;
        stream$.subscribe(() => {
          expect(dispatchBatchEventSpy.calledOnce).to.be.true;
        });
      });
    });

    it('should return Observable with error', () => {
      const err$ = client.emitBatch(null, null!);
      expect(err$).to.be.instanceOf(Observable);
    });
  });

  describe('dispatchEvent', () => {
    const eventMessage = {
      id: undefined,
      pattern: topic,
      data: messageValue,
    };

    let sendStub: sinon.SinonStub;
    let sendSpy: sinon.SinonSpy;

    beforeEach(() => {
      sendStub = sinon.stub().callsFake(async a => {
        throw new Error('ERROR!');
      });
      sendSpy = sinon.spy();
    });

    it('should publish packet', async () => {
      sinon.stub(client as any, '_producer').value({
        send: sendSpy,
      });

      await client['dispatchEvent'](eventMessage);

      expect(sendSpy.calledOnce).to.be.true;
      expect(sendSpy.args[0][0].topic).to.eq(topic);
      expect(sendSpy.args[0][0].messages).to.not.be.empty;

      const sentMessage = sendSpy.args[0][0].messages[0];

      expect(sentMessage.value).to.eq(messageValue);
    });

    it('should throw error', async () => {
      sinon.stub(client as any, 'producer').value({
        send: sendStub,
      });

      client['dispatchEvent'](eventMessage).catch(err =>
        expect(err).to.be.instanceOf(Error),
      );
    });
  });

  describe('getConsumerAssignments', () => {
    it('should get consumer assignments', () => {
      client['consumerAssignments'] = {
        [replyTopic]: 0,
      };

      const result = client.getConsumerAssignments();

      expect(result).to.deep.eq(client['consumerAssignments']);
    });
  });

  describe('getReplyTopicPartition', () => {
    it('should get reply partition', () => {
      client['consumerAssignments'] = {
        [replyTopic]: 0,
      };

      const result = client['getReplyTopicPartition'](replyTopic);

      expect(result).to.eq('0');
    });

    it('should throw error when the topic is not being consumed', () => {
      client['consumerAssignments'] = {};

      expect(() => client['getReplyTopicPartition'](replyTopic)).to.throw(
        InvalidKafkaClientTopicException,
      );
    });

    it('should throw error when the topic is not being consumed', () => {
      client['consumerAssignments'] = {
        [topic]: undefined!,
      };

      expect(() => client['getReplyTopicPartition'](replyTopic)).to.throw(
        InvalidKafkaClientTopicException,
      );
    });
  });

  describe('publish', () => {
    const waitForNextTick = async () =>
      await new Promise(resolve => process.nextTick(resolve));
    const readPacket = {
      pattern: topic,
      data: messageValue,
    };

    let assignPacketIdStub: sinon.SinonStub;
    let normalizePatternSpy: sinon.SinonSpy;
    let getResponsePatternNameSpy: sinon.SinonSpy;
    let getReplyTopicPartitionSpy: sinon.SinonSpy;
    let routingMapSetSpy: sinon.SinonSpy;
    let sendSpy: sinon.SinonSpy;

    beforeEach(() => {
      normalizePatternSpy = sinon.spy(client as any, 'normalizePattern');
      getResponsePatternNameSpy = sinon.spy(
        client as any,
        'getResponsePatternName',
      );
      getReplyTopicPartitionSpy = sinon.spy(
        client as any,
        'getReplyTopicPartition',
      );
      routingMapSetSpy = sinon.spy(untypedClient.routingMap, 'set');
      sendSpy = sinon.spy(() => Promise.resolve());

      assignPacketIdStub = sinon
        .stub(client as any, 'assignPacketId')
        .callsFake(packet =>
          Object.assign(packet as object, {
            id: correlationId,
          }),
        );

      sinon.stub(client as any, '_producer').value({
        send: sendSpy,
      });

      client['consumerAssignments'] = {
        [replyTopic]: parseFloat(replyPartition),
      };
    });

    it('should assign a packet id', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(assignPacketIdStub.calledWith(readPacket)).to.be.true;
    });

    it('should normalize the pattern', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(normalizePatternSpy.calledWith(topic)).to.be.true;
    });

    it('should get the reply pattern', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(getResponsePatternNameSpy.calledWith(topic)).to.be.true;
    });

    it('should get the reply partition', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(getReplyTopicPartitionSpy.calledWith(replyTopic)).to.be.true;
    });

    it('should add the callback to the routing map', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(routingMapSetSpy.calledOnce).to.be.true;
      expect(routingMapSetSpy.args[0][0]).to.eq(correlationId);
      expect(routingMapSetSpy.args[0][1]).to.eq(callback);
    });

    it('should send the message with headers', async () => {
      client['publish'](readPacket, callback);

      await waitForNextTick();

      expect(sendSpy.calledOnce).to.be.true;
      expect(sendSpy.args[0][0].topic).to.eq(topic);
      expect(sendSpy.args[0][0].messages).to.not.be.empty;

      const sentMessage = sendSpy.args[0][0].messages[0];

      expect(sentMessage.value).to.eq(messageValue);
      expect(sentMessage.headers).to.not.be.empty;
      expect(sentMessage.headers[KafkaHeaders.CORRELATION_ID]).to.eq(
        correlationId,
      );
      expect(sentMessage.headers[KafkaHeaders.REPLY_TOPIC]).to.eq(replyTopic);
      expect(sentMessage.headers[KafkaHeaders.REPLY_PARTITION]).to.eq(
        replyPartition,
      );
    });

    it('should remove callback from routing map when unsubscribe', async () => {
      client['publish'](readPacket, callback)();

      await waitForNextTick();

      expect(client['routingMap'].has(correlationId)).to.be.false;
      expect(client['routingMap'].size).to.eq(0);
    });

    describe('on error', () => {
      let clientProducerStub: sinon.SinonStub;
      let sendStub: sinon.SinonStub;

      beforeEach(() => {
        sendStub = sinon.stub().callsFake(() => {
          throw new Error();
        });

        clientProducerStub = sinon.stub(client as any, '_producer').value({
          send: sendStub,
        });
      });

      afterEach(() => {
        clientProducerStub.restore();
      });

      it('should call callback', async () => {
        /* eslint-disable-next-line no-async-promise-executor */
        return new Promise(async resolve => {
          return client['publish'](readPacket, ({ err }) => resolve(err));
        }).then(err => {
          expect(err).to.be.instanceof(Error);
        });
      });
    });

    describe('dispose callback', () => {
      let subscription;
      let getResponsePatternNameStub: sinon.SinonStub;
      let getReplyTopicPartitionStub: sinon.SinonStub;

      beforeEach(async () => {
        // restore
        getResponsePatternNameSpy.restore();
        getReplyTopicPartitionSpy.restore();

        // return the topic instead of the reply topic
        getResponsePatternNameStub = sinon
          .stub(client as any, 'getResponsePatternName')
          .callsFake(() => topic);
        getReplyTopicPartitionStub = sinon
          .stub(client as any, 'getReplyTopicPartition')
          .callsFake(() => '0');

        subscription = client['publish'](readPacket, callback);
        subscription(payloadDisposed);
      });

      afterEach(() => {
        getResponsePatternNameStub.restore();
        getReplyTopicPartitionStub.restore();
      });

      it('should remove callback from routing map', async () => {
        expect(client['routingMap'].has(correlationId)).to.be.false;
        expect(client['routingMap'].size).to.eq(0);
      });
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-mqtt.spec.ts
================================================
import { expect } from 'chai';
import { EMPTY } from 'rxjs';
import * as sinon from 'sinon';
import { ClientMqtt } from '../../client/client-mqtt';
import { MqttEventsMap } from '../../events/mqtt.events';
import { ReadPacket } from '../../interfaces';
import { MqttRecord } from '../../record-builders';

describe('ClientMqtt', () => {
  const test = 'test';
  let client: ClientMqtt = new ClientMqtt({});
  let untypedClient = client as any;

  describe('getRequestPattern', () => {
    it(`should leave pattern as it is`, () => {
      expect(client.getRequestPattern(test)).to.equal(test);
    });
  });
  describe('getResponsePattern', () => {
    it(`should append "/reply" to string`, () => {
      const expectedResult = test + '/reply';
      expect(client.getResponsePattern(test)).to.equal(expectedResult);
    });
  });
  describe('publish', () => {
    const pattern = 'test';
    let msg: ReadPacket;
    let subscribeSpy: sinon.SinonSpy,
      publishSpy: sinon.SinonSpy,
      onSpy: sinon.SinonSpy,
      removeListenerSpy: sinon.SinonSpy,
      unsubscribeSpy: sinon.SinonSpy,
      connectSpy: sinon.SinonStub,
      assignStub: sinon.SinonStub,
      mqttClient: any;

    const id = '1';
    beforeEach(() => {
      client = new ClientMqtt({});
      untypedClient = client as any;

      msg = { pattern, data: 'data' };
      subscribeSpy = sinon.spy((name, fn) => fn());
      publishSpy = sinon.spy();
      onSpy = sinon.spy();
      removeListenerSpy = sinon.spy();
      unsubscribeSpy = sinon.spy();

      mqttClient = {
        subscribe: subscribeSpy,
        on: (type, handler) => (type === 'subscribe' ? handler() : onSpy()),
        removeListener: removeListenerSpy,
        unsubscribe: unsubscribeSpy,
        publish: publishSpy,
        addListener: () => ({}),
      };
      untypedClient.mqttClient = mqttClient;
      connectSpy = sinon.stub(client, 'connect');
      assignStub = sinon
        .stub(client, 'assignPacketId' as any)
        .callsFake(packet => Object.assign(packet as object, { id }));
    });
    afterEach(() => {
      connectSpy.restore();
      assignStub.restore();
    });
    it('should subscribe to response pattern name', async () => {
      client['publish'](msg, () => {});
      expect(subscribeSpy.calledWith(`${pattern}/reply`)).to.be.true;
    });
    it('should publish stringified message to request pattern name', async () => {
      client['publish'](msg, () => {});
      expect(publishSpy.calledWith(pattern, JSON.stringify(msg))).to.be.true;
    });
    it('should add callback to routing map', async () => {
      client['publish'](msg, () => {});
      expect(client['routingMap'].has(id)).to.be.true;
    });
    describe('on error', () => {
      beforeEach(() => {
        assignStub.callsFake(() => {
          throw new Error();
        });
      });

      it('should call callback', () => {
        const callback = sinon.spy();
        client['publish'](msg, callback);

        expect(callback.called).to.be.true;
        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);
      });
    });
    describe('dispose callback', () => {
      let getResponsePatternStub: sinon.SinonStub;
      let callback: sinon.SinonSpy, subscription;

      const channel = 'channel';

      beforeEach(async () => {
        callback = sinon.spy();

        getResponsePatternStub = sinon
          .stub(client, 'getResponsePattern')
          .callsFake(() => channel);
        subscription = client['publish'](msg, callback);
        subscription(channel, JSON.stringify({ isDisposed: true, id }));
      });
      afterEach(() => {
        getResponsePatternStub.restore();
      });

      it('should unsubscribe to response pattern name', () => {
        expect(unsubscribeSpy.calledWith(channel)).to.be.true;
      });
      it('should remove callback from routing map', () => {
        expect(client['routingMap'].has(id)).to.be.false;
      });
    });
    describe('headers', () => {
      it('should not generate headers if none are configured', async () => {
        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2]).to.be.undefined;
      });
      it('should send packet headers', async () => {
        const requestHeaders = { '1': '123' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql(
          requestHeaders,
        );
      });
      it('should combine packet and static headers', async () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.userProperties = staticHeaders;

        const requestHeaders = { '1': '123' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql({
          ...staticHeaders,
          ...requestHeaders,
        });
      });
      it('should prefer packet headers over static headers', async () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { 'client-id': 'override-client-id' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2].properties.userProperties).to.eql(
          requestHeaders,
        );
      });
    });
  });
  describe('createResponseCallback', () => {
    let callback: sinon.SinonSpy, subscription;
    const responseMessage = {
      response: 'test',
      id: '1',
    };

    describe('not completed', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();

        client['routingMap'].set(responseMessage.id, callback);
        subscription('channel', Buffer.from(JSON.stringify(responseMessage)));
      });
      it('should call callback with expected arguments', () => {
        expect(
          callback.calledWith({
            err: undefined,
            response: responseMessage.response,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is correct', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();

        client['routingMap'].set(responseMessage.id, callback);
        subscription(
          'channel',
          Buffer.from(
            JSON.stringify({
              ...responseMessage,
              isDisposed: true,
            }),
          ),
        );
      });

      it('should call callback with dispose param', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            isDisposed: true,
            response: responseMessage.response,
            err: undefined,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is incorrect', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();

        client['routingMap'].set('3', callback);
        subscription('channel', Buffer.from(JSON.stringify(responseMessage)));
      });

      it('should not call callback', () => {
        expect(callback.called).to.be.false;
      });
    });
  });
  describe('close', () => {
    let endSpy: sinon.SinonSpy;
    beforeEach(() => {
      endSpy = sinon.spy();
      untypedClient.mqttClient = { endAsync: endSpy };
    });
    it('should close "pub" when it is not null', async () => {
      await client.close();
      expect(endSpy.called).to.be.true;
    });
    it('should not close "pub" when it is null', async () => {
      untypedClient.mqttClient = null;
      await client.close();
      expect(endSpy.called).to.be.false;
    });
  });
  describe('connect', () => {
    let createClientStub: sinon.SinonStub;
    let registerErrorListenerSpy: sinon.SinonSpy;
    let connect$Stub: sinon.SinonStub;
    let mergeCloseEvent: sinon.SinonStub;

    beforeEach(async () => {
      createClientStub = sinon.stub(client, 'createClient').callsFake(
        () =>
          ({
            addListener: () => ({}),
            removeListener: () => ({}),
            on: () => ({}),
          }) as any,
      );
      registerErrorListenerSpy = sinon.spy(client, 'registerErrorListener');
      connect$Stub = sinon.stub(client, 'connect$' as any).callsFake(() => ({
        subscribe: ({ complete }) => complete(),
        pipe() {
          return this;
        },
      }));
      mergeCloseEvent = sinon
        .stub(client, 'mergeCloseEvent')
        .callsFake((_, source) => source);
    });
    afterEach(() => {
      createClientStub.restore();
      registerErrorListenerSpy.restore();
      connect$Stub.restore();
      mergeCloseEvent.restore();
    });
    describe('when is not connected', () => {
      beforeEach(async () => {
        client['mqttClient'] = null;
        await client.connect();
      });
      it('should call "registerErrorListener" once', async () => {
        expect(registerErrorListenerSpy.called).to.be.true;
      });
      it('should call "createClient" once', async () => {
        expect(createClientStub.called).to.be.true;
      });
      it('should call "connect$" once', async () => {
        expect(connect$Stub.called).to.be.true;
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        client['mqttClient'] = { test: true } as any;
      });
      it('should not call "createClient"', () => {
        expect(createClientStub.called).to.be.false;
      });
      it('should not call "registerErrorListener"', () => {
        expect(registerErrorListenerSpy.called).to.be.false;
      });
      it('should not call "connect$"', () => {
        expect(connect$Stub.called).to.be.false;
      });
    });
  });
  describe('mergeCloseEvent', () => {
    it('should merge close event', () => {
      const error = new Error();
      const instance: any = {
        on: (ev, callback) => callback(error),
        off: () => ({}),
      };
      client.mergeCloseEvent(instance, EMPTY).subscribe({
        error: (err: any) => expect(err).to.be.eql(error),
      });
    });
  });
  describe('registerErrorListener', () => {
    it('should bind error event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerErrorListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(MqttEventsMap.ERROR);
    });
  });
  describe('registerConnectListener', () => {
    it('should bind connect event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerConnectListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(MqttEventsMap.CONNECT);
    });
  });
  describe('registerDisconnectListener', () => {
    it('should bind disconnect event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerDisconnectListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(MqttEventsMap.DISCONNECT);
    });
  });
  describe('registerOfflineListener', () => {
    it('should bind offline event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerOfflineListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(MqttEventsMap.OFFLINE);
    });
  });
  describe('registerCloseListener', () => {
    it('should bind close event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerCloseListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(MqttEventsMap.CLOSE);
    });
  });
  describe('dispatchEvent', () => {
    let msg: ReadPacket;
    let publishStub: sinon.SinonStub, mqttClient;

    beforeEach(() => {
      client = new ClientMqtt({});
      untypedClient = client as any;

      msg = { pattern: 'pattern', data: 'data' };
      publishStub = sinon.stub();
      mqttClient = {
        publish: publishStub,
      };
      untypedClient.mqttClient = mqttClient;
    });

    it('should publish packet', async () => {
      publishStub.callsFake((a, b, c, d) => d());
      await client['dispatchEvent'](msg);

      expect(publishStub.called).to.be.true;
    });
    it('should throw error', async () => {
      publishStub.callsFake((a, b, c, d) => d(new Error()));
      client['dispatchEvent'](msg).catch(err =>
        expect(err).to.be.instanceOf(Error),
      );
    });
    describe('headers', () => {
      it('should not generate headers if none are configured', async () => {
        publishStub.callsFake((a, b, c, d) => d());
        await client['dispatchEvent'](msg);
        expect(publishStub.getCall(0).args[2]).to.be.undefined;
      });
      it('should send packet headers', async () => {
        publishStub.callsFake((a, b, c, d) => d());
        const requestHeaders = { '1': '123' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        await client['dispatchEvent'](msg);
        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(
          requestHeaders,
        );
      });
      it('should combine packet and static headers', async () => {
        publishStub.callsFake((a, b, c, d) => d());
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.userProperties = staticHeaders;

        const requestHeaders = { '1': '123' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        await client['dispatchEvent'](msg);
        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(
          {
            ...staticHeaders,
            ...requestHeaders,
          },
        );
      });
      it('should prefer packet headers over static headers', async () => {
        publishStub.callsFake((a, b, c, d) => d());
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { 'client-id': 'override-client-id' };
        msg.data = new MqttRecord('data', {
          properties: { userProperties: requestHeaders },
        });

        await client['dispatchEvent'](msg);
        expect(publishStub.getCall(0).args[2].properties.userProperties).to.eql(
          requestHeaders,
        );
      });
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-nats.spec.ts
================================================
import { expect } from 'chai';
import { headers as createHeaders, JSONCodec } from 'nats';
import * as sinon from 'sinon';
import { ClientNats } from '../../client/client-nats';
import { ReadPacket } from '../../interfaces';
import { NatsRecord } from '../../record-builders';

describe('ClientNats', () => {
  let client: ClientNats;
  let untypedClient: any;

  describe('publish', () => {
    let msg: ReadPacket;
    const pattern = 'test';
    const id = 3;

    let subscribeSpy: sinon.SinonSpy,
      publishSpy: sinon.SinonSpy,
      removeListenerSpy: sinon.SinonSpy,
      unsubscribeSpy: sinon.SinonSpy,
      connectSpy: sinon.SinonStub,
      natsClient: any,
      subscription: any,
      createClient: sinon.SinonStub;

    beforeEach(() => {
      client = new ClientNats({});
      untypedClient = client as any;

      msg = { pattern, data: 'data' };
      unsubscribeSpy = sinon.spy();
      subscription = {
        unsubscribe: unsubscribeSpy,
      };
      subscribeSpy = sinon.spy(() => subscription);
      publishSpy = sinon.spy();
      removeListenerSpy = sinon.spy();

      natsClient = {
        subscribe: subscribeSpy,
        removeListener: removeListenerSpy,
        addListener: () => ({}),
        publish: publishSpy,
      };
      untypedClient.natsClient = natsClient;

      connectSpy = sinon.stub(client, 'connect').callsFake(async () => {
        untypedClient.natsClient = natsClient;
      });
      createClient = sinon
        .stub(client, 'createClient')
        .callsFake(() => untypedClient);
    });
    afterEach(() => {
      connectSpy.restore();
      createClient.restore();
    });
    it('should publish stringified message to pattern name', () => {
      client['publish'](msg, () => {});
      expect(publishSpy.getCall(0).args[0]).to.be.eql(pattern);
    });
    describe('on error', () => {
      let assignPacketIdStub: sinon.SinonStub;
      beforeEach(() => {
        assignPacketIdStub = sinon
          .stub(client, 'assignPacketId' as any)
          .callsFake(() => {
            throw new Error();
          });
      });
      afterEach(() => {
        assignPacketIdStub.restore();
      });

      it('should call callback', () => {
        const callback = sinon.spy();
        client['publish'](msg, callback);

        expect(callback.called).to.be.true;
        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);
      });
    });
    describe('dispose callback', () => {
      let assignStub: sinon.SinonStub;
      let callback: sinon.SinonSpy, subscription;

      beforeEach(async () => {
        callback = sinon.spy();
        assignStub = sinon
          .stub(client, 'assignPacketId' as any)
          .callsFake(packet => Object.assign(packet as object, { id }));

        subscription = client['publish'](msg, callback);
        subscription();
      });
      afterEach(() => {
        assignStub.restore();
      });

      it('should unsubscribe', () => {
        expect(unsubscribeSpy.called).to.be.true;
      });
    });

    describe('headers', () => {
      it('should not generate headers if none are configured', () => {
        client['publish'](msg, () => {});
        expect(natsClient.publish.getCall(0).args[2].headers).to.be.undefined;
      });

      it('should send packet headers', () => {
        const requestHeaders = createHeaders();
        requestHeaders.set('1', '123');
        msg.data = new NatsRecord('data', requestHeaders);

        client['publish'](msg, () => {});
        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(
          '123',
        );
      });
      it('should combine packet and static headers', () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = createHeaders();
        requestHeaders.set('1', '123');
        msg.data = new NatsRecord('data', requestHeaders);

        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2].headers.get('client-id')).to.eql(
          'some-client-id',
        );
        expect(publishSpy.getCall(0).args[2].headers.get('1')).to.eql('123');
      });

      it('should prefer packet headers over static headers', () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = createHeaders();
        requestHeaders.set('client-id', 'override-client-id');
        msg.data = new NatsRecord('data', requestHeaders);

        client['publish'](msg, () => {});
        expect(publishSpy.getCall(0).args[2].headers.get('client-id')).to.eql(
          'override-client-id',
        );
      });
    });
  });

  describe('createSubscriptionHandler', () => {
    const pattern = 'test';
    const msg = { pattern, data: 'data', id: '1' };
    const responseMessage = {
      response: 'test',
      id: '1',
    };
    const natsMessage = {
      data: JSONCodec().encode(responseMessage),
    };

    let callback: sinon.SinonSpy, subscription;

    describe('not completed', () => {
      beforeEach(async () => {
        callback = sinon.spy();

        subscription = client.createSubscriptionHandler(msg, callback);
        subscription(undefined, natsMessage);
      });
      it('should call callback with expected arguments', () => {
        expect(
          callback.calledWith({
            err: undefined,
            response: responseMessage.response,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is correct', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createSubscriptionHandler(msg, callback);
        subscription(undefined, {
          data: JSONCodec().encode({
            ...responseMessage,
            isDisposed: true,
          }),
        });
      });

      it('should call callback with dispose param', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            isDisposed: true,
            response: responseMessage.response,
            err: undefined,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is incorrect', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createSubscriptionHandler(
          {
            ...msg,
            id: '2',
          },
          callback,
        );
        subscription(undefined, {
          data: JSONCodec().encode({
            ...responseMessage,
            isDisposed: true,
          }),
        });
      });

      it('should not call callback', () => {
        expect(callback.called).to.be.false;
      });
    });
  });
  describe('close', () => {
    let natsClose: sinon.SinonSpy;
    let natsClient: any;

    beforeEach(() => {
      natsClose = sinon.spy();
      natsClient = { close: natsClose };
      untypedClient.natsClient = natsClient;
    });
    it('should close "natsClient" when it is not null', async () => {
      await client.close();
      expect(natsClose.called).to.be.true;
    });
  });
  describe('connect', () => {
    let createClientSpy: sinon.SinonSpy;
    let handleStatusUpdatesSpy: sinon.SinonSpy;

    beforeEach(async () => {
      createClientSpy = sinon
        .stub(client, 'createClient')
        .callsFake(() => Promise.resolve({}));
      handleStatusUpdatesSpy = sinon.spy(client, 'handleStatusUpdates');

      await client.connect();
    });
    afterEach(() => {
      createClientSpy.restore();
      handleStatusUpdatesSpy.restore();
    });
    describe('when is not connected', () => {
      beforeEach(async () => {
        client['natsClient'] = null;
        client['connectionPromise'] = null;
        await client.connect();
      });
      it('should call "handleStatusUpdatesSpy" once', async () => {
        expect(handleStatusUpdatesSpy.called).to.be.true;
      });
      it('should call "createClient" once', async () => {
        expect(createClientSpy.called).to.be.true;
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        client['natsClient'] = { test: true } as any;
        client['connection'] = Promise.resolve(true);
      });
      it('should not call "createClient"', () => {
        expect(createClientSpy.called).to.be.false;
      });
      it('should not call "handleStatusUpdatesSpy"', () => {
        expect(handleStatusUpdatesSpy.called).to.be.false;
      });
    });
  });
  describe('handleStatusUpdates', () => {
    it('should retrieve "status()" async iterator', () => {
      const clientMock = {
        status: sinon.stub().returns({
          [Symbol.asyncIterator]: [],
        }),
      };
      void client.handleStatusUpdates(clientMock as any);
      expect(clientMock.status.called).to.be.true;
    });

    it('should log "disconnect" and "error" statuses as "errors"', async () => {
      const logErrorSpy = sinon.spy(untypedClient.logger, 'error');
      const clientMock = {
        status: sinon.stub().returns({
          async *[Symbol.asyncIterator]() {
            yield { type: 'disconnect', data: 'localhost' };
            yield { type: 'error', data: {} };
          },
        }),
      };
      await client.handleStatusUpdates(clientMock as any);
      expect(logErrorSpy.calledTwice).to.be.true;
      expect(
        logErrorSpy.calledWith(
          `NatsError: type: "disconnect", data: "localhost".`,
        ),
      );
      expect(
        logErrorSpy.calledWith(`NatsError: type: "disconnect", data: "{}".`),
      );
    });
    it('should log other statuses as "logs"', async () => {
      const logSpy = sinon.spy(untypedClient.logger, 'log');
      const clientMock = {
        status: sinon.stub().returns({
          async *[Symbol.asyncIterator]() {
            yield { type: 'non-disconnect', data: 'localhost' };
            yield { type: 'warn', data: {} };
          },
        }),
      };
      await client.handleStatusUpdates(clientMock as any);
      expect(logSpy.calledTwice).to.be.true;
      expect(
        logSpy.calledWith(
          `NatsStatus: type: "non-disconnect", data: "localhost".`,
        ),
      );
      expect(logSpy.calledWith(`NatsStatus: type: "warn", data: "{}".`));
    });
  });
  describe('dispatchEvent', () => {
    let msg: ReadPacket;
    let subscribeStub: sinon.SinonStub, natsClient: any;

    beforeEach(() => {
      client = new ClientNats({});
      untypedClient = client as any;

      msg = { pattern: 'pattern', data: 'data' };
      subscribeStub = sinon
        .stub()
        .callsFake((channel, options) => options.callback());
      natsClient = {
        publish: sinon.spy(),
        subscribe: subscribeStub,
      };
      untypedClient.natsClient = natsClient;
    });

    it('should publish packet', async () => {
      await client['dispatchEvent'](msg);

      expect(natsClient.publish.called).to.be.true;
    });

    it('should throw error', async () => {
      subscribeStub.callsFake((channel, options) =>
        options.callback(new Error()),
      );
      await client['dispatchEvent'](msg).catch(err =>
        expect(err).to.be.instanceOf(Error),
      );
    });

    describe('headers', () => {
      it('should not generate headers if none are configured', async () => {
        await client['dispatchEvent'](msg);
        expect(natsClient.publish.getCall(0).args[2].headers).to.be.undefined;
      });

      it('should send packet headers', async () => {
        const requestHeaders = createHeaders();
        requestHeaders.set('1', '123');
        msg.data = new NatsRecord('data', requestHeaders);

        await client['dispatchEvent'](msg);
        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(
          '123',
        );
      });

      it('should combine packet and static headers', async () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = createHeaders();
        requestHeaders.set('1', '123');
        msg.data = new NatsRecord('data', requestHeaders);

        await client['dispatchEvent'](msg);
        expect(
          natsClient.publish.getCall(0).args[2].headers.get('client-id'),
        ).to.eql('some-client-id');
        expect(natsClient.publish.getCall(0).args[2].headers.get('1')).to.eql(
          '123',
        );
      });

      it('should prefer packet headers over static headers', async () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = createHeaders();
        requestHeaders.set('client-id', 'override-client-id');
        msg.data = new NatsRecord('data', requestHeaders);

        await client['dispatchEvent'](msg);
        expect(
          natsClient.publish.getCall(0).args[2].headers.get('client-id'),
        ).to.eql('override-client-id');
      });
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-proxy-factory.spec.ts
================================================
import { expect } from 'chai';
import { ClientProxyFactory } from '../../client/client-proxy-factory';
import { ClientTCP } from '../../client/client-tcp';
import { Transport } from '../../enums/transport.enum';
import { ClientRedis } from '../../client/client-redis';
import { ClientNats } from '../../client/client-nats';
import { ClientMqtt } from '../../client/client-mqtt';
import { ClientGrpcProxy } from '../../client/client-grpc';
import { ClientRMQ } from '../../client/client-rmq';
import { ClientKafka } from '../../client/client-kafka';
import { join } from 'path';

describe('ClientProxyFactory', () => {
  describe('create', () => {
    it(`should create tcp client by default`, () => {
      const proxy = ClientProxyFactory.create({});
      expect(proxy instanceof ClientTCP).to.be.true;
    });

    it(`should create redis client`, () => {
      const proxy = ClientProxyFactory.create({ transport: Transport.REDIS });
      expect(proxy instanceof ClientRedis).to.be.true;
    });

    it(`should create nats client`, () => {
      const proxy = ClientProxyFactory.create({ transport: Transport.NATS });
      expect(proxy instanceof ClientNats).to.be.true;
    });

    it(`should create mqtt client`, () => {
      const proxy = ClientProxyFactory.create({ transport: Transport.MQTT });
      expect(proxy instanceof ClientMqtt).to.be.true;
    });

    it(`should create grpc client`, () => {
      const proxy = ClientProxyFactory.create({
        transport: Transport.GRPC,
        options: {
          protoPath: join(__dirname, './test.proto'),
          package: 'test',
        },
      });
      expect(proxy instanceof ClientGrpcProxy).to.be.true;
    });

    it(`should create rmq client`, () => {
      const proxy = ClientProxyFactory.create({ transport: Transport.RMQ });
      expect(proxy instanceof ClientRMQ).to.be.true;
    });

    it(`should create kafka client`, () => {
      const proxy = ClientProxyFactory.create({ transport: Transport.KAFKA });
      expect(proxy instanceof ClientKafka).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-proxy.spec.ts
================================================
import { expect } from 'chai';
import { Observable } from 'rxjs';
import * as sinon from 'sinon';
import { ClientProxy } from '../../client/client-proxy';
import { ReadPacket } from '../../interfaces';

class TestClientProxy extends ClientProxy {
  protected async dispatchEvent<T = any>(
    packet: ReadPacket<any>,
  ): Promise<any> {}

  public async connect() {
    return Promise.resolve();
  }

  public unwrap<T>(): T {
    throw new Error('Method not implemented.');
  }

  public publish(pattern, callback): any {}
  public async close() {}
}

describe('ClientProxy', function () {
  this.retries(10);

  let client: TestClientProxy;
  beforeEach(() => {
    client = new TestClientProxy();
  });

  describe('createObserver', () => {
    describe('returned function calls', () => {
      it(`"error" when first parameter is not null or undefined`, () => {
        const testClient = new TestClientProxy();
        const err = 'test';
        const error = sinon.spy();
        const next = sinon.spy();
        const complete = sinon.spy();
        const observer = {
          error,
          next,
          complete,
        };
        const fn = testClient['createObserver'](observer);

        fn({ err });
        expect(error.calledWith(err)).to.be.true;
      });

      it(`"next" when first parameter is null or undefined`, () => {
        const testClient = new TestClientProxy();
        const data = 'test';
        const error = sinon.spy();
        const next = sinon.spy();
        const complete = sinon.spy();
        const observer = {
          error,
          next,
          complete,
        };
        const fn = testClient['createObserver'](observer);

        fn({ response: data });
        expect(next.calledWith(data)).to.be.true;
      });

      it(`"complete" when third parameter is true`, () => {
        const testClient = new TestClientProxy();
        const data = 'test';
        const error = sinon.spy();
        const next = sinon.spy();
        const complete = sinon.spy();
        const observer = {
          error,
          next,
          complete,
        };
        const fn = testClient['createObserver'](observer);

        fn({ data, isDisposed: true } as any);
        expect(complete.called).to.be.true;
      });
    });
  });

  describe('send', () => {
    it(`should return an observable stream`, () => {
      const stream$ = client.send({}, '');
      expect(stream$ instanceof Observable).to.be.true;
    });
    it('should call "connect" on subscribe', () => {
      const connectSpy = sinon.spy(client, 'connect');
      const stream$ = client.send({ test: 3 }, 'test');

      stream$.subscribe();
      expect(connectSpy.calledOnce).to.be.true;
    });
    describe('when "connect" throws', () => {
      it('should return Observable with error', () => {
        sinon.stub(client, 'connect').callsFake(() => {
          throw new Error();
        });
        const stream$ = client.send({ test: 3 }, 'test');
        stream$.subscribe({
          next: () => {},
          error: err => {
            expect(err).to.be.instanceof(Error);
          },
        });
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        sinon.stub(client, 'connect').callsFake(() => Promise.resolve());
      });
      it(`should call "publish"`, () => {
        const pattern = { test: 3 };
        const data = 'test';
        const publishSpy = sinon.spy();
        const stream$ = client.send(pattern, data);
        client.publish = publishSpy;

        stream$.subscribe(() => {
          expect(publishSpy.calledOnce).to.be.true;
        });
      });
    });
    it('should return Observable with error', () => {
      const err$ = client.send(null, null);
      expect(err$).to.be.instanceOf(Observable);
    });
  });

  describe('emit', () => {
    it(`should return an observable stream`, () => {
      const stream$ = client.emit({}, '');
      expect(stream$ instanceof Observable).to.be.true;
    });
    it('should call "connect" immediately', () => {
      const connectSpy = sinon.spy(client, 'connect');
      client.emit({ test: 3 }, 'test');
      expect(connectSpy.calledOnce).to.be.true;
    });
    describe('when "connect" throws', () => {
      it('should return Observable with error', () => {
        sinon.stub(client, 'connect').callsFake(() => {
          throw new Error();
        });
        const stream$ = client.emit({ test: 3 }, 'test');
        stream$.subscribe({
          next: () => {},
          error: err => {
            expect(err).to.be.instanceof(Error);
          },
        });
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        sinon.stub(client, 'connect').callsFake(() => Promise.resolve());
      });
      it(`should call "dispatchEvent"`, () => {
        const pattern = { test: 3 };
        const data = 'test';
        const dispatchEventSpy = sinon
          .stub()
          .callsFake(() => Promise.resolve(true));
        const stream$ = client.emit(pattern, data);
        client['dispatchEvent'] = dispatchEventSpy;

        stream$.subscribe(() => {
          expect(dispatchEventSpy.calledOnce).to.be.true;
        });
      });
    });
    it('should return Observable with error', () => {
      const err$ = client.emit(null, null);
      expect(err$).to.be.instanceOf(Observable);
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-redis.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ClientRedis } from '../../client/client-redis';
import { RedisEventsMap } from '../../events/redis.events';

describe('ClientRedis', () => {
  const test = 'test';
  const client = new ClientRedis({});
  const untypedClient = client as any;

  describe('getRequestPattern', () => {
    it(`should leave pattern as it is`, () => {
      const expectedResult = test;
      expect(client.getRequestPattern(test)).to.equal(expectedResult);
    });
  });
  describe('getReplyPattern', () => {
    it(`should append ".reply" to string`, () => {
      const expectedResult = test + '.reply';
      expect(client.getReplyPattern(test)).to.equal(expectedResult);
    });
  });
  describe('publish', () => {
    const pattern = 'test';
    const msg = { pattern, data: 'data' };
    let subscribeSpy: sinon.SinonSpy,
      publishSpy: sinon.SinonSpy,
      onSpy: sinon.SinonSpy,
      removeListenerSpy: sinon.SinonSpy,
      unsubscribeSpy: sinon.SinonSpy,
      connectSpy: sinon.SinonSpy,
      sub: Record<string, Function>,
      pub: Record<string, Function>;

    beforeEach(() => {
      subscribeSpy = sinon.spy((name, fn) => fn());
      publishSpy = sinon.spy();
      onSpy = sinon.spy();
      removeListenerSpy = sinon.spy();
      unsubscribeSpy = sinon.spy();

      sub = {
        subscribe: subscribeSpy,
        on: (type, handler) => (type === 'subscribe' ? handler() : onSpy()),
        removeListener: removeListenerSpy,
        unsubscribe: unsubscribeSpy,
      };
      pub = { publish: publishSpy };
      untypedClient.subClient = sub;
      untypedClient.pubClient = pub;
      connectSpy = sinon.spy(client, 'connect');
    });
    afterEach(() => {
      connectSpy.restore();
    });
    it('should subscribe to response pattern name', () => {
      client['publish'](msg, () => {});
      expect(subscribeSpy.calledWith(`${pattern}.reply`)).to.be.true;
    });
    it('should publish stringified message to request pattern name', () => {
      client['publish'](msg, () => {});
      expect(publishSpy.calledWith(pattern, JSON.stringify(msg))).to.be.true;
    });
    describe('on error', () => {
      let assignPacketIdStub: sinon.SinonStub;
      beforeEach(() => {
        assignPacketIdStub = sinon
          .stub(client, 'assignPacketId' as any)
          .callsFake(() => {
            throw new Error();
          });
      });
      afterEach(() => {
        assignPacketIdStub.restore();
      });

      it('should call callback', () => {
        const callback = sinon.spy();
        client['publish'](msg, callback);

        expect(callback.called).to.be.true;
        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);
      });
    });
    describe('dispose callback', () => {
      let assignStub: sinon.SinonStub, getReplyPatternStub: sinon.SinonStub;
      let callback: sinon.SinonSpy, subscription;

      const channel = 'channel';
      const id = '1';

      beforeEach(async () => {
        callback = sinon.spy();
        assignStub = sinon
          .stub(client, 'assignPacketId' as any)
          .callsFake(packet => Object.assign(packet as object, { id }));

        getReplyPatternStub = sinon
          .stub(client, 'getReplyPattern')
          .callsFake(() => channel);
        subscription = client['publish'](msg, callback);
        subscription(channel, JSON.stringify({ isDisposed: true, id }));
      });
      afterEach(() => {
        assignStub.restore();
        getReplyPatternStub.restore();
      });

      it('should unsubscribe to response pattern name', () => {
        expect(unsubscribeSpy.calledWith(channel)).to.be.true;
      });
      it('should clean routingMap', () => {
        expect(client['routingMap'].has(id)).to.be.false;
      });
    });
  });
  describe('createResponseCallback', () => {
    let callback: sinon.SinonSpy, subscription; // : ReturnType<typeof client['createResponseCallback']>;
    const responseMessage = {
      response: 'test',
      id: '1',
    };

    describe('not completed', () => {
      beforeEach(async () => {
        callback = sinon.spy();

        subscription = client.createResponseCallback();
        client['routingMap'].set(responseMessage.id, callback);
        await subscription(
          'channel',
          Buffer.from(JSON.stringify(responseMessage)),
        );
      });
      it('should call callback with expected arguments', () => {
        expect(
          callback.calledWith({
            err: undefined,
            response: responseMessage.response,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is correct', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();
        client['routingMap'].set(responseMessage.id, callback);
        subscription(
          'channel',
          Buffer.from(
            JSON.stringify({
              ...responseMessage,
              isDisposed: responseMessage.response,
            }),
          ),
        );
      });

      it('should call callback with dispose param', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            isDisposed: true,
            response: responseMessage.response,
            err: undefined,
          }),
        ).to.be.true;
      });
    });
    describe('disposed and "id" is incorrect', () => {
      beforeEach(() => {
        callback = sinon.spy();
        subscription = client.createResponseCallback();
        subscription('channel', Buffer.from(JSON.stringify(responseMessage)));
      });

      it('should not call callback', () => {
        expect(callback.called).to.be.false;
      });
    });
  });
  describe('close', () => {
    const untypedClient = client as any;

    let pubClose: sinon.SinonSpy;
    let subClose: sinon.SinonSpy;
    let pub: any, sub: any;

    beforeEach(() => {
      pubClose = sinon.spy();
      subClose = sinon.spy();
      pub = { quit: pubClose };
      sub = { quit: subClose };
      untypedClient.pubClient = pub;
      untypedClient.subClient = sub;
    });
    it('should close "pub" when it is not null', () => {
      client.close();
      expect(pubClose.called).to.be.true;
    });
    it('should not close "pub" when it is null', () => {
      untypedClient.pubClient = null;
      client.close();
      expect(pubClose.called).to.be.false;
    });
    it('should close "sub" when it is not null', () => {
      client.close();
      expect(subClose.called).to.be.true;
    });
    it('should not close "sub" when it is null', () => {
      untypedClient.subClient = null;
      client.close();
      expect(subClose.called).to.be.false;
    });
  });
  describe('connect', () => {
    let createClientSpy: sinon.SinonSpy;
    let registerErrorListenerSpy: sinon.SinonSpy;

    beforeEach(async () => {
      createClientSpy = sinon.stub(client, 'createClient').callsFake(
        () =>
          ({
            on: () => null,
            addListener: () => null,
            removeListener: () => null,
            connect: () => Promise.resolve(),
          }) as any,
      );
      registerErrorListenerSpy = sinon.spy(client, 'registerErrorListener');

      await client.connect();
      client['pubClient'] = null;
    });
    afterEach(() => {
      createClientSpy.restore();
      registerErrorListenerSpy.restore();
    });
    it('should call "createClient" twice', () => {
      expect(createClientSpy.calledTwice).to.be.true;
    });
    it('should call "registerErrorListener" twice', () => {
      expect(registerErrorListenerSpy.calledTwice).to.be.true;
    });
  });
  describe('registerErrorListener', () => {
    it('should bind error event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        addListener: callback,
      };
      client.registerErrorListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(RedisEventsMap.ERROR);
    });
  });
  describe('registerEndListener', () => {
    it('should bind end event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerEndListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(RedisEventsMap.END);
    });
  });
  describe('registerReadyListener', () => {
    it('should bind ready event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerReadyListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(RedisEventsMap.READY);
    });
  });
  describe('registerReconnectListener', () => {
    it('should bind reconnect event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerReconnectListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(
        RedisEventsMap.RECONNECTING,
      );
    });
  });
  describe('getClientOptions', () => {
    it('should return options object with "retryStrategy" and call "createRetryStrategy"', () => {
      const createSpy = sinon.spy(client, 'createRetryStrategy');
      const { retryStrategy } = client.getClientOptions()!;
      try {
        retryStrategy!({} as any);
      } catch {
        // No empty
      }
      expect(createSpy.called).to.be.true;
    });
  });
  describe('createRetryStrategy', () => {
    describe('when is terminated', () => {
      it('should return undefined', () => {
        untypedClient.isManuallyClosed = true;
        const result = client.createRetryStrategy(0);
        expect(result).to.be.undefined;
      });
    });
    describe('when "retryAttempts" does not exist', () => {
      it('should return undefined', () => {
        untypedClient.isManuallyClosed = false;
        untypedClient.options.options = {};
        untypedClient.options.options.retryAttempts = undefined;
        const result = client.createRetryStrategy(1);
        expect(result).to.be.undefined;
      });
    });
    describe('when "attempts" count is max', () => {
      it('should return undefined', () => {
        untypedClient.isManuallyClosed = false;
        untypedClient.options.options = {};
        untypedClient.options.options.retryAttempts = 3;
        const result = client.createRetryStrategy(4);
        expect(result).to.be.undefined;
      });
    });
    describe('otherwise', () => {
      it('should return delay (ms)', () => {
        untypedClient.options = {};
        untypedClient.isManuallyClosed = false;
        untypedClient.options.retryAttempts = 3;
        untypedClient.options.retryDelay = 3;
        const result = client.createRetryStrategy(2);
        expect(result).to.be.eql(untypedClient.options.retryDelay);
      });
    });
  });
  describe('dispatchEvent', () => {
    const msg = { pattern: 'pattern', data: 'data' };
    let publishStub: sinon.SinonStub, pubClient;

    beforeEach(() => {
      publishStub = sinon.stub();
      pubClient = {
        publish: publishStub,
      };
      untypedClient.pubClient = pubClient;
    });

    it('should publish packet', async () => {
      publishStub.callsFake((a, b, c) => c());
      await client['dispatchEvent'](msg);

      expect(publishStub.called).to.be.true;
    });
    it('should throw error', async () => {
      publishStub.callsFake((a, b, c) => c(new Error()));
      client['dispatchEvent'](msg).catch(err =>
        expect(err).to.be.instanceOf(Error),
      );
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-rmq.spec.ts
================================================
import { expect } from 'chai';
import { EventEmitter } from 'events';
import { EMPTY } from 'rxjs';
import * as sinon from 'sinon';
import { ClientRMQ } from '../../client/client-rmq';
import { ReadPacket } from '../../interfaces';
import { RmqRecord } from '../../record-builders';

describe('ClientRMQ', function () {
  this.retries(10);

  let client: ClientRMQ;
  let untypedClient: any;

  describe('connect', () => {
    let createClientStub: sinon.SinonStub;
    let registerErrorListenerSpy: sinon.SinonSpy;
    let connect$Stub: sinon.SinonStub;

    beforeEach(async () => {
      client = new ClientRMQ({});
      untypedClient = client as any;

      createClientStub = sinon.stub(client, 'createClient').callsFake(() => ({
        addListener: () => ({}),
        removeListener: () => ({}),
      }));
      registerErrorListenerSpy = sinon.spy(client, 'registerErrorListener');
      connect$Stub = sinon.stub(client, 'connect$' as any).callsFake(() => ({
        subscribe: resolve => resolve(),
        toPromise() {
          return this;
        },
        pipe() {
          return this;
        },
      }));
      sinon
        .stub(client, 'mergeDisconnectEvent')
        .callsFake((_, source) => source);
    });
    describe('when is not connected', () => {
      beforeEach(async () => {
        try {
          client['client'] = null;
          await client.connect();
        } catch {
          // Ignore
        }
      });
      it('should call "registerErrorListener" once', async () => {
        expect(registerErrorListenerSpy.called).to.be.true;
      });
      it('should call "createClient" once', async () => {
        expect(createClientStub.called).to.be.true;
      });
      it('should call "connect$" once', async () => {
        expect(connect$Stub.called).to.be.true;
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        client['client'] = { test: true } as any;
        client['channel'] = { test: true };
      });
      it('should not call "createClient"', () => {
        expect(createClientStub.called).to.be.false;
      });
      it('should not call "registerErrorListener"', () => {
        expect(registerErrorListenerSpy.called).to.be.false;
      });
      it('should not call "connect$"', () => {
        expect(connect$Stub.called).to.be.false;
      });
    });
  });

  describe('createChannel', () => {
    let createChannelStub: sinon.SinonStub;
    let setupChannelStub: sinon.SinonStub;

    beforeEach(() => {
      setupChannelStub = sinon
        .stub(client, 'setupChannel')
        .callsFake((_, done) => done());
      createChannelStub = sinon.stub().callsFake(({ setup }) => setup());
      client['client'] = { createChannel: createChannelStub };
    });
    afterEach(() => {
      setupChannelStub.restore();
    });
    it('should call "createChannel" method of the client instance', async () => {
      await client.createChannel();
      expect(createChannelStub.called).to.be.true;
    });
    it('should call "setupChannel" method of the client instance', async () => {
      await client.createChannel();
      expect(setupChannelStub.called).to.be.true;
    });
  });

  describe('consumeChannel', () => {
    let consumeStub: sinon.SinonStub;
    const channel: any = {};

    beforeEach(() => {
      client['responseEmitter'] = new EventEmitter();
      consumeStub = sinon
        .stub()
        .callsFake((_, done) => done({ properties: { correlationId: 1 } }));

      channel.consume = consumeStub;
    });
    it('should call "consume" method of the channel instance', async () => {
      await client.consumeChannel(channel);
      expect(consumeStub.called).to.be.true;
    });
  });

  describe('setupChannel', () => {
    const queue = 'test';
    const queueOptions = {};
    const isGlobalPrefetchCount = true;
    const prefetchCount = 10;

    let consumeStub: sinon.SinonStub;
    let channel: any = {};

    beforeEach(() => {
      client['queue'] = queue;
      client['queueOptions'] = queueOptions;
      untypedClient['options'] = { isGlobalPrefetchCount, prefetchCount };

      channel = {
        assertQueue: sinon.spy(() => ({})),
        prefetch: sinon.spy(),
      };
      consumeStub = sinon.stub(client, 'consumeChannel').callsFake(() => null!);
    });
    afterEach(() => {
      consumeStub.restore();
    });
    it('should call "assertQueue" with queue and queue options when noAssert is false', async () => {
      client['noAssert'] = false;

      await client.setupChannel(channel, () => null);
      expect(channel.assertQueue.calledWith(queue, queueOptions)).to.be.true;
    });
    it('should not call "assertQueue" when noAssert is true', async () => {
      client['noAssert'] = true;

      await client.setupChannel(channel, () => null);
      expect(channel.assertQueue.called).not.to.be.true;
    });
    it('should call "prefetch" with prefetchCount and "isGlobalPrefetchCount"', async () => {
      await client.setupChannel(channel, () => null);
      expect(channel.prefetch.calledWith(prefetchCount, isGlobalPrefetchCount))
        .to.be.true;
    });
    it('should call "consumeChannel" method', async () => {
      await client.setupChannel(channel, () => null);
      expect(consumeStub.called).to.be.true;
    });
    it('should call "resolve" function', async () => {
      const resolve = sinon.spy();
      await client.setupChannel(channel, resolve);
      expect(resolve.called).to.be.true;
    });
  });

  describe('mergeDisconnectEvent', () => {
    it('should merge disconnect event', () => {
      const error = new Error();
      const instance: any = {
        on: (ev, callback) => callback(error),
        off: () => ({}),
      };
      client
        .mergeDisconnectEvent(instance, EMPTY)
        .subscribe({ error: (err: any) => expect(err).to.be.eql(error) });
    });
  });

  describe('publish', () => {
    const pattern = 'test';
    let msg: ReadPacket;
    let connectSpy: sinon.SinonSpy,
      sendToQueueStub: sinon.SinonStub,
      eventSpy: sinon.SinonSpy;

    beforeEach(() => {
      client = new ClientRMQ({});
      untypedClient = client as any;

      msg = { pattern, data: 'data' };
      connectSpy = sinon.spy(client, 'connect');
      eventSpy = sinon.spy();
      sendToQueueStub = sinon.stub().callsFake(() => ({ catch: sinon.spy() }));

      client['channel'] = {
        sendToQueue: sendToQueueStub,
      };
      client['responseEmitter'] = new EventEmitter();
      client['responseEmitter'].on(pattern, eventSpy);
    });

    afterEach(() => {
      connectSpy.restore();
    });

    it('should send message to a proper queue', () => {
      client['publish'](msg, () => {
        expect(sendToQueueStub.called).to.be.true;
        expect(sendToQueueStub.getCall(0).args[0]).to.be.eql(client['queue']);
      });
    });

    it('should send buffer from stringified message', () => {
      client['publish'](msg, () => {
        expect(sendToQueueStub.called).to.be.true;
        expect(sendToQueueStub.getCall(1).args[1]).to.be.eql(
          Buffer.from(JSON.stringify(msg)),
        );
      });
    });

    describe('dispose callback', () => {
      let unsubscribeSpy: sinon.SinonSpy, subscription;

      beforeEach(async () => {
        unsubscribeSpy = sinon.spy();
        client['responseEmitter'] = {
          removeListener: unsubscribeSpy,
          on: sinon.spy(),
        } as any as EventEmitter;

        subscription = client['publish'](msg, sinon.spy());
        subscription();
      });
      it('should unsubscribe', () => {
        expect(unsubscribeSpy.called).to.be.true;
      });
    });

    describe('headers', () => {
      it('should not generate headers if none are configured', () => {
        client['publish'](msg, () => {
          expect(sendToQueueStub.getCall(0).args[2].headers).to.be.undefined;
        });
      });

      it('should send packet headers', () => {
        const requestHeaders = { '1': '123' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        client['publish'](msg, () => {
          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(
            requestHeaders,
          );
        });
      });

      it('should combine packet and static headers', () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { '1': '123' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        client['publish'](msg, () => {
          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql({
            ...staticHeaders,
            ...requestHeaders,
          });
        });
      });

      it('should prefer packet headers over static headers', () => {
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { 'client-id': 'override-client-id' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        client['publish'](msg, () => {
          expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(
            requestHeaders,
          );
        });
      });
    });
  });

  describe('handleMessage', () => {
    describe('when error', () => {
      let callback: sinon.SinonSpy;

      beforeEach(() => {
        callback = sinon.spy();
      });
      it('should call callback with correct object', async () => {
        const packet = {
          err: true,
          response: 'test',
          isDisposed: false,
        };
        await client.handleMessage(packet, callback);
        expect(
          callback.calledWith({
            err: packet.err,
            response: 'test',
            isDisposed: true,
          }),
        ).to.be.true;
      });
    });
    describe('when disposed', () => {
      let callback: sinon.SinonSpy;

      beforeEach(() => {
        callback = sinon.spy();
      });
      it('should call callback with correct object', async () => {
        const packet = {
          response: 'test',
          isDisposed: true,
        };
        await client.handleMessage(packet, callback);
        expect(
          callback.calledWith({
            err: undefined,
            response: 'test',
            isDisposed: true,
          }),
        ).to.be.true;
      });
    });

    describe('when response', () => {
      let callback: sinon.SinonSpy;

      beforeEach(() => {
        callback = sinon.spy();
      });
      it('should call callback with correct object', async () => {
        const packet = {
          response: 'test',
          isDisposed: false,
        };
        await client.handleMessage(packet, callback);
        expect(
          callback.calledWith({
            err: undefined,
            response: packet.response,
          }),
        ).to.be.true;
      });
    });
  });

  describe('close', () => {
    let channelCloseSpy: sinon.SinonSpy;
    let clientCloseSpy: sinon.SinonSpy;
    beforeEach(() => {
      channelCloseSpy = sinon.spy();
      clientCloseSpy = sinon.spy();
      untypedClient.channel = { close: channelCloseSpy };
      untypedClient.client = { close: clientCloseSpy };
    });

    it('should close channel when it is not null', () => {
      client.close();
      expect(channelCloseSpy.called).to.be.true;
    });

    it('should close client when it is not null', () => {
      client.close();
      expect(clientCloseSpy.called).to.be.true;
    });
  });
  describe('dispatchEvent', () => {
    let msg: ReadPacket;
    let sendToQueueStub: sinon.SinonStub, channel;

    beforeEach(() => {
      client = new ClientRMQ({});
      untypedClient = client as any;

      msg = { pattern: 'pattern', data: 'data' };
      sendToQueueStub = sinon.stub();
      channel = {
        sendToQueue: sendToQueueStub,
      };
      untypedClient.channel = channel;
    });

    it('should publish packet', async () => {
      sendToQueueStub.callsFake((a, b, c, d) => d());
      await client['dispatchEvent'](msg);

      expect(sendToQueueStub.called).to.be.true;
    });
    it('should throw error', async () => {
      sendToQueueStub.callsFake((a, b, c, d) => d(new Error()));
      client['dispatchEvent'](msg).catch(err =>
        expect(err).to.be.instanceOf(Error),
      );
    });

    describe('headers', () => {
      it('should not generate headers if none are configured', async () => {
        sendToQueueStub.callsFake((a, b, c, d) => d());
        await client['dispatchEvent'](msg);
        expect(sendToQueueStub.getCall(0).args[2].headers).to.be.undefined;
      });

      it('should send packet headers', async () => {
        sendToQueueStub.callsFake((a, b, c, d) => d());
        const requestHeaders = { '1': '123' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        await client['dispatchEvent'](msg);
        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(
          requestHeaders,
        );
      });

      it('should combine packet and static headers', async () => {
        sendToQueueStub.callsFake((a, b, c, d) => d());
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { '1': '123' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        await client['dispatchEvent'](msg);
        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql({
          ...staticHeaders,
          ...requestHeaders,
        });
      });

      it('should prefer packet headers over static headers', async () => {
        sendToQueueStub.callsFake((a, b, c, d) => d());
        const staticHeaders = { 'client-id': 'some-client-id' };
        untypedClient.options.headers = staticHeaders;

        const requestHeaders = { 'client-id': 'override-client-id' };
        msg.data = new RmqRecord('data', { headers: requestHeaders });

        await client['dispatchEvent'](msg);
        expect(sendToQueueStub.getCall(0).args[2].headers).to.eql(
          requestHeaders,
        );
      });
    });
  });
});



================================================
FILE: packages/microservices/test/client/client-tcp.spec.ts
================================================
import { expect } from 'chai';
import { Socket as NetSocket } from 'net';
import * as sinon from 'sinon';
import { TLSSocket } from 'tls';
import { ClientTCP } from '../../client/client-tcp';
import { TcpEventsMap } from '../../events/tcp.events';

describe('ClientTCP', () => {
  let client: ClientTCP;
  let untypedClient: any;
  let socket: any;
  let createSocketStub: sinon.SinonStub;

  beforeEach(() => {
    client = new ClientTCP({});
    untypedClient = client as any;

    const onFakeCallback = (event, callback) =>
      event !== 'error' && event !== 'close' && callback({});

    socket = {
      connect: sinon.stub(),
      on: sinon.stub().callsFake(onFakeCallback),
      netSocket: {
        addListener: sinon.stub().callsFake(onFakeCallback),
        removeListener: sinon.spy(),
        once: sinon.stub().callsFake(onFakeCallback),
      },
      sendMessage: sinon.spy(),
      end: sinon.spy(),
    };
    createSocketStub = sinon
      .stub(client, 'createSocket')
      .callsFake(() => socket);
  });
  afterEach(() => {
    createSocketStub.restore();
  });
  describe('publish', () => {
    let msg;
    beforeEach(() => {
      msg = { test: 3 };
      client['isConnected'] = true;
      client['socket'] = socket;
    });
    it('should send message', () => {
      client['publish'](msg, () => ({}));
    });
    describe('on dispose', () => {
      it('should remove listener from routing map', () => {
        client['publish'](msg, () => ({}))();

        expect(client['routingMap'].size).to.be.eq(0);
      });
    });
    describe('on error', () => {
      it('should call callback', () => {
        const callback = sinon.spy();
        sinon.stub(client, 'assignPacketId' as any).callsFake(() => {
          throw new Error();
        });
        client['publish'](msg, callback);
        expect(callback.called).to.be.true;
        expect(callback.getCall(0).args[0].err).to.be.instanceof(Error);
      });
    });
  });
  describe('handleResponse', () => {
    let callback: sinon.SinonSpy;
    const id = '1';

    describe('when disposed', () => {
      beforeEach(async () => {
        callback = sinon.spy();
        client['routingMap'].set(id, callback);
        await client.handleResponse({ id, isDisposed: true });
      });
      it('should emit disposed callback', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            err: undefined,
            response: undefined,
            isDisposed: true,
          }),
        ).to.be.true;
      });
    });
    describe('when not disposed', () => {
      let buffer;
      beforeEach(async () => {
        buffer = { id, err: undefined, response: 'res' };
        callback = sinon.spy();
        client['routingMap'].set(id, callback);
        await client.handleResponse(buffer);
      });
      it('should not end server', () => {
        expect(socket.end.called).to.be.false;
      });
      it('should call callback with error and response data', () => {
        expect(callback.called).to.be.true;
        expect(
          callback.calledWith({
            err: buffer.err,
            response: buffer.response,
          }),
        ).to.be.true;
      });
    });
  });
  describe('connect', () => {
    let registerConnectListenerSpy: sinon.SinonSpy;
    let registerErrorListenerSpy: sinon.SinonSpy;
    let registerCloseListenerSpy: sinon.SinonSpy;
    let connect$Stub: sinon.SinonStub;

    beforeEach(async () => {
      registerConnectListenerSpy = sinon.spy(client, 'registerConnectListener');
      registerErrorListenerSpy = sinon.spy(client, 'registerErrorListener');
      registerCloseListenerSpy = sinon.spy(client, 'registerCloseListener');
    });
    afterEach(() => {
      registerConnectListenerSpy.restore();
      registerErrorListenerSpy.restore();
      registerCloseListenerSpy.restore;
    });
    describe('when is not connected', () => {
      beforeEach(async () => {
        client['isConnected'] = false;
        const source = {
          subscribe: ({ complete }) => complete(),
          pipe: () => source,
        };
        connect$Stub = sinon
          .stub(client, 'connect$' as any)
          .callsFake(() => source);
        await client.connect();
      });
      afterEach(() => {
        connect$Stub.restore();
      });
      it('should call "registerConnectListener" once', async () => {
        expect(registerConnectListenerSpy.called).to.be.true;
      });
      it('should call "registerErrorListener" once', async () => {
        expect(registerErrorListenerSpy.called).to.be.true;
      });
      it('should call "registerCloseListener" once', async () => {
        expect(registerCloseListenerSpy.called).to.be.true;
      });
      it('should call "createSocket" once', async () => {
        expect(createSocketStub.called).to.be.true;
      });
      it('should call "connect$" once', async () => {
        expect(connect$Stub.called).to.be.true;
      });
      it('should listen on messages', () => {
        expect(socket.on.called).to.be.true;
      });
    });
    describe('when is connected', () => {
      beforeEach(() => {
        client['isConnected'] = true;
      });
      it('should not call "createSocket"', () => {
        expect(createSocketStub.called).to.be.false;
      });
      it('should not call "bindEvents"', () => {
        expect(registerConnectListenerSpy.called).to.be.false;
      });
    });
  });
  describe('close', () => {
    let routingMap: Map<string, Function>;
    let callback: sinon.SinonSpy;

    beforeEach(() => {
      routingMap = new Map<string, Function>();
      callback = sinon.spy();
      routingMap.set('some id', callback);

      untypedClient.socket = socket;
      untypedClient.routingMap = routingMap;
      client.close();
    });
    it('should end() socket', () => {
      expect(socket.end.called).to.be.true;
    });
    it('should set "socket" to null', () => {
      expect(untypedClient.socket).to.be.null;
    });
    it('should clear out the routing map', () => {
      expect(untypedClient.routingMap.size).to.be.eq(0);
    });
    it('should call callbacks', () => {
      expect(
        callback.calledWith({
          err: sinon.match({ message: 'Connection closed' }),
        }),
      ).to.be.true;
    });
  });
  describe('registerErrorListener', () => {
    it('should bind error event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerErrorListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(TcpEventsMap.ERROR);
    });
  });
  describe('registerCloseListener', () => {
    it('should bind close event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerCloseListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(TcpEventsMap.CLOSE);
    });
  });
  describe('registerConnectListener', () => {
    it('should bind connect event handler', () => {
      const callback = sinon.stub().callsFake((_, fn) => fn({ code: 'test' }));
      const emitter = {
        on: callback,
      };
      client.registerConnectListener(emitter as any);
      expect(callback.getCall(0).args[0]).to.be.eql(TcpEventsMap.CONNECT);
    });
  });
  describe('dispatchEvent', () => {
    const msg = { pattern: 'pattern', data: 'data' };
    let sendMessageStub: sinon.SinonStub, internalSocket;

    beforeEach(() => {
      sendMessageStub = sinon.stub();
      internalSocket = {
        sendMessage: sendMessageStub,
      };
      untypedClient.socket = internalSocket;
    });

    it('should publish packet', async () => {
      await client['dispatchEvent'](msg);

      expect(sendMessageStub.called).to.be.true;
    });
  });

  describe('tls', () => {
    it('should upgrade to TLS', () => {
      const client = new ClientTCP({ tlsOptions: {} });
      const jsonSocket = client.createSocket();
      expect(jsonSocket.socket).instanceOf(TLSSocket);
    });
    it('should not upgrade to TLS, if not requested', () => {
      const jsonSocket = new ClientTCP({}).createSocket();
      expect(jsonSocket.socket).instanceOf(NetSocket);
    });
  });
});



================================================
FILE: packages/microservices/test/client/test.proto
================================================
syntax = "proto3";

package test;

service TestService {

}



================================================
FILE: packages/microservices/test/client/test2.proto
================================================
syntax = "proto3";

package test2;

service TestService {

}



================================================
FILE: packages/microservices/test/context/exception-filters-context.spec.ts
================================================
import { NestContainer } from '@nestjs/core/injector/container';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Catch } from '../../../common/decorators/core/catch.decorator';
import { UseFilters } from '../../../common/decorators/core/exception-filters.decorator';
import { ApplicationConfig } from '../../../core/application-config';
import { InstanceWrapper } from '../../../core/injector/instance-wrapper';
import { ExceptionFiltersContext } from '../../context/exception-filters-context';

describe('ExceptionFiltersContext', () => {
  let applicationConfig: ApplicationConfig;
  let exceptionFilter: ExceptionFiltersContext;

  class CustomException {}
  @Catch(CustomException)
  class ExceptionFilter {
    public catch(exc, res) {}
  }

  beforeEach(() => {
    applicationConfig = new ApplicationConfig();
    exceptionFilter = new ExceptionFiltersContext(
      new NestContainer(),
      applicationConfig as any,
    );
  });
  describe('create', () => {
    describe('when filters metadata is empty', () => {
      class EmptyMetadata {}
      beforeEach(() => {
        sinon.stub(exceptionFilter, 'createContext').returns([]);
      });
      it('should return plain ExceptionHandler object', () => {
        const filter = exceptionFilter.create(
          new EmptyMetadata(),
          () => ({}) as any,
          undefined!,
        );
        expect((filter as any).filters).to.be.empty;
      });
    });
    describe('when filters metadata is not empty', () => {
      @UseFilters(new ExceptionFilter())
      class WithMetadata {}

      it('should return ExceptionHandler object with exception filters', () => {
        const filter = exceptionFilter.create(
          new WithMetadata(),
          () => ({}) as any,
          undefined!,
        );
        expect((filter as any).filters).to.not.be.empty;
      });
    });
  });

  describe('getGlobalMetadata', () => {
    describe('when contextId is static and inquirerId is nil', () => {
      it('should return global filters', () => {
        const expectedResult = applicationConfig.getGlobalFilters();
        expect(exceptionFilter.getGlobalMetadata()).to.be.equal(expectedResult);
      });
    });
    describe('otherwise', () => {
      it('should merge static global with request/transient scoped filters', () => {
        const globalFilters: any = ['test'];
        const instanceWrapper = new InstanceWrapper();
        const instance = 'request-scoped';
        const scopedFilterWrappers = [instanceWrapper];

        sinon
          .stub(applicationConfig, 'getGlobalFilters')
          .callsFake(() => globalFilters);
        sinon
          .stub(applicationConfig, 'getGlobalRequestFilters')
          .callsFake(() => scopedFilterWrappers);
        sinon
          .stub(instanceWrapper, 'getInstanceByContextId')
          .callsFake(() => ({ instance }) as any);

        expect(exceptionFilter.getGlobalMetadata({ id: 3 })).to.contains(
          instance,
          ...globalFilters,
        );
      });
    });
  });
});



================================================
FILE: packages/microservices/test/context/request-context-host.spec.ts
================================================
import { expect } from 'chai';
import { RequestContextHost } from '../../context/request-context-host';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';

describe('RequestContextHost', () => {
  const data = { test: true };
  const pattern = 'test';
  const ctx = new BaseRpcContext([]);

  let ctxHost: RequestContextHost;
  beforeEach(() => {
    ctxHost = new RequestContextHost(pattern, data, ctx);
  });
  describe('getData', () => {
    it('should return "data" property', () => {
      expect(ctxHost.getData()).to.be.eql(data);
    });
  });
  describe('getContext', () => {
    it('should return "context" property', () => {
      expect(ctxHost.getContext()).to.be.eql(ctx);
    });
  });
  describe('getPattern', () => {
    it('should return "pattern" property', () => {
      expect(ctxHost.getPattern()).to.be.eql(pattern);
    });
  });
});



================================================
FILE: packages/microservices/test/context/rpc-context-creator.spec.ts
================================================
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { Injectable, UseGuards, UsePipes } from '../../../common';
import { CUSTOM_ROUTE_ARGS_METADATA } from '../../../common/constants';
import { ApplicationConfig } from '../../../core/application-config';
import { GuardsConsumer } from '../../../core/guards/guards-consumer';
import { GuardsContextCreator } from '../../../core/guards/guards-context-creator';
import { NestContainer } from '../../../core/injector/container';
import { InterceptorsConsumer } from '../../../core/interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '../../../core/interceptors/interceptors-context-creator';
import { PipesConsumer } from '../../../core/pipes/pipes-consumer';
import { PipesContextCreator } from '../../../core/pipes/pipes-context-creator';
import { ExceptionFiltersContext } from '../../context/exception-filters-context';
import { RpcContextCreator } from '../../context/rpc-context-creator';
import { RpcProxy } from '../../context/rpc-proxy';
import { RpcParamtype } from '../../enums/rpc-paramtype.enum';
import { RpcParamsFactory } from '../../factories/rpc-params-factory';
import { RpcException } from '../../index';

@Injectable()
class TestGuard {
  canActivate: () => true;
}

@Injectable()
class TestPipe {
  transform(val) {
    return val;
  }
}

describe('RpcContextCreator', () => {
  let contextCreator: RpcContextCreator;
  let rpcProxy: RpcProxy;
  let exceptionFiltersContext: ExceptionFiltersContext;
  let pipesCreator: PipesContextCreator;
  let pipesConsumer: PipesConsumer;
  let guardsContextCreator: GuardsContextCreator;
  let guardsConsumer: GuardsConsumer;
  let instance: Test;
  let module: string;

  @UseGuards(TestGuard)
  @Injectable()
  class Test {
    @UsePipes(new TestPipe())
    test(data: string) {
      return of(false);
    }
  }

  beforeEach(() => {
    const container: any = new NestContainer();
    rpcProxy = new RpcProxy();
    exceptionFiltersContext = new ExceptionFiltersContext(
      container,
      new ApplicationConfig() as any,
    );
    sinon.stub(rpcProxy, 'create').callsFake(a => a);

    pipesCreator = new PipesContextCreator(container);
    pipesConsumer = new PipesConsumer();
    guardsContextCreator = new GuardsContextCreator(container);
    guardsConsumer = new GuardsConsumer();
    contextCreator = new RpcContextCreator(
      rpcProxy,
      exceptionFiltersContext,
      pipesCreator as any,
      pipesConsumer as any,
      guardsContextCreator as any,
      guardsConsumer as any,
      new InterceptorsContextCreator(container) as any,
      new InterceptorsConsumer() as any,
    );

    instance = new Test();
    module = 'test';
  });
  describe('create', () => {
    it('should create exception handler', () => {
      const handlerCreateSpy = sinon.spy(exceptionFiltersContext, 'create');
      contextCreator.create(instance, instance.test, module, 'test');
      expect(
        handlerCreateSpy.calledWith(instance, instance.test as any, module),
      ).to.be.true;
    });
    it('should create pipes context', () => {
      const pipesCreateSpy = sinon.spy(pipesCreator, 'create');
      contextCreator.create(instance, instance.test, module, 'test');
      expect(pipesCreateSpy.calledWith(instance, instance.test as any, module))
        .to.be.true;
    });
    it('should create guards context', () => {
      const guardsCreateSpy = sinon.spy(guardsContextCreator, 'create');
      contextCreator.create(instance, instance.test, module, 'test');
      expect(guardsCreateSpy.calledWith(instance, instance.test, module)).to.be
        .true;
    });
    describe('when proxy called', () => {
      it('should call guards consumer `tryActivate`', async () => {
        const tryActivateSpy = sinon.spy(guardsConsumer, 'tryActivate');
        sinon
          .stub(guardsContextCreator, 'create')
          .callsFake(() => [{ canActivate: () => true }]);
        const proxy = contextCreator.create(
          instance,
          instance.test,
          module,
          'test',
        );
        const data = 'test';
        await proxy(data);

        expect(tryActivateSpy.called).to.be.true;
      });
      describe('when can not activate', () => {
        it('should throw forbidden exception', async () => {
          sinon
            .stub(guardsConsumer, 'tryActivate')
            .callsFake(async () => false);

          const proxy = contextCreator.create(
            instance,
            instance.test,
            module,
            'test',
          );
          const data = 'test';

          proxy(null, data).catch(err =>
            expect(err).to.be.instanceOf(RpcException),
          );
        });
      });
    });
  });

  describe('reflectCallbackParamtypes', () => {
    it('should return paramtypes array', () => {
      const paramtypes = contextCreator.reflectCallbackParamtypes(
        instance,
        instance.test,
      );
      expect(paramtypes).to.be.eql([String]);
    });
  });

  describe('createGuardsFn', () => {
    it('should throw exception when "tryActivate" returns false', () => {
      const guardsFn = contextCreator.createGuardsFn([null], null!, null!)!;
      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);
      guardsFn([]).catch(err => expect(err).to.not.be.undefined);
    });
  });

  describe('exchangeKeysForValues', () => {
    it('should exchange arguments keys for appropriate values', () => {
      const metadata = {
        [RpcParamtype.PAYLOAD]: { index: 0, data: 'test', pipes: [] },
        [RpcParamtype.CONTEXT]: { index: 2, data: 'test', pipes: [] },
        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {
          index: 3,
          data: 'custom',
          pipes: [],
        },
      };
      const keys = Object.keys(metadata);
      const values = contextCreator.exchangeKeysForValues(
        keys,
        metadata,
        '',
        new RpcParamsFactory(),
        (args: unknown[]) => new ExecutionContextHost(args),
      );
      const expectedValues = [
        { index: 0, type: RpcParamtype.PAYLOAD, data: 'test' },
        { index: 2, type: RpcParamtype.CONTEXT, data: 'test' },
        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },
      ];
      expect(values[0]).to.deep.include(expectedValues[0]);
      expect(values[1]).to.deep.include(expectedValues[1]);
      expect(values[2]).to.deep.include(expectedValues[2]);
    });
  });
  describe('getParamValue', () => {
    let consumerApplySpy: sinon.SinonSpy;
    const value = 3,
      metatype = null,
      transforms = [{ transform: sinon.spy() }];

    beforeEach(() => {
      consumerApplySpy = sinon.spy(pipesConsumer, 'apply');
    });
    it('should call "consumer.apply"', async () => {
      await contextCreator.getParamValue(
        value,
        { metatype, type: RpcParamtype.PAYLOAD, data: null },
        transforms,
      );
      expect(consumerApplySpy.called).to.be.true;
    });
  });
  describe('createPipesFn', () => {
    describe('when "paramsOptions" is empty', () => {
      it('returns null', async () => {
        const pipesFn = contextCreator.createPipesFn([], []);
        expect(pipesFn).to.be.null;
      });
    });
    describe('when "paramsOptions" is not empty', () => {
      it('returns function', async () => {
        const pipesFn = contextCreator.createPipesFn(
          [],
          [
            {
              index: 1,
              type: 'test',
              data: null!,
              pipes: [],
              extractValue: () => null,
            },
          ],
        )!;
        await pipesFn([]);
        expect(pipesFn).to.be.a('function');
      });
    });
  });
});



================================================
FILE: packages/microservices/test/context/rpc-proxy.spec.ts
================================================
import { expect } from 'chai';
import { of, throwError } from 'rxjs';
import * as sinon from 'sinon';
import { RpcProxy } from '../../context/rpc-proxy';
import { RpcException } from '../../exceptions/rpc-exception';
import { RpcExceptionsHandler } from '../../exceptions/rpc-exceptions-handler';

describe('RpcProxy', () => {
  let routerProxy: RpcProxy;
  let handlerMock: sinon.SinonMock;
  let handler: RpcExceptionsHandler;

  beforeEach(() => {
    handler = new RpcExceptionsHandler();
    handlerMock = sinon.mock(handler);
    routerProxy = new RpcProxy();
  });

  describe('create', () => {
    it('should method return thunk', async () => {
      const proxy = routerProxy.create(async data => of(true), handler);
      expect(typeof proxy === 'function').to.be.true;
    });

    it('should method encapsulate callback passed as argument', async () => {
      const expectation = handlerMock.expects('handle').once();
      const proxy = routerProxy.create(async data => {
        throw new RpcException('test');
      }, handler);
      await proxy(null);
      expectation.verify();
    });

    it('should attach "catchError" operator when observable was returned', async () => {
      const expectation = handlerMock.expects('handle').once();
      const proxy = routerProxy.create(async (client, data) => {
        return throwError(() => new RpcException('test'));
      }, handler);
      (await proxy(null, null)).subscribe({
        error: () => expectation.verify(),
      });
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/base-rpc-context.spec.ts
================================================
import { expect } from 'chai';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';

describe('BaseRpcContext', () => {
  const args = [1, 2, 3];
  let rpcContext: BaseRpcContext;

  beforeEach(() => {
    rpcContext = new BaseRpcContext(args);
  });
  describe('getArgs', () => {
    it('should return "args" array', () => {
      expect(rpcContext.getArgs()).to.be.eql(args);
    });
  });
  describe('getArgByIndex', () => {
    it('should return argument by index', () => {
      expect(rpcContext.getArgByIndex(0)).to.be.eql(args[0]);
      expect(rpcContext.getArgByIndex(1)).to.be.eql(args[1]);
      expect(rpcContext.getArgByIndex(2)).to.be.eql(args[2]);
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/kafka.context.spec.ts
================================================
import { expect } from 'chai';
import { KafkaContext } from '../../ctx-host';
import {
  Consumer,
  KafkaMessage,
  Producer,
} from '../../external/kafka.interface';

describe('KafkaContext', () => {
  const args = [
    'test',
    { test: true },
    undefined,
    { test: 'consumer' },
    () => {},
    { test: 'producer' },
  ];
  let context: KafkaContext;

  beforeEach(() => {
    context = new KafkaContext(
      args as [
        KafkaMessage,
        number,
        string,
        Consumer,
        () => Promise<void>,
        Producer,
      ],
    );
  });
  describe('getTopic', () => {
    it('should return topic', () => {
      expect(context.getTopic()).to.be.eql(args[2]);
    });
  });
  describe('getPartition', () => {
    it('should return partition', () => {
      expect(context.getPartition()).to.be.eql(args[1]);
    });
  });
  describe('getMessage', () => {
    it('should return original message', () => {
      expect(context.getMessage()).to.be.eql(args[0]);
    });
  });
  describe('getConsumer', () => {
    it('should return consumer instance', () => {
      expect(context.getConsumer()).to.deep.eq({ test: 'consumer' });
    });
  });
  describe('getHeartbeat', () => {
    it('should return heartbeat callback', () => {
      expect(context.getHeartbeat()).to.be.eql(args[4]);
    });
  });
  describe('getProducer', () => {
    it('should return producer instance', () => {
      expect(context.getProducer()).to.deep.eq({ test: 'producer' });
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/mqtt.context.spec.ts
================================================
import { expect } from 'chai';
import { MqttContext } from '../../ctx-host';

describe('MqttContext', () => {
  const args = ['test', { test: true }];
  let context: MqttContext;

  beforeEach(() => {
    context = new MqttContext(args as [string, Record<string, any>]);
  });
  describe('getTopic', () => {
    it('should return topic', () => {
      expect(context.getTopic()).to.be.eql(args[0]);
    });
  });
  describe('getPacket', () => {
    it('should return packet', () => {
      expect(context.getPacket()).to.be.eql(args[1]);
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/nats.context.spec.ts
================================================
import { expect } from 'chai';
import { NatsContext } from '../../ctx-host';

describe('NatsContext', () => {
  const args: [string, any] = ['test', {}];
  let context: NatsContext;

  beforeEach(() => {
    context = new NatsContext(args);
  });
  describe('getSubject', () => {
    it('should return subject', () => {
      expect(context.getSubject()).to.be.eql(args[0]);
    });
  });
  describe('getHeaders', () => {
    it('should return headers', () => {
      expect(context.getHeaders()).to.be.eql(args[1]);
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/redis.context.spec.ts
================================================
import { expect } from 'chai';
import { RedisContext } from '../../ctx-host';

describe('RedisContext', () => {
  const args = ['test'];
  let context: RedisContext;

  beforeEach(() => {
    context = new RedisContext(args as [string]);
  });
  describe('getChannel', () => {
    it('should return original channel', () => {
      expect(context.getChannel()).to.be.eql(args[0]);
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/rmq.context.spec.ts
================================================
import { expect } from 'chai';
import { RmqContext } from '../../ctx-host';

describe('RmqContext', () => {
  const args = [{ test: true }, 'test', 'pattern'];
  let context: RmqContext;

  beforeEach(() => {
    context = new RmqContext(args as [Record<string, any>, any, string]);
  });
  describe('getMessage', () => {
    it('should return original message', () => {
      expect(context.getMessage()).to.be.eql(args[0]);
    });
  });
  describe('getChannelRef', () => {
    it('should return channel reference', () => {
      expect(context.getChannelRef()).to.be.eql(args[1]);
    });
  });
  describe('getPattern', () => {
    it('should return pattern', () => {
      expect(context.getPattern()).to.be.eql(args[2]);
    });
  });
});



================================================
FILE: packages/microservices/test/ctx-host/tcp.context.spec.ts
================================================
import { expect } from 'chai';
import { TcpContext } from '../../ctx-host';

describe('TcpContext', () => {
  const args = [{}, 'pattern'];
  let context: TcpContext;

  beforeEach(() => {
    context = new TcpContext(args as any);
  });
  describe('getSubject', () => {
    it('should return subject', () => {
      expect(context.getSocketRef()).to.be.eql(args[0]);
    });
  });
  describe('getPattern', () => {
    it('should return pattern', () => {
      expect(context.getPattern()).to.be.eql(args[1]);
    });
  });
});



================================================
FILE: packages/microservices/test/decorators/client.decorator.spec.ts
================================================
import 'mocha';
import { expect } from 'chai';
import {
  CLIENT_METADATA,
  CLIENT_CONFIGURATION_METADATA,
} from '../../constants';
import { Client } from '../../decorators/client.decorator';

describe('@Client', () => {
  const pattern = { role: 'test' };
  class TestComponent {
    @Client(pattern as any)
    public static instance;
  }
  it(`should enhance property with metadata`, () => {
    const isClient = Reflect.getOwnMetadata(
      CLIENT_METADATA,
      TestComponent,
      'instance',
    );
    const config = Reflect.getOwnMetadata(
      CLIENT_CONFIGURATION_METADATA,
      TestComponent,
      'instance',
    );

    expect(isClient).to.be.true;
    expect(config).to.be.eql(pattern);
  });
});



================================================
FILE: packages/microservices/test/decorators/ctx.decorator.spec.ts
================================================
import { expect } from 'chai';
import { PARAM_ARGS_METADATA } from '../../constants';
import { Ctx } from '../../decorators';
import { RpcParamtype } from '../../enums/rpc-paramtype.enum';

class CtxTest {
  public test(@Ctx() ctx: any) {}
}

describe('@Ctx', () => {
  it('should enhance class with expected request metadata', () => {
    const argsMetadata = Reflect.getMetadata(
      PARAM_ARGS_METADATA,
      CtxTest,
      'test',
    );
    const expectedMetadata = {
      [`${RpcParamtype.CONTEXT}:0`]: {
        data: undefined,
        index: 0,
        pipes: [],
      },
    };
    expect(argsMetadata).to.be.eql(expectedMetadata);
  });
});



================================================
FILE: packages/microservices/test/decorators/event-pattern.decorator.spec.ts
================================================
import { expect } from 'chai';
import {
  PATTERN_EXTRAS_METADATA,
  PATTERN_METADATA,
  TRANSPORT_METADATA,
} from '../../constants';
import { EventPattern } from '../../decorators/event-pattern.decorator';
import { Transport } from '../../enums/transport.enum';

describe('@EventPattern', () => {
  const pattern = { role: 'test' };
  const patternSecond = { role: 'test2' };
  const patternThird = { role: 'test3' };
  const extras = { param: 'value' };
  class TestComponent {
    @EventPattern(pattern, undefined, extras)
    public static test() {}

    @EventPattern(patternSecond, undefined, extras)
    @EventPattern(patternThird, undefined, extras)
    public static testOnlyThird() {}

    @EventPattern([patternSecond, patternThird], undefined, extras)
    public static testBoth() {}
  }
  it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
    const metadata = Reflect.getMetadata(PATTERN_METADATA, TestComponent.test);
    expect(metadata.length).to.equal(1);
    expect(metadata[0]).to.be.eql(pattern);
  });
  it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {
    const metadata = Reflect.getMetadata(
      PATTERN_EXTRAS_METADATA,
      TestComponent.test,
    );
    expect(metadata).to.be.deep.equal(extras);
  });
  it(`should enhance method with last ${PATTERN_METADATA} metadata`, () => {
    const metadata = Reflect.getMetadata(
      PATTERN_METADATA,
      TestComponent.testOnlyThird,
    );
    expect(metadata.length).to.equal(1);
    expect(metadata[0]).to.be.eql(patternSecond);
  });
  it(`should enhance method with both ${PATTERN_METADATA} metadata`, () => {
    const metadata = Reflect.getMetadata(
      PATTERN_METADATA,
      TestComponent.testBoth,
    );
    expect(metadata.length).to.equal(2);
    expect(metadata[0]).to.be.eql(patternSecond);
    expect(metadata[1]).to.be.eql(patternThird);
  });

  describe('decorator overloads', () => {
    const additionalExtras = { foo: 'bar' };

    class TestComponent1 {
      @EventPattern(pattern)
      public static test() {}
    }
    class TestComponent2 {
      @EventPattern(pattern, Transport.TCP)
      public static test() {}
    }
    class TestComponent3 {
      @EventPattern(pattern, extras)
      public static test() {}
    }
    class TestComponent4 {
      @EventPattern(pattern, Transport.TCP, extras)
      public static test() {}
    }
    class TestComponent5 {
      @EventPattern(pattern, Transport.TCP, extras)
      @((
        (): MethodDecorator => (_target, _key, descriptor) =>
          Reflect.defineMetadata(
            PATTERN_EXTRAS_METADATA,
            additionalExtras,
            descriptor.value!,
          )
      )())
      public static test() {}
    }

    it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent1.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent1.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent1.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.undefined;
      expect(extrasArg).to.be.eql({});
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent2.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent2.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent2.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql({});
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent3.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent3.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent3.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.undefined;
      expect(extrasArg).to.be.eql(extras);
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \
${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent4.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent4.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent4.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql(extras);
    });

    it(`should merge with existing ${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent5.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent5.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent5.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql({
        ...additionalExtras,
        ...extras,
      });
    });
  });
});



================================================
FILE: packages/microservices/test/decorators/message-pattern.decorator.spec.ts
================================================
import { expect } from 'chai';
import {
  PATTERN_EXTRAS_METADATA,
  PATTERN_METADATA,
  TRANSPORT_METADATA,
} from '../../constants';
import {
  GrpcMethod,
  GrpcMethodStreamingType,
  GrpcStreamCall,
  GrpcStreamMethod,
  MessagePattern,
} from '../../decorators/message-pattern.decorator';
import { Transport } from '../../enums/transport.enum';

describe('@MessagePattern', () => {
  const pattern = { role: 'test' };
  const extras = { param: 'value' };
  class TestComponent {
    @MessagePattern(pattern, undefined, extras)
    public static test() {}
  }
  it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
    const [metadata] = Reflect.getMetadata(
      PATTERN_METADATA,
      TestComponent.test,
    );
    expect(metadata).to.be.eql(pattern);
  });
  it(`should enhance method with ${PATTERN_EXTRAS_METADATA} metadata`, () => {
    const metadata = Reflect.getMetadata(
      PATTERN_EXTRAS_METADATA,
      TestComponent.test,
    );
    expect(metadata).to.be.deep.equal(extras);
  });

  describe('decorator overloads', () => {
    const additionalExtras = { foo: 'bar' };

    class TestComponent1 {
      @MessagePattern(pattern)
      public static test() {}
    }
    class TestComponent2 {
      @MessagePattern(pattern, Transport.TCP)
      public static test() {}
    }
    class TestComponent3 {
      @MessagePattern(pattern, extras)
      public static test() {}
    }
    class TestComponent4 {
      @MessagePattern(pattern, Transport.TCP, extras)
      public static test() {}
    }
    class TestComponent5 {
      @MessagePattern(pattern, Transport.TCP, extras)
      @((
        (): MethodDecorator => (_target, _key, descriptor) =>
          Reflect.defineMetadata(
            PATTERN_EXTRAS_METADATA,
            additionalExtras,
            descriptor.value!,
          )
      )())
      public static test() {}
    }

    it(`should enhance method with ${PATTERN_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent1.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent1.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent1.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.undefined;
      expect(extrasArg).to.be.eql({});
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent2.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent2.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent2.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql({});
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent3.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent3.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent3.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.undefined;
      expect(extrasArg).to.be.eql(extras);
    });

    it(`should enhance method with ${PATTERN_METADATA}, ${TRANSPORT_METADATA} and \
${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent4.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent4.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent4.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql(extras);
    });

    it(`should merge with existing ${PATTERN_EXTRAS_METADATA} metadata`, () => {
      const [metadataArg] = Reflect.getMetadata(
        PATTERN_METADATA,
        TestComponent5.test,
      );
      const transportArg = Reflect.getMetadata(
        TRANSPORT_METADATA,
        TestComponent5.test,
      );
      const extrasArg = Reflect.getMetadata(
        PATTERN_EXTRAS_METADATA,
        TestComponent5.test,
      );
      expect(metadataArg).to.be.eql(pattern);
      expect(transportArg).to.be.eql(Transport.TCP);
      expect(extrasArg).to.be.eql({
        ...additionalExtras,
        ...extras,
      });
    });
  });
});

describe('@GrpcMethod', () => {
  class TestService {
    @GrpcMethod()
    public test() {}

    @GrpcMethod('TestService2')
    public test2() {}

    @GrpcMethod('TestService2', 'Test2')
    public test3() {}
  }

  it('should derive method and service name', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
    expect(metadata).to.be.eql({
      service: TestService.name,
      rpc: 'Test',
      streaming: GrpcMethodStreamingType.NO_STREAMING,
    });
  });

  it('should derive method', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.NO_STREAMING,
    });
  });

  it('should override both method and service', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.NO_STREAMING,
    });
  });
});

describe('@GrpcStreamMethod', () => {
  class TestService {
    @GrpcStreamMethod()
    public test() {}

    @GrpcStreamMethod('TestService2')
    public test2() {}

    @GrpcStreamMethod('TestService2', 'Test2')
    public test3() {}
  }

  it('should derive method and service name', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
    expect(metadata).to.be.eql({
      service: TestService.name,
      rpc: 'Test',
      streaming: GrpcMethodStreamingType.RX_STREAMING,
    });
  });

  it('should derive method', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.RX_STREAMING,
    });
  });

  it('should override both method and service', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.RX_STREAMING,
    });
  });
});

describe('@GrpcStreamCall', () => {
  class TestService {
    @GrpcStreamCall()
    public test() {}

    @GrpcStreamCall('TestService2')
    public test2() {}

    @GrpcStreamCall('TestService2', 'Test2')
    public test3() {}
  }

  it('should derive method and service name', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test);
    expect(metadata).to.be.eql({
      service: TestService.name,
      rpc: 'Test',
      streaming: GrpcMethodStreamingType.PT_STREAMING,
    });
  });

  it('should derive method', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test2);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.PT_STREAMING,
    });
  });

  it('should override both method and service', () => {
    const svc = new TestService();
    const [metadata] = Reflect.getMetadata(PATTERN_METADATA, svc.test3);
    expect(metadata).to.be.eql({
      service: 'TestService2',
      rpc: 'Test2',
      streaming: GrpcMethodStreamingType.PT_STREAMING,
    });
  });
});



================================================
FILE: packages/microservices/test/decorators/payload.decorator.spec.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { expect } from 'chai';
import { PARAM_ARGS_METADATA } from '../../constants';
import { Payload } from '../../decorators';
import { RpcParamtype } from '../../enums/rpc-paramtype.enum';

class MessagePayloadTest {
  public test(@Payload(ValidationPipe) payload: any) {}
}

describe('@Payload', () => {
  it('should enhance class with expected request metadata', () => {
    const argsMetadata = Reflect.getMetadata(
      PARAM_ARGS_METADATA,
      MessagePayloadTest,
      'test',
    );
    const expectedMetadata = {
      [`${RpcParamtype.PAYLOAD}:0`]: {
        data: undefined,
        index: 0,
        pipes: [ValidationPipe],
      },
    };
    expect(argsMetadata).to.be.eql(expectedMetadata);
  });
});



================================================
FILE: packages/microservices/test/deserializers/identity.deserializer.spec.ts
================================================
import { expect } from 'chai';
import { IdentityDeserializer } from '../../deserializers/identity.deserializer';

describe('IdentityDeserializer', () => {
  let instance: IdentityDeserializer;
  beforeEach(() => {
    instance = new IdentityDeserializer();
  });
  describe('deserialize', () => {
    it('should return the value unchanged', () => {
      const value = {};
      expect(instance.deserialize(value)).to.be.eql(value);
    });
  });
});



================================================
FILE: packages/microservices/test/deserializers/incoming-request.deserializer.spec.ts
================================================
import { expect } from 'chai';
import { IncomingRequestDeserializer } from '../../deserializers/incoming-request.deserializer';
import { IncomingRequest } from '../../interfaces';

describe('IncomingRequestDeserializer', () => {
  let instance: IncomingRequestDeserializer;
  beforeEach(() => {
    instance = new IncomingRequestDeserializer();
  });
  describe('deserialize', () => {
    describe('when response is not external', () => {
      it('should return the same value unchanged', () => {
        const incomingRequest: IncomingRequest = {
          id: '1',
          pattern: 'pattern',
          data: [],
        };
        expect(instance.deserialize(incomingRequest)).to.be.equal(
          incomingRequest,
        );
      });
    });
    describe('otherwise', () => {
      describe('when options are passed in', () => {
        it('should map to the internal schema', () => {
          const externalRequest = {
            array: [1, 2, 3],
          };
          const options = {
            channel: 'test',
          };
          expect(
            instance.deserialize(externalRequest, options),
          ).to.be.deep.equal({
            pattern: options.channel,
            data: externalRequest,
          });
        });
      });
      describe('when options are undefined', () => {
        it('should map to proper schema with undefined values', () => {
          expect(instance.deserialize({})).to.be.deep.equal({
            pattern: undefined,
            data: undefined,
          });
        });
      });
    });
  });
});



================================================
FILE: packages/microservices/test/deserializers/incoming-response.deserializer.spec.ts
================================================
import { expect } from 'chai';
import { IncomingResponseDeserializer } from '../../deserializers/incoming-response.deserializer';
import { IncomingResponse } from '../../interfaces';

describe('IncomingResponseDeserializer', () => {
  let instance: IncomingResponseDeserializer;
  beforeEach(() => {
    instance = new IncomingResponseDeserializer();
  });
  describe('deserialize', () => {
    describe('when response is not external', () => {
      it('should return the same value unchanged', () => {
        const incomingResponse: IncomingResponse = {
          id: '1',
          response: {},
        };
        const errResponse: IncomingResponse = {
          id: '1',
          err: {},
        };
        expect(instance.deserialize(incomingResponse)).to.be.equal(
          incomingResponse,
        );
        expect(instance.deserialize(errResponse)).to.be.equal(errResponse);
      });
    });
    describe('otherwise', () => {
      it('should map to the internal schema', () => {
        const externalResponse = {
          id: '1',
          array: [1, 2, 3],
        };
        expect(instance.deserialize(externalResponse)).to.be.deep.equal({
          id: externalResponse.id,
          isDisposed: true,
          response: externalResponse,
        });
      });
    });
  });
});



================================================
FILE: packages/microservices/test/deserializers/kafka-response.deserializer.spec.ts
================================================
import { expect } from 'chai';
import { KafkaResponseDeserializer } from '../../deserializers/kafka-response.deserializer';
import { KafkaHeaders } from '../../enums/kafka-headers.enum';

describe('KafkaResponseDeserializer', () => {
  const id = '10';

  let instance: KafkaResponseDeserializer;
  beforeEach(() => {
    instance = new KafkaResponseDeserializer();
  });
  describe('serialize', () => {
    describe('when error header is present', () => {
      it('should return an object with "err"', () => {
        const err = new Error();
        const packet = instance.deserialize({
          headers: {
            [KafkaHeaders.CORRELATION_ID]: id,
            [KafkaHeaders.NEST_ERR]: err,
          },
        });
        expect(packet.id).to.be.equal(id);
        expect(packet.err).to.be.equal(err);
        expect(packet.isDisposed).to.be.true;
        expect(packet.response).to.be.undefined;
      });
    });
    describe('when is disposed header is present', () => {
      it('should return an object with "isDisposed"', () => {
        const value = 'test';
        const packet = instance.deserialize({
          headers: {
            [KafkaHeaders.CORRELATION_ID]: id,
            [KafkaHeaders.NEST_IS_DISPOSED]: true,
          },
          value,
        });
        expect(packet.id).to.be.equal(id);
        expect(packet.err).to.be.undefined;
        expect(packet.isDisposed).to.be.true;
        expect(packet.response).to.be.eql(value);
      });
    });
  });
});



================================================
FILE: packages/microservices/test/exceptions/rpc-exception.spec.ts
================================================
import { expect } from 'chai';
import { RpcException } from '../../exceptions/rpc-exception';

describe('RpcException', () => {
  describe('when string passed', () => {
    const error = 'test';
    const instance = new RpcException(error);

    it('should return error message as string', () => {
      expect(instance.getError()).to.be.eql(error);
    });
    it('should set the message property', () => {
      expect(instance.message).to.be.eql(error);
    });
  });

  describe('when object passed', () => {
    describe('and message property is undefined', () => {
      const error = { test: true };
      const instance = new RpcException(error);

      it('should return error as object', () => {
        expect(instance.getError()).to.be.eql(error);
      });
      it('should fallback error message to class name', () => {
        expect(instance.message).to.be.eql('Rpc Exception');
      });
    });
    describe('and message property is not undefined', () => {
      const error = { message: 'test', test: true };
      const instance = new RpcException(error);

      it('should return error as object', () => {
        expect(instance.getError()).to.be.eql(error);
      });
      it('should return error message as the extracted "message" string', () => {
        expect(instance.message).to.be.eql(error.message);
      });
    });
  });
});



================================================
FILE: packages/microservices/test/exceptions/rpc-exceptions-handler.spec.ts
================================================
import { expect } from 'chai';
import { EMPTY, of } from 'rxjs';
import { catchError } from 'rxjs/operators';
import * as sinon from 'sinon';
import { RpcException } from '../../exceptions/rpc-exception';
import { RpcExceptionsHandler } from '../../exceptions/rpc-exceptions-handler';

describe('RpcExceptionsHandler', () => {
  let handler: RpcExceptionsHandler;

  beforeEach(() => {
    handler = new RpcExceptionsHandler();
  });

  describe('handle', () => {
    it('should method returns expected stream with message when exception is unknown', done => {
      const stream$ = handler.handle(new Error(), null!);
      stream$
        .pipe(
          catchError((err: any) => {
            expect(err).to.be.eql({
              status: 'error',
              message: 'Internal server error',
            });
            done();
            return EMPTY;
          }),
        )
        .subscribe(() => ({}));
    });
    describe('when exception is instance of WsException', () => {
      it('should method emit expected status and json object', done => {
        const message = {
          custom: 'Unauthorized',
        };
        const stream$ = handler.handle(new RpcException(message), null!);
        stream$
          .pipe(
            catchError((err: any) => {
              expect(err).to.be.eql(message);
              done();
              return EMPTY;
            }),
          )
          .subscribe(() => ({}));
      });
      it('should method emit expected status and transform message to json', done => {
        const message = 'Unauthorized';

        const stream$ = handler.handle(new RpcException(message), null!);
        stream$
          .pipe(
            catchError((err: any) => {
              expect(err).to.be.eql({ message, status: 'error' });
              done();
              return EMPTY;
            }),
          )
          .subscribe(() => ({}));
      });
    });
    describe('when "invokeCustomFilters" returns observable', () => {
      const observable$ = of(true);
      beforeEach(() => {
        sinon.stub(handler, 'invokeCustomFilters').returns(observable$);
      });
      it('should return observable', () => {
        const result = handler.handle(new RpcException(''), null!);
        expect(result).to.be.eql(observable$);
      });
    });
  });
  describe('setCustomFilters', () => {
    const filters = ['test', 'test2'];
    it('should set custom filters', () => {
      handler.setCustomFilters(filters as any);
      expect((handler as any).filters).to.be.eql(filters);
    });
    it('should throw exception when passed argument is not an array', () => {
      expect(() => handler.setCustomFilters(null!)).to.throw();
    });
  });
  describe('invokeCustomFilters', () => {
    describe('when filters array is empty', () => {
      it('should return identity', () => {
        expect(handler.invokeCustomFilters(null, null!)).to.be.null;
      });
    });
    describe('when filters array is not empty', () => {
      let filters, funcSpy;
      class TestException {}

      beforeEach(() => {
        funcSpy = sinon.spy();
      });
      describe('when filter exists in filters array', () => {
        beforeEach(() => {
          filters = [{ exceptionMetatypes: [TestException], func: funcSpy }];
          (handler as any).filters = filters;
        });
        it('should call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.false;
        });
        it('should call funcSpy with exception and response passed as an arguments', () => {
          const exception = new TestException();
          handler.invokeCustomFilters(exception, null!);
          expect(funcSpy.calledWith(exception)).to.be.true;
        });
        it('should return stream', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .not.null;
        });
      });
      describe('when filter does not exists in filters array', () => {
        it('should not call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.true;
        });
        it('should return null', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .null;
        });
      });
    });
  });
});



================================================
FILE: packages/microservices/test/factories/rpc-params-factory.spec.ts
================================================
import { expect } from 'chai';
import { RpcParamtype } from '../../enums/rpc-paramtype.enum';
import { RpcParamsFactory } from '../../factories/rpc-params-factory';

describe('RpcParamsFactory', () => {
  let factory: RpcParamsFactory;
  beforeEach(() => {
    factory = new RpcParamsFactory();
  });
  describe('exchangeKeyForValue', () => {
    const ctx = {};
    const payload = { data: true };

    describe('when key is', () => {
      const args = [payload, ctx];
      describe(`RpcParamtype.PAYLOAD`, () => {
        it('should return a message payload object', () => {
          expect(
            factory.exchangeKeyForValue(RpcParamtype.PAYLOAD, null!, args),
          ).to.be.eql(payload);
        });
        it('should return a message payload object with parameter extraction', () => {
          expect(
            factory.exchangeKeyForValue(RpcParamtype.PAYLOAD, 'data', args),
          ).to.be.eql(payload.data);
        });
      });
      describe(`RpcParamtype.CONTEXT`, () => {
        it('should return a ctx object', () => {
          expect(
            factory.exchangeKeyForValue(RpcParamtype.CONTEXT, null!, args),
          ).to.be.eql(ctx);
        });
      });
    });
    describe('when key is not available', () => {
      it('should return null', () => {
        expect(factory.exchangeKeyForValue(-1, null!, [])).to.be.eql(null);
      });
    });
    describe('when args are not available', () => {
      it('should return null', () => {
        expect(factory.exchangeKeyForValue(null!, null!, null!)).to.be.eql(
          null,
        );
      });
    });
  });
});



================================================
FILE: packages/microservices/test/helpers/grpc-helpers.spec.ts
================================================
import { expect } from 'chai';
import { InvalidGrpcPackageDefinitionMissingPackageDefinitionException } from '../../errors/invalid-grpc-package-definition-missing-package-definition.exception';
import { InvalidGrpcPackageDefinitionMutexException } from '../../errors/invalid-grpc-package-definition-mutex.exception';
import { getGrpcPackageDefinition } from '../../helpers/grpc-helpers';

const grpcProtoLoaderPackage = { loadSync: (a, b) => 'withLoader' };

describe('getGrpcPackageDefinition', () => {
  describe('when missing both protoPath and packageDefinition', () => {
    it('should throw InvalidGrpcPackageDefinitionMissingPackageDefinitionException', () => {
      expect(() =>
        getGrpcPackageDefinition(
          {
            package: 'somePackage',
          },
          grpcProtoLoaderPackage,
        ),
      ).to.throw(InvalidGrpcPackageDefinitionMissingPackageDefinitionException);
    });
  });

  describe('when both protoPath and packageDefinition are defined', () => {
    it('should throw InvalidGrpcPackageDefinitionMutexException', () => {
      expect(() =>
        getGrpcPackageDefinition(
          {
            package: 'somePackage',
            protoPath: 'some/path',
            packageDefinition: {},
          },
          grpcProtoLoaderPackage,
        ),
      ).to.throw(InvalidGrpcPackageDefinitionMutexException);
    });
  });

  describe('when only protoPath is defined', () => {
    it('should not throw any exception', () => {
      expect(() =>
        getGrpcPackageDefinition(
          {
            package: 'somePackage',
            protoPath: 'some/path',
          },
          grpcProtoLoaderPackage,
        ),
      ).to.not.throw(Error);
    });
  });

  describe('when only packageDefinition is defined', () => {
    it('should not throw any exception', () => {
      expect(() =>
        getGrpcPackageDefinition(
          {
            package: 'somePackage',
            packageDefinition: {},
          },
          grpcProtoLoaderPackage,
        ),
      ).to.not.throw(Error);
    });
  });
});



================================================
FILE: packages/microservices/test/helpers/kafka-logger.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { logLevel } from '../../external/kafka.interface';
import { KafkaLogger } from '../../helpers/kafka-logger';

const namespace = 'namespace';
const label = 'label';
const entry = {
  message: 'message',
  other: {
    stuff: 'here',
  },
};

describe('KafkaLogger', () => {
  let kafkaLogger: any;

  let error: sinon.SinonSpy;
  let warn: sinon.SinonSpy;
  let log: sinon.SinonSpy;
  let debug: sinon.SinonSpy;

  beforeEach(() => {
    // set
    error = sinon.spy();
    warn = sinon.spy();
    log = sinon.spy();
    debug = sinon.spy();

    kafkaLogger = KafkaLogger({
      error,
      warn,
      log,
      debug,
    });
  });

  it('error', () => {
    kafkaLogger({
      namespace,
      level: logLevel.ERROR,
      label,
      log: entry,
    });

    expect(error.calledOnce).to.be.true;
    expect(error.args[0][0]).to.eq(
      'label [namespace] message {"other":{"stuff":"here"}}',
    );
  });

  it('nothing', () => {
    kafkaLogger({
      namespace,
      level: logLevel.NOTHING,
      label,
      log: entry,
    });

    expect(error.calledOnce).to.be.true;
  });

  it('warn', () => {
    kafkaLogger({
      namespace,
      level: logLevel.WARN,
      label,
      log: entry,
    });

    expect(warn.calledOnce).to.be.true;
  });

  it('info', () => {
    kafkaLogger({
      namespace,
      level: logLevel.INFO,
      label,
      log: entry,
    });

    expect(log.calledOnce).to.be.true;
  });

  it('debug', () => {
    kafkaLogger({
      namespace,
      level: logLevel.DEBUG,
      label,
      log: entry,
    });

    expect(debug.calledOnce).to.be.true;
  });
});



================================================
FILE: packages/microservices/test/helpers/kafka-parser.spec.ts
================================================
import { expect } from 'chai';
import { KafkaHeaders } from '../../enums/kafka-headers.enum';
import { KafkaParser } from '../../helpers/kafka-parser';

describe('KafkaParser', () => {
  describe('parse', () => {
    let kafkaParser: any;

    beforeEach(() => {
      kafkaParser = new KafkaParser();
    });

    it('undefined', () => {
      expect(
        kafkaParser.parse({
          value: undefined,
        }),
      ).to.deep.eq({
        headers: {},
        value: null,
      });
    });

    it('null', () => {
      expect(
        kafkaParser.parse({
          value: null,
        }),
      ).to.deep.eq({
        headers: {},
        value: null,
      });
    });

    it('buffer string', () => {
      expect(
        kafkaParser.parse({
          value: Buffer.from('string'),
        }),
      ).to.deep.eq({
        headers: {},
        value: 'string',
      });
    });

    it('binary buffer using kafka schema registry preamble', () => {
      const kafkaSchemaPreambleWithSchemaId = [0x00, 0x00, 0x00, 0x00, 0x01];
      expect(
        kafkaParser.parse({
          value: Buffer.from(kafkaSchemaPreambleWithSchemaId),
        }),
      ).to.deep.eq({
        headers: {},
        value: Buffer.from(kafkaSchemaPreambleWithSchemaId),
      });
    });

    it('buffer number', () => {
      expect(
        kafkaParser.parse({
          value: Buffer.from('12345'),
        }),
      ).to.deep.eq({
        headers: {},
        value: '12345',
      });
    });

    it('buffer bigint', () => {
      const long = '9007199254740992';

      expect(
        kafkaParser.parse({
          value: Buffer.from(long),
        }),
      ).to.deep.eq({
        headers: {},
        value: long,
      });
    });

    it('buffer json', () => {
      expect(
        kafkaParser.parse({
          value: Buffer.from(JSON.stringify({ prop: 'value' })),
        }),
      ).to.deep.eq({
        headers: {},
        value: {
          prop: 'value',
        },
      });
    });

    it('buffer json with key', () => {
      expect(
        kafkaParser.parse({
          value: Buffer.from(JSON.stringify({ prop: 'value' })),
          key: Buffer.from('1'),
        }),
      ).to.deep.eq({
        headers: {},
        key: '1',
        value: {
          prop: 'value',
        },
      });
    });

    it('buffer json with key and headers', () => {
      expect(
        kafkaParser.parse({
          headers: {
            [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),
          },
          value: Buffer.from(JSON.stringify({ prop: 'value' })),
          key: Buffer.from('1'),
        }),
      ).to.deep.eq({
        key: '1',
        value: {
          prop: 'value',
        },
        headers: {
          [KafkaHeaders.CORRELATION_ID]: 'correlation-id',
        },
      });
    });

    it('parse message multiple times (simulate retry)', () => {
      const message = {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),
        },
        value: Buffer.from(JSON.stringify({ prop: 'value' })),
        key: Buffer.from('1'),
      };
      const expectedParsedMessage = {
        key: '1',
        value: {
          prop: 'value',
        },
        headers: {
          [KafkaHeaders.CORRELATION_ID]: 'correlation-id',
        },
      };
      expect(kafkaParser.parse(message)).to.deep.eq(expectedParsedMessage);
      // Parse message again and verify it still works correctly
      expect(kafkaParser.parse(message)).to.deep.eq(expectedParsedMessage);
      // Verify message was not modified
      expect(message).to.deep.eq({
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from('correlation-id'),
        },
        value: Buffer.from(JSON.stringify({ prop: 'value' })),
        key: Buffer.from('1'),
      });
    });
  });
});



================================================
FILE: packages/microservices/test/helpers/kafka-reply-partition-assigner.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import * as Kafka from 'kafkajs';
import { KafkaReplyPartitionAssigner } from '../../helpers/kafka-reply-partition-assigner';
import { ClientKafka } from '../../client/client-kafka';

describe('kafka reply partition assigner', () => {
  let cluster, topics, metadata, assigner, client;

  let getConsumerAssignments: sinon.SinonSpy;
  let getPreviousAssignment: sinon.SinonSpy;

  beforeEach(() => {
    metadata = {};
    cluster = { findTopicPartitionMetadata: topic => metadata[topic] };
    client = new ClientKafka({});
    assigner = new KafkaReplyPartitionAssigner(client, { cluster });
    topics = ['topic-A', 'topic-B'];

    getConsumerAssignments = sinon.spy(client, 'getConsumerAssignments');
    getPreviousAssignment = sinon.spy(assigner, 'getPreviousAssignment');

    // reset previous assignments
    client.consumerAssignments = {};
  });

  describe('assign', () => {
    it('assign all partitions evenly', async () => {
      metadata['topic-A'] = Array(14)
        .fill(1)
        .map((_, i) => ({ partitionId: i }));

      metadata['topic-B'] = Array(5)
        .fill(1)
        .map((_, i) => ({ partitionId: i }));

      const members = [
        {
          memberId: 'member-3',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {},
              }),
            ),
          }),
        },
        {
          memberId: 'member-1',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {},
              }),
            ),
          }),
        },
        {
          memberId: 'member-4',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {},
              }),
            ),
          }),
        },
        {
          memberId: 'member-2',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {},
              }),
            ),
          }),
        },
      ];

      const assignment = await assigner.assign({ members, topics });

      expect(assignment).to.deep.equal([
        {
          memberId: 'member-1',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [0, 4, 8, 12],
              'topic-B': [0],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-2',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [1, 5, 9, 13],
              'topic-B': [1],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-3',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [2, 6, 10],
              'topic-B': [2, 4],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-4',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [3, 7, 11],
              'topic-B': [3],
            },
            userData: Buffer.alloc(0),
          }),
        },
      ]);
    });
  });

  describe('re-assign', () => {
    it('assign all partitions evenly', async () => {
      metadata['topic-A'] = Array(11)
        .fill(1)
        .map((_, i) => ({ partitionId: i }));

      metadata['topic-B'] = Array(7)
        .fill(1)
        .map((_, i) => ({ partitionId: i }));

      const members = [
        {
          memberId: 'member-3',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {
                  'topic-A': 0,
                  'topic-B': 0,
                },
              }),
            ),
          }),
        },
        {
          memberId: 'member-1',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {
                  'topic-A': 1,
                  'topic-B': 1,
                },
              }),
            ),
          }),
        },
        {
          memberId: 'member-4',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {
                  'topic-A': 2,
                },
              }),
            ),
          }),
        },
        {
          memberId: 'member-2',
          memberMetadata: Kafka.AssignerProtocol.MemberMetadata.encode({
            version: assigner.version,
            topics: ['topic-A', 'topic-B'],
            userData: Buffer.from(
              JSON.stringify({
                previousAssignment: {},
              }),
            ),
          }),
        },
      ];

      const assignment = await assigner.assign({ members, topics });

      expect(assignment).to.deep.equal([
        {
          memberId: 'member-1',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [1, 4, 8],
              'topic-B': [1, 5],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-2',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [3, 5, 9],
              'topic-B': [2, 6],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-3',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [0, 6, 10],
              'topic-B': [0],
            },
            userData: Buffer.alloc(0),
          }),
        },
        {
          memberId: 'member-4',
          memberAssignment: Kafka.AssignerProtocol.MemberAssignment.encode({
            version: assigner.version,
            assignment: {
              'topic-A': [2, 7],
              'topic-B': [3, 4],
            },
            userData: Buffer.alloc(0),
          }),
        },
      ]);
    });
  });

  describe('protocol', () => {
    it('returns the assigner name and metadata', () => {
      // set previous assignments
      client.consumerAssignments = {
        'topic-A': 0,
        'topic-B': 1,
      };

      const protocol = assigner.protocol({ topics });

      expect(getPreviousAssignment.calledOnce).to.be.true;
      expect(getConsumerAssignments.calledOnce).to.be.true;

      expect(protocol).to.deep.equal({
        name: assigner.name,
        metadata: Kafka.AssignerProtocol.MemberMetadata.encode({
          version: assigner.version,
          topics,
          userData: Buffer.from(
            JSON.stringify({
              previousAssignment: client.consumerAssignments,
            }),
          ),
        }),
      });
    });
  });
});



================================================
FILE: packages/microservices/test/json-socket/connection.spec.ts
================================================
import { expect } from 'chai';
import { AddressInfo, createServer, Socket } from 'net';
import { TcpEventsMap } from '../../events/tcp.events';
import { JsonSocket } from '../../helpers/json-socket';
import { longPayload } from './data/long-payload-with-special-chars';
import * as helpers from './helpers';
import { ip } from './helpers';

const MESSAGE_EVENT = 'message';

describe('JsonSocket connection', () => {
  it('should connect, send and receive message', done => {
    helpers.createServerAndClient(
      (error, server, clientSocket, serverSocket) => {
        if (error) {
          return done(error);
        }

        expect(clientSocket!['isClosed']).to.be.false;
        expect(serverSocket!['isClosed']).to.be.false;

        Promise.all([
          new Promise(callback => {
            clientSocket!.sendMessage({ type: 'ping' }, callback);
          }),
          new Promise<void>(callback => {
            clientSocket!.on(MESSAGE_EVENT, (message: string) => {
              expect(message).to.deep.equal({ type: 'pong' });
              callback();
            });
          }),
          new Promise(callback => {
            serverSocket!.on(MESSAGE_EVENT, (message: string) => {
              expect(message).to.deep.equal({ type: 'ping' });
              serverSocket!.sendMessage({ type: 'pong' }, callback);
            });
          }),
        ])
          .then(() => {
            expect(clientSocket!['isClosed']).to.equal(false);
            expect(serverSocket!['isClosed']).to.equal(false);
            clientSocket!.end();
            server!.close(done);
          })
          .catch(e => done(e));
      },
    );
  });

  it('should send long messages with special characters without issues', done => {
    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {
      if (err) {
        return done(err);
      }
      expect(clientSocket!['isClosed']).to.equal(false);
      expect(serverSocket!['isClosed']).to.equal(false);
      Promise.all([
        new Promise<void>(callback => {
          clientSocket!.sendMessage(longPayload, callback);
        }),
        new Promise<void>(callback => {
          clientSocket!.on(MESSAGE_EVENT, (message: { type: 'pong' }) => {
            expect(message).to.deep.equal({ type: 'pong' });
            callback();
          });
        }),
        new Promise<void>(callback => {
          serverSocket!.on(MESSAGE_EVENT, (message: { type: 'pong' }) => {
            expect(message).to.deep.equal(longPayload);
            serverSocket!.sendMessage({ type: 'pong' }, callback);
          });
        }),
      ])
        .then(() => {
          expect(clientSocket!['isClosed']).to.equal(false);
          expect(serverSocket!['isClosed']).to.equal(false);
          clientSocket!.end();
          server!.close(done);
        })
        .catch(e => done(e));
    });
  });

  it('should send multiple messages', done => {
    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {
      if (err) {
        return done(err);
      }
      Promise.all([
        new Promise<void>(callback =>
          Promise.all(
            helpers
              .range(1, 100)
              .map(
                i =>
                  new Promise(resolve =>
                    clientSocket!.sendMessage({ number: i }, resolve),
                  ),
              ),
          ).then(_ => callback()),
        ),
        new Promise<void>(callback => {
          let lastNumber = 0;
          serverSocket!.on(MESSAGE_EVENT, (message: { number: number }) => {
            expect(message.number).to.deep.equal(lastNumber + 1);
            lastNumber = message.number;
            if (lastNumber === 100) {
              callback();
            }
          });
        }),
      ])
        .then(() => {
          clientSocket!.end();
          server!.close(done);
        })
        .catch(e => done(e));
    });
  });

  it('should return true for "closed" when server disconnects', done => {
    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {
      if (err) {
        return done(err);
      }

      new Promise(callback => {
        serverSocket!.end();
        setTimeout(callback, 10);
      })
        .then(
          () =>
            new Promise<void>(callback => {
              expect(clientSocket!['isClosed']).to.equal(true);
              expect(serverSocket!['isClosed']).to.equal(true);
              callback();
            }),
        )
        .then(() => {
          clientSocket!.end();
          server!.close(done);
        })
        .catch(e => done(e));
    });
  });

  it('should return true for "closed" when client disconnects', done => {
    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {
      if (err) {
        return done(err);
      }

      new Promise(callback => {
        clientSocket!.end();
        setTimeout(callback, 10);
      })
        .then(
          () =>
            new Promise<void>(callback => {
              expect(clientSocket!['isClosed']).to.equal(true);
              expect(serverSocket!['isClosed']).to.equal(true);
              callback();
            }),
        )
        .then(() => server!.close(done))
        .catch(e => done(e));
    });
  });

  it('should return true for "closed" when client (re)connects', done => {
    const server = createServer();

    server.on('listening', () => {
      const clientSocket = new JsonSocket(new Socket());

      server.once('connection', socket => {
        const serverSocket = new JsonSocket(socket);

        serverSocket.once('end', () => {
          setTimeout(() => {
            expect(serverSocket['isClosed']).to.equal(true);
            expect(clientSocket['isClosed']).to.equal(true);

            clientSocket.on(TcpEventsMap.CONNECT, () => {
              setTimeout(() => {
                expect(clientSocket['isClosed']).to.equal(false);

                clientSocket.end();
                server.close(done);
              }, 10);
            });

            const address2 = server.address();
            if (!address2) {
              throw new Error('server.address() returned null');
            }
            const port2 = (address2 as AddressInfo).port;

            clientSocket.connect(port2, ip);
          }, 10);
        });

        clientSocket.end();
      });

      const address1 = server.address();
      if (!address1) {
        throw new Error('server.address() returned null');
      }
      const port1 = (address1 as AddressInfo).port;

      clientSocket.connect(port1, ip);
    });
    server.listen();
  });
});



================================================
FILE: packages/microservices/test/json-socket/helpers.ts
================================================
import {
  AddressInfo,
  createServer as netCreateServer,
  Server,
  Socket,
} from 'net';
import { TcpEventsMap } from '../../events/tcp.events';
import { JsonSocket } from '../../helpers/json-socket';

export const ip = '127.0.0.1';

export function createServer(callback: (err?: any, server?: Server) => void) {
  const server = netCreateServer();
  server.listen();

  server.on('listening', () => {
    callback(null, server);
  });

  server.on(TcpEventsMap.ERROR, (err: any) => {
    callback(err);
  });
}

export function createClient(
  server: Server,
  callback: (
    err?: any,
    clientSocket?: JsonSocket,
    serverSocket?: JsonSocket,
  ) => void,
) {
  const clientSocket = new JsonSocket(new Socket());

  const address = server.address();
  if (!address) {
    throw new Error('server.address() returned null');
  }
  const port = (address as AddressInfo).port;

  clientSocket.connect(port, ip);

  clientSocket.on(TcpEventsMap.ERROR, (err: any) => {
    callback(err);
  });

  server.once('connection', socket => {
    const serverSocket = new JsonSocket(socket);
    callback(null, clientSocket, serverSocket);
  });
}

export function createServerAndClient(
  callback: (
    err?: any,
    server?: Server,
    clientSocket?: JsonSocket,
    serverSocket?: JsonSocket,
  ) => void,
) {
  createServer((serverErr, server) => {
    if (serverErr) {
      return callback(serverErr);
    }

    createClient(server!, (clientErr, clientSocket, serverSocket) => {
      if (clientErr) {
        return callback(clientErr);
      }

      callback(null, server, clientSocket, serverSocket);
    });
  });
}

export function range(start: number, end: number) {
  const r = [] as number[];
  for (let i = start; i <= end; i++) {
    r.push(i);
  }
  return r;
}



================================================
FILE: packages/microservices/test/json-socket/listener-chaining.spec.ts
================================================
import { expect } from 'chai';
import { TcpEventsMap } from '../../events/tcp.events';
import { JsonSocket } from '../../helpers/json-socket';
import * as helpers from './helpers';

const MESSAGE_EVENT = 'message';

describe('JsonSocket chaining', () => {
  it('should return the instance when subscribing to event', done => {
    helpers.createServerAndClient((err, server, clientSocket, serverSocket) => {
      if (err) {
        return done(err);
      }

      expect(clientSocket!.on(MESSAGE_EVENT, () => {})).to.be.instanceof(
        JsonSocket,
      );
      expect(clientSocket!.on(TcpEventsMap.CONNECT, () => {})).to.deep.equal(
        clientSocket,
      );
      expect(
        clientSocket!.on(MESSAGE_EVENT, () => {}).on('end', () => {}),
      ).to.deep.equal(clientSocket);

      clientSocket!.end();
      server!.close(done);
    });
  });
});



================================================
FILE: packages/microservices/test/json-socket/message-parsing.spec.ts
================================================
import { expect } from 'chai';
import { Socket } from 'net';
import * as sinon from 'sinon';
import { TcpEventsMap } from '../../events/tcp.events';
import { JsonSocket } from '../../helpers/json-socket';

const MESSAGE_EVENT = 'message';

describe('JsonSocket message parsing', () => {
  const socket = new JsonSocket(new Socket());
  let messages: string[] = [];

  socket.on(MESSAGE_EVENT, message => {
    messages.push(message);
  });

  beforeEach(() => {
    messages = [];
    socket['contentLength'] = null;
    socket['buffer'] = '';
  });

  it('should parse JSON strings', () => {
    socket['handleData']('13#"Hello there"');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal('Hello there');
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse JSON numbers', () => {
    socket['handleData']('5#12.34');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal(12.34);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse JSON bools', () => {
    socket['handleData']('4#true');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal(true);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse JSON objects', () => {
    socket['handleData']('17#{"a":"yes","b":9}');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal({ a: 'yes', b: 9 });
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse JSON arrays', () => {
    socket['handleData']('9#["yes",9]');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal(['yes', 9]);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse multiple messages in one packet', () => {
    socket['handleData']('5#"hey"4#true');
    expect(messages.length).to.deep.equal(2);
    expect(messages[0]).to.deep.equal('hey');
    expect(messages[1]).to.deep.equal(true);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse chunked messages', () => {
    socket['handleData']('13#"Hel');
    socket['handleData']('lo there"');
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal('Hello there');
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse chunked and multiple messages', () => {
    socket['handleData']('13#"Hel');
    socket['handleData']('lo there"4#true');
    expect(messages.length).to.deep.equal(2);
    expect(messages[0]).to.deep.equal('Hello there');
    expect(messages[1]).to.deep.equal(true);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse chunked messages with multi-byte characters', () => {
    // 0x33 0x23 0xd8 0x22 0xa9 0x22 = 3#"ة" (U+00629)
    socket['onData'](Buffer.from([0x33, 0x23, 0x22, 0xd8]));
    socket['onData'](Buffer.from([0xa9, 0x22]));
    expect(messages.length).to.deep.equal(1);
    expect(messages[0]).to.deep.equal('ة');
  });

  it('should parse multiple messages with unicode correctly', () => {
    socket['handleData']('41#"Diese Zeile enthält das Unicode-Zeichen"4#true');
    expect(messages[0]).to.deep.equal(
      'Diese Zeile enthält das Unicode-Zeichen',
    );
    expect(messages[1]).to.deep.equal(true);
    expect(socket['buffer']).to.deep.equal('');
  });

  it('should parse multiple and chunked messages with unicode correctly', () => {
    socket['handleData']('41#"Diese Zeile enthält ');
    socket['handleData']('das Unicode-Zeichen"4#true');
    expect(messages[0]).to.deep.equal(
      'Diese Zeile enthält das Unicode-Zeichen',
    );
    expect(messages[1]).to.deep.equal(true);
    expect(socket['buffer']).to.deep.equal('');
  });

  describe('Error handling', () => {
    describe('JSON Error', () => {
      const errorMsgNodeAboveV20 = `Could not parse JSON: Unterminated string in JSON at position 4 (line 1 column 5)\nRequest data: "Hel`;
      const errorMsg = `Could not parse JSON: Unterminated string in JSON at position 4\nRequest data: "Hel`;
      const packetString = '4#"Hel';
      const packet = Buffer.from(packetString);

      it('should fail to parse invalid JSON', () => {
        try {
          socket['handleData']('4#"Hel');
        } catch (err) {
          expect([errorMsgNodeAboveV20, errorMsg]).to.include(err.message);
        }
        expect(messages.length).to.deep.equal(0);
        expect(socket['buffer']).to.deep.equal('');
      });

      it(`should emit ${TcpEventsMap.ERROR} event on socket`, () => {
        const socketEmitSpy: sinon.SinonSpy<any, any> = sinon.spy(
          socket['socket'],
          'emit',
        );

        socket['onData'](packet);

        try {
          expect(
            socketEmitSpy.calledOnceWithExactly(TcpEventsMap.ERROR, errorMsg),
          ).to.be.true;
        } catch (err) {
          expect(
            socketEmitSpy.calledWithExactly(
              TcpEventsMap.ERROR,
              errorMsgNodeAboveV20,
            ),
          ).to.be.true;
        } finally {
          socketEmitSpy.restore();
        }
      });

      it(`should send a FIN packet`, () => {
        const socketEndSpy = sinon.spy(socket['socket'], 'end');

        socket['onData'](packet);

        expect(socketEndSpy.calledOnce).to.be.true;
        socketEndSpy.restore();
      });
    });

    describe('Corrupted length value', () => {
      const errorMsg = `Corrupted length value "wtf" supplied in a packet`;
      const packetString = 'wtf#"Hello"';
      const packet = Buffer.from(packetString);

      it('should not accept invalid content length', () => {
        try {
          socket['handleData'](packetString);
        } catch (err) {
          expect(err.message).to.deep.equal(errorMsg);
        }
        expect(messages.length).to.deep.equal(0);
        expect(socket['buffer']).to.deep.equal('');
      });

      it(`should emit ${TcpEventsMap.ERROR} event on socket`, () => {
        const socketEmitSpy: sinon.SinonSpy<any, any> = sinon.spy(
          socket['socket'],
          'emit',
        );

        socket['onData'](packet);

        try {
          expect(
            socketEmitSpy.calledOnceWithExactly(TcpEventsMap.ERROR, errorMsg),
          ).to.be.true;
        } catch {
          // Do nothing
        } finally {
          socketEmitSpy.restore();
        }
      });

      it(`should send a FIN packet`, () => {
        const socketEndSpy = sinon.spy(socket['socket'], 'end');

        socket['onData'](packet);

        expect(socketEndSpy.calledOnce).to.be.true;
        socketEndSpy.restore();
      });
    });
  });
});



================================================
FILE: packages/microservices/test/json-socket/data/long-payload-with-special-chars.ts
================================================
export const longPayload = [
  {
    _id: '584f17147fce7ca0a8bacfd2',
    index: 0,
    guid: '1d127572-0369-45fb-aa2f-e3bb083ac2b2',
    isActive: true,
    balance: '$2,926.06',
    picture: 'http://placehold.it/32x32',
    age: 26,
    eyeColor: 'green',
    name: 'Wçêtson Aguilar [special characters in name that used to fail on long payloads]',
    gender: 'male',
    company: 'PROWASTE',
    email: 'watsonaguilar@prowaste.com',
    phone: '+1 (821) 517-2430',
    address: '910 Robert Street, Bangor, Delaware, 4159',
    about:
      'Aliqua et irure id do id id non dolore ipsum sit in proident ipsum. Id elit incididunt occaecat do laboris sunt officia fugiat aliquip. Incididunt aute ad minim Lorem cupidatat aute labore enim elit nostrud amet. Tempor sint irure incididunt aliquip amet sunt mollit aliqua Lorem officia pariatur.\r\n',
    registered: '2014-02-11T08:45:28 +05:00',
    latitude: 73.891198,
    longitude: 90.23414,
    tags: ['veniam', 'nulla', 'cillum', 'tempor', 'sint', 'magna', 'nostrud'],
    friends: [
      {
        id: 0,
        name: 'Cecelia James',
      },
      {
        id: 1,
        name: 'Hilary Young',
      },
      {
        id: 2,
        name: 'Sharron Goodwin',
      },
    ],
    greeting: 'Hello, Watson Aguilar! You have 3 unread messages.',
    favoriteFruit: 'banana',
  },
  {
    _id: '584f1714b2e945fb30f73892',
    index: 1,
    guid: '3ffce1ee-a442-4dae-804f-40c59f19e7ee',
    isActive: false,
    balance: '$2,507.49',
    picture: 'http://placehold.it/32x32',
    age: 34,
    eyeColor: 'brown',
    name: 'Aguirre Salazar',
    gender: 'male',
    company: 'EZENTIA',
    email: 'aguirresalazar@ezentia.com',
    phone: '+1 (910) 443-3647',
    address: '629 Burnett Street, Tyhee, West Virginia, 2905',
    about:
      'Labore laboris et deserunt aliquip. Occaecat esse officia est eiusmod. Officia tempor cupidatat commodo minim deserunt mollit qui ut culpa. Est occaecat laborum occaecat non mollit ad reprehenderit magna ad. Consequat culpa excepteur qui aliqua dolore occaecat aliqua sunt elit ea nisi. Officia consectetur dolor labore voluptate. Esse ad esse qui id incididunt.\r\n',
    registered: '2015-01-28T06:47:34 +05:00',
    latitude: -64.632254,
    longitude: -116.659127,
    tags: [
      'sit',
      'anim',
      'quis',
      'officia',
      'minim',
      'cupidatat',
      'adipisicing',
    ],
    friends: [
      {
        id: 0,
        name: 'Olson Mccall',
      },
      {
        id: 1,
        name: 'Carolina Conway',
      },
      {
        id: 2,
        name: 'Carlson Pacheco',
      },
    ],
    greeting: 'Hello, Aguirre Salazar! You have 9 unread messages.',
    favoriteFruit: 'apple',
  },
  {
    _id: '584f17148282bb876fc4e9a2',
    index: 2,
    guid: '892ba80c-7149-4904-bd36-22f619d4df0a',
    isActive: true,
    balance: '$2,132.56',
    picture: 'http://placehold.it/32x32',
    age: 26,
    eyeColor: 'green',
    name: 'Hardin Grant',
    gender: 'male',
    company: 'CINASTER',
    email: 'hardingrant@cinaster.com',
    phone: '+1 (900) 437-2390',
    address: '180 Ide Court, Gibsonia, Washington, 3027',
    about:
      'Ut aliquip officia adipisicing voluptate aliquip aute fugiat ad quis ad eu non consectetur. Laboris labore veniam officia qui eiusmod. Duis aliqua est quis do dolor excepteur ea dolore non. Nisi mollit laboris nostrud nostrud pariatur culpa laboris anim est irure id aute.\r\n',
    registered: '2016-09-13T10:54:27 +04:00',
    latitude: 8.651031,
    longitude: -136.777747,
    tags: ['consequat', 'deserunt', 'magna', 'enim', 'esse', 'minim', 'ipsum'],
    friends: [
      {
        id: 0,
        name: 'Lesley Velasquez',
      },
      {
        id: 1,
        name: 'Natasha Simmons',
      },
      {
        id: 2,
        name: 'Isabel Avery',
      },
    ],
    greeting: 'Hello, Hardin Grant! You have 7 unread messages.',
    favoriteFruit: 'strawberry',
  },
  {
    _id: '584f1714d90ff4b8914a69e7',
    index: 3,
    guid: '76f37726-1f73-4cf7-aabe-8dadf37d3ddd',
    isActive: true,
    balance: '$2,493.04',
    picture: 'http://placehold.it/32x32',
    age: 32,
    eyeColor: 'blue',
    name: 'Randall Roy',
    gender: 'male',
    company: 'ZAJ',
    email: 'randallroy@zaj.com',
    phone: '+1 (938) 562-2214',
    address: '872 Rugby Road, Hoehne, Indiana, 9792',
    about:
      'Non laboris id et cupidatat velit ea ipsum ea mollit quis qui dolore nisi laboris. Enim sit irure enim dolor velit proident sunt pariatur proident consequat mollit enim minim. Laboris deserunt cupidatat nisi enim adipisicing officia dolore ex cupidatat anim. Cupidatat labore voluptate non magna est dolor. Occaecat occaecat magna anim laborum adipisicing esse excepteur cillum aute qui eu do excepteur eu. Nostrud consectetur consectetur aliquip deserunt velit culpa sint excepteur mollit nostrud sit ex. Est ex ut laboris pariatur.\r\n',
    registered: '2016-05-05T05:24:56 +04:00',
    latitude: 18.943281,
    longitude: -110.942673,
    tags: [
      'eu',
      'aliqua',
      'reprehenderit',
      'amet',
      'nulla',
      'consequat',
      'nisi',
    ],
    friends: [
      {
        id: 0,
        name: 'Barron Maynard',
      },
      {
        id: 1,
        name: 'Lynn Shepard',
      },
      {
        id: 2,
        name: 'Robin Whitehead',
      },
    ],
    greeting: 'Hello, Randall Roy! You have 3 unread messages.',
    favoriteFruit: 'strawberry',
  },
  {
    _id: '584f17142a8f47cef0f5401a',
    index: 4,
    guid: '9b50ec22-3fbe-40ce-a5b8-b956f1340a77',
    isActive: false,
    balance: '$3,234.48',
    picture: 'http://placehold.it/32x32',
    age: 33,
    eyeColor: 'green',
    name: 'Chandler Vasquez',
    gender: 'male',
    company: 'ZILLACTIC',
    email: 'chandlervasquez@zillactic.com',
    phone: '+1 (830) 550-3428',
    address: '610 Hunts Lane, Cazadero, Michigan, 3584',
    about:
      'Fugiat in anim adipisicing sint aliquip ea velit do proident eu ad amet. Nulla velit duis ullamco labore ea Lorem velit elit Lorem. Id laboris do mollit exercitation veniam do amet culpa est excepteur reprehenderit consectetur laborum.\r\n',
    registered: '2014-04-20T05:23:32 +04:00',
    latitude: -88.088841,
    longitude: -163.602482,
    tags: [
      'sunt',
      'excepteur',
      'enim',
      'incididunt',
      'officia',
      'amet',
      'irure',
    ],
    friends: [
      {
        id: 0,
        name: 'Mckee Norton',
      },
      {
        id: 1,
        name: 'Durham Parrish',
      },
      {
        id: 2,
        name: 'Stewart Kramer',
      },
    ],
    greeting: 'Hello, Chandler Vasquez! You have 3 unread messages.',
    favoriteFruit: 'strawberry',
  },
  {
    _id: '584f171450a4e9dda687adc5',
    index: 5,
    guid: '68eeea45-ba6e-4740-b89b-10d690c37a02',
    isActive: false,
    balance: '$3,771.46',
    picture: 'http://placehold.it/32x32',
    age: 25,
    eyeColor: 'blue',
    name: 'Fernandez Caldwell',
    gender: 'male',
    company: 'SNIPS',
    email: 'fernandezcaldwell@snips.com',
    phone: '+1 (911) 544-3684',
    address: '786 Newel Street, Elliston, Massachusetts, 6683',
    about:
      'Voluptate commodo labore aliqua excepteur irure aliquip officia. Incididunt excepteur elit quis reprehenderit voluptate aliqua ad voluptate duis nisi dolor dolor id dolor. Irure sit consequat amet ea magna laborum velit eu in. Sunt occaecat quis consectetur laboris. Duis est do eu consectetur dolore id incididunt incididunt ut esse magna est. Nostrud irure magna nulla fugiat deserunt deserunt enim mollit proident qui sint dolore incididunt. Incididunt incididunt do quis culpa sint ut aliqua id.\r\n',
    registered: '2015-08-09T09:02:36 +04:00',
    latitude: -46.941347,
    longitude: -171.796168,
    tags: [
      'sit',
      'irure',
      'reprehenderit',
      'ut',
      'proident',
      'aliquip',
      'labore',
    ],
    friends: [
      {
        id: 0,
        name: 'Adela Preston',
      },
      {
        id: 1,
        name: 'Phillips Moses',
      },
      {
        id: 2,
        name: 'Neva Wise',
      },
    ],
    greeting: 'Hello, Fernandez Caldwell! You have 10 unread messages.',
    favoriteFruit: 'apple',
  },
];



================================================
FILE: packages/microservices/test/module/clients.module.spec.ts
================================================
import {
  DynamicModule,
  FactoryProvider,
  Injectable,
  ValueProvider,
} from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { ClientProxyFactory } from '../../client';
import { Transport } from '../../enums';
import { ClientOptions } from '../../interfaces';
import { ClientsModule, ClientsModuleOptionsFactory } from '../../module';

describe('ClientsModule', () => {
  let dynamicModule: DynamicModule;
  describe('register', () => {
    beforeEach(() => {
      dynamicModule = ClientsModule.register([
        {
          name: 'test',
          options: {},
        },
      ]);
    });
    it('should return an expected module ref', () => {
      expect(dynamicModule.module).to.be.eql(ClientsModule);
    });
    it('should return an expected providers array', () => {
      const provider = dynamicModule.providers!.find(
        p => 'useValue' in p && p.provide === 'test',
      ) as ValueProvider;
      expect(provider).to.not.be.undefined;
      expect(provider.useValue).to.be.deep.eq(
        ClientsModule['assignOnAppShutdownHook'](ClientProxyFactory.create({})),
      );
    });
  });
  describe('registerAsync', () => {
    const useFactory = () => ({
      options: {},
    });
    const registerOption = {
      name: 'test',
      useFactory,
    };

    it('should return an expected module ref', () => {
      dynamicModule = ClientsModule.registerAsync([registerOption]);
      expect(dynamicModule.module).to.be.eql(ClientsModule);
    });

    describe('when useFactory', () => {
      it('should return an expected providers array with useFactory', () => {
        dynamicModule = ClientsModule.registerAsync([registerOption]);
        expect(dynamicModule.imports).to.be.deep.eq([]);
        expect(dynamicModule.exports).to.be.eq(dynamicModule.providers);
        expect(dynamicModule.providers).to.be.have.length(1);

        const provider = dynamicModule.providers![0] as FactoryProvider;
        expect(provider.provide).to.be.eql('test');
        expect(provider.inject).to.be.deep.eq([]);
        expect(provider.useFactory).to.be.an.instanceOf(Function);
      });
    });

    describe('when useClass', () => {
      it('should return an expected providers array with useClass', () => {
        @Injectable()
        class ClientOptionService implements ClientsModuleOptionsFactory {
          createClientOptions(): Promise<ClientOptions> | ClientOptions {
            return {
              transport: Transport.TCP,
              options: {},
            };
          }
        }
        const useClassOption = {
          name: 'classTest',
          useClass: ClientOptionService,
        };
        dynamicModule = ClientsModule.registerAsync([useClassOption]);
        expect(dynamicModule.imports).to.be.deep.eq([]);
        expect(dynamicModule.providers).to.be.have.length(2);

        const classTestProvider = dynamicModule
          .providers![0] as FactoryProvider;
        expect(classTestProvider.provide).to.be.eql('classTest');
        expect(classTestProvider.inject).to.be.deep.eq([ClientOptionService]);
        expect(classTestProvider.useFactory).to.be.an.instanceOf(Function);
      });
      it('provider should call "createClientOptions"', async () => {
        const asyncOptions = {
          useClass: Object,
        };
        const dynamicModule = ClientsModule.registerAsync([
          asyncOptions as any,
        ]);
        const optionsFactory = {
          createClientOptions: sinon.spy(),
        };
        try {
          await (dynamicModule.providers![0] as any).useFactory(optionsFactory);
        } catch (e) {
          console.log(e);
        }
        expect(optionsFactory.createClientOptions.called).to.be.true;
      });
    });

    describe('when useExisting', () => {
      it('should provide an options', () => {
        const asyncOptions = {
          useExisting: Object,
        };
        dynamicModule = ClientsModule.registerAsync([asyncOptions as any]);
        expect(dynamicModule.providers).to.have.length(1);
        expect(dynamicModule.imports).to.be.deep.eq([]);
        const classTestProvider = dynamicModule
          .providers![0] as FactoryProvider;
        expect(classTestProvider.useFactory).to.be.an.instanceOf(Function);
      });
    });
  });
});



================================================
FILE: packages/microservices/test/serializers/identity.serializer.spec.ts
================================================
import { expect } from 'chai';
import { IdentitySerializer } from '../../serializers/identity.serializer';

describe('IdentitySerializer', () => {
  let instance: IdentitySerializer;
  beforeEach(() => {
    instance = new IdentitySerializer();
  });
  describe('serialize', () => {
    it('should return the value unchanged', () => {
      const value = {};
      expect(instance.serialize(value)).to.be.eql(value);
    });
  });
});



================================================
FILE: packages/microservices/test/serializers/kafka-request.serializer.spec.ts
================================================
import { expect } from 'chai';
import { KafkaHeaders } from '../../enums/kafka-headers.enum';
import { KafkaRequestSerializer } from '../../serializers/kafka-request.serializer';

describe('KafkaRequestSerializer', () => {
  let instance: KafkaRequestSerializer;
  beforeEach(() => {
    instance = new KafkaRequestSerializer();
  });
  describe('serialize', () => {
    it('undefined', async () => {
      expect(await instance.serialize(undefined)).to.deep.eq({
        headers: {},
        value: null,
      });
    });

    it('null', async () => {
      expect(await instance.serialize(null)).to.deep.eq({
        headers: {},
        value: null,
      });
    });

    it('string', async () => {
      expect(await instance.serialize('string')).to.deep.eq({
        headers: {},
        value: 'string',
      });
    });

    it('number', async () => {
      expect(await instance.serialize(12345)).to.deep.eq({
        headers: {},
        value: '12345',
      });
    });

    it('buffer', async () => {
      expect(await instance.serialize(Buffer.from('buffer'))).to.deep.eq({
        headers: {},
        value: Buffer.from('buffer'),
      });
    });

    it('array', async () => {
      expect(await instance.serialize([1, 2, 3, 4, 5])).to.deep.eq({
        headers: {},
        value: '[1,2,3,4,5]',
      });
    });

    it('object', async () => {
      expect(
        await instance.serialize({
          prop: 'value',
        }),
      ).to.deep.eq({
        headers: {},
        value: '{"prop":"value"}',
      });
    });

    it('complex object with .toString()', async () => {
      class Complex {
        private readonly name = 'complex';
        public toString(): string {
          return this.name;
        }
      }

      expect(await instance.serialize(new Complex())).to.deep.eq({
        headers: {},
        value: 'complex',
      });
    });

    it('complex object without .toString()', async () => {
      class ComplexWithOutToString {
        private readonly name = 'complex';
      }

      expect(await instance.serialize(new ComplexWithOutToString())).to.deep.eq(
        {
          headers: {},
          value: '[object Object]',
        },
      );
    });
  });

  describe('serialize kafka message', () => {
    it('kafka message without key', async () => {
      expect(
        await instance.serialize({
          value: 'string',
        }),
      ).to.deep.eq({
        headers: {},
        value: 'string',
      });
    });

    it('kafka message with key', async () => {
      expect(
        await instance.serialize({
          key: '1',
          value: 'string',
        }),
      ).to.deep.eq({
        headers: {},
        key: '1',
        value: 'string',
      });
    });

    it('kafka message with headers', async () => {
      expect(
        await instance.serialize({
          key: '1',
          value: 'string',
          headers: {
            [KafkaHeaders.CORRELATION_ID]: '1234',
          },
        }),
      ).to.deep.eq({
        headers: {
          [KafkaHeaders.CORRELATION_ID]: '1234',
        },
        key: '1',
        value: 'string',
      });
    });
  });
});



================================================
FILE: packages/microservices/test/serializers/mqtt-record.serializer.spec.ts
================================================
import { expect } from 'chai';
import { MqttRecordBuilder } from '../../record-builders';
import { MqttRecordSerializer } from '../../serializers/mqtt-record.serializer';

describe('MqttRecordSerializer', () => {
  let instance: MqttRecordSerializer;
  beforeEach(() => {
    instance = new MqttRecordSerializer();
  });
  describe('serialize', () => {
    it('should parse mqtt record instance to a string, ignoring options', () => {
      const mqttMessage = new MqttRecordBuilder()
        .setData({ value: 'string' })
        .setQoS(1)
        .setDup(true)
        .setRetain(true)
        .setProperties({})
        .build();

      expect(
        instance.serialize({
          pattern: 'pattern',
          data: mqttMessage,
        }),
      ).to.deep.eq(
        JSON.stringify({
          pattern: 'pattern',
          data: { value: 'string' },
        }),
      );
    });
    it('should act as an identity function if msg is not an instance of MqttRecord class', () => {
      const packet = {
        pattern: 'pattern',
        data: { random: true },
      };
      expect(instance.serialize(packet)).to.eq(JSON.stringify(packet));
    });
  });
});



================================================
FILE: packages/microservices/test/serializers/nats-record.serializer.spec.ts
================================================
import { expect } from 'chai';
import * as nats from 'nats';
import { NatsRecordBuilder } from '../../record-builders';
import { NatsRecordSerializer } from '../../serializers/nats-record.serializer';

const jsonCodec = nats.JSONCodec();

describe('NatsRecordSerializer', () => {
  let instance: NatsRecordSerializer;
  beforeEach(() => {
    instance = new NatsRecordSerializer();
  });
  describe('serialize', () => {
    it('undefined', () => {
      expect(instance.serialize({ data: undefined })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: undefined }),
      });
    });

    it('null', () => {
      expect(instance.serialize({ data: null })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: null }),
      });
    });

    it('string', () => {
      expect(instance.serialize({ data: 'string' })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: 'string' }),
      });
    });

    it('number', () => {
      expect(instance.serialize({ data: 12345 })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: 12345 }),
      });
    });

    it('buffer', () => {
      expect(instance.serialize({ data: Buffer.from('buffer') })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: Buffer.from('buffer') }),
      });
    });

    it('array', () => {
      expect(instance.serialize({ data: [1, 2, 3, 4, 5] })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: [1, 2, 3, 4, 5] }),
      });
    });

    it('object', () => {
      const serObject = { prop: 'value' };
      expect(instance.serialize({ data: serObject })).to.deep.eq({
        headers: undefined,
        data: jsonCodec.encode({ data: serObject }),
      });
    });

    it('nats message with data and nats headers', () => {
      const natsHeaders = nats.headers();
      natsHeaders.set('1', 'header_1');
      const natsMessage = new NatsRecordBuilder()
        .setHeaders(natsHeaders)
        .setData({ value: 'string' })
        .build();
      expect(
        instance.serialize({
          data: natsMessage,
        }),
      ).to.deep.eq({
        headers: natsHeaders,
        data: jsonCodec.encode({
          data: {
            value: 'string',
          },
        }),
      });
    });
  });
});



================================================
FILE: packages/microservices/test/serializers/rmq-record.serializer.spec.ts
================================================
import { expect } from 'chai';
import { RmqRecordBuilder } from '../../record-builders';
import { RmqRecordSerializer } from '../../serializers/rmq-record.serializer';

describe('RmqRecordSerializer', () => {
  const pattern = 'test';

  let instance: RmqRecordSerializer;
  beforeEach(() => {
    instance = new RmqRecordSerializer();
  });
  describe('serialize', () => {
    it('should parse rmq record instance', () => {
      const rmqMessage = new RmqRecordBuilder()
        .setData({ value: 'string' })
        .setOptions({ appId: 'app', persistent: true })
        .build();

      expect(
        instance.serialize({
          pattern,
          data: rmqMessage,
        }),
      ).to.deep.eq({
        pattern,
        options: { appId: 'app', persistent: true },
        data: { value: 'string' },
      });
    });

    it('should act as an identity function if msg is not an instance of RmqRecord class', () => {
      const packet = {
        pattern,
        data: { random: true },
      };
      expect(instance.serialize(packet)).to.eq(packet);
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-factory.spec.ts
================================================
import { expect } from 'chai';
import { Transport } from '../../enums/transport.enum';
import { ServerFactory } from '../../server/server-factory';
import { ServerGrpc } from '../../server/server-grpc';
import { ServerKafka } from '../../server/server-kafka';
import { ServerMqtt } from '../../server/server-mqtt';
import { ServerNats } from '../../server/server-nats';
import { ServerRedis } from '../../server/server-redis';
import { ServerRMQ } from '../../server/server-rmq';
import { ServerTCP } from '../../server/server-tcp';

describe('ServerFactory', () => {
  describe('create', () => {
    it(`should return tcp server by default`, () => {
      expect(ServerFactory.create({}) instanceof ServerTCP).to.be.true;
    });

    it(`should return redis server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.REDIS }) instanceof
          ServerRedis,
      ).to.be.true;
    });

    it(`should return redis server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.REDIS }) instanceof
          ServerRedis,
      ).to.be.true;
    });

    it(`should return mqtt server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.MQTT }) instanceof
          ServerMqtt,
      ).to.be.true;
    });

    it(`should return nats server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.NATS }) instanceof
          ServerNats,
      ).to.be.true;
    });

    it(`should return rmq server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.RMQ }) instanceof ServerRMQ,
      ).to.be.true;
    });

    it(`should return kafka server`, () => {
      expect(
        ServerFactory.create({ transport: Transport.KAFKA }) instanceof
          ServerKafka,
      ).to.be.true;
    });

    it(`should return grpc server`, () => {
      expect(
        ServerFactory.create({
          transport: Transport.GRPC,
          options: { protoPath: '', package: '' },
        }) instanceof ServerGrpc,
      ).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-grpc.spec.ts
================================================
import { Logger } from '@nestjs/common';
import { expect } from 'chai';
import { join } from 'path';
import { ReplaySubject, Subject, throwError } from 'rxjs';
import * as sinon from 'sinon';
import { InvalidGrpcPackageException } from '../../errors/invalid-grpc-package.exception';
import { InvalidProtoDefinitionException } from '../../errors/invalid-proto-definition.exception';
import * as grpcHelpers from '../../helpers/grpc-helpers';
import { GrpcMethodStreamingType } from '../../index';
import { ServerGrpc } from '../../server';

const CANCELLED_EVENT = 'cancelled';

class NoopLogger extends Logger {
  log(message: any, context?: string): void {}
  error(message: any, trace?: string, context?: string): void {}
  warn(message: any, context?: string): void {}
}

describe('ServerGrpc', () => {
  let server: ServerGrpc;
  let untypedServer: any;
  let serverMulti: ServerGrpc;

  beforeEach(() => {
    server = new ServerGrpc({
      protoPath: join(__dirname, './test.proto'),
      package: 'test',
    });
    untypedServer = server as any;

    serverMulti = new ServerGrpc({
      protoPath: ['test.proto', 'test2.proto'],
      package: ['test', 'test2'],
      loader: {
        includeDirs: [join(__dirname, '.')],
      },
    });
  });

  describe('listen', () => {
    let callback: sinon.SinonSpy;
    let bindEventsStub: sinon.SinonStub;

    beforeEach(() => {
      callback = sinon.spy();
      bindEventsStub = sinon
        .stub(server, 'bindEvents')
        .callsFake(() => ({}) as any);
    });

    it('should call "bindEvents"', async () => {
      await server.listen(callback);
      await server.close();
      expect(bindEventsStub.called).to.be.true;
    });
    it('should call callback', async () => {
      await server.listen(callback);
      await server.close();
      expect(callback.called).to.be.true;
    });
    describe('when "start" throws an exception', () => {
      it('should call callback with a thrown error as an argument', async () => {
        const error = new Error('random error');

        const callbackSpy = sinon.spy();
        sinon.stub(server, 'createClient').callsFake(async () => null);

        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        await server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });

  describe('listen (multiple proto)', () => {
    let callback: sinon.SinonSpy;
    let bindEventsStub: sinon.SinonStub;

    beforeEach(() => {
      callback = sinon.spy();
      bindEventsStub = sinon
        .stub(serverMulti, 'bindEvents')
        .callsFake(() => ({}) as any);
    });

    it('should call "bindEvents"', async () => {
      await serverMulti.listen(callback);
      await serverMulti.close();
      expect(bindEventsStub.called).to.be.true;
    });
    it('should call callback', async () => {
      await serverMulti.listen(callback);
      await serverMulti.close();
      expect(callback.called).to.be.true;
    });
  });

  describe('bindEvents', () => {
    beforeEach(() => {
      sinon.stub(server, 'loadProto').callsFake(() => ({}));
    });
    describe('when package does not exist', () => {
      it('should throw "InvalidGrpcPackageException"', async () => {
        sinon.stub(server, 'lookupPackage').callsFake(() => null);
        untypedServer.logger = new NoopLogger();
        try {
          await server.bindEvents();
        } catch (err) {
          expect(err).to.be.instanceOf(InvalidGrpcPackageException);
        }
      });
    });
    describe('when package exist', () => {
      it('should call "addService"', async () => {
        const serviceNames = [
          {
            name: 'test',
            service: true,
          },
          {
            name: 'test2',
            service: true,
          },
        ];
        sinon.stub(server, 'lookupPackage').callsFake(() => ({
          test: { service: true },
          test2: { service: true },
        }));
        sinon.stub(server, 'getServiceNames').callsFake(() => serviceNames);
        untypedServer.grpcClient = { addService: sinon.spy() };

        await server.bindEvents();
        expect(untypedServer.grpcClient.addService.calledTwice).to.be.true;
      });
    });
  });

  describe('bindEvents (multiple proto)', () => {
    beforeEach(() => {
      sinon.stub(serverMulti, 'loadProto').callsFake(() => ({}));
    });
    describe('when package does not exist', () => {
      it('should throw "InvalidGrpcPackageException"', async () => {
        sinon.stub(serverMulti, 'lookupPackage').callsFake(() => null);
        (serverMulti as any).logger = new NoopLogger();
        try {
          await serverMulti.bindEvents();
        } catch (err) {
          expect(err).to.be.instanceOf(InvalidGrpcPackageException);
        }
      });
    });
    describe('when package exist', () => {
      it('should call "addService"', async () => {
        const serviceNames = [
          {
            name: 'test',
            service: true,
          },
        ];
        sinon.stub(serverMulti, 'lookupPackage').callsFake(() => ({
          test: { service: true },
        }));
        sinon
          .stub(serverMulti, 'getServiceNames')
          .callsFake(() => serviceNames);

        (serverMulti as any).grpcClient = { addService: sinon.spy() };

        await serverMulti.bindEvents();
        expect((serverMulti as any).grpcClient.addService.calledTwice).to.be
          .true;
      });
    });
  });

  describe('getServiceNames', () => {
    it('should return filtered object keys', () => {
      const obj = {
        key: { service: true },
        key2: { service: true },
        key3: { service: false },
      };
      const expected = [
        {
          name: 'key',
          service: { service: true },
        },
        {
          name: 'key2',
          service: { service: true },
        },
      ];
      expect(server.getServiceNames(obj)).to.be.eql(expected);
    });
  });

  describe('createService', () => {
    const objectToMap = obj =>
      new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);

    it('should call "createServiceMethod"', async () => {
      const handlers = objectToMap({
        test: null,
        test2: () => ({}),
      });
      sinon
        .stub(server, 'createPattern')
        .onFirstCall()
        .returns('test')
        .onSecondCall()
        .returns('test2');

      const spy = sinon
        .stub(server, 'createServiceMethod')
        .callsFake(() => ({}) as any);
      untypedServer.messageHandlers = handlers;
      await server.createService(
        {
          prototype: { test: true, test2: true },
        },
        'name',
      );
      expect(spy.calledOnce).to.be.true;
    });
    describe('when RX streaming', () => {
      it('should call "createPattern" with proper arguments', async () => {
        const handlers = objectToMap({
          test2: {
            requestStream: true,
          },
        });
        const createPatternStub = sinon
          .stub(server, 'createPattern')
          .onFirstCall()
          .returns('test2');

        sinon.stub(server, 'createServiceMethod').callsFake(() => ({}) as any);
        untypedServer.messageHandlers = handlers;
        await server.createService(
          {
            prototype: {
              test2: {
                requestStream: true,
              },
            },
          },
          'name',
        );
        expect(
          createPatternStub.calledWith(
            'name',
            'test2',
            GrpcMethodStreamingType.RX_STREAMING,
          ),
        ).to.be.true;
      });
    });
    describe('when pass through streaming', () => {
      it('should call "createPattern" with proper arguments', async () => {
        const handlers = objectToMap({
          test2: {
            requestStream: true,
          },
        });
        const createPatternStub = sinon
          .stub(server, 'createPattern')
          .onFirstCall()
          .returns('_invalid')
          .onSecondCall()
          .returns('_invalid')
          .onThirdCall()
          .returns('test2');

        sinon.stub(server, 'createServiceMethod').callsFake(() => ({}) as any);
        untypedServer.messageHandlers = handlers;
        await server.createService(
          {
            prototype: {
              test2: {
                requestStream: true,
              },
            },
          },
          'name',
        );
        expect(
          createPatternStub.calledWith(
            'name',
            'test2',
            GrpcMethodStreamingType.PT_STREAMING,
          ),
        ).to.be.true;
      });
    });
  });

  describe('getMessageHandler', () => {
    it('should return handler when service name specified', () => {
      const testPattern = server.createPattern(
        'test',
        'TestMethod',
        GrpcMethodStreamingType.NO_STREAMING,
      );
      const handlers = new Map([[testPattern, () => ({})]]);
      console.log(handlers.entries());
      untypedServer.messageHandlers = handlers;

      expect(
        server.getMessageHandler(
          'test',
          'TestMethod',
          GrpcMethodStreamingType.NO_STREAMING,
          {},
        ),
      ).not.to.be.undefined;
    });
    it('should return handler when package name specified with service name', () => {
      const testPattern = server.createPattern(
        'package.example.test',
        'TestMethod',
        GrpcMethodStreamingType.NO_STREAMING,
      );
      const handlers = new Map([[testPattern, () => ({})]]);
      untypedServer.messageHandlers = handlers;

      expect(
        server.getMessageHandler(
          'test',
          'TestMethod',
          GrpcMethodStreamingType.NO_STREAMING,
          {
            path: '/package.example.test/TestMethod',
          },
        ),
      ).not.to.be.undefined;
    });

    it('should return undefined when method name is unknown', () => {
      const testPattern = server.createPattern(
        'package.example.test',
        'unknown',
        GrpcMethodStreamingType.NO_STREAMING,
      );
      const handlers = new Map([[testPattern, () => ({})]]);
      untypedServer.messageHandlers = handlers;

      expect(
        server.getMessageHandler(
          'test',
          'TestMethod',
          GrpcMethodStreamingType.NO_STREAMING,
          {
            path: '/package.example.test/TestMethod',
          },
        ),
      ).to.be.undefined;
    });
  });

  describe('createPattern', () => {
    it('should return pattern', () => {
      const service = 'test';
      const method = 'method';
      expect(
        server.createPattern(
          service,
          method,
          GrpcMethodStreamingType.NO_STREAMING,
        ),
      ).to.be.eql(
        JSON.stringify({
          service,
          rpc: method,
          streaming: GrpcMethodStreamingType.NO_STREAMING,
        }),
      );
    });
  });

  describe('createServiceMethod', () => {
    describe('when method is a response stream', () => {
      it('should call "createStreamServiceMethod"', () => {
        const cln = sinon.spy();
        const spy = sinon.spy(server, 'createStreamServiceMethod');
        server.createServiceMethod(
          cln,
          { responseStream: true } as any,
          GrpcMethodStreamingType.NO_STREAMING,
        );

        expect(spy.called).to.be.true;
      });
    });
    describe('when method is not a response stream', () => {
      it('should call "createUnaryServiceMethod"', () => {
        const cln = sinon.spy();
        const spy = sinon.spy(server, 'createUnaryServiceMethod');
        server.createServiceMethod(
          cln,
          { responseStream: false } as any,
          GrpcMethodStreamingType.NO_STREAMING,
        );

        expect(spy.called).to.be.true;
      });
    });
    describe('when request is a stream', () => {
      describe('when stream type is RX_STREAMING', () => {
        it('should call "createRequestStreamMethod"', () => {
          const cln = sinon.spy();
          const spy = sinon.spy(server, 'createRequestStreamMethod');
          server.createServiceMethod(
            cln,
            { requestStream: true } as any,
            GrpcMethodStreamingType.RX_STREAMING,
          );

          expect(spy.called).to.be.true;
        });
      });
      describe('when stream type is PT_STREAMING', () => {
        it('should call "createStreamCallMethod"', () => {
          const cln = sinon.spy();
          const spy = sinon.spy(server, 'createStreamCallMethod');
          server.createServiceMethod(
            cln,
            { requestStream: true } as any,
            GrpcMethodStreamingType.PT_STREAMING,
          );

          expect(spy.called).to.be.true;
        });
      });
    });
  });

  describe('createStreamServiceMethod', () => {
    it('should return function', () => {
      const fn = server.createStreamServiceMethod(sinon.spy());
      expect(fn).to.be.a('function');
    });

    describe('on call', () => {
      it('should call native method', async () => {
        const call = {
          write: sinon.spy(() => true),
          end: sinon.spy(),
          on: sinon.spy(),
          off: sinon.spy(),
        };
        const callback = sinon.spy();
        const native = sinon.spy();

        await server.createStreamServiceMethod(native)(call, callback);
        expect(native.called).to.be.true;
        expect(call.on.calledWith('cancelled')).to.be.true;
        expect(call.off.calledWith('cancelled')).to.be.true;
      });

      it('should handle error thrown in handler', async () => {
        const call = {
          write: sinon.spy(() => true),
          end: sinon.spy(),
          on: sinon.spy(),
          off: sinon.spy(),
          emit: sinon.spy(),
        };

        const callback = sinon.spy();
        const error = new Error('handler threw');
        const native = sinon.spy(() => throwError(() => error));

        // implicit assertion that this will never throw when call.emit emits an error event
        await server.createStreamServiceMethod(native)(call, callback);
        expect(native.called).to.be.true;
        expect(call.emit.calledWith('error', error)).to.be.ok;
        expect(call.end.called).to.be.true;
      });

      it(`should close the result observable when receiving an 'cancelled' event from the client`, async () => {
        const et = new EventTarget();
        const cancel = () => et.dispatchEvent(new Event('cancelled'));

        const written: any[] = [];
        const call = {
          write: sinon.spy((value: any) => {
            written.push(value);
            return true;
          }),
          end: sinon.spy(() => written.push('end')),
          on: sinon.spy((name, cb) => {
            et.addEventListener(name, cb);
          }),
          off: sinon.spy((name, cb) => {
            et.removeEventListener(name, cb);
          }),
        };

        const result$ = new Subject<number>();
        const resolvedObservable = Promise.resolve(result$);
        const callback = sinon.spy();
        const native = sinon.stub().returns(resolvedObservable);

        const result = server.createStreamServiceMethod(native)(call, callback);

        await resolvedObservable;

        result$.next(1);
        expect(written).to.deep.equal([1]);
        result$.next(2);
        expect(written).to.deep.equal([1, 2]);
        result$.next(3);
        expect(written).to.deep.equal([1, 2, 3]);
        cancel();
        result$.next(4);
        expect(written).to.deep.equal([1, 2, 3, 'end']);

        expect(call.end.called).to.be.true;
        expect(call.on.calledWith('cancelled')).to.be.true;
        expect(call.on.calledWith('drain')).to.be.true;
        expect(call.off.calledWith('cancelled')).to.be.true;
        expect(call.off.calledWith('drain')).to.be.true;

        await result;
      });
    });
  });

  describe('createUnaryServiceMethod', () => {
    it('should return observable', () => {
      const fn = server.createUnaryServiceMethod(sinon.spy());
      expect(fn).to.be.a('function');
    });
    describe('on call', () => {
      it('should call native & callback methods', async () => {
        const call = { write: sinon.spy(), end: sinon.spy() };
        const callback = sinon.spy();
        const native = sinon.spy();

        await server.createUnaryServiceMethod(native)(call, callback);
        expect(native.called).to.be.true;
        expect(callback.called).to.be.true;
      });

      it('should await when a promise is return by the native', async () => {
        const call = { write: sinon.spy(), end: sinon.spy() };
        const callback = sinon.spy();

        const original = { native: Function };
        const mock = sinon.mock(original);

        mock
          .expects('native')
          .once()
          .returns(
            (() => {
              const sub = new ReplaySubject<any>(1);
              sub.next(new Promise(resolve => resolve({ foo: 'bar' })));
              return sub.asObservable();
            })(),
          );

        await server.createUnaryServiceMethod(original.native)(call, callback);
        mock.verify();
        expect(callback.calledWith(null, { foo: 'bar' })).to.be.true;
      });
    });
  });

  describe('createRequestStreamMethod', () => {
    it('should wrap call into Subject', async () => {
      const handler = sinon.spy();
      const fn = server.createRequestStreamMethod(handler, false);
      const call = {
        on: (event, callback) => callback(),
        off: sinon.spy(),
        end: sinon.spy(),
        write: sinon.spy(),
      };
      await fn(call as any, sinon.spy());

      expect(handler.called).to.be.true;
    });

    it('should wrap call into Subject with metadata', async () => {
      const handler = sinon.spy();
      const fn = server.createRequestStreamMethod(handler, false);
      const call = {
        on: (event, callback) => callback(),
        off: sinon.spy(),
        end: sinon.spy(),
        write: sinon.spy(),
        metadata: {
          test: '123',
        },
      };
      await fn(call as any, sinon.spy());

      expect(handler.called).to.be.true;
      expect(handler.args[0][1]).to.eq(call.metadata);
    });

    describe('when response is not a stream', () => {
      it('should call callback', async () => {
        const handler = async () => ({ test: true });
        const fn = server.createRequestStreamMethod(handler, false);
        const call = {
          on: (event, callback) => {
            if (event !== CANCELLED_EVENT) {
              callback();
            }
          },
          off: sinon.spy(),
          end: sinon.spy(),
          write: sinon.spy(() => false),
        };

        const responseCallback = sinon.spy();
        await fn(call as any, responseCallback);

        expect(responseCallback.called).to.be.true;
      });

      it('should handle error thrown in handler', async () => {
        const error = new Error('Error');
        const handler = async () => throwError(() => error);
        const fn = server.createRequestStreamMethod(handler, false);
        const call = {
          on: (event, callback) => {
            if (event !== CANCELLED_EVENT) {
              callback();
            }
          },
          off: sinon.spy(),
          end: sinon.spy(),
          write: sinon.spy(),
        };

        const responseCallback = sinon.spy();
        await fn(call as any, responseCallback);

        expect(responseCallback.calledOnce).to.be.true;
        expect(responseCallback.firstCall.args).to.eql([error, null]);
      });

      describe('when response is a stream', () => {
        /**
         * A helper to create a repeated fixture to test streaming writes against.
         */
        async function createCall() {
          const emitter = new EventTarget();

          // If we write more than this number, the call will become unwritable.
          const highwaterMark = 2;
          let writeCounter = 0;

          // What has been "written" so far.
          const written: any[] = [];

          const drain = () => {
            writeCounter = 0;
            emitter.dispatchEvent(new Event('drain'));
          };

          const cancel = () => {
            emitter.dispatchEvent(new Event(CANCELLED_EVENT));
          };

          const call = {
            write: sinon.spy(value => {
              // Simulating a writable stream becoming overwhelmed.
              if (writeCounter++ < highwaterMark) {
                // We can write this value to the stream.
                written.push(value);
              }
              // But as soon as we pass the highwater mark, we can't write anymore.
              return writeCounter < highwaterMark;
            }),
            end: sinon.spy(() => {
              written.push('end');
            }),
            emit: sinon.spy(),
            request: sinon.spy(),
            metadata: sinon.spy(),
            sendMetadata: sinon.spy(),
            on: (name, cb) => {
              emitter.addEventListener(name, cb);
            },
            off: (name, cb) => {
              emitter.removeEventListener(name, cb);
            },
            fire: {
              drain,
              cancel,
            },
          };

          const callback = sinon.spy();

          const subject = new Subject<string>();
          const handlerResult = Promise.resolve(subject);
          const methodHandler = () => handlerResult;

          const serviceMethod = server.createRequestStreamMethod(
            methodHandler,
            true,
          );

          const result = serviceMethod(call, callback);

          await handlerResult;

          return { call, written, result, subject };
        }

        it('should call write() and end() for streams from promises', async () => {
          const handler = async () => ({ test: true });
          const fn = server.createRequestStreamMethod(handler, true);
          const call = {
            on: (event, callback) => {
              if (event !== CANCELLED_EVENT) {
                callback();
              }
            },
            off: sinon.spy(),
            end: sinon.spy(),
            write: sinon.spy(() => true),
          };

          await fn(call as any, null!);

          expect(call.write.called).to.be.true;
          expect(call.end.called).to.be.true;
        });

        it('should drain all values emitted from the observable while waiting for the drain event from the call', async () => {
          const { call, written, result, subject } = await createCall();

          subject.next('a');
          subject.next('b');
          expect(written).to.deep.equal(['a', 'b']);
          subject.next('c'); // can't be written yet.
          expect(written).to.deep.equal(['a', 'b']);
          call.fire.drain();
          subject.next('d');
          expect(written).to.deep.equal(['a', 'b', 'c', 'd']);
          subject.next('e'); // can't be written yet.
          expect(written).to.deep.equal(['a', 'b', 'c', 'd']);
          call.fire.drain();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e']);
          subject.next('f');
          expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'f']);
          subject.complete();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'f', 'end']);

          return result;
        });

        it(
          'should drain all values emitted from the observable while waiting for the drain event from the call ' +
            'even if the call becomes unwritable during draining',
          async () => {
            const { call, written, result, subject } = await createCall();

            subject.next('a');
            subject.next('b');
            subject.next('c');
            subject.next('d');
            subject.next('e');
            expect(written).to.deep.equal(['a', 'b']);
            call.fire.drain();
            expect(written).to.deep.equal(['a', 'b', 'c', 'd']);
            call.fire.drain();
            expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e']);
            subject.complete();
            expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'end']);

            return result;
          },
        );

        it('should wait to end until after the internal buffer has drained', async () => {
          const { call, written, result, subject } = await createCall();

          subject.next('a');
          subject.next('b');
          subject.next('c');
          subject.next('d');
          subject.next('e');
          subject.complete();
          expect(written).to.deep.equal(['a', 'b']);
          call.fire.drain();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd']);
          call.fire.drain();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'end']);

          return result;
        });

        it('should end the subscription to the source if the call is cancelled', async () => {
          const { call, subject, result } = await createCall();

          expect(subject.observed).to.be.true;
          call.fire.cancel();
          expect(subject.observed).to.be.false;
          expect(call.end.called).to.be.true;

          return result;
        });

        it('should wait to throw errors from the observable source until after the internal buffer has drained', async () => {
          const { call, written, result, subject } = await createCall();
          const error = new Error('test');
          subject.next('a');
          subject.next('b');
          subject.next('c');
          subject.next('d');
          subject.next('e');
          subject.error(error);
          expect(written).to.deep.equal(['a', 'b']);
          call.fire.drain();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd']);
          call.fire.drain();
          expect(written).to.deep.equal(['a', 'b', 'c', 'd', 'e', 'end']);

          try {
            await result;
          } catch (err) {
            expect(err).to.equal(error);
          }
        });
      });
    });
  });

  describe('createStreamCallMethod', () => {
    it('should pass through to "methodHandler"', async () => {
      const handler = sinon.spy();
      const fn = server.createStreamCallMethod(handler, false);
      const args = [1, 2, 3];
      await fn(args as any, sinon.spy());

      expect(handler.calledWith(args)).to.be.true;
    });
  });

  describe('loadProto', () => {
    describe('when proto is invalid', () => {
      it('should throw InvalidProtoDefinitionException', () => {
        const getPackageDefinitionStub = sinon.stub(
          grpcHelpers,
          'getGrpcPackageDefinition' as any,
        );
        getPackageDefinitionStub.callsFake(() => {
          throw new Error();
        });
        untypedServer.logger = new NoopLogger();
        expect(() => server.loadProto()).to.throws(
          InvalidProtoDefinitionException,
        );
        getPackageDefinitionStub.restore();
      });
    });
  });

  describe('close', () => {
    it('should call "forceShutdown" by default', async () => {
      const grpcClient = {
        forceShutdown: sinon.spy(),
        tryShutdown: sinon.stub().yields(),
      };
      untypedServer.grpcClient = grpcClient;
      await server.close();
      expect(grpcClient.forceShutdown.called).to.be.true;
      expect(grpcClient.tryShutdown.called).to.be.false;
    });

    it('should call "forceShutdown" when "gracefulShutdown" is false', async () => {
      const grpcClient = {
        forceShutdown: sinon.spy(),
        tryShutdown: sinon.stub().yields(),
      };
      untypedServer.grpcClient = grpcClient;
      untypedServer.options.gracefulShutdown = false;
      await server.close();
      expect(grpcClient.forceShutdown.called).to.be.true;
      expect(grpcClient.tryShutdown.called).to.be.false;
    });

    it('should call "tryShutdown" when "gracefulShutdown" is true', async () => {
      const grpcClient = {
        forceShutdown: sinon.spy(),
        tryShutdown: sinon.stub().yields(),
      };
      untypedServer.grpcClient = grpcClient;
      untypedServer.options.gracefulShutdown = true;
      await server.close();
      expect(grpcClient.forceShutdown.called).to.be.false;
      expect(grpcClient.tryShutdown.called).to.be.true;
    });
  });

  describe('deserialize', () => {
    it(`should return parsed json`, () => {
      const obj = { test: 'test' };
      expect(server.deserialize(obj)).to.deep.equal(
        JSON.parse(JSON.stringify(obj)),
      );
    });
    it(`should not parse argument if it is not an object`, () => {
      const content = 'test';
      expect(server.deserialize(content)).to.equal(content);
    });
  });

  describe('proto interfaces parser should account for package namespaces', () => {
    it('should parse multi-level proto package tree"', () => {
      const grpcPkg = {
        A: {
          C: {
            E: {
              service: {
                serviceName: {},
              },
            },
          },
        },
        B: {
          D: {
            service: {
              serviceName: {},
            },
          },
        },
      };
      const svcs = server.getServiceNames(grpcPkg);
      expect(svcs.length).to.be.equal(
        2,
        'Amount of services collected from namespace should be equal 2',
      );
      expect(svcs[0].name).to.be.equal('A.C.E');
      expect(svcs[1].name).to.be.equal('B.D');
    });
    it('should parse single level proto package tree"', () => {
      const grpcPkg = {
        A: {
          service: {
            serviceName: {},
          },
        },
        B: {
          service: {
            serviceName: {},
          },
        },
      };
      const services = server.getServiceNames(grpcPkg);
      expect(services.length).to.be.equal(
        2,
        'Amount of services collected from namespace should be equal 2',
      );
      expect(services[0].name).to.be.equal('A');
      expect(services[1].name).to.be.equal('B');
    });
  });

  describe('addHandler', () => {
    const callback = () => {},
      pattern = { test: 'test pattern' };

    it(`should add handler`, () => {
      sinon.stub(server as any, 'messageHandlers').value({ set() {} });

      const messageHandlersSetSpy = sinon.spy(
        untypedServer.messageHandlers,
        'set',
      );
      server.addHandler(pattern, callback as any);

      expect(messageHandlersSetSpy.called).to.be.true;
      expect(messageHandlersSetSpy.getCall(0).args[0]).to.be.equal(
        JSON.stringify(pattern),
      );
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-kafka.spec.ts
================================================
import { Logger } from '@nestjs/common';
import { AssertionError, expect } from 'chai';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { KafkaHeaders } from '../../enums';
import {
  EachMessagePayload,
  KafkaMessage,
} from '../../external/kafka.interface';
import { ServerKafka } from '../../server';
import { objectToMap } from './utils/object-to-map';

class NoopLogger extends Logger {
  log(message: any, context?: string): void {}
  error(message: any, trace?: string, context?: string): void {}
  warn(message: any, context?: string): void {}
}

describe('ServerKafka', () => {
  const topic = 'test.topic';
  const replyTopic = 'test.topic.reply';
  const replyPartition = '0';
  const correlationId = '696fa0a9-1827-4e59-baef-f3628173fe4f';
  const key = '1';
  const timestamp = new Date().toISOString();
  const messageValue = 'test-message';
  const heartbeat = async () => {};
  const pause = () => () => {};

  const eventMessage: KafkaMessage = {
    key: Buffer.from(key),
    offset: '0',
    size: messageValue.length,
    value: Buffer.from(messageValue),
    timestamp,
    attributes: 1,
  };
  const eventPayload: EachMessagePayload = {
    topic,
    partition: 0,
    message: Object.assign(
      {
        headers: {},
      },
      eventMessage,
    ),
    heartbeat,
    pause,
  };

  const eventWithCorrelationIdPayload: EachMessagePayload = {
    topic,
    partition: 0,
    message: Object.assign(
      {
        headers: {
          [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
        },
      },
      eventMessage,
    ),
    heartbeat,
    pause,
  };

  const message: KafkaMessage = Object.assign(
    {
      headers: {
        [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
        [KafkaHeaders.REPLY_TOPIC]: Buffer.from(replyTopic),
        [KafkaHeaders.REPLY_PARTITION]: Buffer.from(replyPartition),
      },
    },
    eventMessage,
  );
  const payload: EachMessagePayload = {
    topic,
    partition: 0,
    message,
    heartbeat,
    pause,
  };

  let server: ServerKafka;
  let untypedServer: any;
  let callback: sinon.SinonSpy;
  let bindEventsStub: sinon.SinonStub;
  let connect: sinon.SinonSpy;
  let subscribe: sinon.SinonSpy;
  let run: sinon.SinonSpy;
  let send: sinon.SinonSpy;
  let on: sinon.SinonSpy;
  let consumerStub: sinon.SinonStub;
  let producerStub: sinon.SinonStub;
  let client: any;

  beforeEach(() => {
    server = new ServerKafka({});
    untypedServer = server as any;

    callback = sinon.spy();
    connect = sinon.spy();
    subscribe = sinon.spy();
    run = sinon.spy();
    send = sinon.spy();
    on = sinon.spy();

    consumerStub = sinon.stub(server as any, 'consumer').callsFake(() => {
      return {
        connect,
        subscribe,
        run,
        on,
        events: {
          GROUP_JOIN: 'consumer.group_join',
          HEARTBEAT: 'consumer.heartbeat',
          COMMIT_OFFSETS: 'consumer.commit_offsets',
          FETCH_START: 'consumer.fetch_start',
          FETCH: 'consumer.fetch',
          START_BATCH_PROCESS: 'consumer.start_batch_process',
          END_BATCH_PROCESS: 'consumer.end_batch_process',
          CONNECT: 'consumer.connect',
          DISCONNECT: 'consumer.disconnect',
          STOP: 'consumer.stop',
          CRASH: 'consumer.crash',
          REBALANCING: 'consumer.rebalancing',
          RECEIVED_UNSUBSCRIBED_TOPICS: 'consumer.received_unsubscribed_topics',
          REQUEST: 'consumer.network.request',
          REQUEST_TIMEOUT: 'consumer.network.request_timeout',
          REQUEST_QUEUE_SIZE: 'consumer.network.request_queue_size',
        },
      };
    });
    producerStub = sinon.stub(server as any, 'producer').callsFake(() => {
      return {
        connect,
        send,
        on,
        events: {
          CONNECT: 'producer.connect',
          DISCONNECT: 'producer.disconnect',
          REQUEST: 'producer.network.request',
          REQUEST_TIMEOUT: 'producer.network.request_timeout',
          REQUEST_QUEUE_SIZE: 'producer.network.request_queue_size',
        },
      };
    });
    client = {
      consumer: consumerStub,
      producer: producerStub,
    };
    sinon.stub(server, 'createClient').callsFake(() => client);

    untypedServer = server as any;
  });

  describe('listen', () => {
    it('should call "bindEvents"', async () => {
      bindEventsStub = sinon
        .stub(server, 'bindEvents')
        .callsFake(() => ({}) as any);

      await server.listen(err => console.log(err));
      expect(bindEventsStub.called).to.be.true;
    });
    it('should call callback', async () => {
      await server.listen(callback);
      expect(callback.called).to.be.true;
    });
    describe('when "start" throws an exception', () => {
      it('should call callback with a thrown error as an argument', async () => {
        const error = new Error('random error');

        const callbackSpy = sinon.spy();
        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        await server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });

  describe('close', () => {
    const consumer = { disconnect: sinon.spy() };
    const producer = { disconnect: sinon.spy() };
    beforeEach(() => {
      untypedServer.consumer = consumer;
      untypedServer.producer = producer;
    });
    it('should close server', async () => {
      await server.close();

      expect(consumer.disconnect.calledOnce).to.be.true;
      expect(producer.disconnect.calledOnce).to.be.true;
      expect(untypedServer.consumer).to.be.null;
      expect(untypedServer.producer).to.be.null;
      expect(untypedServer.client).to.be.null;
    });
  });

  describe('bindEvents', () => {
    it('should not call subscribe nor run on consumer when there are no messageHandlers', async () => {
      untypedServer.logger = new NoopLogger();
      await server.listen(callback);
      await server.bindEvents(untypedServer.consumer);
      expect(subscribe.called).to.be.false;
      expect(run.called).to.be.true;
      expect(connect.called).to.be.true;
    });
    it('should call subscribe and run on consumer when there are messageHandlers', async () => {
      untypedServer.logger = new NoopLogger();
      await server.listen(callback);

      const pattern = 'test';
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler,
      });

      await server.bindEvents(untypedServer.consumer);

      expect(subscribe.called).to.be.true;
      expect(
        subscribe.calledWith({
          topics: [pattern],
        }),
      ).to.be.true;

      expect(run.called).to.be.true;
      expect(connect.called).to.be.true;
    });
    it('should call subscribe with options and run on consumer when there are messageHandlers', async () => {
      untypedServer.logger = new NoopLogger();
      untypedServer.options.subscribe = {};
      untypedServer.options.subscribe.fromBeginning = true;
      await server.listen(callback);

      const pattern = 'test';
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler,
      });

      await server.bindEvents(untypedServer.consumer);

      expect(subscribe.called).to.be.true;
      expect(
        subscribe.calledWith({
          topics: [pattern],
          fromBeginning: true,
        }),
      ).to.be.true;

      expect(run.called).to.be.true;
      expect(connect.called).to.be.true;
    });
  });

  describe('getMessageHandler', () => {
    it(`should return function`, () => {
      expect(typeof server.getMessageHandler()).to.be.eql('function');
    });
    describe('handler', () => {
      it('should call "handleMessage"', async () => {
        const handleMessageStub = sinon
          .stub(server, 'handleMessage')
          .callsFake(() => null!);
        await server.getMessageHandler()(null!);
        expect(handleMessageStub.called).to.be.true;
      });
    });
  });

  describe('getPublisher', () => {
    let sendMessageStub: sinon.SinonStub;
    let publisher;

    beforeEach(() => {
      publisher = server.getPublisher(
        replyTopic,
        replyPartition,
        correlationId,
      );
      sendMessageStub = sinon
        .stub(server, 'sendMessage')
        .callsFake(async () => []);
    });
    it(`should return function`, () => {
      expect(typeof server.getPublisher(null!, null!, correlationId)).to.be.eql(
        'function',
      );
    });
    it(`should call "publish" with expected arguments`, () => {
      const data = {
        id: 'uuid',
        value: 'string',
      };
      publisher(data);

      expect(
        sendMessageStub.calledWith(
          data,
          replyTopic,
          replyPartition,
          correlationId,
        ),
      ).to.be.true;
    });
  });

  describe('handleMessage', () => {
    let getPublisherSpy: sinon.SinonSpy;

    beforeEach(() => {
      sinon.stub(server, 'sendMessage').callsFake(async () => []);
      getPublisherSpy = sinon.spy();

      sinon.stub(server, 'getPublisher').callsFake(() => getPublisherSpy);
    });

    it('should call "handleEvent" if correlation identifier is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(eventPayload);
      expect(handleEventSpy.called).to.be.true;
    });

    it('should call "handleEvent" if correlation identifier is present but the reply topic is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(eventWithCorrelationIdPayload);
      expect(handleEventSpy.called).to.be.true;
    });

    it('should call event handler when "handleEvent" is called', async () => {
      const messageHandler = sinon.mock();
      const context = { test: true } as any;
      const messageData = 'some data';
      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);

      await server.handleEvent(
        topic,
        { data: messageData, pattern: topic },
        context,
      );
      expect(messageHandler.calledWith(messageData, context)).to.be.true;
    });

    it('should not catch error thrown by event handler as part of "handleEvent"', async () => {
      const error = new Error('handler error');
      const messageHandler = sinon.mock().throwsException(error);
      sinon.stub(server, 'getHandlerByPattern').callsFake(() => messageHandler);

      try {
        await server.handleEvent(
          topic,
          { data: 'some data', pattern: topic },
          {} as any,
        );

        // code should not be executed
        expect(true).to.be.false;
      } catch (e) {
        if (e instanceof AssertionError) {
          throw e;
        }
        expect(e).to.be.eq(error);
      }
    });

    it('should call "handleEvent" if correlation identifier and reply topic are present but the handler is of type eventHandler', async () => {
      const handler = sinon.spy();
      (handler as any).isEventHandler = true;
      untypedServer.messageHandlers = objectToMap({
        [topic]: handler,
      });
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(payload);
      expect(handleEventSpy.called).to.be.true;
    });

    it('should NOT call "handleEvent" if correlation identifier and reply topic are present but the handler is not of type eventHandler', async () => {
      const handler = sinon.spy();
      (handler as any).isEventHandler = false;
      untypedServer.messageHandlers = objectToMap({
        [topic]: handler,
      });
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(payload);
      expect(handleEventSpy.called).to.be.false;
    });

    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {
      await server.handleMessage(payload);
      expect(
        getPublisherSpy.calledWith({
          id: payload.message.headers![KafkaHeaders.CORRELATION_ID]!.toString(),
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });

    it(`should call handler with expected arguments`, async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [topic]: handler,
      });

      await server.handleMessage(payload);
      expect(handler.called).to.be.true;
    });
  });

  describe('sendMessage', () => {
    let sendSpy: sinon.SinonSpy;

    beforeEach(() => {
      sendSpy = sinon.spy();
      sinon.stub(server as any, 'producer').value({
        send: sendSpy,
      });
    });

    it('should send message', async () => {
      await server.sendMessage(
        {
          id: correlationId,
          response: messageValue,
        },
        replyTopic,
        replyPartition,
        correlationId,
      );

      expect(
        sendSpy.calledWith({
          topic: replyTopic,
          messages: [
            {
              partition: parseFloat(replyPartition),
              value: messageValue,
              headers: {
                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
              },
            },
          ],
        }),
      ).to.be.true;
    });
    it('should send message without reply partition', async () => {
      await server.sendMessage(
        {
          id: correlationId,
          response: messageValue,
        },
        replyTopic,
        undefined,
        correlationId,
      );

      expect(
        sendSpy.calledWith({
          topic: replyTopic,
          messages: [
            {
              value: messageValue,
              headers: {
                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
              },
            },
          ],
        }),
      ).to.be.true;
    });
    it('should send error message', async () => {
      await server.sendMessage(
        {
          id: correlationId,
          err: NO_MESSAGE_HANDLER,
        },
        replyTopic,
        replyPartition,
        correlationId,
      );

      expect(
        sendSpy.calledWith({
          topic: replyTopic,
          messages: [
            {
              value: null,
              partition: parseFloat(replyPartition),
              headers: {
                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
                [KafkaHeaders.NEST_ERR]: Buffer.from(NO_MESSAGE_HANDLER),
              },
            },
          ],
        }),
      ).to.be.true;
    });
    it('should send `isDisposed` message', async () => {
      await server.sendMessage(
        {
          id: correlationId,
          isDisposed: true,
        },
        replyTopic,
        replyPartition,
        correlationId,
      );

      expect(
        sendSpy.calledWith({
          topic: replyTopic,
          messages: [
            {
              value: null,
              partition: parseFloat(replyPartition),
              headers: {
                [KafkaHeaders.CORRELATION_ID]: Buffer.from(correlationId),
                [KafkaHeaders.NEST_IS_DISPOSED]: Buffer.alloc(1),
              },
            },
          ],
        }),
      ).to.be.true;
    });
  });

  describe('createClient', () => {
    it('should accept a custom logCreator in client options', () => {
      const logCreatorSpy = sinon.spy(() => 'test');
      const logCreator = () => logCreatorSpy;

      server = new ServerKafka({
        client: {
          brokers: [],
          logCreator,
        },
      });

      const logger = server.createClient().logger();

      logger.info({ namespace: '', level: 1, log: 'test' });

      expect(logCreatorSpy.called).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-mqtt.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
import { ServerMqtt } from '../../server/server-mqtt';
import { objectToMap } from './utils/object-to-map';

describe('ServerMqtt', () => {
  let server: ServerMqtt;
  let untypedServer: any;

  beforeEach(() => {
    server = new ServerMqtt({});
    untypedServer = server as any;
  });
  describe('listen', () => {
    let onSpy: sinon.SinonSpy;
    let client: any;
    let callbackSpy: sinon.SinonSpy;

    beforeEach(() => {
      onSpy = sinon.spy();
      client = {
        on: onSpy,
      };
      sinon.stub(server, 'createMqttClient').callsFake(() => client);
      callbackSpy = sinon.spy();
    });
    it('should bind "error" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(0).args[0]).to.be.equal('error');
    });
    it('should bind "reconnect" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(1).args[0]).to.be.equal('reconnect');
    });
    it('should bind "disconnect" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(2).args[0]).to.be.equal('disconnect');
    });
    it('should bind "close" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(3).args[0]).to.be.equal('close');
    });
    it('should bind "connect" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(4).args[0]).to.be.equal('connect');
    });
    it('should bind "message" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onSpy.getCall(5).args[0]).to.be.equal('message');
    });
    describe('when "start" throws an exception', () => {
      it('should call callback with a thrown error as an argument', async () => {
        const error = new Error('random error');

        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        await server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });
  describe('close', () => {
    const mqttClient = { end: sinon.spy() };
    beforeEach(() => {
      untypedServer.mqttClient = mqttClient;
    });
    it('should end mqttClient', () => {
      server.close();
      expect(mqttClient.end.called).to.be.true;
    });
  });
  describe('bindEvents', () => {
    let onSpy: sinon.SinonSpy, subscribeSpy: sinon.SinonSpy, mqttClient;

    beforeEach(() => {
      onSpy = sinon.spy();
      subscribeSpy = sinon.spy();
      mqttClient = {
        on: onSpy,
        subscribe: subscribeSpy,
      };
    });
    it('should subscribe to each pattern', () => {
      const pattern = 'test';
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler,
      });
      server.bindEvents(mqttClient);
      expect(subscribeSpy.calledWith(pattern)).to.be.true;
    });
  });
  describe('getMessageHandler', () => {
    it(`should return function`, () => {
      expect(
        typeof server.getMessageHandler(untypedServer.mqttClient),
      ).to.be.eql('function');
    });
    describe('handler', () => {
      it('should call "handleMessage"', async () => {
        const handleMessageStub = sinon
          .stub(server, 'handleMessage')
          .callsFake(() => null!);
        await server.getMessageHandler(untypedServer.mqttClient)(
          null!,
          null!,
          null!,
        );
        expect(handleMessageStub.called).to.be.true;
      });
    });
  });
  describe('handleMessage', () => {
    let getPublisherSpy: sinon.SinonSpy;

    const channel = 'test';
    const data = 'test';
    const id = '3';

    beforeEach(() => {
      getPublisherSpy = sinon.spy();
      sinon.stub(server, 'getPublisher').callsFake(() => getPublisherSpy);
    });
    it('should call "handleEvent" if identifier is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(
        channel,
        Buffer.from(JSON.stringify({ pattern: '', data })),
        null,
      );
      expect(handleEventSpy.called).to.be.true;
    });
    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {
      await server.handleMessage(
        channel,
        Buffer.from(JSON.stringify({ id, pattern: '', data })),
        null,
      );
      expect(
        getPublisherSpy.calledWith({
          id,
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it(`should call handler with expected arguments`, async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleMessage(
        channel,
        Buffer.from(JSON.stringify({ pattern: '', data, id: '2' })),
        null,
      );
      expect(handler.calledWith(data)).to.be.true;
    });
  });
  describe('getPublisher', () => {
    let publisherSpy: sinon.SinonSpy;
    let pub, publisher;

    const id = '1';
    const pattern = 'test';

    beforeEach(() => {
      publisherSpy = sinon.spy();
      pub = {
        publish: publisherSpy,
      };
      publisher = server.getPublisher(pub, pattern, id);
    });
    it(`should return function`, () => {
      expect(typeof server.getPublisher(null, null, id)).to.be.eql('function');
    });
    it(`should call "publish" with expected arguments`, () => {
      const respond = 'test';
      publisher({ respond, id });
      expect(
        publisherSpy.calledWith(
          `${pattern}/reply`,
          JSON.stringify({ respond, id }),
        ),
      ).to.be.true;
    });
  });
  describe('getRequestPattern', () => {
    const test = 'test';
    it(`should leave pattern as it is`, () => {
      expect(server.getRequestPattern(test)).to.equal(test);
    });
  });
  describe('getReplyPattern', () => {
    const test = 'test';
    it(`should append "/reply" to string`, () => {
      const expectedResult = test + '/reply';
      expect(server.getReplyPattern(test)).to.equal(expectedResult);
    });
  });
  describe('parseMessage', () => {
    it(`should return parsed json`, () => {
      const obj = { test: 'test' };
      expect(server.parseMessage(obj)).to.deep.equal(
        JSON.parse(JSON.stringify(obj)),
      );
    });
    it(`should not parse argument if it is not an object`, () => {
      const content = 'test';
      expect(server.parseMessage(content)).to.equal(content);
    });
  });
  describe('handleEvent', () => {
    const channel = 'test';
    const data = 'test';

    it('should call handler with expected arguments', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleEvent(
        channel,
        { pattern: '', data },
        new BaseRpcContext([]),
      );
      expect(handler.calledWith(data)).to.be.true;
    });
  });
  describe('matchMqttPattern', () => {
    it('should return true when topic matches with provided pattern', () => {
      expect(server.matchMqttPattern('root/valid/+', 'root/valid/child')).to.be
        .true;
      expect(server.matchMqttPattern('root/valid/#', 'root/valid/child')).to.be
        .true;
      expect(
        server.matchMqttPattern('root/valid/#', 'root/valid/child/grandchild'),
      ).to.be.true;
      expect(server.matchMqttPattern('root/+/child', 'root/valid/child')).to.be
        .true;
    });

    it('should return false when topic does not matches with provided pattern', () => {
      expect(server.matchMqttPattern('root/test/+', 'root/invalid/child')).to.be
        .false;
      expect(server.matchMqttPattern('root/test/#', 'root/invalid/child')).to.be
        .false;
      expect(
        server.matchMqttPattern(
          'root/#/grandchild',
          'root/invalid/child/grandchild',
        ),
      ).to.be.false;
      expect(
        server.matchMqttPattern(
          'root/+/grandchild',
          'root/invalid/child/grandchild',
        ),
      ).to.be.false;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-nats.spec.ts
================================================
import { expect } from 'chai';
import { JSONCodec } from 'nats';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { NatsContext } from '../../ctx-host';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
import { ServerNats } from '../../server/server-nats';
import { objectToMap } from './utils/object-to-map';

// type NatsMsg = import('nats').Msg;
type NatsMsg = any;

describe('ServerNats', () => {
  let server: ServerNats;
  let untypedServer: any;

  beforeEach(() => {
    server = new ServerNats({});
    untypedServer = server as any;
  });
  describe('listen', () => {
    let client: any;
    let callbackSpy: sinon.SinonSpy;

    beforeEach(() => {
      sinon.stub(server, 'createNatsClient').callsFake(() => client);
      callbackSpy = sinon.spy();
    });
    describe('when "start" throws an exception', async () => {
      it('should call callback with a thrown error as an argument', async () => {
        const error = new Error('random error');

        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        await server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });
  describe('close', () => {
    const natsClient = { close: sinon.spy() };
    beforeEach(() => {
      untypedServer.natsClient = natsClient;
    });
    it('should close natsClient', async () => {
      await server.close();
      expect(natsClient.close.called).to.be.true;
    });

    describe('when "gracefulShutdown" is true', () => {
      const waitForGracePeriod = sinon.spy();
      const subscriptions = [
        { unsubscribe: sinon.spy() },
        { unsubscribe: sinon.spy() },
      ];
      beforeEach(() => {
        (server as any).subscriptions = subscriptions;
        (server as any).waitForGracePeriod = waitForGracePeriod;
        (server as any).options.gracefulShutdown = true;
      });

      it('should unsubscribe all subscriptions', async () => {
        await server.close();
        for (const subscription of subscriptions) {
          expect(subscription.unsubscribe.calledOnce).to.be.true;
        }
      });

      it('should call "waitForGracePeriod"', async () => {
        await server.close();
        expect(waitForGracePeriod.called).to.be.true;
      });
    });

    describe('when "gracefulShutdown" is false', () => {
      const waitForGracePeriod = sinon.spy();
      const subscriptions = [
        { unsubscribe: sinon.spy() },
        { unsubscribe: sinon.spy() },
      ];
      beforeEach(() => {
        (server as any).subscriptions = subscriptions;
        (server as any).waitForGracePeriod = waitForGracePeriod;
        (server as any).options.gracefulShutdown = false;
      });
      it('should not unsubscribe all subscriptions', async () => {
        await server.close();
        for (const subscription of subscriptions) {
          expect(subscription.unsubscribe.called).to.be.false;
        }
      });

      it('should not call "waitForGracePeriod"', async () => {
        await server.close();
        expect(waitForGracePeriod.called).to.be.false;
      });
    });
  });
  describe('bindEvents', () => {
    let onSpy: sinon.SinonSpy, subscribeSpy: sinon.SinonSpy, natsClient;
    const pattern = 'test';
    const messageHandler = sinon.spy();

    beforeEach(() => {
      onSpy = sinon.spy();
      subscribeSpy = sinon.spy();
      natsClient = {
        on: onSpy,
        subscribe: subscribeSpy,
      };
      untypedServer.messageHandlers = objectToMap({
        [pattern]: messageHandler,
      });
    });

    it('should subscribe to every pattern', () => {
      server.bindEvents(natsClient);
      expect(subscribeSpy.calledWith(pattern)).to.be.true;
    });

    it('should use a per pattern queue if provided', () => {
      const queue = 'test';
      untypedServer.messageHandlers = objectToMap({
        [pattern]: Object.assign(messageHandler, {
          extras: {
            queue,
          },
        }),
      });
      server.bindEvents(natsClient);
      const lastCall = subscribeSpy.lastCall;
      expect(lastCall.args[1].queue).to.be.eql(queue);
    });

    it('should fill the subscriptions array properly', () => {
      server.bindEvents(natsClient);
      expect(server['subscriptions'].length).to.be.equals(1);
    });
  });
  describe('getMessageHandler', () => {
    it(`should return function`, () => {
      expect(typeof server.getMessageHandler(null!)).to.be.eql('function');
    });
    describe('handler', () => {
      it('should call "handleMessage"', async () => {
        const handleMessageStub = sinon
          .stub(server, 'handleMessage')
          .callsFake(() => null!);
        await server.getMessageHandler('')('' as any, '');
        expect(handleMessageStub.called).to.be.true;
      });
    });
  });
  describe('handleMessage', () => {
    let getPublisherSpy: sinon.SinonSpy;

    const channel = 'test';
    const id = '3';

    beforeEach(() => {
      getPublisherSpy = sinon.spy();
      sinon.stub(server, 'getPublisher').callsFake(() => getPublisherSpy);
    });
    it('should call "handleEvent" if identifier is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      const data = JSONCodec().encode({ id: 10 });
      const natsMsg: NatsMsg = {
        data,
        subject: channel,
        sid: +id,
        respond: sinon.spy(),
      };
      await server.handleMessage(channel, natsMsg);
      expect(handleEventSpy.called).to.be.true;
    });
    it(`should publish NO_MESSAGE_HANDLER if pattern does not exist in messageHandlers object`, async () => {
      const data = JSONCodec().encode({
        id,
        pattern: 'test',
        data: 'test',
      });
      const natsMsg: NatsMsg = {
        data,
        subject: channel,
        sid: +id,
        respond: sinon.spy(),
      };

      await server.handleMessage(channel, natsMsg);
      expect(
        getPublisherSpy.calledWith({
          id,
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it(`should call handler with expected arguments`, async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      const headers = {};
      const natsContext = new NatsContext([channel, headers]);

      const data = JSONCodec().encode({
        pattern: channel,
        data: 'test',
        id,
      });
      const natsMsg: NatsMsg = {
        data,
        subject: channel,
        sid: +id,
        respond: sinon.spy(),
        headers,
      };
      await server.handleMessage(channel, natsMsg);
      expect(handler.calledWith('test', natsContext)).to.be.true;
    });
  });
  describe('getPublisher', () => {
    const id = '1';

    it(`should return function`, () => {
      const natsMsg: NatsMsg = {
        data: new Uint8Array(),
        subject: '',
        sid: +id,
        respond: sinon.spy(),
      };
      expect(typeof server.getPublisher(natsMsg, id)).to.be.eql('function');
    });
    it(`should call "respond" when reply topic provided`, () => {
      const replyTo = 'test';
      const natsMsg = {
        data: new Uint8Array(),
        subject: '',
        sid: +id,
        respond: sinon.spy(),
        reply: replyTo,
      };
      const publisher = server.getPublisher(natsMsg, id);

      const respond = 'test';
      publisher({ respond, id });
      expect(natsMsg.respond.calledWith(JSONCodec().encode({ respond, id }))).to
        .be.true;
    });
    it(`should not call "publish" when replyTo NOT provided`, () => {
      const replyTo = undefined;
      const natsMsg = {
        data: new Uint8Array(),
        subject: '',
        reply: replyTo,
        sid: +id,
        respond: sinon.spy(),
      };
      const publisher = server.getPublisher(natsMsg, id);

      const respond = 'test';
      publisher({ respond, id });
      expect(natsMsg.respond.notCalled);
    });
  });
  describe('handleEvent', () => {
    const channel = 'test';
    const data = 'test';

    it('should call handler with expected arguments', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleEvent(
        channel,
        { pattern: '', data },
        new BaseRpcContext([]),
      );
      expect(handler.calledWith(data)).to.be.true;
    });
  });
  describe('handleStatusUpdates', () => {
    it('should retrieve "status()" async iterator', () => {
      const serverMock = {
        status: sinon.stub().returns({
          [Symbol.asyncIterator]: [],
        }),
      };
      void server.handleStatusUpdates(serverMock as any);
      expect(serverMock.status.called).to.be.true;
    });

    it('should log "disconnect" and "error" statuses as "errors"', async () => {
      const logErrorSpy = sinon.spy(untypedServer.logger, 'error');
      const serverMock = {
        status: sinon.stub().returns({
          async *[Symbol.asyncIterator]() {
            yield { type: 'disconnect', data: 'localhost' };
            yield { type: 'error', data: {} };
          },
        }),
      };
      await server.handleStatusUpdates(serverMock as any);
      expect(logErrorSpy.calledTwice).to.be.true;
      expect(
        logErrorSpy.calledWith(
          `NatsError: type: "disconnect", data: "localhost".`,
        ),
      );
      expect(
        logErrorSpy.calledWith(`NatsError: type: "disconnect", data: "{}".`),
      );
    });
    it('should log other statuses as "logs"', async () => {
      const logSpy = sinon.spy(untypedServer.logger, 'log');
      const serverMock = {
        status: sinon.stub().returns({
          async *[Symbol.asyncIterator]() {
            yield { type: 'non-disconnect', data: 'localhost' };
            yield { type: 'warn', data: {} };
          },
        }),
      };
      await server.handleStatusUpdates(serverMock as any);
      expect(logSpy.calledTwice).to.be.true;
      expect(
        logSpy.calledWith(
          `NatsStatus: type: "non-disconnect", data: "localhost".`,
        ),
      );
      expect(logSpy.calledWith(`NatsStatus: type: "warn", data: "{}".`));
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-redis.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
import { ServerRedis } from '../../server/server-redis';
import { objectToMap } from './utils/object-to-map';

describe('ServerRedis', () => {
  let server: ServerRedis;
  let untypedServer: any;

  beforeEach(() => {
    server = new ServerRedis({});
    untypedServer = server as any;
  });
  describe('listen', () => {
    let onSpy: sinon.SinonSpy;
    let connectSpy: sinon.SinonSpy;
    let client: any;
    let callbackSpy: sinon.SinonSpy;

    beforeEach(() => {
      onSpy = sinon.spy();
      connectSpy = sinon.spy();

      client = {
        on: onSpy,
        connect: connectSpy,
      };
      sinon.stub(server, 'createRedisClient').callsFake(() => client);

      callbackSpy = sinon.spy();
    });
    it('should bind "error" event to handler', () => {
      server.listen(callbackSpy);
      expect(onSpy.getCall(0).args[0]).to.be.equal('error');
    });
    it('should call "RedisClient#connect()"', () => {
      server.listen(callbackSpy);
      expect(connectSpy.called).to.be.true;
    });
    describe('when "start" throws an exception', () => {
      it('should call callback with a thrown error as an argument', () => {
        const error = new Error('random error');

        const callbackSpy = sinon.spy();
        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });
  describe('close', () => {
    const pub = { quit: sinon.spy() };
    const sub = { quit: sinon.spy() };
    beforeEach(() => {
      untypedServer.pubClient = pub;
      untypedServer.subClient = sub;
    });
    it('should close pub & sub server', () => {
      server.close();

      expect(pub.quit.called).to.be.true;
      expect(sub.quit.called).to.be.true;
    });
  });
  describe('handleConnection', () => {
    let onSpy: sinon.SinonSpy, subscribeSpy: sinon.SinonSpy, sub, psub;

    beforeEach(() => {
      onSpy = sinon.spy();
      subscribeSpy = sinon.spy();
      sub = {
        on: onSpy,
        subscribe: subscribeSpy,
      };
      psub = {
        on: onSpy,
        psubscribe: subscribeSpy,
      };
    });
    it('should bind "message" event to handler if wildcards are disabled', () => {
      server.bindEvents(sub, null);
      expect(onSpy.getCall(0).args[0]).to.be.equal('message');
    });
    it('should bind "pmessage" event to handler if wildcards are enabled', () => {
      untypedServer.options = {};
      untypedServer.options.wildcards = true;

      server.bindEvents(psub, null);
      expect(onSpy.getCall(0).args[0]).to.be.equal('pmessage');
    });

    it('should "subscribe" to each pattern if wildcards are disabled', () => {
      const pattern = 'test';
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler,
      });
      server.bindEvents(sub, null);
      expect(subscribeSpy.calledWith(pattern)).to.be.true;
    });

    it('should "psubscribe" to each pattern if wildcards are enabled', () => {
      untypedServer.options = {};
      untypedServer.options.wildcards = true;

      const pattern = 'test';
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler,
      });
      server.bindEvents(psub, null);
      expect(subscribeSpy.calledWith(pattern)).to.be.true;
    });
  });
  describe('getMessageHandler', () => {
    it(`should return function`, () => {
      expect(typeof server.getMessageHandler(null)).to.be.eql('function');
    });
  });
  describe('handleMessage', () => {
    let getPublisherSpy: sinon.SinonSpy;

    const channel = 'test';
    const data = 'test';
    const id = '3';

    beforeEach(() => {
      getPublisherSpy = sinon.spy();
      sinon.stub(server, 'getPublisher').callsFake(() => getPublisherSpy);
    });
    it('should call "handleEvent" if identifier is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      sinon.stub(server, 'parseMessage').callsFake(() => ({ data }) as any);

      await server.handleMessage(channel, JSON.stringify({}), null, channel);
      expect(handleEventSpy.called).to.be.true;
    });
    it(`should publish NO_MESSAGE_HANDLER if pattern not exists in messageHandlers object`, async () => {
      sinon.stub(server, 'parseMessage').callsFake(() => ({ id, data }) as any);
      await server.handleMessage(
        channel,
        JSON.stringify({ id }),
        null,
        channel,
      );
      expect(
        getPublisherSpy.calledWith({
          id,
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it(`should call handler with expected arguments`, async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });
      sinon.stub(server, 'parseMessage').callsFake(() => ({ id, data }) as any);

      await server.handleMessage(channel, '', null, channel);
      expect(handler.calledWith(data)).to.be.true;
    });
  });
  describe('getPublisher', () => {
    let publisherSpy: sinon.SinonSpy;
    let pub, publisher;

    const id = '1';
    const pattern = 'test';

    beforeEach(() => {
      publisherSpy = sinon.spy();
      pub = {
        publish: publisherSpy,
      };
      publisher = server.getPublisher(pub, pattern, id);
    });
    it(`should return function`, () => {
      expect(typeof server.getPublisher(null, null, id)).to.be.eql('function');
    });
    it(`should call "publish" with expected arguments`, () => {
      const respond = 'test';
      publisher({ respond, id });
      expect(
        publisherSpy.calledWith(
          `${pattern}.reply`,
          JSON.stringify({ respond, id }),
        ),
      ).to.be.true;
    });
  });
  describe('parseMessage', () => {
    it(`should return parsed json`, () => {
      const obj = { test: 'test' };
      expect(server.parseMessage(obj)).to.deep.equal(
        JSON.parse(JSON.stringify(obj)),
      );
    });
    it(`should not parse argument if it is not an object`, () => {
      const content = 'test';
      expect(server.parseMessage(content)).to.equal(content);
    });
  });
  describe('getRequestPattern', () => {
    const test = 'test';
    it(`should leave pattern as it is`, () => {
      const expectedResult = test;
      expect(server.getRequestPattern(test)).to.equal(expectedResult);
    });
  });
  describe('getReplyPattern', () => {
    const test = 'test';
    it(`should append ".reply" to string`, () => {
      const expectedResult = test + '.reply';
      expect(server.getReplyPattern(test)).to.equal(expectedResult);
    });
  });
  describe('getClientOptions', () => {
    it('should return options object with "retryStrategy" and call "createRetryStrategy"', () => {
      const createSpy = sinon.spy(server, 'createRetryStrategy');
      const { retryStrategy } = server.getClientOptions()!;
      try {
        retryStrategy!(0);
      } catch {
        // Ignore
      }
      expect(createSpy.called).to.be.true;
    });
  });
  describe('createRetryStrategy', () => {
    describe('when is terminated', () => {
      it('should return undefined', () => {
        untypedServer.isManuallyClosed = true;
        const result = server.createRetryStrategy(0);
        expect(result).to.be.undefined;
      });
    });
    describe('when "retryAttempts" does not exist', () => {
      it('should return undefined', () => {
        untypedServer.options.options = {};
        untypedServer.options.options.retryAttempts = undefined;

        expect(server.createRetryStrategy(4)).to.be.undefined;
      });
    });
    describe('when "attempts" count is max', () => {
      it('should return undefined', () => {
        untypedServer.options.options = {};
        untypedServer.options.options.retryAttempts = 3;

        expect(server.createRetryStrategy(4)).to.be.undefined;
      });
    });
    describe('otherwise', () => {
      it('should return delay (ms)', () => {
        untypedServer.options = {};
        untypedServer.isManuallyClosed = false;
        untypedServer.options.retryAttempts = 3;
        untypedServer.options.retryDelay = 3;
        const result = server.createRetryStrategy(2);
        expect(result).to.be.eql(untypedServer.options.retryDelay);
      });
    });
  });
  describe('handleEvent', () => {
    const channel = 'test';
    const data = 'test';

    it('should call handler with expected arguments', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleEvent(
        channel,
        { pattern: '', data },
        new BaseRpcContext([]),
      );
      expect(handler.calledWith(data)).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-rmq.spec.ts
================================================
import { assert, expect } from 'chai';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { RmqContext } from '../../ctx-host';
import { ServerRMQ } from '../../server/server-rmq';
import { objectToMap } from './utils/object-to-map';

describe('ServerRMQ', () => {
  let server: ServerRMQ;
  let untypedServer: any;

  beforeEach(() => {
    server = new ServerRMQ({});
    untypedServer = server as any;
  });

  describe('listen', () => {
    let createClient: sinon.SinonStub;
    let onStub: sinon.SinonStub;
    let createChannelStub: sinon.SinonStub;
    let setupChannelStub: sinon.SinonStub;
    let client: any;
    let callbackSpy: sinon.SinonSpy;

    beforeEach(() => {
      onStub = sinon
        .stub()
        .callsFake((event, callback) => event === 'connect' && callback());
      createChannelStub = sinon.stub().callsFake(({ setup }) => setup());
      setupChannelStub = sinon
        .stub(server, 'setupChannel')
        .callsFake(() => ({}) as any);

      client = {
        on: onStub,
        once: onStub,
        createChannel: createChannelStub,
      };
      createClient = sinon.stub(server, 'createClient').callsFake(() => client);
      callbackSpy = sinon.spy();
    });
    afterEach(() => {
      setupChannelStub.restore();
    });
    it('should call "createClient"', async () => {
      await server.listen(callbackSpy);
      expect(createClient.called).to.be.true;
    });
    it('should bind "connect" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onStub.getCall(0).args[0]).to.be.equal('connect');
    });
    it('should bind "disconnected" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onStub.getCall(2).args[0]).to.be.equal('disconnect');
    });
    it('should bind "connectFailed" event to handler', async () => {
      await server.listen(callbackSpy);
      expect(onStub.getCall(3).args[0]).to.be.equal('connectFailed');
    });
    describe('when "start" throws an exception', () => {
      it('should call callback with a thrown error as an argument', async () => {
        const error = new Error('random error');

        sinon.stub(server, 'start').callsFake(() => {
          throw error;
        });
        await server.listen(callbackSpy);
        expect(callbackSpy.calledWith(error)).to.be.true;
      });
    });
  });
  describe('close', () => {
    const rmqServer = { close: sinon.spy() };
    const rmqChannel = { close: sinon.spy() };

    beforeEach(() => {
      untypedServer.server = rmqServer;
      untypedServer.channel = rmqChannel;
    });
    it('should close server', () => {
      server.close();
      expect(rmqServer.close.called).to.be.true;
    });
    it('should close channel', () => {
      server.close();
      expect(rmqChannel.close.called).to.be.true;
    });
  });

  describe('handleMessage', () => {
    const createMessage = payload => ({
      content: {
        toString: () => JSON.stringify(payload),
      },
      properties: { correlationId: 1 },
    });
    const pattern = 'test';
    const msg = createMessage({
      pattern,
      data: 'tests',
      id: '3',
    });
    const channel = {
      nack: sinon.spy(),
    };

    let sendMessageStub: sinon.SinonStub;

    beforeEach(() => {
      sendMessageStub = sinon.stub(server, 'sendMessage').callsFake(() => ({}));
      untypedServer.channel = channel;
    });
    afterEach(() => {
      channel.nack.resetHistory();
    });
    it('should call "handleEvent" if identifier is not present', async () => {
      const handleEventSpy = sinon.spy(server, 'handleEvent');
      await server.handleMessage(createMessage({ pattern: '', data: '' }), '');
      expect(handleEventSpy.called).to.be.true;
    });
    it('should send NO_MESSAGE_HANDLER error if key does not exists in handlers object', async () => {
      await server.handleMessage(msg, '');
      expect(
        sendMessageStub.calledWith({
          id: '3',
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it('should call handler if exists in handlers object', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler as any,
      });
      await server.handleMessage(msg, '');
      expect(handler.calledOnce).to.be.true;
    });
    it('should not throw if the message is an invalid json', async () => {
      const invalidMsg = {
        content: {
          toString: () => 'd',
        },
        properties: { correlationId: 1 },
      };
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [pattern]: handler as any,
      });

      return server.handleMessage(invalidMsg, '').catch(() => {
        assert.fail('Was not supposed to throw an error');
      });
    });
    it('should negative acknowledge if message does not exists in handlers object and noAck option is false', async () => {
      untypedServer.noAck = false;
      await server.handleMessage(msg, '');
      expect(channel.nack.calledWith(msg, false, false)).to.be.true;
      expect(
        sendMessageStub.calledWith({
          id: '3',
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it('should not negative acknowledge if key does not exists in handlers object and noAck option is true', async () => {
      await server.handleMessage(msg, '');
      expect(channel.nack.notCalled).to.be.true;
      expect(
        sendMessageStub.calledWith({
          id: '3',
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
  });
  describe('setupChannel', () => {
    const queue = 'test';
    const queueOptions = {};
    const isGlobalPrefetchCount = true;
    const prefetchCount = 10;

    let channel: any = {};

    beforeEach(() => {
      untypedServer['queue'] = queue;
      untypedServer['queueOptions'] = queueOptions;
      untypedServer['options'] = {
        isGlobalPrefetchCount,
        prefetchCount,
      };

      channel = {
        assertQueue: sinon.spy(() => ({})),
        prefetch: sinon.spy(),
        consume: sinon.spy(),
      };
    });
    it('should call "assertQueue" with queue and queue options when noAssert is false', async () => {
      server['noAssert' as any] = false;

      await server.setupChannel(channel, () => null);
      expect(channel.assertQueue.calledWith(queue, queueOptions)).to.be.true;
    });
    it('should not call "assertQueue" when noAssert is true', async () => {
      server['options' as any] = {
        ...(server as any)['options'],
        noAssert: true,
      };

      await server.setupChannel(channel, () => null);
      expect(channel.assertQueue.called).not.to.be.true;
    });
    it('should call "prefetch" with prefetchCount and "isGlobalPrefetchCount"', async () => {
      await server.setupChannel(channel, () => null);
      expect(channel.prefetch.calledWith(prefetchCount, isGlobalPrefetchCount))
        .to.be.true;
    });
    it('should call "consumeChannel" method', async () => {
      await server.setupChannel(channel, () => null);
      expect(channel.consume.called).to.be.true;
    });
    it('should call "resolve" function', async () => {
      const resolve = sinon.spy();
      await server.setupChannel(channel, resolve);
      expect(resolve.called).to.be.true;
    });
  });

  describe('sendMessage', () => {
    let channel: any;

    beforeEach(() => {
      channel = {
        sendToQueue: sinon.spy(),
      };
      server['channel'] = channel;
    });

    it('should publish message to indicated queue', () => {
      const message = { test: true };
      const replyTo = 'test';
      const correlationId = '0';

      server.sendMessage(message, replyTo, correlationId);
      expect(
        channel.sendToQueue.calledWith(
          replyTo,
          Buffer.from(JSON.stringify(message)),
          { correlationId },
        ),
      ).to.be.true;
    });
  });

  describe('handleEvent', () => {
    const channel = 'test';
    const data = 'test';

    it('should call handler with expected arguments', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleEvent(
        channel,
        { pattern: '', data },
        new RmqContext([{}, {}, '']),
      );
      expect(handler.calledWith(data)).to.be.true;
    });

    it('should negative acknowledge without retrying if key does not exists in handlers object and noAck option is false', async () => {
      const nack = sinon.spy();
      const message = { pattern: 'no-exists', data };
      untypedServer.channel = {
        nack,
      };
      untypedServer.noAck = false;
      await server.handleEvent(
        channel,
        message,
        new RmqContext([message, '', '']),
      );

      expect(nack.calledWith(message, false, false)).to.be.true;
    });

    it('should not negative acknowledge if key does not exists in handlers object but noAck option is true', async () => {
      const nack = sinon.spy();
      const message = { pattern: 'no-exists', data };
      untypedServer.channel = {
        nack,
      };
      untypedServer.noAck = true;
      await server.handleEvent(
        channel,
        message,
        new RmqContext([message, '', '']),
      );

      expect(nack.calledWith(message, false, false)).not.to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server-tcp.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { NO_MESSAGE_HANDLER } from '../../constants';
import { BaseRpcContext } from '../../ctx-host/base-rpc.context';
import { ServerTCP } from '../../server/server-tcp';
import { objectToMap } from './utils/object-to-map';

describe('ServerTCP', () => {
  let server: ServerTCP;
  let untypedServer: any;

  beforeEach(() => {
    server = new ServerTCP({});
    untypedServer = server as any;
  });

  describe('bindHandler', () => {
    const socket = { on: sinon.spy() };

    beforeEach(() => {
      sinon.stub(server, 'getSocketInstance' as any).callsFake(() => socket);
    });
    it('should bind message and error events to handler', () => {
      server.bindHandler(null!);
      expect(socket.on.calledTwice).to.be.true;
    });
  });
  describe('close', () => {
    const tcpServer = { close: sinon.spy() };
    beforeEach(() => {
      untypedServer.server = tcpServer;
    });
    it('should close server', () => {
      server.close();
      expect(tcpServer.close.called).to.be.true;
    });
  });
  describe('listen', () => {
    const serverMock = { listen: sinon.spy(), once: sinon.spy() };
    beforeEach(() => {
      untypedServer.server = serverMock;
    });
    it('should call native listen method with expected arguments', () => {
      const callback = () => {};
      server.listen(callback);
      expect(
        serverMock.listen.calledWith(
          untypedServer.port,
          untypedServer.host,
          callback,
        ),
      ).to.be.true;
    });
  });
  describe('handleMessage', () => {
    let socket;
    const msg = {
      pattern: 'test',
      data: 'tests',
      id: '3',
    };
    beforeEach(() => {
      socket = {
        sendMessage: sinon.spy(),
      };
    });
    it('should send NO_MESSAGE_HANDLER error if key does not exists in handlers object', async () => {
      await server.handleMessage(socket, msg);
      expect(
        socket.sendMessage.calledWith({
          id: msg.id,
          status: 'error',
          err: NO_MESSAGE_HANDLER,
        }),
      ).to.be.true;
    });
    it('should call handler if exists in handlers object', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [msg.pattern]: handler as any,
      });
      await server.handleMessage(socket, msg);
      expect(handler.calledOnce).to.be.true;
    });
  });
  describe('handleClose', () => {
    describe('when is terminated', () => {
      it('should return undefined', () => {
        untypedServer.isExplicitlyTerminated = true;
        const result = server.handleClose();
        expect(result).to.be.undefined;
      });
    });
    describe('when "retryAttempts" does not exist', () => {
      it('should return undefined', () => {
        untypedServer.options.retryAttempts = undefined;
        const result = server.handleClose();
        expect(result).to.be.undefined;
      });
    });
    describe('when "retryAttemptsCount" count is max', () => {
      it('should return undefined', () => {
        untypedServer.options.retryAttempts = 3;
        untypedServer.retryAttemptsCount = 3;
        const result = server.handleClose();
        expect(result).to.be.undefined;
      });
    });
    describe('otherwise', () => {
      it('should return delay (ms)', () => {
        untypedServer.options = {};
        untypedServer.isExplicitlyTerminated = false;
        untypedServer.options.retryAttempts = 3;
        untypedServer.retryAttemptsCount = 2;
        untypedServer.options.retryDelay = 3;
        const result = server.handleClose();
        expect(result).to.be.not.undefined;
      });
    });
  });

  describe('handleEvent', () => {
    const channel = 'test';
    const data = 'test';

    it('should call handler with expected arguments', async () => {
      const handler = sinon.spy();
      untypedServer.messageHandlers = objectToMap({
        [channel]: handler,
      });

      await server.handleEvent(
        channel,
        { pattern: '', data },
        new BaseRpcContext([]),
      );
      expect(handler.calledWith(data)).to.be.true;
    });
  });
});



================================================
FILE: packages/microservices/test/server/server.spec.ts
================================================
import { expect } from 'chai';
import { throwError as _throw, lastValueFrom, Observable, of } from 'rxjs';
import * as sinon from 'sinon';
import { Server } from '../../server/server';

class TestServer extends Server {
  public on<
    EventKey extends string = string,
    EventCallback extends Function = Function,
  >(event: EventKey, callback: EventCallback) {}
  public unwrap<T>(): T {
    return null!;
  }
  public listen(callback: () => void) {}
  public close() {}
}

describe('Server', () => {
  const server = new TestServer();
  const untypedServer = server as any;
  const sandbox = sinon.createSandbox();
  const callback = () => {},
    pattern = { test: 'test pattern' };

  afterEach(() => {
    sandbox.restore();
  });

  describe('addHandler', () => {
    it(`should add handler`, () => {
      const handlerRoute = 'hello';
      sandbox
        .stub(server as any, 'messageHandlers')
        .value({ set() {}, has() {} });

      const messageHandlersSetSpy = sinon.spy(
        untypedServer.messageHandlers,
        'set',
      );
      const normalizePatternStub = sinon
        .stub(server as any, 'normalizePattern')
        .returns(handlerRoute);

      server.addHandler(pattern, callback as any);

      expect(messageHandlersSetSpy.called).to.be.true;
      expect(messageHandlersSetSpy.args[0][0]).to.be.equal(handlerRoute);
      expect(messageHandlersSetSpy.args[0][1]).to.be.equal(callback);

      normalizePatternStub.restore();
    });
    describe('when handler is an event handler', () => {
      describe('and there are other handlers registered for the pattern already', () => {
        it('should find tail and assign a handler ref to it', () => {
          const handlerRoute = 'hello';
          const headHandler: any = () => null;
          const nextHandler: any = () => null;

          headHandler.next = nextHandler;
          untypedServer['messageHandlers'] = new Map([
            [handlerRoute, headHandler],
          ]);
          const normalizePatternStub = sinon
            .stub(server as any, 'normalizePattern')
            .returns(handlerRoute);

          server.addHandler(pattern, callback as any, true);

          expect(nextHandler.next).to.equal(callback);
          normalizePatternStub.restore();
        });
      });
    });
  });

  describe('getRouteFromPattern', () => {
    let normalizePatternStub: sinon.SinonStub;

    beforeEach(() => {
      normalizePatternStub = sinon.stub(server as any, 'normalizePattern');
    });

    afterEach(() => {
      normalizePatternStub.restore();
    });

    describe(`when gets 'string' pattern`, () => {
      it(`should call 'transformPatternToRoute' with 'string' argument`, () => {
        const inputServerPattern = 'hello';
        const transformedServerPattern = inputServerPattern;
        untypedServer.getRouteFromPattern(inputServerPattern);

        expect(normalizePatternStub.args[0][0]).to.be.equal(
          transformedServerPattern,
        );
      });
    });

    describe(`when gets 'json' pattern as 'string'`, () => {
      it(`should call 'transformPatternToRoute' with 'json' argument`, () => {
        const inputServerPattern = '{"controller":"app","use":"getHello"}';
        const transformedServerPattern = {
          controller: 'app',
          use: 'getHello',
        };
        untypedServer.getRouteFromPattern(inputServerPattern);

        expect(normalizePatternStub.args[0][0]).to.be.deep.equal(
          transformedServerPattern,
        );
      });
    });
  });

  describe('send', () => {
    let stream$: Observable<string>;
    let sendSpy: sinon.SinonSpy;
    beforeEach(() => {
      stream$ = of('test');
    });
    describe('when stream', () => {
      beforeEach(() => {
        sendSpy = sinon.spy();
      });
      describe('throws exception', () => {
        beforeEach(() => {
          server.send(_throw(() => 'test') as any, sendSpy);
        });
        it('should send error and complete', () => {
          process.nextTick(() => {
            expect(
              sendSpy.calledWith({
                err: 'test',
                isDisposed: true,
              }),
            ).to.be.true;
          });
        });
      });
      describe('emits response', () => {
        beforeEach(() => {
          server.send(stream$, sendSpy);
        });
        it('should send response and "complete" event', () => {
          process.nextTick(() => {
            expect(
              sendSpy.calledWith({
                response: 'test',
                isDisposed: true,
              }),
            ).to.be.true;
          });
        });
      });
    });
  });
  describe('transformToObservable', () => {
    describe('when resultOrDeferred', () => {
      describe('is Promise', () => {
        it('should return Observable that emits the resolved value of the supplied promise', async () => {
          const value = 100;
          expect(
            await lastValueFrom(
              server.transformToObservable(Promise.resolve(value)),
            ),
          ).to.be.eq(100);
        });
      });
      describe('is Observable', () => {
        it('should return the observable itself', async () => {
          const value = 100;
          expect(
            await lastValueFrom(server.transformToObservable(of(value))),
          ).to.be.eq(100);
        });
      });
      describe('is any number', () => {
        it('should return Observable that emits the supplied number', async () => {
          const value = 100;
          expect(
            await lastValueFrom(server.transformToObservable(value)),
          ).to.be.eq(100);
        });
      });
      describe('is an array', () => {
        it('should return Observable that emits the supplied array', async () => {
          const value = [1, 2, 3];
          expect(
            await lastValueFrom(server.transformToObservable(value)),
          ).to.be.eq(value);
        });
      });
    });
  });

  describe('getHandlers', () => {
    it('should return registered handlers', () => {
      const messageHandlers = [() => null, () => true];
      sandbox.stub(server as any, 'messageHandlers').value(messageHandlers);
      expect(server.getHandlers()).to.equal(messageHandlers);
    });
  });

  describe('getHandlerByPattern', () => {
    let messageHandlersGetSpy: sinon.SinonStub;
    let messageHandlersHasSpy: sinon.SinonStub;
    const handlerRoute = 'hello';

    beforeEach(() => {
      sandbox
        .stub(server as any, 'messageHandlers')
        .value({ get() {}, has() {} });
      messageHandlersGetSpy = sinon
        .stub(untypedServer.messageHandlers, 'get')
        .returns(callback);
      messageHandlersHasSpy = sinon.stub(untypedServer.messageHandlers, 'has');

      sandbox.stub(server as any, 'getRouteFromPattern').returns(handlerRoute);
    });

    afterEach(() => {
      messageHandlersGetSpy.restore();
      messageHandlersHasSpy.restore();
    });

    describe('when handler exists', () => {
      it('should return expected handler', () => {
        messageHandlersHasSpy.returns(true);

        const value = server.getHandlerByPattern(handlerRoute);

        expect(messageHandlersHasSpy.args[0][0]).to.be.equal(handlerRoute);
        expect(messageHandlersGetSpy.called).to.be.true;
        expect(messageHandlersGetSpy.args[0][0]).to.be.equal(handlerRoute);
        expect(value).to.be.equal(callback);
      });
    });

    describe('when handler does not exists', () => {
      it('should return null', () => {
        messageHandlersHasSpy.returns(false);

        const value = server.getHandlerByPattern(handlerRoute);

        expect(messageHandlersHasSpy.args[0][0]).to.be.equal(handlerRoute);
        expect(messageHandlersGetSpy.called).to.be.false;
        expect(value).to.be.null;
      });
    });
  });
});



================================================
FILE: packages/microservices/test/server/test.proto
================================================
syntax = "proto3";

package test;


================================================
FILE: packages/microservices/test/server/test2.proto
================================================
syntax = "proto3";

package test2;


================================================
FILE: packages/microservices/test/server/utils/object-to-map.ts
================================================
export const objectToMap = (obj: Record<string, any>) =>
  new Map(Object.keys(obj).map(key => [key, obj[key]]) as any);



================================================
FILE: packages/microservices/test/utils/transform-pattern.utils.spec.ts
================================================
import { expect } from 'chai';
import { MsPattern } from '../../interfaces';
import { transformPatternToRoute } from '../../utils/transform-pattern.utils';

function equalTest<R>(testPatterns: MsPattern[], expectedResults: R[]) {
  testPatterns.forEach((testPattern: MsPattern, index: number) => {
    const testData = transformPatternToRoute(testPattern);
    expect(testData).to.be.equal(expectedResults[index]);
  });
}
describe('transformPatternToRoute', () => {
  describe(`when gets 'number' value`, () => {
    it(`should return the 'number' what is wrapped in a string`, () => {
      const testPatterns = [1, 150, 12345];
      const expectedResults = [`1`, `150`, `12345`];

      equalTest(testPatterns, expectedResults);
    });
  });

  describe(`when gets 'string' value`, () => {
    it(`should return the same string`, () => {
      const testPatterns = [`pattern1`, 'PaTteRn2', '3PaTteRn'];

      equalTest(testPatterns, testPatterns);
    });
  });

  describe(`when gets 'JSON' value`, () => {
    describe(`without nested JSON (1 level)`, () => {
      it(`should return correct route`, () => {
        const testPatterns = [
          {
            controller: 'app',
            use: 'getHello',
          },
          {
            use: 'getHello',
            controller: 'app',
          },
          {
            service: 'one',
            use: 'getHello',
            controller: 'app',
            id: 150,
          },
        ] as MsPattern[];

        const expectedResults = [
          JSON.stringify(testPatterns[0]),
          `{"controller":"app","use":"getHello"}`,
          `{"controller":"app","id":150,"service":"one","use":"getHello"}`,
        ];

        equalTest(testPatterns, expectedResults);
      });
    });
    describe(`with nested JSON (2 levels)`, () => {
      it(`should return correct route`, () => {
        const testPatterns = [
          {
            controller: 'app',
            use: { p1: 'path1', p2: 'path2', p3: 10 },
          },
          {
            use: { p1: 'path1', p2: 'path2' },
            controller: 'app',
          },
          {
            service: 'one',
            use: { p1: 'path1', p2: 'path2', id: 160 },
            controller: 'app',
          },
        ] as MsPattern[];

        const expectedResults = [
          JSON.stringify(testPatterns[0]),
          `{"controller":"app","use":{"p1":"path1","p2":"path2"}}`,
          `{"controller":"app","service":"one","use":{"id":160,"p1":"path1","p2":"path2"}}`,
        ];

        equalTest(testPatterns, expectedResults);
      });
    });
    describe(`with nested JSON (3 levels)`, () => {
      it(`should return correct route`, () => {
        const testPatterns = [
          {
            controller: 'app',
            use: { p1: 'path1', p2: { pp1: 'ppath1' } },
          },
          {
            use: { p1: 'path1' },
            controller: { p2: 'path2' },
          },
          {
            service: 'one',
            use: { p1: 'path1', p2: { pp1: 'ppath1' } },
            controller: { p1: { pp1: 'ppath1', id: 180 } },
          },
        ] as MsPattern[];

        const expectedResults = [
          JSON.stringify(testPatterns[0]),
          `{"controller":{"p2":"path2"},"use":{"p1":"path1"}}`,
          `{"controller":{"p1":{"id":180,"pp1":"ppath1"}},"service":"one","use":{"p1":"path1","p2":{"pp1":"ppath1"}}}`,
        ];

        equalTest(testPatterns, expectedResults);
      });
    });
  });

  describe(`when gets value with incorrect type (no string/number/JSON)`, () => {
    it(`should return the value unchanged`, () => {
      const testPatterns = [null, undefined, Symbol(213)];

      testPatterns.forEach((testPattern: any) => {
        expect(transformPatternToRoute(testPattern)).to.be.eq(testPattern);
      });
    });
  });
});



================================================
FILE: packages/microservices/utils/index.ts
================================================
export * from './transform-pattern.utils';



================================================
FILE: packages/microservices/utils/param.utils.ts
================================================
import { PipeTransform, Type } from '@nestjs/common';
import { assignMetadata } from '@nestjs/common/decorators/http/route-params.decorator';
import { isNil, isString } from '@nestjs/common/utils/shared.utils';
import 'reflect-metadata';
import { PARAM_ARGS_METADATA } from '../constants';
import { RpcParamtype } from '../enums/rpc-paramtype.enum';

export function createRpcParamDecorator(
  paramtype: RpcParamtype,
): (...pipes: (Type<PipeTransform> | PipeTransform)[]) => ParameterDecorator {
  return (...pipes: (Type<PipeTransform> | PipeTransform)[]) =>
    (target, key, index) => {
      const args =
        Reflect.getMetadata(PARAM_ARGS_METADATA, target.constructor, key!) ||
        {};
      Reflect.defineMetadata(
        PARAM_ARGS_METADATA,
        assignMetadata(args, paramtype, index, undefined, ...pipes),
        target.constructor,
        key!,
      );
    };
}

export const createPipesRpcParamDecorator =
  (paramtype: RpcParamtype) =>
  (
    data?: any,
    ...pipes: (Type<PipeTransform> | PipeTransform)[]
  ): ParameterDecorator =>
  (target, key, index) => {
    const args =
      Reflect.getMetadata(PARAM_ARGS_METADATA, target.constructor, key!) || {};

    const hasParamData = isNil(data) || isString(data);
    const paramData = hasParamData ? data : undefined;
    const paramPipes = hasParamData ? pipes : [data, ...pipes];

    Reflect.defineMetadata(
      PARAM_ARGS_METADATA,
      assignMetadata(args, paramtype, index, paramData!, ...paramPipes),
      target.constructor,
      key!,
    );
  };



================================================
FILE: packages/microservices/utils/transform-pattern.utils.ts
================================================
import {
  isObject,
  isString,
  isNumber,
} from '@nestjs/common/utils/shared.utils';
import { MsPattern } from '../interfaces';

/**
 * Transforms the Pattern to Route.
 * 1. If Pattern is a `string`, it will be returned as it is.
 * 2. If Pattern is a `number`, it will be converted to `string`.
 * 3. If Pattern is a `JSON` object, it will be transformed to Route. For that end,
 * the function will sort properties of `JSON` Object and creates `route` string
 * according to the following template:
 * <key1>:<value1>/<key2>:<value2>/.../<keyN>:<valueN>
 *
 * @param  {MsPattern} pattern - client pattern
 * @returns string
 */
export function transformPatternToRoute(pattern: MsPattern): string {
  if (isString(pattern) || isNumber(pattern)) {
    return `${pattern}`;
  }
  if (!isObject(pattern)) {
    return pattern;
  }

  const sortedKeys = Object.keys(pattern).sort((a, b) =>
    ('' + a).localeCompare(b),
  );

  // Creates the array of Pattern params from sorted keys and their corresponding values
  const sortedPatternParams = sortedKeys.map(key => {
    let partialRoute = `"${key}":`;
    partialRoute += isString(pattern[key])
      ? `"${transformPatternToRoute(pattern[key])}"`
      : transformPatternToRoute(pattern[key]);
    return partialRoute;
  });

  const route = sortedPatternParams.join(',');
  return `{${route}}`;
}



================================================
FILE: packages/platform-express/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/platform-express/index.ts
================================================
/*
 * Nest @platform-express
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */

export * from './adapters';
export * from './interfaces';
export * from './multer';



================================================
FILE: packages/platform-express/package.json
================================================
{
  "name": "@nestjs/platform-express",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@platform-express)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/platform-express"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "cors": "2.8.5",
    "express": "5.1.0",
    "multer": "1.4.5-lts.2",
    "path-to-regexp": "8.2.0",
    "tslib": "2.8.1"
  },
  "devDependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0"
  }
}



================================================
FILE: packages/platform-express/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/core": ["../core"],
      "@nestjs/core/*": ["../core/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../core/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-express/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-express/adapters/express-adapter.ts
================================================
import {
  HttpStatus,
  InternalServerErrorException,
  Logger,
  RequestMethod,
  StreamableFile,
  VERSION_NEUTRAL,
  VersioningOptions,
  VersioningType,
} from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';
import {
  CorsOptions,
  CorsOptionsDelegate,
} from '@nestjs/common/interfaces/external/cors-options.interface';
import { NestApplicationOptions } from '@nestjs/common/interfaces/nest-application-options.interface';
import {
  isFunction,
  isNil,
  isObject,
  isString,
  isUndefined,
} from '@nestjs/common/utils/shared.utils';
import { AbstractHttpAdapter } from '@nestjs/core/adapters/http-adapter';
import { RouterMethodFactory } from '@nestjs/core/helpers/router-method-factory';
import { LegacyRouteConverter } from '@nestjs/core/router/legacy-route-converter';
import * as cors from 'cors';
import * as express from 'express';
import type { Server } from 'http';
import * as http from 'http';
import * as https from 'https';
import { pathToRegexp } from 'path-to-regexp';
import { Duplex, pipeline } from 'stream';
import { NestExpressBodyParserOptions } from '../interfaces/nest-express-body-parser-options.interface';
import { NestExpressBodyParserType } from '../interfaces/nest-express-body-parser.interface';
import { ServeStaticOptions } from '../interfaces/serve-static-options.interface';
import { getBodyParserOptions } from './utils/get-body-parser-options.util';

type VersionedRoute = <
  TRequest extends Record<string, any> = any,
  TResponse = any,
>(
  req: TRequest,
  res: TResponse,
  next: () => void,
) => any;

/**
 * @publicApi
 */
export class ExpressAdapter extends AbstractHttpAdapter<
  http.Server | https.Server
> {
  private readonly routerMethodFactory = new RouterMethodFactory();
  private readonly logger = new Logger(ExpressAdapter.name);
  private readonly openConnections = new Set<Duplex>();

  constructor(instance?: any) {
    super(instance || express());
  }

  public reply(response: any, body: any, statusCode?: number) {
    if (statusCode) {
      response.status(statusCode);
    }
    if (isNil(body)) {
      return response.send();
    }
    if (body instanceof StreamableFile) {
      const streamHeaders = body.getHeaders();
      if (
        response.getHeader('Content-Type') === undefined &&
        streamHeaders.type !== undefined
      ) {
        response.setHeader('Content-Type', streamHeaders.type);
      }
      if (
        response.getHeader('Content-Disposition') === undefined &&
        streamHeaders.disposition !== undefined
      ) {
        response.setHeader('Content-Disposition', streamHeaders.disposition);
      }
      if (
        response.getHeader('Content-Length') === undefined &&
        streamHeaders.length !== undefined
      ) {
        response.setHeader('Content-Length', streamHeaders.length);
      }
      return pipeline(
        body.getStream().once('error', (err: Error) => {
          body.errorHandler(err, response);
        }),
        response,
        (err: any) => {
          if (err) {
            body.errorLogger(err);
          }
        },
      );
    }
    const responseContentType = response.getHeader('Content-Type');
    if (
      typeof responseContentType === 'string' &&
      !responseContentType.startsWith('application/json') &&
      body?.statusCode >= HttpStatus.BAD_REQUEST
    ) {
      this.logger.warn(
        "Content-Type doesn't match Reply body, you might need a custom ExceptionFilter for non-JSON responses",
      );
      response.setHeader('Content-Type', 'application/json');
    }
    return isObject(body) ? response.json(body) : response.send(String(body));
  }

  public status(response: any, statusCode: number) {
    return response.status(statusCode);
  }

  public end(response: any, message?: string) {
    return response.end(message);
  }

  public render(response: any, view: string, options: any) {
    return response.render(view, options);
  }

  public redirect(response: any, statusCode: number, url: string) {
    return response.redirect(statusCode, url);
  }

  public setErrorHandler(handler: Function, prefix?: string) {
    return this.use(handler);
  }

  public setNotFoundHandler(handler: Function, prefix?: string) {
    return this.use(handler);
  }

  public isHeadersSent(response: any): boolean {
    return response.headersSent;
  }

  public getHeader(response: any, name: string) {
    return response.get(name);
  }

  public setHeader(response: any, name: string, value: string) {
    return response.set(name, value);
  }

  public appendHeader(response: any, name: string, value: string) {
    return response.append(name, value);
  }

  public normalizePath(path: string): string {
    try {
      const convertedPath = LegacyRouteConverter.tryConvert(path);
      // Call "pathToRegexp" to trigger a TypeError if the path is invalid
      pathToRegexp(convertedPath);
      return convertedPath;
    } catch (e) {
      if (e instanceof TypeError) {
        LegacyRouteConverter.printError(path);
      }
      throw e;
    }
  }

  public listen(port: string | number, callback?: () => void): Server;
  public listen(
    port: string | number,
    hostname: string,
    callback?: () => void,
  ): Server;
  public listen(port: any, ...args: any[]): Server {
    return this.httpServer.listen(port, ...args);
  }

  public close() {
    this.closeOpenConnections();

    if (!this.httpServer) {
      return undefined;
    }
    return new Promise(resolve => this.httpServer.close(resolve));
  }

  public set(...args: any[]) {
    return this.instance.set(...args);
  }

  public enable(...args: any[]) {
    return this.instance.enable(...args);
  }

  public disable(...args: any[]) {
    return this.instance.disable(...args);
  }

  public engine(...args: any[]) {
    return this.instance.engine(...args);
  }

  public useStaticAssets(path: string, options: ServeStaticOptions) {
    if (options && options.prefix) {
      return this.use(options.prefix, express.static(path, options));
    }
    return this.use(express.static(path, options));
  }

  public setBaseViewsDir(path: string | string[]) {
    return this.set('views', path);
  }

  public setViewEngine(engine: string) {
    return this.set('view engine', engine);
  }

  public getRequestHostname(request: any): string {
    return request.hostname;
  }

  public getRequestMethod(request: any): string {
    return request.method;
  }

  public getRequestUrl(request: any): string {
    return request.originalUrl;
  }

  public enableCors(options: CorsOptions | CorsOptionsDelegate<any>) {
    return this.use(cors(options as any));
  }

  public createMiddlewareFactory(
    requestMethod: RequestMethod,
  ): (path: string, callback: Function) => any {
    return (path: string, callback: Function) => {
      try {
        const convertedPath = LegacyRouteConverter.tryConvert(path);
        return this.routerMethodFactory
          .get(this.instance, requestMethod)
          .call(this.instance, convertedPath, callback);
      } catch (e) {
        if (e instanceof TypeError) {
          LegacyRouteConverter.printError(path);
        }
        throw e;
      }
    };
  }

  public initHttpServer(options: NestApplicationOptions) {
    const isHttpsEnabled = options && options.httpsOptions;
    if (isHttpsEnabled) {
      this.httpServer = https.createServer(
        options.httpsOptions!,
        this.getInstance(),
      );
    } else {
      this.httpServer = http.createServer(this.getInstance());
    }

    if (options?.forceCloseConnections) {
      this.trackOpenConnections();
    }
  }

  public registerParserMiddleware(prefix?: string, rawBody?: boolean) {
    const bodyParserJsonOptions = getBodyParserOptions(rawBody!);
    const bodyParserUrlencodedOptions = getBodyParserOptions(rawBody!, {
      extended: true,
    });

    const parserMiddleware = {
      jsonParser: express.json(bodyParserJsonOptions),
      urlencodedParser: express.urlencoded(bodyParserUrlencodedOptions),
    };
    Object.keys(parserMiddleware)
      .filter(parser => !this.isMiddlewareApplied(parser))
      .forEach(parserKey => this.use(parserMiddleware[parserKey]));
  }

  public useBodyParser<
    Options extends NestExpressBodyParserOptions = NestExpressBodyParserOptions,
  >(
    type: NestExpressBodyParserType,
    rawBody: boolean,
    options?: Omit<Options, 'verify'>,
  ): this {
    const parserOptions = getBodyParserOptions<Options>(rawBody, options);
    const parser = express[type](parserOptions);

    this.use(parser);

    return this;
  }

  public setLocal(key: string, value: any) {
    this.instance.locals[key] = value;
    return this;
  }

  public getType(): string {
    return 'express';
  }

  public applyVersionFilter(
    handler: Function,
    version: VersionValue,
    versioningOptions: VersioningOptions,
  ): VersionedRoute {
    const callNextHandler: VersionedRoute = (req, res, next) => {
      if (!next) {
        throw new InternalServerErrorException(
          'HTTP adapter does not support filtering on version',
        );
      }
      return next();
    };

    if (
      version === VERSION_NEUTRAL ||
      // URL Versioning is done via the path, so the filter continues forward
      versioningOptions.type === VersioningType.URI
    ) {
      const handlerForNoVersioning: VersionedRoute = (req, res, next) =>
        handler(req, res, next);

      return handlerForNoVersioning;
    }

    // Custom Extractor Versioning Handler
    if (versioningOptions.type === VersioningType.CUSTOM) {
      const handlerForCustomVersioning: VersionedRoute = (req, res, next) => {
        const extractedVersion = versioningOptions.extractor(req);

        if (Array.isArray(version)) {
          if (
            Array.isArray(extractedVersion) &&
            version.filter(v => extractedVersion.includes(v as string)).length
          ) {
            return handler(req, res, next);
          }

          if (
            isString(extractedVersion) &&
            version.includes(extractedVersion)
          ) {
            return handler(req, res, next);
          }
        } else if (isString(version)) {
          // Known bug here - if there are multiple versions supported across separate
          // handlers/controllers, we can't select the highest matching handler.
          // Since this code is evaluated per-handler, then we can't see if the highest
          // specified version exists in a different handler.
          if (
            Array.isArray(extractedVersion) &&
            extractedVersion.includes(version)
          ) {
            return handler(req, res, next);
          }

          if (isString(extractedVersion) && version === extractedVersion) {
            return handler(req, res, next);
          }
        }

        return callNextHandler(req, res, next);
      };

      return handlerForCustomVersioning;
    }

    // Media Type (Accept Header) Versioning Handler
    if (versioningOptions.type === VersioningType.MEDIA_TYPE) {
      const handlerForMediaTypeVersioning: VersionedRoute = (
        req,
        res,
        next,
      ) => {
        const MEDIA_TYPE_HEADER = 'Accept';
        const acceptHeaderValue: string | undefined =
          req.headers?.[MEDIA_TYPE_HEADER] ||
          req.headers?.[MEDIA_TYPE_HEADER.toLowerCase()];

        const acceptHeaderVersionParameter = acceptHeaderValue
          ? acceptHeaderValue.split(';')[1]
          : undefined;

        // No version was supplied
        if (isUndefined(acceptHeaderVersionParameter)) {
          if (Array.isArray(version)) {
            if (version.includes(VERSION_NEUTRAL)) {
              return handler(req, res, next);
            }
          }
        } else {
          const headerVersion = acceptHeaderVersionParameter.split(
            versioningOptions.key,
          )[1];

          if (Array.isArray(version)) {
            if (version.includes(headerVersion)) {
              return handler(req, res, next);
            }
          } else if (isString(version)) {
            if (version === headerVersion) {
              return handler(req, res, next);
            }
          }
        }

        return callNextHandler(req, res, next);
      };

      return handlerForMediaTypeVersioning;
    }

    // Header Versioning Handler
    if (versioningOptions.type === VersioningType.HEADER) {
      const handlerForHeaderVersioning: VersionedRoute = (req, res, next) => {
        const customHeaderVersionParameter: string | undefined =
          req.headers?.[versioningOptions.header] ||
          req.headers?.[versioningOptions.header.toLowerCase()];

        // No version was supplied
        if (isUndefined(customHeaderVersionParameter)) {
          if (Array.isArray(version)) {
            if (version.includes(VERSION_NEUTRAL)) {
              return handler(req, res, next);
            }
          }
        } else {
          if (Array.isArray(version)) {
            if (version.includes(customHeaderVersionParameter)) {
              return handler(req, res, next);
            }
          } else if (isString(version)) {
            if (version === customHeaderVersionParameter) {
              return handler(req, res, next);
            }
          }
        }

        return callNextHandler(req, res, next);
      };

      return handlerForHeaderVersioning;
    }

    throw new Error('Unsupported versioning options');
  }

  private trackOpenConnections() {
    this.httpServer.on('connection', (socket: Duplex) => {
      this.openConnections.add(socket);

      socket.on('close', () => this.openConnections.delete(socket));
    });
  }

  private closeOpenConnections() {
    for (const socket of this.openConnections) {
      socket.destroy();
      this.openConnections.delete(socket);
    }
  }

  private isMiddlewareApplied(name: string): boolean {
    const app = this.getInstance();
    return (
      !!app.router &&
      !!app.router.stack &&
      isFunction(app.router.stack.filter) &&
      app.router.stack.some(
        (layer: any) => layer && layer.handle && layer.handle.name === name,
      )
    );
  }
}



================================================
FILE: packages/platform-express/adapters/index.ts
================================================
export * from './express-adapter';



================================================
FILE: packages/platform-express/adapters/utils/get-body-parser-options.util.ts
================================================
import type { RawBodyRequest } from '@nestjs/common';
import type { IncomingMessage, ServerResponse } from 'http';
import type { NestExpressBodyParserOptions } from '../../interfaces';

const rawBodyParser = (
  req: RawBodyRequest<IncomingMessage>,
  _res: ServerResponse,
  buffer: Buffer,
) => {
  if (Buffer.isBuffer(buffer)) {
    req.rawBody = buffer;
  }
  return true;
};

export function getBodyParserOptions<Options = NestExpressBodyParserOptions>(
  rawBody: boolean,
  options?: Omit<Options, 'verify'>,
): Options {
  let parserOptions: Options = (options || {}) as Options;

  if (rawBody === true) {
    parserOptions = {
      ...parserOptions,
      verify: rawBodyParser,
    };
  }

  return parserOptions;
}



================================================
FILE: packages/platform-express/interfaces/index.ts
================================================
export * from './nest-express-application.interface';
export { NestExpressBodyParserOptions } from './nest-express-body-parser-options.interface';
export * from './nest-express-body-parser.interface';



================================================
FILE: packages/platform-express/interfaces/nest-express-application.interface.ts
================================================
import { HttpServer, INestApplication } from '@nestjs/common';
import type {
  CorsOptions,
  CorsOptionsDelegate,
} from '@nestjs/common/interfaces/external/cors-options.interface';
import type { Express } from 'express';
import type { Server as CoreHttpServer } from 'http';
import type { Server as CoreHttpsServer } from 'https';
import { NestExpressBodyParserOptions } from './nest-express-body-parser-options.interface';
import { NestExpressBodyParserType } from './nest-express-body-parser.interface';
import { ServeStaticOptions } from './serve-static-options.interface';

/**
 * Interface describing methods on NestExpressApplication.
 *
 * @see [Platform](https://docs.nestjs.com/first-steps#platform)
 *
 * @publicApi
 */
export interface NestExpressApplication<
  TServer extends CoreHttpServer | CoreHttpsServer = CoreHttpServer,
> extends INestApplication<TServer> {
  /**
   * Returns the underlying HTTP adapter bounded to the Express.js app.
   *
   * @returns {HttpServer}
   */
  getHttpAdapter(): HttpServer<Express.Request, Express.Response, Express>;

  /**
   * Starts the application.
   *
   * @param {number|string} port
   * @param {string} [hostname]
   * @param {Function} [callback] Optional callback
   * @returns {Promise} A Promise that, when resolved, is a reference to the underlying HttpServer.
   */
  listen(port: number | string, callback?: () => void): Promise<TServer>;
  listen(
    port: number | string,
    hostname: string,
    callback?: () => void,
  ): Promise<TServer>;

  /**
   * A wrapper function around native `express.set()` method.
   *
   * @example
   * app.set('trust proxy', 'loopback')
   *
   * @returns {this}
   */
  set(...args: any[]): this;

  /**
   * A wrapper function around native `express.engine()` method.
   * @example
   * app.engine('mustache', mustacheExpress())
   *
   * @returns {this}
   */
  engine(...args: any[]): this;

  /**
   * A wrapper function around native `express.enable()` method.
   * @example
   * app.enable('x-powered-by')
   *
   * @returns {this}
   */
  enable(...args: any[]): this;

  /**
   * A wrapper function around native `express.disable()` method.
   *
   * @example
   * app.disable('x-powered-by')
   *
   * @returns {this}
   */
  disable(...args: any[]): this;

  useStaticAssets(options: ServeStaticOptions): this;
  /**
   * Sets a base directory for public assets.
   * @example
   * app.useStaticAssets('public')
   *
   * @returns {this}
   */
  useStaticAssets(path: string, options?: ServeStaticOptions): this;

  enableCors(options?: CorsOptions | CorsOptionsDelegate<any>): void;

  /**
   * Register Express body parsers on the fly. Will respect
   * the application's `rawBody` option.
   *
   * @example
   * const app = await NestFactory.create<NestExpressApplication>(
   *   AppModule,
   *   { rawBody: true }
   * );
   * app.useBodyParser('json', { limit: '50mb' });
   *
   * @returns {this}
   */
  useBodyParser<Options = NestExpressBodyParserOptions>(
    parser: NestExpressBodyParserType,
    options?: Omit<Options, 'verify'>,
  ): this;

  /**
   * Sets one or multiple base directories for templates (views).
   *
   * @example
   * app.setBaseViewsDir('views')
   *
   * @returns {this}
   */
  setBaseViewsDir(path: string | string[]): this;

  /**
   * Sets a view engine for templates (views).
   * @example
   * app.setViewEngine('pug')
   *
   * @returns {this}
   */
  setViewEngine(engine: string): this;

  /**
   * Sets app-level globals for view templates.
   *
   * @example
   * app.setLocal('title', 'My Site')
   *
   * @see https://expressjs.com/en/4x/api.html#app.locals
   *
   * @returns {this}
   */
  setLocal(key: string, value: any): this;
}



================================================
FILE: packages/platform-express/interfaces/nest-express-body-parser-options.interface.ts
================================================
import type { IncomingMessage } from 'http';

/**
 * Type alias to keep compatibility with @types/body-parser
 * @see https://github.com/DefinitelyTyped/DefinitelyTyped/blob/dcd1673c4fa18a15ea8cd8ff8af7d563bb6dc8e6/types/body-parser/index.d.ts#L48-L66#L48-L66
 * @publicApi
 */
export interface NestExpressBodyParserOptions {
  /** When set to true, then deflated (compressed) bodies will be inflated; when false, deflated bodies are rejected. Defaults to true. */
  inflate?: boolean | undefined;

  /**
   * Controls the maximum request body size. If this is a number,
   * then the value specifies the number of bytes; if it is a string,
   * the value is passed to the bytes library for parsing. Defaults to '100kb'.
   */
  limit?: number | string | undefined;

  /**
   * The type option is used to determine what media type the middleware will parse
   */
  type?: string | string[] | ((req: IncomingMessage) => any) | undefined;

  // Catch-all for body-parser type specific options
  [key: string]: unknown;
}



================================================
FILE: packages/platform-express/interfaces/nest-express-body-parser.interface.ts
================================================
/**
 * Interface defining possible body parser types, to be used with `NestExpressApplication.useBodyParser()`.
 */
export type NestExpressBodyParserType = 'json' | 'urlencoded' | 'text' | 'raw';



================================================
FILE: packages/platform-express/interfaces/serve-static-options.interface.ts
================================================
/**
 * Interface describing options for serving static assets.
 *
 * @see [Serving static files in Express](https://expressjs.com/en/starter/static-files.html)
 * @see [Model-View-Controller](https://docs.nestjs.com/techniques/mvc)
 *
 * @publicApi
 */
export interface ServeStaticOptions {
  /**
   * Set how "dotfiles" are treated when encountered. A dotfile is a file or directory that begins with a dot (".").
   * Note this check is done on the path itself without checking if the path actually exists on the disk.
   * If root is specified, only the dotfiles above the root are checked (i.e. the root itself can be within a dotfile when when set to "deny").
   * The default value is 'ignore'.
   * 'allow' No special treatment for dotfiles
   * 'deny' Send a 403 for any request for a dotfile
   * 'ignore' Pretend like the dotfile does not exist and call next()
   */
  dotfiles?: string;

  /**
   * Enable or disable etag generation, defaults to true.
   */
  etag?: boolean;

  /**
   * Set file extension fallbacks. When set, if a file is not found, the given extensions will be added to the file name and search for.
   * The first that exists will be served. Example: ['html', 'htm'].
   * The default value is false.
   */
  extensions?: string[];

  /**
   * Let client errors fall-through as unhandled requests, otherwise forward a client error.
   * The default value is false.
   */
  fallthrough?: boolean;

  /**
   * Enable or disable the immutable directive in the Cache-Control response header.
   * If enabled, the maxAge option should also be specified to enable caching. The immutable directive will prevent supported clients from making conditional requests during the life of the maxAge option to check if the file has changed.
   */
  immutable?: boolean;

  /**
   * By default this module will send "index.html" files in response to a request on a directory.
   * To disable this set false or to supply a new index pass a string or an array in preferred order.
   */
  index?: boolean | string | string[];

  /**
   * Enable or disable Last-Modified header, defaults to true. Uses the file system's last modified value.
   */
  lastModified?: boolean;

  /**
   * Provide a max-age in milliseconds for http caching, defaults to 0. This can also be a string accepted by the ms module.
   */
  maxAge?: number | string;

  /**
   * Redirect to trailing "/" when the pathname is a dir. Defaults to true.
   */
  redirect?: boolean;

  /**
   * Function to set custom headers on response. Alterations to the headers need to occur synchronously.
   * The function is called as `fn(res, path, stat)`, where the arguments are:
   * `res` - the response object
   * `path` - the file path that is being sent
   * `stat` - the stat object of the file that is being sent
   */
  setHeaders?: (res: any, path: string, stat: any) => any;

  /**
   * Creates a virtual path prefix
   */
  prefix?: string;
}



================================================
FILE: packages/platform-express/multer/files.constants.ts
================================================
export const MULTER_MODULE_OPTIONS = 'MULTER_MODULE_OPTIONS';



================================================
FILE: packages/platform-express/multer/index.ts
================================================
export * from './interceptors';
export * from './interfaces';
export * from './multer.module';



================================================
FILE: packages/platform-express/multer/multer.constants.ts
================================================
export const MULTER_MODULE_ID = 'MULTER_MODULE_ID';



================================================
FILE: packages/platform-express/multer/multer.module.ts
================================================
import { DynamicModule, Module, Provider } from '@nestjs/common';
import { randomStringGenerator } from '@nestjs/common/utils/random-string-generator.util';
import { MULTER_MODULE_OPTIONS } from './files.constants';
import {
  MulterModuleAsyncOptions,
  MulterModuleOptions,
  MulterOptionsFactory,
} from './interfaces/files-upload-module.interface';
import { MULTER_MODULE_ID } from './multer.constants';

/**
 * @publicApi
 */
@Module({})
export class MulterModule {
  static register(options: MulterModuleOptions = {}): DynamicModule {
    return {
      module: MulterModule,
      providers: [
        { provide: MULTER_MODULE_OPTIONS, useFactory: () => options },
        {
          provide: MULTER_MODULE_ID,
          useValue: randomStringGenerator(),
        },
      ],
      exports: [MULTER_MODULE_OPTIONS],
    };
  }

  static registerAsync(options: MulterModuleAsyncOptions): DynamicModule {
    return {
      module: MulterModule,
      imports: options.imports,
      providers: [
        ...this.createAsyncProviders(options),
        {
          provide: MULTER_MODULE_ID,
          useValue: randomStringGenerator(),
        },
      ],
      exports: [MULTER_MODULE_OPTIONS],
    };
  }

  private static createAsyncProviders(
    options: MulterModuleAsyncOptions,
  ): Provider[] {
    if (options.useExisting || options.useFactory) {
      return [this.createAsyncOptionsProvider(options)];
    }
    return [
      this.createAsyncOptionsProvider(options),
      {
        provide: options.useClass!,
        useClass: options.useClass!,
      },
    ];
  }

  private static createAsyncOptionsProvider(
    options: MulterModuleAsyncOptions,
  ): Provider {
    if (options.useFactory) {
      return {
        provide: MULTER_MODULE_OPTIONS,
        useFactory: options.useFactory,
        inject: options.inject || [],
      };
    }
    return {
      provide: MULTER_MODULE_OPTIONS,
      useFactory: async (optionsFactory: MulterOptionsFactory) =>
        optionsFactory.createMulterOptions(),
      inject: [options.useExisting || options.useClass!],
    };
  }
}



================================================
FILE: packages/platform-express/multer/interceptors/any-files.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  mixin,
  NestInterceptor,
  Optional,
  Type,
} from '@nestjs/common';
import * as multer from 'multer';
import { Observable } from 'rxjs';
import { MULTER_MODULE_OPTIONS } from '../files.constants';
import { MulterModuleOptions } from '../interfaces';
import { MulterOptions } from '../interfaces/multer-options.interface';
import { transformException } from '../multer/multer.utils';

type MulterInstance = any;

/**
 * @param localOptions
 *
 * @publicApi
 */
export function AnyFilesInterceptor(
  localOptions?: MulterOptions,
): Type<NestInterceptor> {
  class MixinInterceptor implements NestInterceptor {
    protected multer: MulterInstance;

    constructor(
      @Optional()
      @Inject(MULTER_MODULE_OPTIONS)
      options: MulterModuleOptions = {},
    ) {
      this.multer = (multer as any)({
        ...options,
        ...localOptions,
      });
    }

    async intercept(
      context: ExecutionContext,
      next: CallHandler,
    ): Promise<Observable<any>> {
      const ctx = context.switchToHttp();

      await new Promise<void>((resolve, reject) =>
        this.multer.any()(ctx.getRequest(), ctx.getResponse(), (err: any) => {
          if (err) {
            const error = transformException(err);
            return reject(error);
          }
          resolve();
        }),
      );
      return next.handle();
    }
  }
  const Interceptor = mixin(MixinInterceptor);
  return Interceptor;
}



================================================
FILE: packages/platform-express/multer/interceptors/file-fields.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  mixin,
  NestInterceptor,
  Optional,
  Type,
} from '@nestjs/common';
import * as multer from 'multer';
import { Observable } from 'rxjs';
import { MULTER_MODULE_OPTIONS } from '../files.constants';
import { MulterModuleOptions } from '../interfaces';
import {
  MulterField,
  MulterOptions,
} from '../interfaces/multer-options.interface';
import { transformException } from '../multer/multer.utils';

type MulterInstance = any;

/**
 * @param uploadFields
 * @param localOptions
 * @publicApi
 */
export function FileFieldsInterceptor(
  uploadFields: MulterField[],
  localOptions?: MulterOptions,
): Type<NestInterceptor> {
  class MixinInterceptor implements NestInterceptor {
    protected multer: MulterInstance;

    constructor(
      @Optional()
      @Inject(MULTER_MODULE_OPTIONS)
      options: MulterModuleOptions = {},
    ) {
      this.multer = (multer as any)({
        ...options,
        ...localOptions,
      });
    }

    async intercept(
      context: ExecutionContext,
      next: CallHandler,
    ): Promise<Observable<any>> {
      const ctx = context.switchToHttp();

      await new Promise<void>((resolve, reject) =>
        this.multer.fields(uploadFields)(
          ctx.getRequest(),
          ctx.getResponse(),
          (err: any) => {
            if (err) {
              const error = transformException(err);
              return reject(error);
            }
            resolve();
          },
        ),
      );
      return next.handle();
    }
  }
  const Interceptor = mixin(MixinInterceptor);
  return Interceptor;
}



================================================
FILE: packages/platform-express/multer/interceptors/file.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  mixin,
  NestInterceptor,
  Optional,
  Type,
} from '@nestjs/common';
import * as multer from 'multer';
import { Observable } from 'rxjs';
import { MULTER_MODULE_OPTIONS } from '../files.constants';
import { MulterModuleOptions } from '../interfaces';
import { MulterOptions } from '../interfaces/multer-options.interface';
import { transformException } from '../multer/multer.utils';

type MulterInstance = any;

/**
 * @param fieldName
 * @param localOptions
 *
 * @publicApi
 */
export function FileInterceptor(
  fieldName: string,
  localOptions?: MulterOptions,
): Type<NestInterceptor> {
  class MixinInterceptor implements NestInterceptor {
    protected multer: MulterInstance;

    constructor(
      @Optional()
      @Inject(MULTER_MODULE_OPTIONS)
      options: MulterModuleOptions = {},
    ) {
      this.multer = (multer as any)({
        ...options,
        ...localOptions,
      });
    }

    async intercept(
      context: ExecutionContext,
      next: CallHandler,
    ): Promise<Observable<any>> {
      const ctx = context.switchToHttp();

      await new Promise<void>((resolve, reject) =>
        this.multer.single(fieldName)(
          ctx.getRequest(),
          ctx.getResponse(),
          (err: any) => {
            if (err) {
              const error = transformException(err);
              return reject(error);
            }
            resolve();
          },
        ),
      );
      return next.handle();
    }
  }
  const Interceptor = mixin(MixinInterceptor);
  return Interceptor;
}



================================================
FILE: packages/platform-express/multer/interceptors/files.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  mixin,
  NestInterceptor,
  Optional,
  Type,
} from '@nestjs/common';
import * as multer from 'multer';
import { Observable } from 'rxjs';
import { MULTER_MODULE_OPTIONS } from '../files.constants';
import { MulterModuleOptions } from '../interfaces';
import { MulterOptions } from '../interfaces/multer-options.interface';
import { transformException } from '../multer/multer.utils';

type MulterInstance = any;

/**
 *
 * @param fieldName
 * @param maxCount
 * @param localOptions
 *
 * @publicApi
 */
export function FilesInterceptor(
  fieldName: string,
  maxCount?: number,
  localOptions?: MulterOptions,
): Type<NestInterceptor> {
  class MixinInterceptor implements NestInterceptor {
    protected multer: MulterInstance;

    constructor(
      @Optional()
      @Inject(MULTER_MODULE_OPTIONS)
      options: MulterModuleOptions = {},
    ) {
      this.multer = (multer as any)({
        ...options,
        ...localOptions,
      });
    }

    async intercept(
      context: ExecutionContext,
      next: CallHandler,
    ): Promise<Observable<any>> {
      const ctx = context.switchToHttp();

      await new Promise<void>((resolve, reject) =>
        this.multer.array(fieldName, maxCount)(
          ctx.getRequest(),
          ctx.getResponse(),
          (err: any) => {
            if (err) {
              const error = transformException(err);
              return reject(error);
            }
            resolve();
          },
        ),
      );
      return next.handle();
    }
  }
  const Interceptor = mixin(MixinInterceptor);
  return Interceptor;
}



================================================
FILE: packages/platform-express/multer/interceptors/index.ts
================================================
export * from './any-files.interceptor';
export * from './file-fields.interceptor';
export * from './file.interceptor';
export * from './files.interceptor';
export * from './no-files.interceptor';



================================================
FILE: packages/platform-express/multer/interceptors/no-files.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Inject,
  mixin,
  NestInterceptor,
  Optional,
  Type,
} from '@nestjs/common';
import * as multer from 'multer';
import { Observable } from 'rxjs';
import { MULTER_MODULE_OPTIONS } from '../files.constants';
import { MulterModuleOptions } from '../interfaces';
import { MulterOptions } from '../interfaces/multer-options.interface';
import { transformException } from '../multer/multer.utils';

type MulterInstance = any;

/**
 *
 * @param localOptions
 * @publicApi
 */
export function NoFilesInterceptor(
  localOptions?: MulterOptions,
): Type<NestInterceptor> {
  class MixinInterceptor implements NestInterceptor {
    protected multer: MulterInstance;

    constructor(
      @Optional()
      @Inject(MULTER_MODULE_OPTIONS)
      options: MulterModuleOptions = {},
    ) {
      this.multer = (multer as any)({
        ...options,
        ...localOptions,
      });
    }

    async intercept(
      context: ExecutionContext,
      next: CallHandler,
    ): Promise<Observable<any>> {
      const ctx = context.switchToHttp();

      await new Promise<void>((resolve, reject) =>
        this.multer.none()(ctx.getRequest(), ctx.getResponse(), (err: any) => {
          if (err) {
            const error = transformException(err);
            return reject(error);
          }
          resolve();
        }),
      );
      return next.handle();
    }
  }
  const Interceptor = mixin(MixinInterceptor);
  return Interceptor;
}



================================================
FILE: packages/platform-express/multer/interfaces/files-upload-module.interface.ts
================================================
import { ModuleMetadata, Type } from '@nestjs/common/interfaces';
import { MulterOptions } from './multer-options.interface';

export type MulterModuleOptions = MulterOptions;

/**
 * @publicApi
 */
export interface MulterOptionsFactory {
  createMulterOptions(): Promise<MulterModuleOptions> | MulterModuleOptions;
}

/**
 * @publicApi
 */
export interface MulterModuleAsyncOptions
  extends Pick<ModuleMetadata, 'imports'> {
  useExisting?: Type<MulterOptionsFactory>;
  useClass?: Type<MulterOptionsFactory>;
  useFactory?: (
    ...args: any[]
  ) => Promise<MulterModuleOptions> | MulterModuleOptions;
  inject?: any[];
}



================================================
FILE: packages/platform-express/multer/interfaces/index.ts
================================================
export * from './files-upload-module.interface';



================================================
FILE: packages/platform-express/multer/interfaces/multer-options.interface.ts
================================================
/**
 * @see https://github.com/expressjs/multer
 *
 * @publicApi
 */
export interface MulterOptions {
  dest?: string | Function;
  /** The storage engine to use for uploaded files. */
  storage?: any;
  /**
   * An object specifying the size limits of the following optional properties. This object is passed to busboy
   * directly, and the details of properties can be found on https://github.com/mscdex/busboy#busboy-methods
   */
  limits?: {
    /** Max field name size (Default: 100 bytes) */
    fieldNameSize?: number;
    /** Max field value size (Default: 1MB) */
    fieldSize?: number;
    /** Max number of non- file fields (Default: Infinity) */
    fields?: number;
    /** For multipart forms, the max file size (in bytes)(Default: Infinity) */
    fileSize?: number;
    /** For multipart forms, the max number of file fields (Default: Infinity) */
    files?: number;
    /** For multipart forms, the max number of parts (fields + files)(Default: Infinity) */
    parts?: number;
    /** For multipart forms, the max number of header key=> value pairs to parse Default: 2000(same as node's http). */
    headerPairs?: number;
  };

  /** Keep the full path of files instead of just the base name (Default: false) */
  preservePath?: boolean;

  fileFilter?(
    req: any,
    file: {
      /** Field name specified in the form */
      fieldname: string;
      /** Name of the file on the user's computer */
      originalname: string;
      /** Encoding type of the file */
      encoding: string;
      /** Mime type of the file */
      mimetype: string;
      /** Size of the file in bytes */
      size: number;
      /** The folder to which the file has been saved (DiskStorage) */
      destination: string;
      /** The name of the file within the destination (DiskStorage) */
      filename: string;
      /** Location of the uploaded file (DiskStorage) */
      path: string;
      /** A Buffer of the entire file (MemoryStorage) */
      buffer: Buffer;
    },
    callback: (error: Error | null, acceptFile: boolean) => void,
  ): void;
}

/**
 * @publicApi
 */
export interface MulterField {
  /** The field name. */
  name: string;
  /** Optional maximum number of files per field to accept. */
  maxCount?: number;
}



================================================
FILE: packages/platform-express/multer/multer/multer.constants.ts
================================================
export const multerExceptions = {
  // from https://github.com/expressjs/multer/blob/master/lib/multer-error.js
  LIMIT_PART_COUNT: 'Too many parts',
  LIMIT_FILE_SIZE: 'File too large',
  LIMIT_FILE_COUNT: 'Too many files',
  LIMIT_FIELD_KEY: 'Field name too long',
  LIMIT_FIELD_VALUE: 'Field value too long',
  LIMIT_FIELD_COUNT: 'Too many fields',
  LIMIT_UNEXPECTED_FILE: 'Unexpected field',
  MISSING_FIELD_NAME: 'Field name missing',
};

export const busboyExceptions = {
  // from https://github.com/mscdex/busboy/blob/master/lib/types/multipart.js
  MULTIPART_BOUNDARY_NOT_FOUND: 'Multipart: Boundary not found',
  MULTIPART_MALFORMED_PART_HEADER: 'Malformed part header',
  MULTIPART_UNEXPECTED_END_OF_FORM: 'Unexpected end of form',
  MULTIPART_UNEXPECTED_END_OF_FILE: 'Unexpected end of file',
};



================================================
FILE: packages/platform-express/multer/multer/multer.utils.ts
================================================
import {
  BadRequestException,
  HttpException,
  PayloadTooLargeException,
} from '@nestjs/common';
import { multerExceptions, busboyExceptions } from './multer.constants';

// Multer may add in a 'field' property to the error
// https://github.com/expressjs/multer/blob/aa42bea6ac7d0cb8fcb279b15a7278cda805dc63/lib/multer-error.js#L19
export function transformException(
  error: (Error & { field?: string }) | undefined,
) {
  if (!error || error instanceof HttpException) {
    return error;
  }
  switch (error.message) {
    case multerExceptions.LIMIT_FILE_SIZE:
      return new PayloadTooLargeException(error.message);
    case multerExceptions.LIMIT_FILE_COUNT:
    case multerExceptions.LIMIT_FIELD_KEY:
    case multerExceptions.LIMIT_FIELD_VALUE:
    case multerExceptions.LIMIT_FIELD_COUNT:
    case multerExceptions.LIMIT_UNEXPECTED_FILE:
    case multerExceptions.LIMIT_PART_COUNT:
    case multerExceptions.MISSING_FIELD_NAME:
      if (error.field) {
        return new BadRequestException(`${error.message} - ${error.field}`);
      }
      return new BadRequestException(error.message);
    case busboyExceptions.MULTIPART_BOUNDARY_NOT_FOUND:
      return new BadRequestException(error.message);
    case busboyExceptions.MULTIPART_MALFORMED_PART_HEADER:
    case busboyExceptions.MULTIPART_UNEXPECTED_END_OF_FORM:
    case busboyExceptions.MULTIPART_UNEXPECTED_END_OF_FILE:
      return new BadRequestException(`Multipart: ${error.message}`);
  }
  return error;
}



================================================
FILE: packages/platform-express/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/platform-express/test/adapters/express-adapter.spec.ts
================================================
import { ExpressAdapter } from '@nestjs/platform-express';
import { expect } from 'chai';
import * as express from 'express';
import * as sinon from 'sinon';

describe('ExpressAdapter', () => {
  afterEach(() => sinon.restore());

  describe('registerParserMiddleware', () => {
    it('should register the express built-in parsers for json and urlencoded payloads', () => {
      const expressInstance = express();
      const jsonParserInstance = express.json();
      const urlencodedInstance = express.urlencoded();
      const jsonParserSpy = sinon
        .stub(express, 'json')
        .returns(jsonParserInstance);
      const urlencodedParserSpy = sinon
        .stub(express, 'urlencoded')
        .returns(urlencodedInstance);
      const useSpy = sinon.spy(expressInstance, 'use');
      const expressAdapter = new ExpressAdapter(expressInstance);

      expressAdapter.registerParserMiddleware();

      expect(useSpy.calledTwice).to.be.true;
      expect(useSpy.calledWith(sinon.match.same(jsonParserInstance))).to.be
        .true;
      expect(useSpy.calledWith(sinon.match.same(urlencodedInstance))).to.be
        .true;
      expect(jsonParserSpy.calledOnceWith({})).to.be.true;
      expect(urlencodedParserSpy.calledOnceWith({ extended: true })).to.be.true;
    });

    it('should not register default parsers if custom parsers have already been registered', () => {
      const expressInstance = express();
      expressInstance.use(function jsonParser() {});
      expressInstance.use(function urlencodedParser() {});
      const useSpy = sinon.spy(expressInstance, 'use');
      const expressAdapter = new ExpressAdapter(expressInstance);

      expressAdapter.registerParserMiddleware();

      expect(useSpy.called).to.be.false;
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/interceptors/any-files.interceptor.spec.ts
================================================
import { CallHandler } from '@nestjs/common';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { AnyFilesInterceptor } from '../../../multer/interceptors/any-files.interceptor';

describe('FilesInterceptor', () => {
  it('should return metatype with expected structure', async () => {
    const targetClass = AnyFilesInterceptor();
    expect(targetClass.prototype.intercept).to.not.be.undefined;
  });
  describe('intercept', () => {
    let handler: CallHandler;
    beforeEach(() => {
      handler = {
        handle: () => of('test'),
      };
    });
    it('should call any() with expected params', async () => {
      const target = new (AnyFilesInterceptor())();

      const callback = (req, res, next) => next();
      const arraySpy = sinon
        .stub((target as any).multer, 'any')
        .returns(callback);

      await target.intercept(new ExecutionContextHost([]), handler);

      expect(arraySpy.called).to.be.true;
      expect(arraySpy.calledWith()).to.be.true;
    });
    it('should transform exception', async () => {
      const target = new (AnyFilesInterceptor())();
      const err = {};
      const callback = (req, res, next) => next(err);
      (target as any).multer = {
        any: () => callback,
      };
      (target.intercept(new ExecutionContextHost([]), handler) as any).catch(
        error => expect(error).to.not.be.undefined,
      );
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/interceptors/file-fields.interceptor.spec.ts
================================================
import { CallHandler } from '@nestjs/common';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { FileFieldsInterceptor } from '../../../multer/interceptors/file-fields.interceptor';

describe('FileFieldsInterceptor', () => {
  it('should return metatype with expected structure', async () => {
    const targetClass = FileFieldsInterceptor([
      { name: 'file', maxCount: 1 },
      { name: 'anotherFile', maxCount: 1 },
    ]);
    expect(targetClass.prototype.intercept).to.not.be.undefined;
  });
  describe('intercept', () => {
    let handler: CallHandler;
    beforeEach(() => {
      handler = {
        handle: () => of('test'),
      };
    });
    it('should call object with expected params', async () => {
      const fieldName1 = 'file';
      const maxCount1 = 1;
      const fieldName2 = 'anotherFile';
      const maxCount2 = 2;
      const argument = [
        { name: fieldName1, maxCount: maxCount1 },
        { name: fieldName2, maxCount: maxCount2 },
      ];
      const target = new (FileFieldsInterceptor(argument))();

      const callback = (req, res, next) => next();
      const fieldsSpy = sinon
        .stub((target as any).multer, 'fields')
        .returns(callback);

      await target.intercept(new ExecutionContextHost([]), handler);

      expect(fieldsSpy.called).to.be.true;
      expect(fieldsSpy.calledWith(argument)).to.be.true;
    });
    it('should transform exception', async () => {
      const fieldName1 = 'file';
      const maxCount1 = 1;
      const fieldName2 = 'anotherFile';
      const maxCount2 = 2;
      const argument = [
        { name: fieldName1, maxCount: maxCount1 },
        { name: fieldName2, maxCount: maxCount2 },
      ];
      const target = new (FileFieldsInterceptor(argument))();
      const err = {};
      const callback = (req, res, next) => next(err);
      (target as any).fields = {
        array: () => callback,
      };
      (target.intercept(new ExecutionContextHost([]), handler) as any).catch(
        error => expect(error).to.not.be.undefined,
      );
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/interceptors/file.interceptor.spec.ts
================================================
import { CallHandler } from '@nestjs/common';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { FileInterceptor } from '../../../multer/interceptors/file.interceptor';

describe('FileInterceptor', () => {
  it('should return metatype with expected structure', async () => {
    const targetClass = FileInterceptor('file');
    expect(targetClass.prototype.intercept).to.not.be.undefined;
  });
  describe('intercept', () => {
    let handler: CallHandler;
    beforeEach(() => {
      handler = {
        handle: () => of('test'),
      };
    });
    it('should call single() with expected params', async () => {
      const fieldName = 'file';
      const target = new (FileInterceptor(fieldName))();
      const callback = (req, res, next) => next();
      const singleSpy = sinon
        .stub((target as any).multer, 'single')
        .returns(callback);

      await target.intercept(new ExecutionContextHost([]), handler);

      expect(singleSpy.called).to.be.true;
      expect(singleSpy.calledWith(fieldName)).to.be.true;
    });
    it('should transform exception', async () => {
      const fieldName = 'file';
      const target = new (FileInterceptor(fieldName))();
      const err = {};
      const callback = (req, res, next) => next(err);
      (target as any).multer = {
        single: () => callback,
      };
      (target.intercept(new ExecutionContextHost([]), handler) as any).catch(
        error => expect(error).to.not.be.undefined,
      );
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/interceptors/files.interceptor.spec.ts
================================================
import { CallHandler } from '@nestjs/common';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { FilesInterceptor } from '../../../multer/interceptors/files.interceptor';

describe('FilesInterceptor', () => {
  it('should return metatype with expected structure', async () => {
    const targetClass = FilesInterceptor('file');
    expect(targetClass.prototype.intercept).to.not.be.undefined;
  });
  describe('intercept', () => {
    let handler: CallHandler;
    beforeEach(() => {
      handler = {
        handle: () => of('test'),
      };
    });
    it('should call array() with expected params', async () => {
      const fieldName = 'file';
      const maxCount = 10;
      const target = new (FilesInterceptor(fieldName, maxCount))();

      const callback = (req, res, next) => next();
      const arraySpy = sinon
        .stub((target as any).multer, 'array')
        .returns(callback);

      await target.intercept(new ExecutionContextHost([]), handler);

      expect(arraySpy.called).to.be.true;
      expect(arraySpy.calledWith(fieldName, maxCount)).to.be.true;
    });
    it('should transform exception', async () => {
      const fieldName = 'file';
      const target = new (FilesInterceptor(fieldName))();
      const err = {};
      const callback = (req, res, next) => next(err);
      (target as any).multer = {
        array: () => callback,
      };
      (target.intercept(new ExecutionContextHost([]), handler) as any).catch(
        error => expect(error).to.not.be.undefined,
      );
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/interceptors/no-files.inteceptor.spec.ts
================================================
import { CallHandler } from '@nestjs/common';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { NoFilesInterceptor } from '../../../multer/interceptors/no-files.interceptor';

describe('NoFilesInterceptor', () => {
  it('should return metatype with expected structure', async () => {
    const targetClass = NoFilesInterceptor();
    expect(targetClass.prototype.intercept).to.not.be.undefined;
  });
  describe('intercept', () => {
    let handler: CallHandler;
    beforeEach(() => {
      handler = {
        handle: () => of('test'),
      };
    });
    it('should call none() with expected params', async () => {
      const target = new (NoFilesInterceptor())();

      const callback = (req, res, next) => next();
      const noneSpy = sinon
        .stub((target as any).multer, 'none')
        .returns(callback);

      await target.intercept(new ExecutionContextHost([]), handler);

      expect(noneSpy.called).to.be.true;
    });
    it('should transform exception', async () => {
      const target = new (NoFilesInterceptor())();
      const err = {};
      const callback = (req, res, next) => next(err);
      (target as any).multer = {
        none: () => callback,
      };
      (target.intercept(new ExecutionContextHost([]), handler) as any).catch(
        error => expect(error).to.not.be.undefined,
      );
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/multer/multer.module.spec.ts
================================================
import { FactoryProvider } from '@nestjs/common';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { MULTER_MODULE_OPTIONS } from '../../../multer/files.constants';
import { MulterModule } from '../../../multer/multer.module';

describe('MulterModule', () => {
  describe('register', () => {
    it('should provide an options', () => {
      const options = {
        test: 'test',
      };
      const dynamicModule = MulterModule.register(options as any);

      expect(dynamicModule.providers).to.have.length(2);
      expect(dynamicModule.imports).to.be.undefined;
      expect(dynamicModule.exports).to.include(MULTER_MODULE_OPTIONS);

      const moduleOptionsProvider = dynamicModule.providers!.find(
        p => 'useFactory' in p && p.provide === MULTER_MODULE_OPTIONS,
      ) as FactoryProvider;
      expect(moduleOptionsProvider).to.not.be.undefined;
      expect(moduleOptionsProvider.useFactory()).to.be.eq(options);
    });
  });

  describe('register async', () => {
    describe('when useFactory', () => {
      it('should provide an options', () => {
        const options: any = {};
        const asyncOptions = {
          useFactory: () => options,
        };
        const dynamicModule = MulterModule.registerAsync(asyncOptions);

        expect(dynamicModule.providers).to.have.length(2);
        expect(dynamicModule.imports).to.be.undefined;
        expect(dynamicModule.exports).to.include(MULTER_MODULE_OPTIONS);
        expect(dynamicModule.providers).to.deep.include({
          provide: MULTER_MODULE_OPTIONS,
          useFactory: asyncOptions.useFactory,
          inject: [],
        });
      });
    });

    describe('when useExisting', () => {
      it('should provide an options', () => {
        const asyncOptions = {
          useExisting: Object,
        };
        const dynamicModule = MulterModule.registerAsync(asyncOptions as any);

        expect(dynamicModule.providers).to.have.length(2);
        expect(dynamicModule.imports).to.be.undefined;
        expect(dynamicModule.exports).to.include(MULTER_MODULE_OPTIONS);
      });
    });

    describe('when useClass', () => {
      it('should provide an options', () => {
        const asyncOptions = {
          useClass: Object,
        };
        const dynamicModule = MulterModule.registerAsync(asyncOptions as any);

        expect(dynamicModule.providers).to.have.length(3);
        expect(dynamicModule.imports).to.be.undefined;
        expect(dynamicModule.exports).to.include(MULTER_MODULE_OPTIONS);
      });
      it('provider should call "createMulterOptions"', async () => {
        const asyncOptions = {
          useClass: Object,
        };
        const dynamicModule = MulterModule.registerAsync(asyncOptions as any);
        const optionsFactory = {
          createMulterOptions: sinon.spy(),
        };
        await (dynamicModule.providers![0] as any).useFactory(optionsFactory);
        expect(optionsFactory.createMulterOptions.called).to.be.true;
      });
    });
  });
});



================================================
FILE: packages/platform-express/test/multer/multer/multer.utils.spec.ts
================================================
import {
  BadRequestException,
  HttpException,
  PayloadTooLargeException,
} from '@nestjs/common';
import { expect } from 'chai';
import {
  busboyExceptions,
  multerExceptions,
} from '../../../multer/multer/multer.constants';
import { transformException } from '../../../multer/multer/multer.utils';

describe('transformException', () => {
  describe('if error does not exist', () => {
    it('should behave as identity', () => {
      const err = undefined;
      expect(transformException(err)).to.be.eq(err);
    });
  });
  describe('if error is instance of HttpException', () => {
    it('should behave as identity', () => {
      const err = new HttpException('response', 500);
      expect(transformException(err)).to.be.eq(err);
    });
  });
  describe('if error exists and is not instance of HttpException', () => {
    describe('and is LIMIT_FILE_SIZE exception', () => {
      it('should return "PayloadTooLargeException"', () => {
        const err = { message: multerExceptions.LIMIT_FILE_SIZE };
        expect(transformException(err as any)).to.be.instanceof(
          PayloadTooLargeException,
        );
      });
    });
    describe('and is multer exception but not a LIMIT_FILE_SIZE', () => {
      it('should return "BadRequestException"', () => {
        const err = { message: multerExceptions.LIMIT_FIELD_KEY };
        expect(transformException(err as any)).to.be.instanceof(
          BadRequestException,
        );
      });
    });
    describe('and is busboy/multipart exception', () => {
      it('should return "BadRequestException"', () => {
        const err = { message: busboyExceptions.MULTIPART_BOUNDARY_NOT_FOUND };
        expect(transformException(err as any)).to.be.instanceof(
          BadRequestException,
        );
      });

      it('should return "BadRequestException"', () => {
        const err = {
          message: busboyExceptions.MULTIPART_UNEXPECTED_END_OF_FORM,
        };
        expect(transformException(err as any)).to.be.instanceof(
          BadRequestException,
        );
      });
    });
    describe(`and has a 'field' property`, () => {
      it('should return the field propery appended to the error message', () => {
        const err = {
          message: multerExceptions.LIMIT_UNEXPECTED_FILE,
          field: 'foo',
        };
        expect(transformException(err as any)!.message).to.equal(
          `${multerExceptions.LIMIT_UNEXPECTED_FILE} - foo`,
        );
      });
    });
  });
});



================================================
FILE: packages/platform-fastify/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/platform-fastify/constants.ts
================================================
export const FASTIFY_ROUTE_CONFIG_METADATA = '__fastify_route_config__';
export const FASTIFY_ROUTE_CONSTRAINTS_METADATA =
  '__fastify_route_constraints__';



================================================
FILE: packages/platform-fastify/index.ts
================================================
/*
 * Nest @platform-fastify
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */

export * from './adapters';
export * from './interfaces';
export * from './decorators';



================================================
FILE: packages/platform-fastify/package.json
================================================
{
  "name": "@nestjs/platform-fastify",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@platform-fastify)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/platform-fastify"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "@fastify/cors": "11.0.1",
    "@fastify/formbody": "8.0.2",
    "@fastify/middie": "9.0.3",
    "fast-querystring": "1.1.2",
    "fastify": "5.2.2",
    "light-my-request": "6.6.0",
    "path-to-regexp": "8.2.0",
    "tslib": "2.8.1"
  },
  "peerDependencies": {
    "@fastify/static": "^8.0.0",
    "@fastify/view": "^10.0.0 || ^11.0.0",
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0"
  },
  "peerDependenciesMeta": {
    "@fastify/static": {
      "optional": true
    },
    "@fastify/view": {
      "optional": true
    }
  }
}



================================================
FILE: packages/platform-fastify/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/core": ["../core"],
      "@nestjs/core/*": ["../core/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../core/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-fastify/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-fastify/adapters/fastify-adapter.ts
================================================
/* eslint-disable @typescript-eslint/no-floating-promises */
import { FastifyCorsOptions } from '@fastify/cors';
import {
  HttpStatus,
  Logger,
  RawBodyRequest,
  RequestMethod,
  StreamableFile,
  VERSION_NEUTRAL,
  VersioningOptions,
  VersioningType,
} from '@nestjs/common';
import { VersionValue } from '@nestjs/common/interfaces';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isString, isUndefined } from '@nestjs/common/utils/shared.utils';
import { AbstractHttpAdapter } from '@nestjs/core/adapters/http-adapter';
import { LegacyRouteConverter } from '@nestjs/core/router/legacy-route-converter';
import {
  FastifyBaseLogger,
  FastifyBodyParser,
  FastifyInstance,
  FastifyListenOptions,
  FastifyPluginAsync,
  FastifyPluginCallback,
  FastifyRegister,
  FastifyReply,
  FastifyRequest,
  FastifyServerOptions,
  HTTPMethods,
  RawReplyDefaultExpression,
  RawRequestDefaultExpression,
  RawServerBase,
  RawServerDefault,
  RequestGenericInterface,
  RouteGenericInterface,
  RouteOptions,
  RouteShorthandOptions,
  fastify,
} from 'fastify';
import * as Reply from 'fastify/lib/reply';
import { kRouteContext } from 'fastify/lib/symbols';
import * as http from 'http';
import * as http2 from 'http2';
import * as https from 'https';
import {
  InjectOptions,
  Chain as LightMyRequestChain,
  Response as LightMyRequestResponse,
} from 'light-my-request';
import { pathToRegexp } from 'path-to-regexp';
// Fastify uses `fast-querystring` internally to quickly parse URL query strings.
import { parse as querystringParse } from 'fast-querystring';
import {
  FASTIFY_ROUTE_CONFIG_METADATA,
  FASTIFY_ROUTE_CONSTRAINTS_METADATA,
} from '../constants';
import { NestFastifyBodyParserOptions } from '../interfaces';
import {
  FastifyStaticOptions,
  FastifyViewOptions,
} from '../interfaces/external';

type FastifyAdapterBaseOptions<
  Server extends RawServerBase = RawServerDefault,
  Logger extends FastifyBaseLogger = FastifyBaseLogger,
> = FastifyServerOptions<Server, Logger> & {
  skipMiddie?: boolean;
};

type FastifyHttp2SecureOptions<
  Server extends http2.Http2SecureServer,
  Logger extends FastifyBaseLogger = FastifyBaseLogger,
> = FastifyAdapterBaseOptions<Server, Logger> & {
  http2: true;
  https: http2.SecureServerOptions;
};

type FastifyHttp2Options<
  Server extends http2.Http2Server,
  Logger extends FastifyBaseLogger = FastifyBaseLogger,
> = FastifyAdapterBaseOptions<Server, Logger> & {
  http2: true;
  http2SessionTimeout?: number;
};

type FastifyHttpsOptions<
  Server extends https.Server,
  Logger extends FastifyBaseLogger = FastifyBaseLogger,
> = FastifyAdapterBaseOptions<Server, Logger> & {
  https: https.ServerOptions;
};

type FastifyHttpOptions<
  Server extends http.Server,
  Logger extends FastifyBaseLogger = FastifyBaseLogger,
> = FastifyAdapterBaseOptions<Server, Logger> & {
  http: http.ServerOptions;
};

type VersionedRoute<TRequest, TResponse> = ((
  req: TRequest,
  res: TResponse,
  next: Function,
) => Function) & {
  version: VersionValue;
  versioningOptions: VersioningOptions;
};

/**
 * The following type assertion is valid as we enforce "middie" plugin registration
 * which enhances the FastifyRequest.RawRequest with the "originalUrl" property.
 * ref https://github.com/fastify/middie/pull/16
 * ref https://github.com/fastify/fastify/pull/559
 */
type FastifyRawRequest<TServer extends RawServerBase> =
  RawRequestDefaultExpression<TServer> & { originalUrl?: string };

/**
 * @publicApi
 */
export class FastifyAdapter<
  TServer extends RawServerBase = RawServerDefault,
  TRawRequest extends FastifyRawRequest<TServer> = FastifyRawRequest<TServer>,
  TRawResponse extends
    RawReplyDefaultExpression<TServer> = RawReplyDefaultExpression<TServer>,
  TRequest extends FastifyRequest<
    RequestGenericInterface,
    TServer,
    TRawRequest
  > = FastifyRequest<RequestGenericInterface, TServer, TRawRequest>,
  TReply extends FastifyReply<
    RouteGenericInterface,
    TServer,
    TRawRequest,
    TRawResponse
  > = FastifyReply<RouteGenericInterface, TServer, TRawRequest, TRawResponse>,
  TInstance extends FastifyInstance<
    TServer,
    TRawRequest,
    TRawResponse
  > = FastifyInstance<TServer, TRawRequest, TRawResponse>,
> extends AbstractHttpAdapter<TServer, TRequest, TReply> {
  protected readonly logger = new Logger(FastifyAdapter.name);
  protected readonly instance: TInstance;
  protected _pathPrefix?: string;

  private _isParserRegistered: boolean;
  private isMiddieRegistered: boolean;
  private versioningOptions?: VersioningOptions;
  private readonly versionConstraint = {
    name: 'version',
    validate(value: unknown) {
      if (!isString(value) && !Array.isArray(value)) {
        throw new Error(
          'Version constraint should be a string or an array of strings.',
        );
      }
    },
    storage() {
      const versions = new Map<string, unknown>();
      return {
        get(version: string | Array<string>) {
          if (Array.isArray(version)) {
            return versions.get(version.find(v => versions.has(v))!) || null;
          }
          return versions.get(version) || null;
        },
        set(versionOrVersions: string | Array<string>, store: unknown) {
          const storeVersionConstraint = (version: string) =>
            versions.set(version, store);
          if (Array.isArray(versionOrVersions))
            versionOrVersions.forEach(storeVersionConstraint);
          else storeVersionConstraint(versionOrVersions);
        },
        del(version: string | Array<string>) {
          if (Array.isArray(version)) {
            version.forEach(v => versions.delete(v));
          } else {
            versions.delete(version);
          }
        },
        empty() {
          versions.clear();
        },
      };
    },
    deriveConstraint: (req: FastifyRequest) => {
      // Media Type (Accept Header) Versioning Handler
      if (this.versioningOptions?.type === VersioningType.MEDIA_TYPE) {
        const MEDIA_TYPE_HEADER = 'Accept';
        const acceptHeaderValue: string | undefined = (req.headers?.[
          MEDIA_TYPE_HEADER
        ] || req.headers?.[MEDIA_TYPE_HEADER.toLowerCase()]) as string;

        const acceptHeaderVersionParameter = acceptHeaderValue
          ? acceptHeaderValue.split(';')[1]
          : '';

        return isUndefined(acceptHeaderVersionParameter)
          ? VERSION_NEUTRAL // No version was supplied
          : acceptHeaderVersionParameter.split(this.versioningOptions.key)[1];
      }
      // Header Versioning Handler
      else if (this.versioningOptions?.type === VersioningType.HEADER) {
        const customHeaderVersionParameter: string | string[] | undefined =
          req.headers?.[this.versioningOptions.header] ||
          req.headers?.[this.versioningOptions.header.toLowerCase()];

        return isUndefined(customHeaderVersionParameter)
          ? VERSION_NEUTRAL // No version was supplied
          : customHeaderVersionParameter;
      }
      // Custom Versioning Handler
      else if (this.versioningOptions?.type === VersioningType.CUSTOM) {
        return this.versioningOptions.extractor(req);
      }
      return undefined;
    },
    mustMatchWhenDerived: false,
  };

  get isParserRegistered(): boolean {
    return !!this._isParserRegistered;
  }

  constructor(
    instanceOrOptions?:
      | TInstance
      | FastifyHttp2Options<any>
      | FastifyHttp2SecureOptions<any>
      | FastifyHttpsOptions<any>
      | FastifyHttpOptions<any>
      | FastifyAdapterBaseOptions<TServer>,
  ) {
    super();

    const instance =
      instanceOrOptions && (instanceOrOptions as TInstance).server
        ? instanceOrOptions
        : fastify({
            constraints: {
              version: this.versionConstraint as any,
            },
            ...(instanceOrOptions as FastifyServerOptions),
          });

    this.setInstance(instance);

    if ((instanceOrOptions as FastifyAdapterBaseOptions)?.skipMiddie) {
      this.isMiddieRegistered = true;
    }
  }

  public async init() {
    if (this.isMiddieRegistered) {
      return;
    }
    await this.registerMiddie();
  }

  public listen(port: string | number, callback?: () => void): void;
  public listen(
    port: string | number,
    hostname: string,
    callback?: () => void,
  ): void;
  public listen(
    listenOptions: string | number | FastifyListenOptions,
    ...args: any[]
  ): void {
    const isFirstArgTypeofFunction = typeof args[0] === 'function';
    const callback = isFirstArgTypeofFunction ? args[0] : args[1];

    let options: Record<string, any>;
    if (
      typeof listenOptions === 'object' &&
      (listenOptions.host !== undefined ||
        listenOptions.port !== undefined ||
        listenOptions.path !== undefined)
    ) {
      // First parameter is an object with a path, port and/or host attributes
      options = listenOptions;
    } else {
      options = {
        port: +listenOptions,
      };
    }
    if (!isFirstArgTypeofFunction) {
      options.host = args[0];
    }
    return this.instance.listen(options, callback);
  }

  public get(...args: any[]) {
    return this.injectRouteOptions('GET', ...args);
  }

  public post(...args: any[]) {
    return this.injectRouteOptions('POST', ...args);
  }

  public head(...args: any[]) {
    return this.injectRouteOptions('HEAD', ...args);
  }

  public delete(...args: any[]) {
    return this.injectRouteOptions('DELETE', ...args);
  }

  public put(...args: any[]) {
    return this.injectRouteOptions('PUT', ...args);
  }

  public patch(...args: any[]) {
    return this.injectRouteOptions('PATCH', ...args);
  }

  public options(...args: any[]) {
    return this.injectRouteOptions('OPTIONS', ...args);
  }

  public search(...args: any[]) {
    return this.injectRouteOptions('SEARCH', ...args);
  }

  public propfind(...args: any[]) {
    return this.injectRouteOptions('PROPFIND', ...args);
  }

  public proppatch(...args: any[]) {
    return this.injectRouteOptions('PROPPATCH', ...args);
  }

  public mkcol(...args: any[]) {
    return this.injectRouteOptions('MKCOL', ...args);
  }

  public copy(...args: any[]) {
    return this.injectRouteOptions('COPY', ...args);
  }

  public move(...args: any[]) {
    return this.injectRouteOptions('MOVE', ...args);
  }

  public lock(...args: any[]) {
    return this.injectRouteOptions('LOCK', ...args);
  }

  public unlock(...args: any[]) {
    return this.injectRouteOptions('UNLOCK', ...args);
  }

  public applyVersionFilter(
    handler: Function,
    version: VersionValue,
    versioningOptions: VersioningOptions,
  ): VersionedRoute<TRequest, TReply> {
    if (!this.versioningOptions) {
      this.versioningOptions = versioningOptions;
    }
    const versionedRoute = handler as VersionedRoute<TRequest, TReply>;
    versionedRoute.version = version;
    return versionedRoute;
  }

  public reply(
    response: TRawResponse | TReply,
    body: any,
    statusCode?: number,
  ) {
    const fastifyReply: TReply = this.isNativeResponse(response)
      ? new Reply(
          response,
          {
            [kRouteContext]: {
              preSerialization: null,
              preValidation: [],
              preHandler: [],
              onSend: [],
              onError: [],
            },
          },
          {},
        )
      : response;

    if (statusCode) {
      fastifyReply.status(statusCode);
    }
    if (body instanceof StreamableFile) {
      const streamHeaders = body.getHeaders();
      if (
        fastifyReply.getHeader('Content-Type') === undefined &&
        streamHeaders.type !== undefined
      ) {
        fastifyReply.header('Content-Type', streamHeaders.type);
      }
      if (
        fastifyReply.getHeader('Content-Disposition') === undefined &&
        streamHeaders.disposition !== undefined
      ) {
        fastifyReply.header('Content-Disposition', streamHeaders.disposition);
      }
      if (
        fastifyReply.getHeader('Content-Length') === undefined &&
        streamHeaders.length !== undefined
      ) {
        fastifyReply.header('Content-Length', streamHeaders.length);
      }
      body = body.getStream();
    }
    if (
      fastifyReply.getHeader('Content-Type') !== undefined &&
      fastifyReply.getHeader('Content-Type') !== 'application/json' &&
      body?.statusCode >= HttpStatus.BAD_REQUEST
    ) {
      Logger.warn(
        "Content-Type doesn't match Reply body, you might need a custom ExceptionFilter for non-JSON responses",
        FastifyAdapter.name,
      );
      fastifyReply.header('Content-Type', 'application/json');
    }
    return fastifyReply.send(body);
  }

  public status(response: TRawResponse | TReply, statusCode: number) {
    if (this.isNativeResponse(response)) {
      response.statusCode = statusCode;
      return response;
    }
    return (response as { code: Function }).code(statusCode);
  }

  public end(response: TReply, message?: string) {
    response.raw.end(message!);
  }

  public render(
    response: TReply & { view: Function },
    view: string,
    options: any,
  ) {
    return response && response.view(view, options);
  }

  public redirect(response: TReply, statusCode: number, url: string) {
    const code = statusCode ?? HttpStatus.FOUND;
    return response.status(code).redirect(url);
  }

  public setErrorHandler(handler: Parameters<TInstance['setErrorHandler']>[0]) {
    return this.instance.setErrorHandler(handler);
  }

  public setNotFoundHandler(handler: Function) {
    return this.instance.setNotFoundHandler(handler as any);
  }

  public getHttpServer<T = TServer>(): T {
    return this.instance.server as unknown as T;
  }

  public getInstance<T = TInstance>(): T {
    return this.instance as unknown as T;
  }

  public register<
    TRegister extends Parameters<
      FastifyRegister<FastifyInstance<TServer, TRawRequest, TRawResponse>>
    >,
  >(plugin: TRegister['0'], opts?: TRegister['1']) {
    return (this.instance.register as any)(plugin, opts);
  }

  public inject(): LightMyRequestChain;
  public inject(opts: InjectOptions | string): Promise<LightMyRequestResponse>;
  public inject(
    opts?: InjectOptions | string,
  ): LightMyRequestChain | Promise<LightMyRequestResponse> {
    return this.instance.inject(opts!);
  }

  public async close() {
    try {
      return await this.instance.close();
    } catch (err) {
      // Check if server is still running
      if (err.code !== 'ERR_SERVER_NOT_RUNNING') {
        throw err;
      }
      return;
    }
  }

  public initHttpServer() {
    this.httpServer = this.instance.server;
  }

  public useStaticAssets(options: FastifyStaticOptions) {
    return this.register(
      loadPackage('@fastify/static', 'FastifyAdapter.useStaticAssets()', () =>
        require('@fastify/static'),
      ),
      options,
    );
  }

  public setViewEngine(options: FastifyViewOptions | string) {
    if (isString(options)) {
      new Logger('FastifyAdapter').error(
        "setViewEngine() doesn't support a string argument.",
      );
      process.exit(1);
    }
    return this.register(
      loadPackage('@fastify/view', 'FastifyAdapter.setViewEngine()', () =>
        require('@fastify/view'),
      ),
      options,
    );
  }

  public isHeadersSent(response: TReply): boolean {
    return response.sent;
  }

  public getHeader?(response: any, name: string) {
    return response.getHeader(name);
  }

  public setHeader(response: TReply, name: string, value: string) {
    return response.header(name, value);
  }

  public appendHeader?(response: any, name: string, value: string) {
    response.header(name, value);
  }

  public getRequestHostname(request: TRequest): string {
    return request.hostname;
  }

  public getRequestMethod(request: TRequest): string {
    return request.raw ? request.raw.method! : request.method;
  }

  public getRequestUrl(request: TRequest): string;
  public getRequestUrl(request: TRawRequest): string;
  public getRequestUrl(request: TRequest & TRawRequest): string {
    return this.getRequestOriginalUrl(request.raw || request);
  }

  public enableCors(options?: FastifyCorsOptions) {
    this.register(
      import('@fastify/cors') as Parameters<TInstance['register']>[0],
      options,
    );
  }

  public registerParserMiddleware(prefix?: string, rawBody?: boolean) {
    if (this._isParserRegistered) {
      return;
    }

    this.registerUrlencodedContentParser(rawBody);
    this.registerJsonContentParser(rawBody);

    this._isParserRegistered = true;
    this._pathPrefix = prefix
      ? !prefix.startsWith('/')
        ? `/${prefix}`
        : prefix
      : undefined;
  }

  public useBodyParser(
    type: string | string[] | RegExp,
    rawBody: boolean,
    options?: NestFastifyBodyParserOptions,
    parser?: FastifyBodyParser<Buffer, TServer>,
  ) {
    const parserOptions = {
      ...(options || {}),
      parseAs: 'buffer' as const,
    };

    this.getInstance().addContentTypeParser<Buffer>(
      type,
      parserOptions,
      (
        req: RawBodyRequest<FastifyRequest<any, TServer, TRawRequest>>,
        body: Buffer,
        done,
      ) => {
        if (rawBody === true && Buffer.isBuffer(body)) {
          req.rawBody = body;
        }

        if (parser) {
          parser(req, body, done);
          return;
        }

        done(null, body);
      },
    );

    // To avoid the Nest application init to override our custom
    // body parser, we mark the parsers as registered.
    this._isParserRegistered = true;
  }

  public async createMiddlewareFactory(
    requestMethod: RequestMethod,
  ): Promise<(path: string, callback: Function) => any> {
    if (!this.isMiddieRegistered) {
      await this.registerMiddie();
    }
    return (path: string, callback: Function) => {
      const hasEndOfStringCharacter = path.endsWith('$');
      path = hasEndOfStringCharacter ? path.slice(0, -1) : path;

      let normalizedPath = LegacyRouteConverter.tryConvert(path);

      // Fallback to "*path" to support plugins like GraphQL
      normalizedPath = normalizedPath === '/*path' ? '*path' : normalizedPath;

      // Normalize the path to support the prefix if it set in application
      if (this._pathPrefix && !normalizedPath.startsWith(this._pathPrefix)) {
        normalizedPath = `${this._pathPrefix}${normalizedPath}`;
        if (normalizedPath.endsWith('/')) {
          normalizedPath = `${normalizedPath}{*path}`;
        }
      }

      try {
        let { regexp: re } = pathToRegexp(normalizedPath);
        re = hasEndOfStringCharacter
          ? new RegExp(re.source + '$', re.flags)
          : re;

        // The following type assertion is valid as we use import('@fastify/middie') rather than require('@fastify/middie')
        // ref https://github.com/fastify/middie/pull/55
        this.instance.use(
          normalizedPath,
          (req: any, res: any, next: Function) => {
            const queryParamsIndex = req.originalUrl.indexOf('?');
            const pathname =
              queryParamsIndex >= 0
                ? req.originalUrl.slice(0, queryParamsIndex)
                : req.originalUrl;

            if (!re.exec(pathname + '/') && normalizedPath) {
              return next();
            }
            return callback(req, res, next);
          },
        );
      } catch (e) {
        if (e instanceof TypeError) {
          LegacyRouteConverter.printError(path);
        }
        throw e;
      }
    };
  }

  public getType(): string {
    return 'fastify';
  }

  protected registerWithPrefix(
    factory:
      | FastifyPluginCallback<any>
      | FastifyPluginAsync<any>
      | Promise<{ default: FastifyPluginCallback<any> }>
      | Promise<{ default: FastifyPluginAsync<any> }>,
    prefix = '/',
  ) {
    return this.instance.register(factory, { prefix });
  }

  private isNativeResponse(
    response: TRawResponse | TReply,
  ): response is TRawResponse {
    return !('status' in response);
  }

  private registerJsonContentParser(rawBody?: boolean) {
    const contentType = 'application/json';
    const withRawBody = !!rawBody;
    const { bodyLimit } = this.getInstance().initialConfig;

    this.useBodyParser(
      contentType,
      withRawBody,
      { bodyLimit },
      (req, body, done) => {
        const { onProtoPoisoning, onConstructorPoisoning } =
          this.instance.initialConfig;
        const defaultJsonParser = this.instance.getDefaultJsonParser(
          onProtoPoisoning || 'error',
          onConstructorPoisoning || 'error',
        ) as FastifyBodyParser<string | Buffer, TServer>;
        defaultJsonParser(req, body, done);
      },
    );
  }

  private registerUrlencodedContentParser(rawBody?: boolean) {
    const contentType = 'application/x-www-form-urlencoded';
    const withRawBody = !!rawBody;
    const { bodyLimit } = this.getInstance().initialConfig;

    this.useBodyParser(
      contentType,
      withRawBody,
      { bodyLimit },
      (_req, body, done) => {
        done(null, querystringParse(body.toString()));
      },
    );
  }

  private async registerMiddie() {
    this.isMiddieRegistered = true;
    await this.register(
      import('@fastify/middie') as Parameters<TInstance['register']>[0],
    );
  }

  private getRequestOriginalUrl(rawRequest: TRawRequest) {
    return rawRequest.originalUrl || rawRequest.url!;
  }

  private injectRouteOptions(
    routerMethodKey: Uppercase<HTTPMethods>,
    ...args: any[]
  ) {
    const handlerRef = args[args.length - 1];
    const isVersioned =
      !isUndefined(handlerRef.version) &&
      handlerRef.version !== VERSION_NEUTRAL;
    const routeConfig = Reflect.getMetadata(
      FASTIFY_ROUTE_CONFIG_METADATA,
      handlerRef,
    );

    const routeConstraints = Reflect.getMetadata(
      FASTIFY_ROUTE_CONSTRAINTS_METADATA,
      handlerRef,
    );

    const hasConfig = !isUndefined(routeConfig);
    const hasConstraints = !isUndefined(routeConstraints);

    const routeToInject: RouteOptions<TServer, TRawRequest, TRawResponse> &
      RouteShorthandOptions = {
      method: routerMethodKey,
      url: args[0],
      handler: handlerRef,
    };

    if (isVersioned || hasConstraints || hasConfig) {
      const isPathAndRouteTuple = args.length === 2;
      if (isPathAndRouteTuple) {
        const constraints = {
          ...(hasConstraints && routeConstraints),
          ...(isVersioned && {
            version: handlerRef.version,
          }),
        };

        const options = {
          constraints,
          ...(hasConfig && {
            config: {
              ...routeConfig,
            },
          }),
        };

        const routeToInjectWithOptions = { ...routeToInject, ...options };

        return this.instance.route(routeToInjectWithOptions);
      }
    }
    return this.instance.route(routeToInject);
  }
}



================================================
FILE: packages/platform-fastify/adapters/index.ts
================================================
export * from './fastify-adapter';



================================================
FILE: packages/platform-fastify/decorators/index.ts
================================================
export * from './route-config.decorator';
export * from './route-constraints.decorator';



================================================
FILE: packages/platform-fastify/decorators/route-config.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';
import { FASTIFY_ROUTE_CONFIG_METADATA } from '../constants';

/**
 * @publicApi
 *
 * @param config See {@link https://fastify.dev/docs/latest/Reference/Routes/#config}
 */
export const RouteConfig = (config: any) =>
  SetMetadata(FASTIFY_ROUTE_CONFIG_METADATA, config);



================================================
FILE: packages/platform-fastify/decorators/route-constraints.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';
import { FASTIFY_ROUTE_CONSTRAINTS_METADATA } from '../constants';
import { RouteShorthandOptions } from 'fastify';

/**
 * @publicApi
 *
 * @param config See {@link https://fastify.dev/docs/latest/Reference/Routes/#constraints}
 */
export const RouteConstraints = (config: RouteShorthandOptions['config']) =>
  SetMetadata(FASTIFY_ROUTE_CONSTRAINTS_METADATA, config);



================================================
FILE: packages/platform-fastify/interfaces/index.ts
================================================
export * from './nest-fastify-application.interface';
export * from './nest-fastify-body-parser-options.interface';



================================================
FILE: packages/platform-fastify/interfaces/nest-fastify-application.interface.ts
================================================
import { FastifyCorsOptions } from '@fastify/cors';
import { HttpServer, INestApplication } from '@nestjs/common';
import {
  FastifyBodyParser,
  FastifyInstance,
  FastifyListenOptions,
  FastifyPluginAsync,
  FastifyPluginCallback,
  FastifyPluginOptions,
  FastifyRegisterOptions,
  FastifyReply,
  FastifyRequest,
  RawServerBase,
  RawServerDefault,
} from 'fastify';
import {
  InjectOptions,
  Chain as LightMyRequestChain,
  Response as LightMyRequestResponse,
} from 'light-my-request';
import { FastifyStaticOptions, FastifyViewOptions } from './external';
import { NestFastifyBodyParserOptions } from './nest-fastify-body-parser-options.interface';

/**
 * @publicApi
 */
export interface NestFastifyApplication<
  TServer extends RawServerBase = RawServerDefault,
> extends INestApplication<TServer> {
  /**
   * Returns the underlying HTTP adapter bounded to a Fastify app.
   *
   * @returns {HttpServer}
   */
  getHttpAdapter(): HttpServer<FastifyRequest, FastifyReply, FastifyInstance>;

  /**
   * A wrapper function around native `fastify.register()` method.
   * Example `app.register(require('@fastify/formbody'))
   * @returns {Promise<FastifyInstance>}
   */
  register<Options extends FastifyPluginOptions = any>(
    plugin:
      | FastifyPluginCallback<Options>
      | FastifyPluginAsync<Options>
      | Promise<{ default: FastifyPluginCallback<Options> }>
      | Promise<{ default: FastifyPluginAsync<Options> }>,
    opts?: FastifyRegisterOptions<Options>,
  ): Promise<FastifyInstance>;

  /**
   * Register Fastify body parsers on the fly. Will respect
   * the application's `rawBody` option.
   *
   * @example
   * const app = await NestFactory.create<NestFastifyApplication>(
   *   AppModule,
   *   new FastifyAdapter(),
   *   { rawBody: true }
   * );
   * // enable the json parser with a parser limit of 50mb
   * app.useBodyParser('application/json', { bodyLimit: 50 * 1000 * 1024 });
   *
   * @returns {this}
   */
  useBodyParser<TServer extends RawServerBase = RawServerBase>(
    type: string | string[] | RegExp,
    options?: NestFastifyBodyParserOptions,
    parser?: FastifyBodyParser<Buffer, TServer>,
  ): this;

  /**
   * Sets a base directory for public assets.
   * Example `app.useStaticAssets({ root: 'public' })`
   * @returns {this}
   */
  useStaticAssets(options: FastifyStaticOptions): this;

  /**
   * Enables CORS (Cross-Origin Resource Sharing)
   *
   * @returns {void}
   */
  enableCors(options?: FastifyCorsOptions): void;

  /**
   * Sets a view engine for templates (views), for example: `pug`, `handlebars`, or `ejs`.
   *
   * Don't pass in a string. The string type in the argument is for compatibility reason and will cause an exception.
   * @returns {this}
   */
  setViewEngine(options: FastifyViewOptions | string): this;

  /**
   * A wrapper function around native `fastify.inject()` method.
   * @returns {void}
   */
  inject(): LightMyRequestChain;
  inject(opts: InjectOptions | string): Promise<LightMyRequestResponse>;

  /**
   * Starts the application.
   * @returns A Promise that, when resolved, is a reference to the underlying HttpServer.
   */
  listen(
    opts: FastifyListenOptions,
    callback?: (err: Error | null, address: string) => void,
  ): Promise<TServer>;
  listen(opts?: FastifyListenOptions): Promise<TServer>;
  listen(
    callback?: (err: Error | null, address: string) => void,
  ): Promise<TServer>;
  listen(
    port: number | string,
    callback?: (err: Error | null, address: string) => void,
  ): Promise<TServer>;
  listen(
    port: number | string,
    address: string,
    callback?: (err: Error | null, address: string) => void,
  ): Promise<TServer>;
  listen(
    port: number | string,
    address: string,
    backlog: number,
    callback?: (err: Error | null, address: string) => void,
  ): Promise<TServer>;
}



================================================
FILE: packages/platform-fastify/interfaces/nest-fastify-body-parser-options.interface.ts
================================================
import type { AddContentTypeParser } from 'fastify';

export type NestFastifyBodyParserOptions = Omit<
  Parameters<AddContentTypeParser>[1],
  'parseAs'
>;



================================================
FILE: packages/platform-fastify/interfaces/external/fastify-static-options.interface.ts
================================================
/**
 * "fastify-static" interfaces
 * @see https://github.com/fastify/fastify-static/blob/master/types/index.d.ts
 * @publicApi
 */
import { RouteOptions, FastifyRequest, FastifyReply } from 'fastify';
import { Stats } from 'fs';

interface SetHeadersResponse {
  getHeader: FastifyReply['getHeader'];
  setHeader: FastifyReply['header'];
  readonly filename: string;
  statusCode: number;
}

interface ExtendedInformation {
  fileCount: number;
  totalFileCount: number;
  folderCount: number;
  totalFolderCount: number;
  totalSize: number;
  lastModified: number;
}

interface ListDir {
  href: string;
  name: string;
  stats: Stats;
  extendedInfo?: ExtendedInformation;
}

interface ListFile {
  href: string;
  name: string;
  stats: Stats;
}

interface ListRender {
  (dirs: ListDir[], files: ListFile[]): string;
}

interface ListOptions {
  names: string[];
  extendedFolderInfo?: boolean;
  jsonFormat?: 'names' | 'extended';
}

export interface ListOptionsJsonFormat extends ListOptions {
  format: 'json';
  // Required when the URL parameter `format=html` exists
  render?: ListRender;
}

export interface ListOptionsHtmlFormat extends ListOptions {
  format: 'html';
  render: ListRender;
}

// Passed on to `send`
interface SendOptions {
  acceptRanges?: boolean;
  cacheControl?: boolean;
  dotfiles?: 'allow' | 'deny' | 'ignore';
  etag?: boolean;
  extensions?: string[];
  immutable?: boolean;
  index?: string[] | string | false;
  lastModified?: boolean;
  maxAge?: string | number;
  serveDotFiles?: boolean;
}

export interface FastifyStaticOptions extends SendOptions {
  root: string | string[] | URL | URL[];
  prefix?: string;
  prefixAvoidTrailingSlash?: boolean;
  serve?: boolean;
  decorateReply?: boolean;
  schemaHide?: boolean;
  setHeaders?: (res: SetHeadersResponse, path: string, stat: Stats) => void;
  redirect?: boolean;
  wildcard?: boolean;
  list?: boolean | ListOptionsJsonFormat | ListOptionsHtmlFormat;
  allowedPath?: (
    pathName: string,
    root: string,
    request: FastifyRequest,
  ) => boolean;
  /**
   * @description
   * Opt-in to looking for pre-compressed files
   */
  preCompressed?: boolean;

  // Passed on to `send`
  acceptRanges?: boolean;
  cacheControl?: boolean;
  dotfiles?: 'allow' | 'deny' | 'ignore';
  etag?: boolean;
  extensions?: string[];
  immutable?: boolean;
  index?: string[] | string | false;
  lastModified?: boolean;
  maxAge?: string | number;
  constraints?: RouteOptions['constraints'];
}



================================================
FILE: packages/platform-fastify/interfaces/external/fastify-view-options.interface.ts
================================================
/**
 * "fastify/view" interfaces
 * @see https://github.com/fastify/point-of-view/blob/master/types/index.d.ts
 * @publicApi
 */
export interface FastifyViewOptions {
  engine: {
    ejs?: any;
    eta?: any;
    nunjucks?: any;
    pug?: any;
    handlebars?: any;
    mustache?: any;
    'art-template'?: any;
    twig?: any;
    liquid?: any;
    dot?: any;
  };
  templates?: string | string[];
  includeViewExtension?: boolean;
  options?: object;
  charset?: string;
  maxCache?: number;
  production?: boolean;
  defaultContext?: object;
  layout?: string;
  root?: string;
  viewExt?: string;
  propertyName?: string;
  asyncProperyName?: string;
}



================================================
FILE: packages/platform-fastify/interfaces/external/index.ts
================================================
export * from './fastify-static-options.interface';
export * from './fastify-view-options.interface';



================================================
FILE: packages/platform-fastify/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/platform-fastify/test/decorators/router-config.decorator.spec.ts
================================================
import { expect } from 'chai';
import { FASTIFY_ROUTE_CONFIG_METADATA } from '../../constants';
import { RouteConfig } from '../../decorators/route-config.decorator';

describe('@RouteConfig', () => {
  const routeConfig = { testKey: 'testValue' };
  class Test {
    config;
    @RouteConfig(routeConfig)
    public static test() {}
  }

  it('should enhance method with expected fastify route config', () => {
    const path = Reflect.getMetadata(FASTIFY_ROUTE_CONFIG_METADATA, Test.test);
    expect(path).to.be.eql(routeConfig);
  });
});



================================================
FILE: packages/platform-fastify/test/decorators/router-constraints.decorator.spec.ts
================================================
import { expect } from 'chai';
import { FASTIFY_ROUTE_CONSTRAINTS_METADATA } from '../../constants';
import { RouteConstraints } from '../../decorators/route-constraints.decorator';

describe('@RouteConstraints', () => {
  describe('has version constraints', () => {
    const routeConstraints = { version: '1.2.x' };
    class TestVersionConstraints {
      config;
      @RouteConstraints(routeConstraints)
      public static test() {}
    }

    it('should have a version constraint', () => {
      const path = Reflect.getMetadata(
        FASTIFY_ROUTE_CONSTRAINTS_METADATA,
        TestVersionConstraints.test,
      );
      expect(path).to.be.eql(routeConstraints);
    });
  });

  describe('has custom constraints', () => {
    const customRouteConstraints = { something: 'foo' };
    class TestConstraints {
      config;
      @RouteConstraints(customRouteConstraints)
      public static test() {}
    }

    it('should set a custom constraint', () => {
      const path = Reflect.getMetadata(
        FASTIFY_ROUTE_CONSTRAINTS_METADATA,
        TestConstraints.test,
      );
      expect(path).to.be.eql(customRouteConstraints);
    });
  });
});



================================================
FILE: packages/platform-socket.io/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/platform-socket.io/index.ts
================================================
/*
 * Nest @platform-socket.io
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */

export * from './adapters';



================================================
FILE: packages/platform-socket.io/package.json
================================================
{
  "name": "@nestjs/platform-socket.io",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@platform-socket.io)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/platform-socket.io"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "socket.io": "4.8.1",
    "tslib": "2.8.1"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/websockets": "^11.0.0",
    "rxjs": "^7.1.0"
  }
}



================================================
FILE: packages/platform-socket.io/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/websockets": ["../websockets"],
      "@nestjs/websockets/*": ["../websockets/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../websockets/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-socket.io/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-socket.io/adapters/index.ts
================================================
export * from './io-adapter';



================================================
FILE: packages/platform-socket.io/adapters/io-adapter.ts
================================================
import { isFunction, isNil } from '@nestjs/common/utils/shared.utils';
import {
  AbstractWsAdapter,
  MessageMappingProperties,
} from '@nestjs/websockets';
import { DISCONNECT_EVENT } from '@nestjs/websockets/constants';
import { fromEvent, Observable } from 'rxjs';
import { filter, first, map, mergeMap, share, takeUntil } from 'rxjs/operators';
import { Server, ServerOptions, Socket } from 'socket.io';

/**
 * @publicApi
 */
export class IoAdapter extends AbstractWsAdapter {
  public create(
    port: number,
    options?: ServerOptions & { namespace?: string; server?: any },
  ): Server {
    if (!options) {
      return this.createIOServer(port);
    }
    const { namespace, server, ...opt } = options;
    return server && isFunction(server.of)
      ? server.of(namespace)
      : namespace
        ? this.createIOServer(port, opt).of(namespace)
        : this.createIOServer(port, opt);
  }

  public createIOServer(port: number, options?: any): any {
    if (this.httpServer && port === 0) {
      return new Server(this.httpServer, options);
    }
    return new Server(port, options);
  }

  public bindMessageHandlers(
    socket: Socket,
    handlers: MessageMappingProperties[],
    transform: (data: any) => Observable<any>,
  ) {
    const disconnect$ = fromEvent(socket, DISCONNECT_EVENT).pipe(
      share(),
      first(),
    );

    handlers.forEach(({ message, callback }) => {
      const source$ = fromEvent(socket, message).pipe(
        mergeMap((payload: any) => {
          const { data, ack } = this.mapPayload(payload);
          return transform(callback(data, ack)).pipe(
            filter((response: any) => !isNil(response)),
            map((response: any) => [response, ack]),
          );
        }),
        takeUntil(disconnect$),
      );
      source$.subscribe(([response, ack]) => {
        if (response.event) {
          return socket.emit(response.event, response.data);
        }
        isFunction(ack) && ack(response);
      });
    });
  }

  public mapPayload(payload: unknown): { data: any; ack?: Function } {
    if (!Array.isArray(payload)) {
      if (isFunction(payload)) {
        return { data: undefined, ack: payload };
      }
      return { data: payload };
    }
    const lastElement = payload[payload.length - 1];
    const isAck = isFunction(lastElement);
    if (isAck) {
      const size = payload.length - 1;
      return {
        data: size === 1 ? payload[0] : payload.slice(0, size),
        ack: lastElement,
      };
    }
    return { data: payload };
  }

  public async close(server: Server): Promise<void> {
    if (this.forceCloseConnections && server.httpServer === this.httpServer) {
      return;
    }

    return super.close(server);
  }
}



================================================
FILE: packages/platform-ws/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/platform-ws/index.ts
================================================
/*
 * Nest @platform-ws
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */

export * from './adapters';



================================================
FILE: packages/platform-ws/package.json
================================================
{
  "name": "@nestjs/platform-ws",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@platform-ws)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/platform-ws"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "tslib": "2.8.1",
    "ws": "8.18.1"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/websockets": "^11.0.0",
    "rxjs": "^7.1.0"
  }
}



================================================
FILE: packages/platform-ws/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/websockets": ["../websockets"],
      "@nestjs/websockets/*": ["../websockets/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../websockets/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-ws/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/platform-ws/adapters/index.ts
================================================
export * from './ws-adapter';



================================================
FILE: packages/platform-ws/adapters/ws-adapter.ts
================================================
import { INestApplicationContext, Logger } from '@nestjs/common';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isNil, normalizePath } from '@nestjs/common/utils/shared.utils';
import { AbstractWsAdapter } from '@nestjs/websockets';
import {
  CLOSE_EVENT,
  CONNECTION_EVENT,
  ERROR_EVENT,
} from '@nestjs/websockets/constants';
import { MessageMappingProperties } from '@nestjs/websockets/gateway-metadata-explorer';
import * as http from 'http';
import { EMPTY, fromEvent, Observable } from 'rxjs';
import { filter, first, mergeMap, share, takeUntil } from 'rxjs/operators';

let wsPackage: any = {};

enum READY_STATE {
  CONNECTING_STATE = 0,
  OPEN_STATE = 1,
  CLOSING_STATE = 2,
  CLOSED_STATE = 3,
}

type HttpServerRegistryKey = number;
type HttpServerRegistryEntry = any;
type WsServerRegistryKey = number;
type WsServerRegistryEntry = any[];
type WsData = string | Buffer | ArrayBuffer | Buffer[];
type WsMessageParser = (data: WsData) => { event: string; data: any } | void;
type WsAdapterOptions = {
  messageParser?: WsMessageParser;
};

const UNDERLYING_HTTP_SERVER_PORT = 0;

/**
 * @publicApi
 */
export class WsAdapter extends AbstractWsAdapter {
  protected readonly logger = new Logger(WsAdapter.name);
  protected readonly httpServersRegistry = new Map<
    HttpServerRegistryKey,
    HttpServerRegistryEntry
  >();
  protected readonly wsServersRegistry = new Map<
    WsServerRegistryKey,
    WsServerRegistryEntry
  >();
  protected messageParser: WsMessageParser = (data: WsData) => {
    return JSON.parse(data.toString());
  };

  constructor(
    appOrHttpServer?: INestApplicationContext | object,
    options?: WsAdapterOptions,
  ) {
    super(appOrHttpServer);
    wsPackage = loadPackage('ws', 'WsAdapter', () => require('ws'));

    if (options?.messageParser) {
      this.messageParser = options.messageParser;
    }
  }

  public create(
    port: number,
    options?: Record<string, any> & {
      namespace?: string;
      server?: any;
      path?: string;
    },
  ) {
    const { server, path, ...wsOptions } = options as {
      namespace?: string;
      server?: any;
      path?: string;
    };
    if (wsOptions?.namespace) {
      const error = new Error(
        '"WsAdapter" does not support namespaces. If you need namespaces in your project, consider using the "@nestjs/platform-socket.io" package instead.',
      );
      this.logger.error(error);
      throw error;
    }

    if (port === UNDERLYING_HTTP_SERVER_PORT && this.httpServer) {
      this.ensureHttpServerExists(port, this.httpServer);
      const wsServer = this.bindErrorHandler(
        new wsPackage.Server({
          noServer: true,
          ...wsOptions,
        }),
      );

      this.addWsServerToRegistry(wsServer, port, path!);
      return wsServer;
    }

    if (server) {
      return server;
    }
    if (path && port !== UNDERLYING_HTTP_SERVER_PORT) {
      // Multiple servers with different paths
      // sharing a single HTTP/S server running on different port
      // than a regular HTTP application
      const httpServer = this.ensureHttpServerExists(port);
      httpServer?.listen(port);

      const wsServer = this.bindErrorHandler(
        new wsPackage.Server({
          noServer: true,
          ...wsOptions,
        }),
      );
      this.addWsServerToRegistry(wsServer, port, path);
      return wsServer;
    }
    const wsServer = this.bindErrorHandler(
      new wsPackage.Server({
        port,
        path,
        ...wsOptions,
      }),
    );
    return wsServer;
  }

  public bindMessageHandlers(
    client: any,
    handlers: MessageMappingProperties[],
    transform: (data: any) => Observable<any>,
  ) {
    const handlersMap = new Map<string, MessageMappingProperties>();
    handlers.forEach(handler => handlersMap.set(handler.message, handler));

    const close$ = fromEvent(client, CLOSE_EVENT).pipe(share(), first());
    const source$ = fromEvent(client, 'message').pipe(
      mergeMap(data =>
        this.bindMessageHandler(data, handlersMap, transform).pipe(
          filter(result => !isNil(result)),
        ),
      ),
      takeUntil(close$),
    );
    const onMessage = (response: any) => {
      if (client.readyState !== READY_STATE.OPEN_STATE) {
        return;
      }
      client.send(JSON.stringify(response));
    };
    source$.subscribe(onMessage);
  }

  public bindMessageHandler(
    buffer: any,
    handlersMap: Map<string, MessageMappingProperties>,
    transform: (data: any) => Observable<any>,
  ): Observable<any> {
    try {
      const message = this.messageParser(buffer.data);
      if (!message) {
        return EMPTY;
      }
      const messageHandler = handlersMap.get(message.event)!;
      const { callback } = messageHandler;
      return transform(callback(message.data, message.event));
    } catch {
      return EMPTY;
    }
  }

  public bindErrorHandler(server: any) {
    server.on(CONNECTION_EVENT, (ws: any) =>
      ws.on(ERROR_EVENT, (err: any) => this.logger.error(err)),
    );
    server.on(ERROR_EVENT, (err: any) => this.logger.error(err));
    return server;
  }

  public bindClientDisconnect(client: any, callback: Function) {
    client.on(CLOSE_EVENT, callback);
  }

  public async close(server: any) {
    const closeEventSignal = new Promise((resolve, reject) =>
      server.close((err: Error) => (err ? reject(err) : resolve(undefined))),
    );
    for (const ws of server.clients) {
      ws.terminate();
    }
    await closeEventSignal;
  }

  public async dispose() {
    const closeEventSignals = Array.from(this.httpServersRegistry)
      .filter(([port]) => port !== UNDERLYING_HTTP_SERVER_PORT)
      .map(([_, server]) => new Promise(resolve => server.close(resolve)));

    await Promise.all(closeEventSignals);
    this.httpServersRegistry.clear();
    this.wsServersRegistry.clear();
  }

  public setMessageParser(parser: WsMessageParser) {
    this.messageParser = parser;
  }

  protected ensureHttpServerExists(
    port: number,
    httpServer = http.createServer(),
  ) {
    if (this.httpServersRegistry.has(port)) {
      return;
    }
    this.httpServersRegistry.set(port, httpServer);

    httpServer.on('upgrade', (request, socket, head) => {
      try {
        const baseUrl = 'ws://' + request.headers.host + '/';
        const pathname = new URL(request.url!, baseUrl).pathname;
        const wsServersCollection = this.wsServersRegistry.get(port)!;

        let isRequestDelegated = false;
        for (const wsServer of wsServersCollection) {
          if (pathname === wsServer.path) {
            wsServer.handleUpgrade(request, socket, head, (ws: unknown) => {
              wsServer.emit('connection', ws, request);
            });
            isRequestDelegated = true;
            break;
          }
        }
        if (!isRequestDelegated) {
          socket.destroy();
        }
      } catch (err) {
        socket.end('HTTP/1.1 400\r\n' + err.message);
      }
    });
    return httpServer;
  }

  protected addWsServerToRegistry<T extends Record<'path', string> = any>(
    wsServer: T,
    port: number,
    path: string,
  ) {
    const entries = this.wsServersRegistry.get(port) ?? [];
    entries.push(wsServer);

    wsServer.path = normalizePath(path);
    this.wsServersRegistry.set(port, entries);
  }
}



================================================
FILE: packages/testing/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/testing/index.ts
================================================
/*
 * Nest @testing
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */

export * from './interfaces';
export * from './test';
export * from './testing-module';
export * from './testing-module.builder';



================================================
FILE: packages/testing/package.json
================================================
{
  "name": "@nestjs/testing",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@testing)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "homepage": "https://nestjs.com",
  "funding": {
    "type": "opencollective",
    "url": "https://opencollective.com/nest"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/testing"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "tslib": "2.8.1"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/microservices": "^11.0.0",
    "@nestjs/platform-express": "^11.0.0"
  },
  "peerDependenciesMeta": {
    "@nestjs/microservices": {
      "optional": true
    },
    "@nestjs/platform-express": {
      "optional": true
    }
  }
}



================================================
FILE: packages/testing/test.ts
================================================
import { ModuleMetadata } from '@nestjs/common/interfaces/modules/module-metadata.interface';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import {
  TestingModuleBuilder,
  TestingModuleOptions,
} from './testing-module.builder';

export class Test {
  private static readonly metadataScanner = new MetadataScanner();

  public static createTestingModule(
    metadata: ModuleMetadata,
    options?: TestingModuleOptions,
  ) {
    return new TestingModuleBuilder(this.metadataScanner, metadata, options);
  }
}



================================================
FILE: packages/testing/testing-injector.ts
================================================
import { NestContainer } from '@nestjs/core';
import { STATIC_CONTEXT } from '@nestjs/core/injector/constants';
import {
  Injector,
  InjectorDependencyContext,
} from '@nestjs/core/injector/injector';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { Module } from '@nestjs/core/injector/module';
import { MockFactory } from './interfaces';

/**
 * @publicApi
 */
export class TestingInjector extends Injector {
  protected mocker?: MockFactory;
  protected container: NestContainer;

  public setMocker(mocker: MockFactory) {
    this.mocker = mocker;
  }

  public setContainer(container: NestContainer) {
    this.container = container;
  }

  public async resolveComponentInstance<T>(
    moduleRef: Module,
    name: any,
    dependencyContext: InjectorDependencyContext,
    wrapper: InstanceWrapper<T>,
    contextId = STATIC_CONTEXT,
    inquirer?: InstanceWrapper,
    keyOrIndex?: string | number,
  ): Promise<InstanceWrapper> {
    try {
      const existingProviderWrapper = await super.resolveComponentInstance(
        moduleRef,
        name,
        dependencyContext,
        wrapper,
        contextId,
        inquirer,
        keyOrIndex,
      );
      return existingProviderWrapper;
    } catch (err) {
      if (this.mocker) {
        const mockedInstance = this.mocker(name);
        if (!mockedInstance) {
          throw err;
        }
        const newWrapper = new InstanceWrapper({
          name,
          isAlias: false,
          scope: wrapper.scope,
          instance: mockedInstance,
          isResolved: true,
          host: moduleRef,
          metatype: wrapper.metatype,
        });
        const internalCoreModule = this.container.getInternalCoreModuleRef();
        if (!internalCoreModule) {
          throw new Error(
            'Expected to have internal core module reference at this point.',
          );
        }

        internalCoreModule.addCustomProvider(
          {
            provide: name,
            useValue: mockedInstance,
          },
          internalCoreModule.providers,
        );
        internalCoreModule.addExportedProviderOrModule(name);
        return newWrapper;
      } else {
        throw err;
      }
    }
  }
}



================================================
FILE: packages/testing/testing-instance-loader.ts
================================================
import { InstanceLoader } from '@nestjs/core/injector/instance-loader';
import { Module } from '@nestjs/core/injector/module';
import { MockFactory } from './interfaces';
import { TestingInjector } from './testing-injector';

export class TestingInstanceLoader extends InstanceLoader<TestingInjector> {
  public async createInstancesOfDependencies(
    modules: Map<string, Module> = this.container.getModules(),
    mocker?: MockFactory,
  ): Promise<void> {
    this.injector.setContainer(this.container);
    mocker && this.injector.setMocker(mocker);
    await super.createInstancesOfDependencies();
  }
}



================================================
FILE: packages/testing/testing-module.builder.ts
================================================
import { Logger, LoggerService, Module, ModuleMetadata } from '@nestjs/common';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { NestContainer } from '@nestjs/core/injector/container';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import { NoopGraphInspector } from '@nestjs/core/inspector/noop-graph-inspector';
import {
  UuidFactory,
  UuidFactoryMode,
} from '@nestjs/core/inspector/uuid-factory';
import { ModuleDefinition } from '@nestjs/core/interfaces/module-definition.interface';
import { ModuleOverride } from '@nestjs/core/interfaces/module-override.interface';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import { DependenciesScanner } from '@nestjs/core/scanner';
import {
  MockFactory,
  OverrideBy,
  OverrideByFactoryOptions,
} from './interfaces';
import { OverrideModule } from './interfaces/override-module.interface';
import { TestingLogger } from './services/testing-logger.service';
import { TestingInjector } from './testing-injector';
import { TestingInstanceLoader } from './testing-instance-loader';
import { TestingModule } from './testing-module';

/**
 * @publicApi
 */
export type TestingModuleOptions = Pick<
  NestApplicationContextOptions,
  'moduleIdGeneratorAlgorithm'
>;

/**
 * @publicApi
 */
export class TestingModuleBuilder {
  private readonly applicationConfig = new ApplicationConfig();
  private readonly container: NestContainer;
  private readonly overloadsMap = new Map();
  private readonly moduleOverloadsMap = new Map<
    ModuleDefinition,
    ModuleDefinition
  >();
  private readonly module: any;
  private testingLogger: LoggerService;
  private mocker?: MockFactory;

  constructor(
    private readonly metadataScanner: MetadataScanner,
    metadata: ModuleMetadata,
    options?: TestingModuleOptions,
  ) {
    this.container = new NestContainer(this.applicationConfig, options);
    this.module = this.createModule(metadata);
  }

  public setLogger(testingLogger: LoggerService) {
    this.testingLogger = testingLogger;
    return this;
  }

  public overridePipe<T = any>(typeOrToken: T): OverrideBy {
    return this.override(typeOrToken, false);
  }

  public useMocker(mocker: MockFactory): TestingModuleBuilder {
    this.mocker = mocker;
    return this;
  }

  public overrideFilter<T = any>(typeOrToken: T): OverrideBy {
    return this.override(typeOrToken, false);
  }

  public overrideGuard<T = any>(typeOrToken: T): OverrideBy {
    return this.override(typeOrToken, false);
  }

  public overrideInterceptor<T = any>(typeOrToken: T): OverrideBy {
    return this.override(typeOrToken, false);
  }

  public overrideProvider<T = any>(typeOrToken: T): OverrideBy {
    return this.override(typeOrToken, true);
  }

  public overrideModule(moduleToOverride: ModuleDefinition): OverrideModule {
    return {
      useModule: newModule => {
        this.moduleOverloadsMap.set(moduleToOverride, newModule);
        return this;
      },
    };
  }

  public async compile(
    options: Pick<NestApplicationContextOptions, 'snapshot' | 'preview'> = {},
  ): Promise<TestingModule> {
    this.applyLogger();

    let graphInspector: GraphInspector;
    if (options?.snapshot) {
      graphInspector = new GraphInspector(this.container);
      UuidFactory.mode = UuidFactoryMode.Deterministic;
    } else {
      graphInspector = NoopGraphInspector;
      UuidFactory.mode = UuidFactoryMode.Random;
    }

    const scanner = new DependenciesScanner(
      this.container,
      this.metadataScanner,
      graphInspector,
      this.applicationConfig,
    );
    await scanner.scan(this.module, {
      overrides: this.getModuleOverloads(),
    });

    this.applyOverloadsMap();
    await this.createInstancesOfDependencies(graphInspector, options);
    scanner.applyApplicationProviders();

    const root = this.getRootModule();
    return new TestingModule(
      this.container,
      graphInspector,
      root,
      this.applicationConfig,
    );
  }

  private override<T = any>(typeOrToken: T, isProvider: boolean): OverrideBy {
    const addOverload = (options: any) => {
      this.overloadsMap.set(typeOrToken, {
        ...options,
        isProvider,
      });
      return this;
    };
    return this.createOverrideByBuilder(addOverload);
  }

  private createOverrideByBuilder(
    add: (provider: any) => TestingModuleBuilder,
  ): OverrideBy {
    return {
      useValue: value => add({ useValue: value }),
      useFactory: (options: OverrideByFactoryOptions) =>
        add({ ...options, useFactory: options.factory }),
      useClass: metatype => add({ useClass: metatype }),
    };
  }

  private applyOverloadsMap() {
    const overloads = [...this.overloadsMap.entries()];
    overloads.forEach(([item, options]) => {
      this.container.replace(item, options);
    });
  }

  private getModuleOverloads(): ModuleOverride[] {
    const overloads = [...this.moduleOverloadsMap.entries()];
    return overloads.map(([moduleToReplace, newModule]) => ({
      moduleToReplace,
      newModule,
    }));
  }

  private getRootModule() {
    const modules = this.container.getModules().values();
    return modules.next().value!;
  }

  private async createInstancesOfDependencies(
    graphInspector: GraphInspector,
    options: { preview?: boolean },
  ) {
    const injector = new TestingInjector({
      preview: options?.preview ?? false,
    });
    const instanceLoader = new TestingInstanceLoader(
      this.container,
      injector,
      graphInspector,
    );
    await instanceLoader.createInstancesOfDependencies(
      this.container.getModules(),
      this.mocker,
    );
  }

  private createModule(metadata: ModuleMetadata) {
    class RootTestModule {}
    Module(metadata)(RootTestModule);
    return RootTestModule;
  }

  private applyLogger() {
    Logger.overrideLogger(this.testingLogger || new TestingLogger());
  }
}



================================================
FILE: packages/testing/testing-module.ts
================================================
import {
  HttpServer,
  INestApplication,
  INestMicroservice,
  Logger,
  NestApplicationOptions,
  Type,
} from '@nestjs/common';
import { NestMicroserviceOptions } from '@nestjs/common/interfaces/microservices/nest-microservice-options.interface';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { loadPackage } from '@nestjs/common/utils/load-package.util';
import { isUndefined } from '@nestjs/common/utils/shared.utils';
import {
  AbstractHttpAdapter,
  NestApplication,
  NestApplicationContext,
} from '@nestjs/core';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { NestContainer } from '@nestjs/core/injector/container';
import { Module } from '@nestjs/core/injector/module';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';

/**
 * @publicApi
 */
export class TestingModule extends NestApplicationContext {
  protected readonly graphInspector: GraphInspector;

  constructor(
    container: NestContainer,
    graphInspector: GraphInspector,
    contextModule: Module,
    private readonly applicationConfig: ApplicationConfig,
    scope: Type<any>[] = [],
  ) {
    const options = {};
    super(container, options, contextModule, scope);

    this.graphInspector = graphInspector;
  }

  private isHttpServer(
    serverOrOptions:
      | HttpServer
      | AbstractHttpAdapter
      | NestApplicationOptions
      | undefined,
  ): serverOrOptions is HttpServer | AbstractHttpAdapter {
    return !!(serverOrOptions && (serverOrOptions as HttpServer).patch);
  }

  public createNestApplication<T extends INestApplication = INestApplication>(
    httpAdapter: HttpServer | AbstractHttpAdapter,
    options?: NestApplicationOptions,
  ): T;
  public createNestApplication<T extends INestApplication = INestApplication>(
    options?: NestApplicationOptions,
  ): T;
  public createNestApplication<T extends INestApplication = INestApplication>(
    serverOrOptions:
      | HttpServer
      | AbstractHttpAdapter
      | NestApplicationOptions
      | undefined,
    options?: NestApplicationOptions,
  ): T {
    const [httpAdapter, appOptions] = this.isHttpServer(serverOrOptions)
      ? [serverOrOptions, options]
      : [this.createHttpAdapter(), serverOrOptions];

    this.applyLogger(appOptions);
    this.container.setHttpAdapter(httpAdapter);

    const instance = new NestApplication(
      this.container,
      httpAdapter,
      this.applicationConfig,
      this.graphInspector,
      appOptions,
    );
    return this.createAdapterProxy<T>(instance, httpAdapter);
  }

  public createNestMicroservice<T extends object>(
    options: NestMicroserviceOptions & T,
  ): INestMicroservice {
    const { NestMicroservice } = loadPackage(
      '@nestjs/microservices',
      'TestingModule',
      () => require('@nestjs/microservices'),
    );
    this.applyLogger(options);
    return new NestMicroservice(
      this.container,
      options,
      this.graphInspector,
      this.applicationConfig,
    );
  }

  private createHttpAdapter<T = any>(httpServer?: T): AbstractHttpAdapter {
    const { ExpressAdapter } = loadPackage(
      '@nestjs/platform-express',
      'NestFactory',
      () => require('@nestjs/platform-express'),
    );
    return new ExpressAdapter(httpServer);
  }

  private applyLogger(options: NestApplicationContextOptions | undefined) {
    if (!options || isUndefined(options.logger)) {
      return;
    }
    Logger.overrideLogger(options.logger);
  }

  private createAdapterProxy<T>(app: NestApplication, adapter: HttpServer): T {
    return new Proxy(app, {
      get: (receiver: Record<string, any>, prop: string) => {
        if (!(prop in receiver) && prop in adapter) {
          return adapter[prop];
        }
        return receiver[prop];
      },
    }) as any as T;
  }
}



================================================
FILE: packages/testing/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/core": ["../core"],
      "@nestjs/core/*": ["../core/*"],
      "@nestjs/microservices": ["../microservices"],
      "@nestjs/microservices/*": ["../microservices/*"],
      "@nestjs/platform-express": ["../platform-express"],
      "@nestjs/platform-express/*": ["../platform-express/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../core/tsconfig.build.json"
    },
    {
      "path": "../microservices/tsconfig.build.json"
    },
    {
      "path": "../platform-express/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/testing/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/testing/interfaces/index.ts
================================================
export * from './mock-factory';
export * from './override-by-factory-options.interface';
export * from './override-by.interface';



================================================
FILE: packages/testing/interfaces/mock-factory.ts
================================================
import { InjectionToken } from '@nestjs/common';

export type MockFactory = (token?: InjectionToken) => any;



================================================
FILE: packages/testing/interfaces/override-by-factory-options.interface.ts
================================================
/**
 * @publicApi
 */
export interface OverrideByFactoryOptions {
  factory: (...args: any[]) => any;
  inject?: any[];
}



================================================
FILE: packages/testing/interfaces/override-by.interface.ts
================================================
import { TestingModuleBuilder } from '../testing-module.builder';
import { OverrideByFactoryOptions } from './override-by-factory-options.interface';

/**
 * @publicApi
 */
export interface OverrideBy {
  useValue: (value: any) => TestingModuleBuilder;
  useFactory: (options: OverrideByFactoryOptions) => TestingModuleBuilder;
  useClass: (metatype: any) => TestingModuleBuilder;
}



================================================
FILE: packages/testing/interfaces/override-module.interface.ts
================================================
import { ModuleDefinition } from '@nestjs/core/interfaces/module-definition.interface';
import { TestingModuleBuilder } from '../testing-module.builder';

/**
 * @publicApi
 */
export interface OverrideModule {
  useModule: (newModule: ModuleDefinition) => TestingModuleBuilder;
}



================================================
FILE: packages/testing/services/testing-logger.service.ts
================================================
import { ConsoleLogger } from '@nestjs/common';

/**
 * @publicApi
 */
export class TestingLogger extends ConsoleLogger {
  constructor() {
    super('Testing');
  }

  log(message: string) {}
  warn(message: string) {}
  debug(message: string) {}
  verbose(message: string) {}
  error(message: string, ...optionalParams: any[]) {
    return super.error(message, ...optionalParams);
  }
}



================================================
FILE: packages/websockets/Readme.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

Nest is a framework for building efficient, scalable <a href="https://nodejs.org" target="_blank">Node.js</a> server-side applications. It uses modern JavaScript, is built with <a href="https://www.typescriptlang.org" target="_blank">TypeScript</a> (preserves compatibility with pure JavaScript) and combines elements of OOP (Object Oriented Programming), FP (Functional Programming), and FRP (Functional Reactive Programming).

<p>Under the hood, Nest makes use of <a href="https://expressjs.com/" target="_blank">Express</a>, but also provides compatibility with a wide range of other libraries, like <a href="https://github.com/fastify/fastify" target="_blank">Fastify</a>, allowing for easy use of the myriad of third-party plugins which are available.</p>

## Philosophy

<p>In recent years, thanks to Node.js, JavaScript has become the “lingua franca” of the web for both front and backend applications, giving rise to awesome projects like <a href="https://angular.io/" target="_blank">Angular</a>, <a href="https://github.com/facebook/react" target="_blank">React</a>, and <a href="https://github.com/vuejs/vue" target="_blank">Vue</a>, which improve developer productivity and enable the construction of fast, testable, and extensible frontend applications. However, on the server-side, while there are a lot of superb libraries, helpers, and tools for Node, none of them effectively solve the main problem - the architecture.</p>
<p>Nest aims to provide an application architecture out of the box which allows for effortless creation of highly testable, scalable, and loosely coupled and easily maintainable applications. The architecture is heavily inspired by Angular.</p>

## Getting started

- To check out the [guide](https://docs.nestjs.com), visit [docs.nestjs.com](https://docs.nestjs.com). :books:
- 要查看中文 [指南](readme_zh.md), 请访问 [docs.nestjs.cn](https://docs.nestjs.cn). :books:
- [가이드](readme_kr.md) 문서는 [docs.nestjs.com](https://docs.nestjs.com)에서 확인하실 수 있습니다. :books:
- [ガイド](readme_jp.md)は [docs.nestjs.com](https://docs.nestjs.com)でご確認ください。 :books:

## Questions

For questions and support please use the official [Discord channel](https://discord.gg/G7Qnnhy). The issue list of this repo is **exclusively** for bug reports and feature requests.

## Issues

Please make sure to read the [Issue Reporting Checklist](https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md#-submitting-an-issue) before opening an issue. Issues not conforming to the guidelines may be closed immediately.

## Consulting

With official support, you can get expert help straight from Nest core team. We provide dedicated technical support, migration strategies, advice on best practices (and design decisions), PR reviews, and team augmentation. Read more about [support here](https://enterprise.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support from the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

#### Principal Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://trilon.io" target="_blank"><img src="https://nestjs.com/img/trilon.svg" width="200" valign="middle" /></a></td>
<td><a href="https://microsoft.com/" target="_blank"><img src="https://nestjs.com/img/logos/microsoft-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://mojam.co" target="_blank"><img src="https://nestjs.com/img/logos/mojam-logo.png" width="80" valign="middle" /></a></td>
<td><a href="https://marblism.com?utm_source=nest" target="_blank"><img src="https://nestjs.com/img/logos/marblism-logo.png" width="180" valign="middle" /></a></td>
<td><a href="https://valor-software.com/" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/valor-software.png" width="170" valign="middle" /></a></td>
<td><a href="https://amplication.com/" target="_blank"><img src="https://nestjs.com/img/logos/amplication-logo.svg" width="190" valign="middle" /></a></td>
</tr>
</table>

#### Gold Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.redhat.com" target="_blank"><img src="https://nestjs.com/img/logos/red-hat-logo.svg" width="200" valign="middle" /></a></td>
<td><a href="https://github.com/Sanofi-IADC" target="_blank"><img src="https://docs.nestjs.com/assets/sponsors/sanofi.png" width="180" valign="middle" /></a></td>
<td><a href="https://nx.dev" target="_blank"><img src="https://nestjs.com/img/logos/nx-logo.png" height="45" valign="middle" /></a></td>
<td><a href="https://intrinsic.ventures/" target="_blank"><img src="https://nestjs.com/img/logos/intrinisic-logo.png" width="210" valign="middle" /></a></td>
<td><a href="https://jetbrains.com/" target="_blank"><img src="https://nestjs.com/img/logos/jetbrains-logo.svg" width="90" valign="middle" /></a></td>
</tr>
<tr>
<td><a href="https://snyk.co/nestjs" target="_blank"><img src="https://nestjs.com/img/logos/snyk-logo-black.png" width="185" valign="middle" /></a></td>
<td><a href="https://fuseautotech.com/" target="_blank"><img src="https://nestjs.com/img/logos/fuse-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://ridicorp.com/career/" target="_blank"><img src="https://nestjs.com/img/logos/ridi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://www.movavi.com/imovie-for-windows.html" target="_blank"><img src="https://nestjs.com/img/logos/movavi-logo.svg" width="105" valign="middle" /></a></td>
<td><a href="https://skunk.team" target="_blank"><img src="https://nestjs.com/img/logos/skunk-logo.png" height="60" valign="middle" /></a></td>
</tr>
</table>

#### Silver Sponsors

<table style="text-align:center;">
<tr>
<td><a href="https://www.mercedes-benz.com/" target="_blank"><img src="https://nestjs.com/img/logos/mercedes-logo.png" width="100" valign="middle" /></a></td>
<td><a href="https://www.dinii.jp/" target="_blank"><img src="https://nestjs.com/img/logos/dinii-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://bloodycase.com/?promocode=NEST" target="_blank"><img src="https://nestjs.com/img/logos/bloodycase-logo.png" width="65" valign="middle" /></a></td>
<td><a href="https://handsontable.com/docs/react-data-grid/?utm_source=NestJS_GH&utm_medium=sponsorship&utm_campaign=library_sponsorship_2024" target="_blank"><img src="https://nestjs.com/img/logos/handsontable-dark-logo.svg#2" width="150" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.itflashcards.com/" target="_blank"><img src="https://nestjs.com/img/logos/it_flashcards-logo.png" width="170" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://arcjet.com/?ref=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/arcjet-logo.svg" width="170" valign="middle" /></a></td>
</tr>
</table>

#### Sponsors

<table>
<tr>
<td align="center" valign="middle"><a href="https://www.swingdev.io" target="_blank"><img src="https://nestjs.com/img/logos/swingdev-logo.svg#1" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.novologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/novologic.png" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://mantro.net/" target="_blank"><img src="https://nestjs.com/img/logos/mantro-logo.svg" width="95" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplebyte.com/" target="_blank"><img src="https://nestjs.com/img/logos/triplebyte.png" width="107" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nearpod.com/" target="_blank"><img src="https://nestjs.com/img/logos/nearpod-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://genuinebee.com/" target="_blank"><img src="https://nestjs.com/img/logos/genuinebee.svg" width="97" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://vpn-review.com/vpn-for-torrenting" target="_blank"><img src="https://nestjs.com/img/logos/vpn-review-logo.png" width="85" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://lambda-it.ch/" target="_blank"><img src="https://nestjs.com/img/logos/lambda-it-logo.svg" width="115" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://rocketech.it/cases/?utm_source=google&utm_medium=badge&utm_campaign=nestjs" target="_blank"><img src="https://nestjs.com/img/logos/rocketech-logo.svg" width="110" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.anonymistic.com/" target="_blank"><img src="https://nestjs.com/img/logos/anonymistic-logo.png" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.naologic.com/" target="_blank"><img src="https://nestjs.com/img/logos/naologic-logo.svg" width="125" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://triplecore.io" target="_blank"><img src="https://nestjs.com/img/logos/triplecore-logo.svg" width="50" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://thecasinowizard.com/bonuses/no-deposit-bonuses/" target="_blank"><img src="https://nestjs.com/img/logos/casinowizard-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://polygon-software.ch/" target="_blank"><img src="https://nestjs.com/img/logos/polygon-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://boringowl.io/" target="_blank"><img src="https://nestjs.com/img/logos/boringowl-logo.svg" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://nordbot.app/" target="_blank"><img src="https://nestjs.com/img/logos/nordbot-logo.png" width="120" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://doppio.sh/" target="_blank"><img src="https://nestjs.com/img/logos/dopiosh-logo.png" width="50" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.hingehealth.com/" target="_blank"><img src="https://nestjs.com/img/logos/hinge-health-logo.svg" width="100" valign="middle" /></a></td>
</tr>
<tr>
<td align="center" valign="middle"><a href="https://julienferand.dev/" target="_blank"><img src="https://nestjs.com/img/logos/julienferand-logo.jpeg" width="55" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.tripoffice.com/" target="_blank"><img src="https://nestjs.com/img/logos/tripoffice-logo.png" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://solcellsforetag.se/" target="_blank"><img src="https://nestjs.com/img/logos/solcellsforetag-logo.svg" width="140" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.route4me.com/" target="_blank"><img src="https://nestjs.com/img/logos/route4me-logo.svg" width="100" valign="middle" /></a></td>
<td align="center" valign="middle"><a href="https://www.slotsup.com/" target="_blank"><img src="https://nestjs.com/img/logos/slotsup-logo.png" width="60" valign="middle" /></a></td>
</tr>
</table>

## Backers

<a href="https://opencollective.com/nest" target="_blank"><img src="https://opencollective.com/nest/backers.svg?width=1000"></a>

## Stay in touch

- Author - [Kamil Myśliwiec](https://x.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- X - [@nestframework](https://x.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: packages/websockets/constants.ts
================================================
import { ROUTE_ARGS_METADATA } from '@nestjs/common/constants';

export const MESSAGE_MAPPING_METADATA = 'websockets:message_mapping';
export const MESSAGE_METADATA = 'message';
export const GATEWAY_SERVER_METADATA = 'websockets:is_socket';
export const GATEWAY_METADATA = 'websockets:is_gateway';
export const NAMESPACE_METADATA = 'namespace';
export const PORT_METADATA = 'port';
export const GATEWAY_OPTIONS = 'websockets:gateway_options';
export const PARAM_ARGS_METADATA = ROUTE_ARGS_METADATA;

export const CONNECTION_EVENT = 'connection';
export const DISCONNECT_EVENT = 'disconnect';
export const CLOSE_EVENT = 'close';
export const ERROR_EVENT = 'error';



================================================
FILE: packages/websockets/gateway-metadata-explorer.ts
================================================
import { isFunction, isUndefined } from '@nestjs/common/utils/shared.utils';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import { Observable } from 'rxjs';
import {
  GATEWAY_SERVER_METADATA,
  MESSAGE_MAPPING_METADATA,
  MESSAGE_METADATA,
} from './constants';
import { NestGateway } from './interfaces/nest-gateway.interface';

export interface MessageMappingProperties {
  message: any;
  methodName: string;
  callback: (...args: any[]) => Observable<any> | Promise<any>;
}

export class GatewayMetadataExplorer {
  constructor(private readonly metadataScanner: MetadataScanner) {}

  public explore(instance: NestGateway): MessageMappingProperties[] {
    const instancePrototype = Object.getPrototypeOf(instance);
    return this.metadataScanner
      .getAllMethodNames(instancePrototype)
      .map(method => this.exploreMethodMetadata(instancePrototype, method)!)
      .filter(metadata => metadata);
  }

  public exploreMethodMetadata(
    instancePrototype: object,
    methodName: string,
  ): MessageMappingProperties | null {
    const callback = instancePrototype[methodName];
    const isMessageMapping = Reflect.getMetadata(
      MESSAGE_MAPPING_METADATA,
      callback,
    );
    if (isUndefined(isMessageMapping)) {
      return null;
    }
    const message = Reflect.getMetadata(MESSAGE_METADATA, callback);
    return {
      callback,
      message,
      methodName,
    };
  }

  public *scanForServerHooks(instance: NestGateway): IterableIterator<string> {
    for (const propertyKey in instance) {
      if (isFunction(propertyKey)) {
        continue;
      }
      const property = String(propertyKey);
      const isServer = Reflect.getMetadata(
        GATEWAY_SERVER_METADATA,
        instance,
        property,
      );
      if (!isUndefined(isServer)) {
        yield property;
      }
    }
  }
}



================================================
FILE: packages/websockets/index.ts
================================================
/*
 * Nest @websockets
 * Copyright(c) 2017 - 2025 Kamil Mysliwiec
 * https://nestjs.com
 * MIT Licensed
 */
import 'reflect-metadata';

export * from './adapters';
export * from './decorators';
export * from './errors';
export * from './exceptions';
export { MessageMappingProperties } from './gateway-metadata-explorer';
export * from './interfaces';



================================================
FILE: packages/websockets/package.json
================================================
{
  "name": "@nestjs/websockets",
  "version": "11.0.13",
  "description": "Nest - modern, fast, powerful node.js web framework (@websockets)",
  "author": "Kamil Mysliwiec",
  "license": "MIT",
  "repository": {
    "type": "git",
    "url": "https://github.com/nestjs/nest.git",
    "directory": "packages/websockets"
  },
  "publishConfig": {
    "access": "public"
  },
  "dependencies": {
    "iterare": "1.2.1",
    "object-hash": "3.0.0",
    "tslib": "2.8.1"
  },
  "devDependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13"
  },
  "peerDependencies": {
    "@nestjs/common": "^11.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/platform-socket.io": "^11.0.0",
    "reflect-metadata": "^0.1.12 || ^0.2.0",
    "rxjs": "^7.1.0"
  },
  "peerDependenciesMeta": {
    "@nestjs/platform-socket.io": {
      "optional": true
    }
  }
}



================================================
FILE: packages/websockets/socket-module.ts
================================================
import { NestApplicationOptions } from '@nestjs/common';
import { InjectionToken } from '@nestjs/common/interfaces';
import { Injectable } from '@nestjs/common/interfaces/injectable.interface';
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { GuardsConsumer } from '@nestjs/core/guards/guards-consumer';
import { GuardsContextCreator } from '@nestjs/core/guards/guards-context-creator';
import { loadAdapter } from '@nestjs/core/helpers/load-adapter';
import { NestContainer } from '@nestjs/core/injector/container';
import { InstanceWrapper } from '@nestjs/core/injector/instance-wrapper';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import { InterceptorsConsumer } from '@nestjs/core/interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '@nestjs/core/interceptors/interceptors-context-creator';
import { PipesConsumer } from '@nestjs/core/pipes/pipes-consumer';
import { PipesContextCreator } from '@nestjs/core/pipes/pipes-context-creator';
import { iterate } from 'iterare';
import { AbstractWsAdapter } from './adapters';
import { GATEWAY_METADATA } from './constants';
import { ExceptionFiltersContext } from './context/exception-filters-context';
import { WsContextCreator } from './context/ws-context-creator';
import { WsProxy } from './context/ws-proxy';
import { NestGateway } from './interfaces/nest-gateway.interface';
import { SocketServerProvider } from './socket-server-provider';
import { SocketsContainer } from './sockets-container';
import { WebSocketsController } from './web-sockets-controller';

export class SocketModule<
  THttpServer = any,
  TAppOptions extends
    NestApplicationContextOptions = NestApplicationContextOptions,
> {
  private readonly socketsContainer = new SocketsContainer();
  private applicationConfig: ApplicationConfig;
  private webSocketsController: WebSocketsController;
  private isAdapterInitialized: boolean;
  private httpServer: THttpServer | undefined;
  private appOptions: TAppOptions;

  public register(
    container: NestContainer,
    applicationConfig: ApplicationConfig,
    graphInspector: GraphInspector,
    appOptions: TAppOptions,
    httpServer?: THttpServer,
  ) {
    this.applicationConfig = applicationConfig;
    this.appOptions = appOptions;
    this.httpServer = httpServer;

    const contextCreator = this.getContextCreator(container);
    const serverProvider = new SocketServerProvider(
      this.socketsContainer,
      applicationConfig,
    );
    this.webSocketsController = new WebSocketsController(
      serverProvider,
      applicationConfig,
      contextCreator,
      graphInspector,
      this.appOptions,
    );
    const modules = container.getModules();
    modules.forEach(({ providers }, moduleName: string) =>
      this.connectAllGateways(providers, moduleName),
    );
  }

  public connectAllGateways(
    providers: Map<InjectionToken, InstanceWrapper<Injectable>>,
    moduleName: string,
  ) {
    iterate(providers.values())
      .filter(wrapper => wrapper && !wrapper.isNotMetatype)
      .forEach(wrapper => this.connectGatewayToServer(wrapper, moduleName));
  }

  public connectGatewayToServer(
    wrapper: InstanceWrapper<Injectable>,
    moduleName: string,
  ) {
    const { instance, metatype } = wrapper;
    const metadataKeys = Reflect.getMetadataKeys(metatype!);
    if (!metadataKeys.includes(GATEWAY_METADATA)) {
      return;
    }
    if (!this.isAdapterInitialized) {
      this.initializeAdapter();
    }
    this.webSocketsController.connectGatewayToServer(
      instance as NestGateway,
      metatype!,
      moduleName,
      wrapper.id,
    );
  }

  public async close(): Promise<any> {
    if (!this.applicationConfig) {
      return;
    }
    const adapter = this.applicationConfig.getIoAdapter();
    if (!adapter) {
      return;
    }
    const servers = this.socketsContainer.getAll();
    await Promise.all(
      iterate(servers.values())
        .filter(({ server }) => server)
        .map(async ({ server }) => adapter.close(server)),
    );
    await (adapter as AbstractWsAdapter)?.dispose();

    this.socketsContainer.clear();
  }

  private initializeAdapter() {
    const forceCloseConnections = (this.appOptions as NestApplicationOptions)
      .forceCloseConnections;
    const adapter = this.applicationConfig.getIoAdapter();
    if (adapter) {
      (adapter as AbstractWsAdapter).forceCloseConnections =
        forceCloseConnections!;
      this.isAdapterInitialized = true;
      return;
    }
    const { IoAdapter } = loadAdapter(
      '@nestjs/platform-socket.io',
      'WebSockets',
      () => require('@nestjs/platform-socket.io'),
    );
    const ioAdapter = new IoAdapter(this.httpServer);
    ioAdapter.forceCloseConnections = forceCloseConnections;
    this.applicationConfig.setIoAdapter(ioAdapter);

    this.isAdapterInitialized = true;
  }

  private getContextCreator(container: NestContainer): WsContextCreator {
    return new WsContextCreator(
      new WsProxy(),
      new ExceptionFiltersContext(container),
      new PipesContextCreator(container),
      new PipesConsumer(),
      new GuardsContextCreator(container),
      new GuardsConsumer(),
      new InterceptorsContextCreator(container),
      new InterceptorsConsumer(),
    );
  }
}



================================================
FILE: packages/websockets/socket-server-provider.ts
================================================
import { addLeadingSlash, isString } from '@nestjs/common/utils/shared.utils';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { ServerAndEventStreamsFactory } from './factories/server-and-event-streams-factory';
import { GatewayMetadata } from './interfaces/gateway-metadata.interface';
import { ServerAndEventStreamsHost } from './interfaces/server-and-event-streams-host.interface';
import { SocketsContainer } from './sockets-container';

export class SocketServerProvider {
  constructor(
    private readonly socketsContainer: SocketsContainer,
    private readonly applicationConfig: ApplicationConfig,
  ) {}

  public scanForSocketServer<T extends GatewayMetadata = any>(
    options: T,
    port: number,
  ): ServerAndEventStreamsHost {
    const serverAndStreamsHost = this.socketsContainer.getOneByConfig({
      port,
      path: options.path,
    });
    if (serverAndStreamsHost && options.namespace) {
      return this.decorateWithNamespace(
        options,
        port,
        serverAndStreamsHost.server,
      );
    }
    return serverAndStreamsHost
      ? serverAndStreamsHost
      : this.createSocketServer(options, port);
  }

  private createSocketServer<T extends GatewayMetadata>(
    options: T,
    port: number,
  ): ServerAndEventStreamsHost {
    const adapter = this.applicationConfig.getIoAdapter();
    const { namespace, server, ...partialOptions } = options as Record<
      string,
      unknown
    >;
    const ioServer = adapter.create(port, partialOptions);
    const serverAndEventStreamsHost =
      ServerAndEventStreamsFactory.create(ioServer);

    this.socketsContainer.addOne(
      { port, path: options.path },
      serverAndEventStreamsHost,
    );
    if (!namespace) {
      return serverAndEventStreamsHost;
    }
    return this.decorateWithNamespace(options, port, ioServer);
  }

  private decorateWithNamespace<T extends GatewayMetadata = any>(
    options: T,
    port: number,
    targetServer: unknown,
  ): ServerAndEventStreamsHost {
    const namespaceServer = this.getServerOfNamespace(
      options,
      port,
      targetServer,
    );
    const serverAndEventStreamsHost =
      ServerAndEventStreamsFactory.create(namespaceServer);
    this.socketsContainer.addOne(
      { port, path: options.path, namespace: options.namespace },
      serverAndEventStreamsHost,
    );
    return serverAndEventStreamsHost;
  }

  private getServerOfNamespace<
    TOptions extends GatewayMetadata = any,
    TServer = any,
  >(options: TOptions, port: number, server: TServer) {
    const adapter = this.applicationConfig.getIoAdapter();
    return adapter.create(port, {
      ...options,
      namespace: this.validateNamespace(options.namespace || ''),
      server,
    });
  }

  private validateNamespace(namespace: string | RegExp): string | RegExp {
    if (!isString(namespace)) {
      return namespace;
    }
    return addLeadingSlash(namespace);
  }
}



================================================
FILE: packages/websockets/sockets-container.ts
================================================
import * as hash from 'object-hash';
import { GatewayMetadata, ServerAndEventStreamsHost } from './interfaces';

export class SocketsContainer {
  private readonly serverAndEventStreamsHosts = new Map<
    string | RegExp,
    ServerAndEventStreamsHost
  >();

  public getAll(): Map<string | RegExp, ServerAndEventStreamsHost> {
    return this.serverAndEventStreamsHosts;
  }

  public getOneByConfig<T extends GatewayMetadata = any>(
    options: T,
  ): ServerAndEventStreamsHost {
    const uniqueToken = this.generateHashByOptions(options);
    return this.serverAndEventStreamsHosts.get(uniqueToken)!;
  }

  public addOne<T extends GatewayMetadata = any>(
    options: T,
    host: ServerAndEventStreamsHost,
  ) {
    const uniqueToken = this.generateHashByOptions(options);
    this.serverAndEventStreamsHosts.set(uniqueToken, host);
  }

  public clear() {
    this.serverAndEventStreamsHosts.clear();
  }

  private generateHashByOptions<T extends GatewayMetadata = any>(
    options: T,
  ): string {
    return hash(options, { ignoreUnknown: true });
  }
}



================================================
FILE: packages/websockets/tsconfig.build.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "outDir": ".",
    "rootDir": ".",
    "paths": {
      "@nestjs/common": ["../common"],
      "@nestjs/common/*": ["../common/*"],
      "@nestjs/core": ["../core"],
      "@nestjs/core/*": ["../core/*"]
    }
  },
  "exclude": ["node_modules", "dist", "test/**/*", "*.spec.ts"],
  "references": [
    {
      "path": "../common/tsconfig.build.json"
    },
    {
      "path": "../core/tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/websockets/tsconfig.json
================================================
{
  "extends": "../tsconfig.build.json",
  "compilerOptions": {
    "types": ["node"]
  },
  "files": [],
  "include": [],
  "references": [
    {
      "path": "./tsconfig.build.json"
    }
  ]
}



================================================
FILE: packages/websockets/web-sockets-controller.ts
================================================
import { NestApplicationContextOptions } from '@nestjs/common/interfaces/nest-application-context-options.interface';
import { Type } from '@nestjs/common/interfaces/type.interface';
import { Logger } from '@nestjs/common/services/logger.service';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { GraphInspector } from '@nestjs/core/inspector/graph-inspector';
import { MetadataScanner } from '@nestjs/core/metadata-scanner';
import {
  from as fromPromise,
  isObservable,
  Observable,
  of,
  Subject,
} from 'rxjs';
import { distinctUntilChanged, mergeAll } from 'rxjs/operators';
import { GATEWAY_OPTIONS, PORT_METADATA } from './constants';
import { WsContextCreator } from './context/ws-context-creator';
import { InvalidSocketPortException } from './errors/invalid-socket-port.exception';
import {
  GatewayMetadataExplorer,
  MessageMappingProperties,
} from './gateway-metadata-explorer';
import { GatewayMetadata } from './interfaces/gateway-metadata.interface';
import { NestGateway } from './interfaces/nest-gateway.interface';
import { ServerAndEventStreamsHost } from './interfaces/server-and-event-streams-host.interface';
import { WebsocketEntrypointMetadata } from './interfaces/websockets-entrypoint-metadata.interface';
import { SocketServerProvider } from './socket-server-provider';
import { compareElementAt } from './utils/compare-element.util';

export class WebSocketsController {
  private readonly logger = new Logger(WebSocketsController.name, {
    timestamp: true,
  });
  private readonly metadataExplorer = new GatewayMetadataExplorer(
    new MetadataScanner(),
  );

  constructor(
    private readonly socketServerProvider: SocketServerProvider,
    private readonly config: ApplicationConfig,
    private readonly contextCreator: WsContextCreator,
    private readonly graphInspector: GraphInspector,
    private readonly appOptions: NestApplicationContextOptions = {},
  ) {}

  public connectGatewayToServer(
    instance: NestGateway,
    metatype: Type<unknown> | Function,
    moduleKey: string,
    instanceWrapperId: string,
  ) {
    const options = Reflect.getMetadata(GATEWAY_OPTIONS, metatype) || {};
    const port = Reflect.getMetadata(PORT_METADATA, metatype) || 0;

    if (!Number.isInteger(port)) {
      throw new InvalidSocketPortException(port, metatype);
    }
    this.subscribeToServerEvents(
      instance,
      options,
      port,
      moduleKey,
      instanceWrapperId,
    );
  }

  public subscribeToServerEvents<T extends GatewayMetadata>(
    instance: NestGateway,
    options: T,
    port: number,
    moduleKey: string,
    instanceWrapperId: string,
  ) {
    const nativeMessageHandlers = this.metadataExplorer.explore(instance);
    const messageHandlers = nativeMessageHandlers.map(
      ({ callback, message, methodName }) => ({
        message,
        methodName,
        callback: this.contextCreator.create(
          instance,
          callback,
          moduleKey,
          methodName,
        ),
      }),
    );

    this.inspectEntrypointDefinitions(
      instance,
      port,
      messageHandlers,
      instanceWrapperId,
    );

    if (this.appOptions.preview) {
      return;
    }
    const observableServer = this.socketServerProvider.scanForSocketServer<T>(
      options,
      port,
    );
    this.assignServerToProperties(instance, observableServer.server);
    this.subscribeEvents(instance, messageHandlers, observableServer);
  }

  public subscribeEvents(
    instance: NestGateway,
    subscribersMap: MessageMappingProperties[],
    observableServer: ServerAndEventStreamsHost,
  ) {
    const { init, disconnect, connection, server } = observableServer;
    const adapter = this.config.getIoAdapter();

    this.subscribeInitEvent(instance, init);
    this.subscribeConnectionEvent(instance, connection);
    this.subscribeDisconnectEvent(instance, disconnect);

    const handler = this.getConnectionHandler(
      this,
      instance,
      subscribersMap,
      disconnect,
      connection,
    );
    adapter.bindClientConnect(server, handler);
    this.printSubscriptionLogs(instance, subscribersMap);
  }

  public getConnectionHandler(
    context: WebSocketsController,
    instance: NestGateway,
    subscribersMap: MessageMappingProperties[],
    disconnect: Subject<any>,
    connection: Subject<any>,
  ) {
    const adapter = this.config.getIoAdapter();
    return (...args: unknown[]) => {
      const [client] = args;
      connection.next(args);
      context.subscribeMessages(subscribersMap, client, instance);

      const disconnectHook = adapter.bindClientDisconnect;
      disconnectHook &&
        disconnectHook.call(adapter, client, () => disconnect.next(client));
    };
  }

  public subscribeInitEvent(instance: NestGateway, event: Subject<any>) {
    if (instance.afterInit) {
      event.subscribe(instance.afterInit.bind(instance));
    }
  }

  public subscribeConnectionEvent(instance: NestGateway, event: Subject<any>) {
    if (instance.handleConnection) {
      event
        .pipe(
          distinctUntilChanged((prev, curr) => compareElementAt(prev, curr, 0)),
        )
        .subscribe((args: unknown[]) => instance.handleConnection!(...args));
    }
  }

  public subscribeDisconnectEvent(instance: NestGateway, event: Subject<any>) {
    if (instance.handleDisconnect) {
      event
        .pipe(distinctUntilChanged())
        .subscribe(instance.handleDisconnect.bind(instance));
    }
  }

  public subscribeMessages<T = any>(
    subscribersMap: MessageMappingProperties[],
    client: T,
    instance: NestGateway,
  ) {
    const adapter = this.config.getIoAdapter();
    const handlers = subscribersMap.map(({ callback, message }) => ({
      message,

      callback: callback.bind(instance, client),
    }));
    adapter.bindMessageHandlers(client, handlers, data =>
      fromPromise(this.pickResult(data)).pipe(mergeAll()),
    );
  }

  public async pickResult(
    deferredResult: Promise<any>,
  ): Promise<Observable<any>> {
    const result = await deferredResult;
    if (isObservable(result)) {
      return result;
    }
    if (result instanceof Promise) {
      return fromPromise(result);
    }
    return of(result);
  }

  public inspectEntrypointDefinitions(
    instance: NestGateway,
    port: number,
    messageHandlers: MessageMappingProperties[],
    instanceWrapperId: string,
  ) {
    messageHandlers.forEach(handler => {
      this.graphInspector.insertEntrypointDefinition<WebsocketEntrypointMetadata>(
        {
          type: 'websocket',
          methodName: handler.methodName,
          className: instance.constructor?.name,
          classNodeId: instanceWrapperId,
          metadata: {
            port,
            key: handler.message,
            message: handler.message,
          },
        },
        instanceWrapperId,
      );
    });
  }

  private assignServerToProperties<T = any>(
    instance: NestGateway,
    server: object,
  ) {
    for (const propertyKey of this.metadataExplorer.scanForServerHooks(
      instance,
    )) {
      Reflect.set(instance, propertyKey, server);
    }
  }

  private printSubscriptionLogs(
    instance: NestGateway,
    subscribersMap: MessageMappingProperties[],
  ) {
    const gatewayClassName = (instance as object)?.constructor?.name;
    if (!gatewayClassName) {
      return;
    }
    subscribersMap.forEach(({ message }) =>
      this.logger.log(
        `${gatewayClassName} subscribed to the "${message}" message`,
      ),
    );
  }
}



================================================
FILE: packages/websockets/adapters/index.ts
================================================
export * from './ws-adapter';



================================================
FILE: packages/websockets/adapters/ws-adapter.ts
================================================
import { INestApplicationContext, WebSocketAdapter } from '@nestjs/common';
import { WsMessageHandler } from '@nestjs/common/interfaces';
import { isFunction } from '@nestjs/common/utils/shared.utils';
import { NestApplication } from '@nestjs/core';
import { Observable } from 'rxjs';
import { CONNECTION_EVENT, DISCONNECT_EVENT } from '../constants';

export interface BaseWsInstance {
  on: (event: string, callback: Function) => void;
  close: Function;
}

export abstract class AbstractWsAdapter<
  TServer extends BaseWsInstance = any,
  TClient extends BaseWsInstance = any,
  TOptions = any,
> implements WebSocketAdapter<TServer, TClient, TOptions>
{
  protected readonly httpServer: any;
  private _forceCloseConnections: boolean;

  public set forceCloseConnections(value: boolean) {
    this._forceCloseConnections = value;
  }

  public get forceCloseConnections(): boolean {
    return this._forceCloseConnections;
  }

  constructor(appOrHttpServer?: INestApplicationContext | object) {
    if (appOrHttpServer && appOrHttpServer instanceof NestApplication) {
      this.httpServer = appOrHttpServer.getUnderlyingHttpServer();
    } else {
      this.httpServer = appOrHttpServer;
    }
  }

  public bindClientConnect(server: TServer, callback: Function) {
    server.on(CONNECTION_EVENT, callback);
  }

  public bindClientDisconnect(client: TClient, callback: Function) {
    client.on(DISCONNECT_EVENT, callback);
  }

  public async close(server: TServer) {
    const isCallable = server && isFunction(server.close);
    isCallable && (await new Promise(resolve => server.close(resolve)));
  }

  public async dispose() {}

  public abstract create(port: number, options?: TOptions): TServer;
  public abstract bindMessageHandlers(
    client: TClient,
    handlers: WsMessageHandler[],
    transform: (data: any) => Observable<any>,
  );
}



================================================
FILE: packages/websockets/context/exception-filters-context.ts
================================================
import { EXCEPTION_FILTERS_METADATA } from '@nestjs/common/constants';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { BaseExceptionFilterContext } from '@nestjs/core/exceptions/base-exception-filter-context';
import { NestContainer } from '@nestjs/core/injector/container';
import { WsExceptionsHandler } from '../exceptions/ws-exceptions-handler';

/**
 * @publicApi
 */
export class ExceptionFiltersContext extends BaseExceptionFilterContext {
  constructor(container: NestContainer) {
    super(container);
  }

  public create(
    instance: object,
    callback: <TClient>(client: TClient, data: any) => any,
    moduleKey: string,
  ): WsExceptionsHandler {
    this.moduleContext = moduleKey;

    const exceptionHandler = new WsExceptionsHandler();
    const filters = this.createContext(
      instance,
      callback,
      EXCEPTION_FILTERS_METADATA,
    );
    if (isEmpty(filters)) {
      return exceptionHandler;
    }
    exceptionHandler.setCustomFilters(filters.reverse());
    return exceptionHandler;
  }

  public getGlobalMetadata<T extends any[]>(): T {
    return [] as any[] as T;
  }
}



================================================
FILE: packages/websockets/context/ws-context-creator.ts
================================================
import {
  CUSTOM_ROUTE_ARGS_METADATA,
  PARAMTYPES_METADATA,
} from '@nestjs/common/constants';
import {
  ContextType,
  Controller,
  PipeTransform,
} from '@nestjs/common/interfaces';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { FORBIDDEN_MESSAGE } from '@nestjs/core/guards/constants';
import { GuardsConsumer } from '@nestjs/core/guards/guards-consumer';
import { GuardsContextCreator } from '@nestjs/core/guards/guards-context-creator';
import {
  ContextUtils,
  ParamProperties,
} from '@nestjs/core/helpers/context-utils';
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { HandlerMetadataStorage } from '@nestjs/core/helpers/handler-metadata-storage';
import { ParamsMetadata } from '@nestjs/core/helpers/interfaces';
import {
  InterceptorsConsumer,
  InterceptorsContextCreator,
} from '@nestjs/core/interceptors';
import { PipesConsumer, PipesContextCreator } from '@nestjs/core/pipes';
import { MESSAGE_METADATA, PARAM_ARGS_METADATA } from '../constants';
import { WsException } from '../errors/ws-exception';
import { WsParamsFactory } from '../factories/ws-params-factory';
import { ExceptionFiltersContext } from './exception-filters-context';
import { DEFAULT_CALLBACK_METADATA } from './ws-metadata-constants';
import { WsProxy } from './ws-proxy';

type WsParamProperties = ParamProperties & { metatype?: any };
export interface WsHandlerMetadata {
  argsLength: number;
  paramtypes: any[];
  getParamsMetadata: (moduleKey: string) => WsParamProperties[];
}

export class WsContextCreator {
  private readonly contextUtils = new ContextUtils();
  private readonly wsParamsFactory = new WsParamsFactory();
  private readonly handlerMetadataStorage =
    new HandlerMetadataStorage<WsHandlerMetadata>();

  constructor(
    private readonly wsProxy: WsProxy,
    private readonly exceptionFiltersContext: ExceptionFiltersContext,
    private readonly pipesContextCreator: PipesContextCreator,
    private readonly pipesConsumer: PipesConsumer,
    private readonly guardsContextCreator: GuardsContextCreator,
    private readonly guardsConsumer: GuardsConsumer,
    private readonly interceptorsContextCreator: InterceptorsContextCreator,
    private readonly interceptorsConsumer: InterceptorsConsumer,
  ) {}

  public create<T extends ParamsMetadata = ParamsMetadata>(
    instance: Controller,
    callback: (...args: unknown[]) => void,
    moduleKey: string,
    methodName: string,
  ): (...args: any[]) => Promise<void> {
    const contextType: ContextType = 'ws';
    const { argsLength, paramtypes, getParamsMetadata } = this.getMetadata<T>(
      instance,
      methodName,
      contextType,
    );
    const exceptionHandler = this.exceptionFiltersContext.create(
      instance,
      callback,
      moduleKey,
    );
    const pipes = this.pipesContextCreator.create(
      instance,
      callback,
      moduleKey,
    );
    const guards = this.guardsContextCreator.create(
      instance,
      callback,
      moduleKey,
    );
    const interceptors = this.interceptorsContextCreator.create(
      instance,
      callback,
      moduleKey,
    );

    const paramsMetadata = getParamsMetadata(moduleKey);
    const paramsOptions = paramsMetadata
      ? this.contextUtils.mergeParamsMetatypes(paramsMetadata, paramtypes)
      : [];
    const fnApplyPipes = this.createPipesFn(pipes, paramsOptions);

    const fnCanActivate = this.createGuardsFn(
      guards,
      instance,
      callback,
      contextType,
    );

    const handler = (initialArgs: unknown[], args: unknown[]) => async () => {
      if (fnApplyPipes) {
        await fnApplyPipes(initialArgs, ...args);
        return callback.apply(instance, initialArgs);
      }
      return callback.apply(instance, args);
    };
    const targetPattern = this.reflectCallbackPattern(callback);
    return this.wsProxy.create(
      async (...args: unknown[]) => {
        args.push(targetPattern);

        const initialArgs = this.contextUtils.createNullArray(argsLength);
        fnCanActivate && (await fnCanActivate(args));

        return this.interceptorsConsumer.intercept(
          interceptors,
          args,
          instance,
          callback,
          handler(initialArgs, args),
          contextType,
        );
      },
      exceptionHandler,
      targetPattern,
    );
  }

  public reflectCallbackParamtypes(
    instance: Controller,
    callback: (...args: any[]) => any,
  ): any[] {
    return Reflect.getMetadata(PARAMTYPES_METADATA, instance, callback.name);
  }

  public reflectCallbackPattern(callback: (...args: any[]) => any): string {
    return Reflect.getMetadata(MESSAGE_METADATA, callback);
  }

  public createGuardsFn<TContext extends string = ContextType>(
    guards: any[],
    instance: Controller,
    callback: (...args: unknown[]) => any,
    contextType?: TContext,
  ): Function | null {
    const canActivateFn = async (args: any[]) => {
      const canActivate = await this.guardsConsumer.tryActivate<TContext>(
        guards,
        args,
        instance,
        callback,
        contextType,
      );
      if (!canActivate) {
        throw new WsException(FORBIDDEN_MESSAGE);
      }
    };
    return guards.length ? canActivateFn : null;
  }

  public getMetadata<TMetadata, TContext extends ContextType = ContextType>(
    instance: Controller,
    methodName: string,
    contextType: TContext,
  ): WsHandlerMetadata {
    const cacheMetadata = this.handlerMetadataStorage.get(instance, methodName);
    if (cacheMetadata) {
      return cacheMetadata;
    }
    const metadata =
      this.contextUtils.reflectCallbackMetadata<TMetadata>(
        instance,
        methodName,
        PARAM_ARGS_METADATA,
      ) || DEFAULT_CALLBACK_METADATA;
    const keys = Object.keys(metadata);
    const argsLength = this.contextUtils.getArgumentsLength(keys, metadata);
    const paramtypes = this.contextUtils.reflectCallbackParamtypes(
      instance,
      methodName,
    );
    const contextFactory = this.contextUtils.getContextFactory(
      contextType,
      instance,
      instance[methodName],
    );
    const getParamsMetadata = (moduleKey: string) =>
      this.exchangeKeysForValues(
        keys,
        metadata,
        moduleKey,
        this.wsParamsFactory,
        contextFactory,
      );

    const handlerMetadata: WsHandlerMetadata = {
      argsLength,
      paramtypes,
      getParamsMetadata,
    };
    this.handlerMetadataStorage.set(instance, methodName, handlerMetadata);
    return handlerMetadata;
  }

  public exchangeKeysForValues<TMetadata = any>(
    keys: string[],
    metadata: TMetadata,
    moduleContext: string,
    paramsFactory: WsParamsFactory,
    contextFactory: (args: unknown[]) => ExecutionContextHost,
  ): ParamProperties[] {
    this.pipesContextCreator.setModuleContext(moduleContext);

    return keys.map(key => {
      const { index, data, pipes: pipesCollection } = metadata[key];
      const pipes =
        this.pipesContextCreator.createConcreteContext(pipesCollection);
      const type = this.contextUtils.mapParamType(key);

      if (key.includes(CUSTOM_ROUTE_ARGS_METADATA)) {
        const { factory } = metadata[key];
        const customExtractValue = this.contextUtils.getCustomFactory(
          factory,
          data,
          contextFactory,
        );
        return { index, extractValue: customExtractValue, type, data, pipes };
      }
      const numericType = Number(type);
      const extractValue = (...args: any[]) =>
        paramsFactory.exchangeKeyForValue(numericType, data, args);

      return { index, extractValue, type: numericType, data, pipes };
    });
  }

  public createPipesFn(
    pipes: PipeTransform[],
    paramsOptions: (ParamProperties & { metatype?: unknown })[],
  ) {
    const pipesFn = async (args: unknown[], ...params: unknown[]) => {
      const resolveParamValue = async (
        param: ParamProperties & { metatype?: unknown },
      ) => {
        const {
          index,
          extractValue,
          type,
          data,
          metatype,
          pipes: paramPipes,
        } = param;
        const value = extractValue(...params);

        args[index] = await this.getParamValue(
          value,
          { metatype, type, data },
          pipes.concat(paramPipes),
        );
      };
      await Promise.all(paramsOptions.map(resolveParamValue));
    };
    return paramsOptions.length ? pipesFn : null;
  }

  public async getParamValue<T>(
    value: T,
    { metatype, type, data }: { metatype: any; type: any; data: any },
    pipes: PipeTransform[],
  ): Promise<any> {
    return isEmpty(pipes)
      ? value
      : this.pipesConsumer.apply(value, { metatype, type, data }, pipes);
  }
}



================================================
FILE: packages/websockets/context/ws-metadata-constants.ts
================================================
import { WsParamtype } from '../enums/ws-paramtype.enum';

export const DEFAULT_CALLBACK_METADATA = {
  [`${WsParamtype.PAYLOAD}:1`]: { index: 1, data: undefined, pipes: [] },
  [`${WsParamtype.SOCKET}:0`]: { index: 0, data: undefined, pipes: [] },
};



================================================
FILE: packages/websockets/context/ws-proxy.ts
================================================
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { EMPTY, isObservable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { WsExceptionsHandler } from '../exceptions/ws-exceptions-handler';

export class WsProxy {
  public create(
    targetCallback: (...args: unknown[]) => Promise<any>,
    exceptionsHandler: WsExceptionsHandler,
    targetPattern?: string,
  ): (...args: unknown[]) => Promise<any> {
    return async (...args: unknown[]) => {
      args = [...args, targetPattern ?? 'unknown'];
      try {
        const result = await targetCallback(...args);
        return !isObservable(result)
          ? result
          : result.pipe(
              catchError(error => {
                this.handleError(exceptionsHandler, args, error);
                return EMPTY;
              }),
            );
      } catch (error) {
        this.handleError(exceptionsHandler, args, error);
      }
    };
  }

  handleError<T>(
    exceptionsHandler: WsExceptionsHandler,
    args: unknown[],
    error: T,
  ) {
    const host = new ExecutionContextHost(args);
    host.setType('ws');
    exceptionsHandler.handle(error as Error, host);
  }
}



================================================
FILE: packages/websockets/decorators/connected-socket.decorator.ts
================================================
import { WsParamtype } from '../enums/ws-paramtype.enum';
import { createWsParamDecorator } from '../utils/param.utils';

/**
 * @publicApi
 */
export const ConnectedSocket: () => ParameterDecorator = createWsParamDecorator(
  WsParamtype.SOCKET,
);



================================================
FILE: packages/websockets/decorators/gateway-server.decorator.ts
================================================
import { GATEWAY_SERVER_METADATA } from '../constants';

/**
 * Attaches native Web Socket Server to a given property.
 *
 * @publicApi
 */
export const WebSocketServer = (): PropertyDecorator => {
  return (target: object, propertyKey: string | symbol) => {
    Reflect.set(target, propertyKey, null);
    Reflect.defineMetadata(GATEWAY_SERVER_METADATA, true, target, propertyKey);
  };
};



================================================
FILE: packages/websockets/decorators/index.ts
================================================
export * from './connected-socket.decorator';
export * from './gateway-server.decorator';
export * from './message-body.decorator';
export * from './socket-gateway.decorator';
export * from './subscribe-message.decorator';



================================================
FILE: packages/websockets/decorators/message-body.decorator.ts
================================================
import { PipeTransform, Type } from '@nestjs/common';
import { WsParamtype } from '../enums/ws-paramtype.enum';
import { createPipesWsParamDecorator } from '../utils/param.utils';

/**
 * WebSockets message body parameter decorator.
 *
 * @publicApi
 */
export function MessageBody(): ParameterDecorator;
/**
 * WebSockets message body parameter decorator.
 *
 * Example:
 * ```typescript
 * create(@MessageBody(new ValidationPipe()) createDto: CreateCatDto)
 * ```
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @publicApi
 */
export function MessageBody(
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
/**
 * WebSockets message body parameter decorator. Extracts a property from the
 * message payload object. May also apply pipes to the bound parameter.
 *
 * For example, extracting all params:
 * ```typescript
 * findMany(@MessageBody() ids: string[])
 * ```
 *
 * For example, extracting a single param:
 * ```typescript
 * create(@MessageBody('data') createDto: { data: string })
 * ```
 *
 * For example, extracting a single param with pipe:
 * ```typescript
 * create(@MessageBody('data', new ValidationPipe()) createDto: { data: string })
 * ```
 * @param propertyKey name of single property to extract from the message payload
 * @param pipes one or more pipes - either instances or classes - to apply to
 * the bound parameter.
 *
 * @publicApi
 */
export function MessageBody(
  propertyKey: string,
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator;
export function MessageBody(
  propertyOrPipe?: string | (Type<PipeTransform> | PipeTransform),
  ...pipes: (Type<PipeTransform> | PipeTransform)[]
): ParameterDecorator {
  return createPipesWsParamDecorator(WsParamtype.PAYLOAD)(
    propertyOrPipe,
    ...pipes,
  );
}



================================================
FILE: packages/websockets/decorators/socket-gateway.decorator.ts
================================================
import { GATEWAY_METADATA, GATEWAY_OPTIONS, PORT_METADATA } from '../constants';
import { GatewayMetadata } from '../interfaces';

/**
 * Decorator that marks a class as a Nest gateway that enables real-time, bidirectional
 * and event-based communication between the browser and the server.
 *
 * @publicApi
 */
export function WebSocketGateway(port?: number): ClassDecorator;
export function WebSocketGateway<
  T extends Record<string, any> = GatewayMetadata,
>(options?: T): ClassDecorator;
export function WebSocketGateway<
  T extends Record<string, any> = GatewayMetadata,
>(port?: number, options?: T): ClassDecorator;
export function WebSocketGateway<
  T extends Record<string, any> = GatewayMetadata,
>(portOrOptions?: number | T, options?: T): ClassDecorator {
  const isPortInt = Number.isInteger(portOrOptions as number);
  // eslint-disable-next-line prefer-const
  let [port, opt] = isPortInt ? [portOrOptions, options] : [0, portOrOptions];

  opt = opt || ({} as T);
  return (target: object) => {
    Reflect.defineMetadata(GATEWAY_METADATA, true, target);
    Reflect.defineMetadata(PORT_METADATA, port, target);
    Reflect.defineMetadata(GATEWAY_OPTIONS, opt, target);
  };
}



================================================
FILE: packages/websockets/decorators/subscribe-message.decorator.ts
================================================
import { MESSAGE_MAPPING_METADATA, MESSAGE_METADATA } from '../constants';

/**
 * Subscribes to messages that fulfils chosen pattern.
 *
 * @publicApi
 */
export const SubscribeMessage = <T = string>(message: T): MethodDecorator => {
  return (
    target: object,
    key: string | symbol,
    descriptor: PropertyDescriptor,
  ) => {
    Reflect.defineMetadata(MESSAGE_MAPPING_METADATA, true, descriptor.value);
    Reflect.defineMetadata(MESSAGE_METADATA, message, descriptor.value);
    return descriptor;
  };
};



================================================
FILE: packages/websockets/enums/ws-paramtype.enum.ts
================================================
import { RouteParamtypes } from '@nestjs/common/enums/route-paramtypes.enum';

export enum WsParamtype {
  SOCKET = RouteParamtypes.REQUEST,
  PAYLOAD = RouteParamtypes.BODY,
}



================================================
FILE: packages/websockets/errors/index.ts
================================================
export * from './ws-exception';



================================================
FILE: packages/websockets/errors/invalid-socket-port.exception.ts
================================================
import { RuntimeException } from '@nestjs/core/errors/exceptions/runtime.exception';

export class InvalidSocketPortException extends RuntimeException {
  constructor(port: number | string, type: any) {
    super(`Invalid port (${port}) in gateway ${type}`);
  }
}



================================================
FILE: packages/websockets/errors/ws-exception.ts
================================================
import { isObject, isString } from '@nestjs/common/utils/shared.utils';

export class WsException extends Error {
  constructor(private readonly error: string | object) {
    super();
    this.initMessage();
  }

  public initMessage() {
    if (isString(this.error)) {
      this.message = this.error;
    } else if (
      isObject(this.error) &&
      isString((this.error as Record<string, any>).message)
    ) {
      this.message = (this.error as Record<string, any>).message;
    } else if (this.constructor) {
      this.message = this.constructor.name
        .match(/[A-Z][a-z]+|[0-9]+/g)!
        .join(' ');
    }
  }

  public getError(): string | object {
    return this.error;
  }
}



================================================
FILE: packages/websockets/exceptions/base-ws-exception-filter.ts
================================================
import {
  ArgumentsHost,
  IntrinsicException,
  Logger,
  WsExceptionFilter,
} from '@nestjs/common';
import { isObject } from '@nestjs/common/utils/shared.utils';
import { MESSAGES } from '@nestjs/core/constants';
import { WsException } from '../errors/ws-exception';

export interface ErrorPayload<Cause = { pattern: string; data: unknown }> {
  /**
   * Error message identifier.
   */
  status: 'error';
  /**
   * Error message.
   */
  message: string;
  /**
   * Message that caused the exception.
   */
  cause?: Cause;
}

interface BaseWsExceptionFilterOptions {
  /**
   * When true, the data that caused the exception will be included in the response.
   * This is useful when you want to provide additional context to the client, or
   * when you need to associate the error with a specific request.
   * @default true
   */
  includeCause?: boolean;

  /**
   * A factory function that can be used to control the shape of the "cause" object.
   * This is useful when you need a custom structure for the cause object.
   * @default (pattern, data) => ({ pattern, data })
   */
  causeFactory?: (pattern: string, data: unknown) => Record<string, any>;
}

/**
 * @publicApi
 */
export class BaseWsExceptionFilter<TError = any>
  implements WsExceptionFilter<TError>
{
  protected static readonly logger = new Logger('WsExceptionsHandler');

  constructor(protected readonly options: BaseWsExceptionFilterOptions = {}) {
    this.options.includeCause = this.options.includeCause ?? true;
    this.options.causeFactory =
      this.options.causeFactory ?? ((pattern, data) => ({ pattern, data }));
  }

  public catch(exception: TError, host: ArgumentsHost) {
    const client = host.switchToWs().getClient();
    const pattern = host.switchToWs().getPattern();
    const data = host.switchToWs().getData();
    this.handleError(client, exception, {
      pattern,
      data,
    });
  }

  public handleError<TClient extends { emit: Function }>(
    client: TClient,
    exception: TError,
    cause: ErrorPayload['cause'],
  ) {
    if (!(exception instanceof WsException)) {
      return this.handleUnknownError(exception, client, cause);
    }

    const status = 'error';
    const result = exception.getError();

    if (isObject(result)) {
      return client.emit('exception', result);
    }

    const payload: ErrorPayload<unknown> = {
      status,
      message: result,
    };

    if (this.options?.includeCause && cause) {
      payload.cause = this.options.causeFactory!(cause.pattern, cause.data);
    }

    client.emit('exception', payload);
  }

  public handleUnknownError<TClient extends { emit: Function }>(
    exception: TError,
    client: TClient,
    data: ErrorPayload['cause'],
  ) {
    const status = 'error';
    const payload: ErrorPayload<unknown> = {
      status,
      message: MESSAGES.UNKNOWN_EXCEPTION_MESSAGE,
    };

    if (this.options?.includeCause && data) {
      payload.cause = this.options.causeFactory!(data.pattern, data.data);
    }

    client.emit('exception', payload);

    if (!(exception instanceof IntrinsicException)) {
      const logger = BaseWsExceptionFilter.logger;
      logger.error(exception);
    }
  }

  public isExceptionObject(err: any): err is Error {
    return isObject(err) && !!(err as Error).message;
  }
}



================================================
FILE: packages/websockets/exceptions/index.ts
================================================
export * from './base-ws-exception-filter';



================================================
FILE: packages/websockets/exceptions/ws-exceptions-handler.ts
================================================
import { ArgumentsHost } from '@nestjs/common';
import { ExceptionFilterMetadata } from '@nestjs/common/interfaces/exceptions/exception-filter-metadata.interface';
import { selectExceptionFilterMetadata } from '@nestjs/common/utils/select-exception-filter-metadata.util';
import { isEmpty } from '@nestjs/common/utils/shared.utils';
import { InvalidExceptionFilterException } from '@nestjs/core/errors/exceptions/invalid-exception-filter.exception';
import { WsException } from '../errors/ws-exception';
import { BaseWsExceptionFilter } from './base-ws-exception-filter';

/**
 * @publicApi
 */
export class WsExceptionsHandler extends BaseWsExceptionFilter {
  private filters: ExceptionFilterMetadata[] = [];

  public handle(exception: Error | WsException, host: ArgumentsHost) {
    const client = host.switchToWs().getClient();
    if (this.invokeCustomFilters(exception, host) || !client.emit) {
      return;
    }
    super.catch(exception, host);
  }

  public setCustomFilters(filters: ExceptionFilterMetadata[]) {
    if (!Array.isArray(filters)) {
      throw new InvalidExceptionFilterException();
    }
    this.filters = filters;
  }

  public invokeCustomFilters<T = any>(
    exception: T,
    args: ArgumentsHost,
  ): boolean {
    if (isEmpty(this.filters)) return false;

    const filter = selectExceptionFilterMetadata(this.filters, exception);
    filter && filter.func(exception, args);
    return !!filter;
  }
}



================================================
FILE: packages/websockets/factories/server-and-event-streams-factory.ts
================================================
import { ReplaySubject, Subject } from 'rxjs';
import { ServerAndEventStreamsHost } from '../interfaces/server-and-event-streams-host.interface';

export class ServerAndEventStreamsFactory {
  public static create<T = any>(server: T): ServerAndEventStreamsHost<T> {
    const init = new ReplaySubject<T>();
    init.next(server);

    const connection = new Subject();
    const disconnect = new Subject();
    return {
      init,
      connection,
      disconnect,
      server,
    };
  }
}



================================================
FILE: packages/websockets/factories/ws-params-factory.ts
================================================
import { WsParamtype } from '../enums/ws-paramtype.enum';

export class WsParamsFactory {
  public exchangeKeyForValue(
    type: number,
    data: string | undefined,
    args: unknown[],
  ) {
    if (!args) {
      return null;
    }
    switch (type as WsParamtype) {
      case WsParamtype.SOCKET:
        return args[0];
      case WsParamtype.PAYLOAD:
        return data ? args[1]?.[data] : args[1];
      default:
        return null;
    }
  }
}



================================================
FILE: packages/websockets/interfaces/gateway-metadata.interface.ts
================================================
import { CorsOptions } from '@nestjs/common/interfaces/external/cors-options.interface';

/**
 * External interface
 * @see https://github.com/socketio/socket.io/blob/master/lib/index.ts
 * @publicApi
 */
export interface GatewayMetadata {
  /**
   * The name of a namespace
   */
  namespace?: string | RegExp;
  /**
   * Name of the path to capture
   * @default "/socket.io"
   */
  path?: string;
  /**
   * Whether to serve the client files
   * @default true
   */
  serveClient?: boolean;
  /**
   * The adapter to use
   * @default the in-memory adapter (https://github.com/socketio/socket.io-adapter)
   */
  adapter?: any;
  /**
   * The parser to use
   * @default the default parser (https://github.com/socketio/socket.io-parser)
   */
  parser?: any;
  /**
   * How many ms before a client without namespace is closed
   * @default 45_000
   */
  connectTimeout?: number;
  /**
   * How many ms without a pong packet to consider the connection closed
   * @default 20_000
   */
  pingTimeout?: number;
  /**
   * How many ms before sending a new ping packet
   * @default 25_000
   */
  pingInterval?: number;
  /**
   * How many ms before an uncompleted transport upgrade is cancelled
   * @default 10_000
   */
  upgradeTimeout?: number;
  /**
   * How many bytes or characters a message can be, before closing the session (to avoid DoS).
   * @default 1e6 (1 MB)
   */
  maxHttpBufferSize?: number;
  /**
   * A function that receives a given handshake or upgrade request as its first parameter,
   * and can decide whether to continue or not. The second argument is a function that needs
   * to be called with the decided information: fn(err, success), where success is a boolean
   * value where false means that the request is rejected, and err is an error code.
   */
  allowRequest?: (
    req: any,
    fn: (err: string | null | undefined, success: boolean) => void,
  ) => void;
  /**
   * The low-level transports that are enabled
   * @default ["polling", "websocket"]
   */
  transports?: Array<'polling' | 'websocket'>;
  /**
   * Whether to allow transport upgrades
   * @default true
   */
  allowUpgrades?: boolean;
  /**
   * Parameters of the WebSocket permessage-deflate extension (see ws module api docs). Set to false to disable.
   * @default false
   */
  perMessageDeflate?: boolean | object;
  /**
   * Parameters of the http compression for the polling transports (see zlib api docs). Set to false to disable.
   * @default true
   */
  httpCompression?: boolean | object;
  /**
   * What WebSocket server implementation to use. Specified module must
   * conform to the ws interface (see ws module api docs). Default value is ws.
   * An alternative c++ addon is also available by installing uws module.
   */
  wsEngine?: string;
  /**
   * An optional packet which will be concatenated to the handshake packet emitted by Engine.IO.
   */
  initialPacket?: any;
  /**
   * Configuration of the cookie that contains the client sid to send as part of handshake response headers. This cookie
   * might be used for sticky-session. Defaults to not sending any cookie.
   * @default false
   */
  cookie?: any;
  /**
   * The options that will be forwarded to the cors module
   */
  cors?: CorsOptions;
  /**
   * Whether to enable compatibility with Socket.IO v2 clients
   * @default false
   */
  allowEIO3?: boolean;
  /**
   * Destroy unhandled upgrade requests
   * @default true
   */
  destroyUpgrade?: boolean;
  /**
   * Milliseconds after which unhandled requests are ended
   * @default 1_000
   */
  destroyUpgradeTimeout?: number;
}



================================================
FILE: packages/websockets/interfaces/index.ts
================================================
export * from './gateway-metadata.interface';
export * from './hooks';
export * from './server-and-event-streams-host.interface';
export * from './web-socket-server.interface';
export * from './ws-response.interface';



================================================
FILE: packages/websockets/interfaces/nest-gateway.interface.ts
================================================
/**
 * @publicApi
 */
export interface NestGateway {
  afterInit?: (server: any) => void;
  handleConnection?: (...args: any[]) => void;
  handleDisconnect?: (client: any) => void;
}



================================================
FILE: packages/websockets/interfaces/server-and-event-streams-host.interface.ts
================================================
import { ReplaySubject, Subject } from 'rxjs';

/**
 * @publicApi
 */
export interface ServerAndEventStreamsHost<T = any> {
  server: T;
  init: ReplaySubject<T>;
  connection: Subject<any>;
  disconnect: Subject<any>;
}



================================================
FILE: packages/websockets/interfaces/web-socket-server.interface.ts
================================================
/**
 * @publicApi
 */
export interface WebSocketServerOptions {
  port: number;
  namespace: string;
}



================================================
FILE: packages/websockets/interfaces/websockets-entrypoint-metadata.interface.ts
================================================
export type WebsocketEntrypointMetadata = {
  port: number;
  message: unknown;
};



================================================
FILE: packages/websockets/interfaces/ws-response.interface.ts
================================================
/**
 * @publicApi
 */
export interface WsResponse<T = any> {
  event: string;
  data: T;
}



================================================
FILE: packages/websockets/interfaces/hooks/index.ts
================================================
export * from './on-gateway-connection.interface';
export * from './on-gateway-disconnect.interface';
export * from './on-gateway-init.interface';



================================================
FILE: packages/websockets/interfaces/hooks/on-gateway-connection.interface.ts
================================================
/**
 * @publicApi
 */
export interface OnGatewayConnection<T = any> {
  handleConnection(client: T, ...args: any[]): any;
}



================================================
FILE: packages/websockets/interfaces/hooks/on-gateway-disconnect.interface.ts
================================================
/**
 * @publicApi
 */
export interface OnGatewayDisconnect<T = any> {
  handleDisconnect(client: T): any;
}



================================================
FILE: packages/websockets/interfaces/hooks/on-gateway-init.interface.ts
================================================
/**
 * @publicApi
 */
export interface OnGatewayInit<T = any> {
  afterInit(server: T): any;
}



================================================
FILE: packages/websockets/test/container.spec.ts
================================================
import { expect } from 'chai';
import * as hash from 'object-hash';
import * as sinon from 'sinon';
import { SocketsContainer } from '../sockets-container';

describe('SocketsContainer', () => {
  const port = 30;

  let instance: SocketsContainer;
  let getSpy: sinon.SinonSpy, setSpy: sinon.SinonSpy;

  beforeEach(() => {
    setSpy = sinon.spy();
    getSpy = sinon.spy();
    instance = new SocketsContainer();
    (instance as any).serverAndEventStreamsHosts = {
      get: getSpy,
      set: setSpy,
    };
  });
  describe('getSocketEventsHostByPort', () => {
    it(`should call "serverAndEventStreamsHosts" get method with expected arguments`, () => {
      const config = { port, path: 'random' };
      instance.getOneByConfig(config);

      const token = hash(config);
      expect(getSpy.calledWith(token)).to.be.true;
    });
  });
  describe('addOne', () => {
    it(`should call "serverAndEventStreamsHosts" set method with expected arguments`, () => {
      const server = {};
      const config = { port, path: 'random' };

      instance.addOne(config, server as any);

      const token = hash(config);
      expect(setSpy.calledWith(token, server)).to.be.true;
    });
  });
  describe('getAll', () => {
    it('should return "serverAndEventStreamsHosts"', () => {
      const collection = ['test'];
      (instance as any).serverAndEventStreamsHosts = collection;
      expect(instance.getAll()).to.be.eq(collection);
    });
  });
  describe('clear', () => {
    it('should clear hosts collection', () => {
      const collection = { clear: sinon.spy() };
      (instance as any).serverAndEventStreamsHosts = collection;
      instance.clear();
      expect(collection.clear.called).to.be.true;
    });
  });
});



================================================
FILE: packages/websockets/test/gateway-metadata-explorer.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { MetadataScanner } from '../../core/metadata-scanner';
import { WebSocketServer } from '../decorators/gateway-server.decorator';
import { WebSocketGateway } from '../decorators/socket-gateway.decorator';
import { SubscribeMessage } from '../decorators/subscribe-message.decorator';
import { GatewayMetadataExplorer } from '../gateway-metadata-explorer';

describe('GatewayMetadataExplorer', () => {
  const message = 'test';
  const secMessage = 'test2';

  @WebSocketGateway()
  class Test {
    @WebSocketServer() public server;
    @WebSocketServer() public anotherServer;

    get testGet() {
      return 0;
    }
    set testSet(val) {}

    constructor() {}

    @SubscribeMessage(message)
    public test() {}

    @SubscribeMessage(secMessage)
    public testSec() {}

    public noMessage() {}
  }
  let instance: GatewayMetadataExplorer;
  let scanner: MetadataScanner;

  beforeEach(() => {
    scanner = new MetadataScanner();
    instance = new GatewayMetadataExplorer(scanner);
  });
  describe('explore', () => {
    let getAllMethodNames: sinon.SinonSpy;
    beforeEach(() => {
      getAllMethodNames = sinon.spy(scanner, 'getAllMethodNames');
    });
    it(`should call "scanFromPrototype" with expected arguments`, () => {
      const obj = new Test();
      instance.explore(obj as any);

      const [argProto] = getAllMethodNames.getCall(0).args;
      expect(argProto).to.be.eql(Object.getPrototypeOf(obj));
    });
  });
  describe('exploreMethodMetadata', () => {
    let test: Test;
    beforeEach(() => {
      test = new Test();
    });
    it(`should return null when "isMessageMapping" metadata is undefined`, () => {
      const metadata = instance.exploreMethodMetadata(test, 'noMessage');
      expect(metadata).to.eq(null);
    });
    it(`should return message mapping properties when "isMessageMapping" metadata is not undefined`, () => {
      const metadata = instance.exploreMethodMetadata(test, 'test')!;
      expect(metadata).to.have.keys(['callback', 'message', 'methodName']);
      expect(metadata.message).to.eql(message);
    });
  });
  describe('scanForServerHooks', () => {
    it(`should return properties with @Client decorator`, () => {
      const obj = new Test();
      const servers = [...instance.scanForServerHooks(obj as any)];

      expect(servers).to.have.length(2);
      expect(servers).to.deep.eq(['server', 'anotherServer']);
    });
  });
});



================================================
FILE: packages/websockets/test/socket-server-provider.spec.ts
================================================
import { ApplicationConfig } from '@nestjs/core/application-config';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { AbstractWsAdapter } from '../adapters/ws-adapter';
import { SocketServerProvider } from '../socket-server-provider';
import { SocketsContainer } from '../sockets-container';

class NoopAdapter extends AbstractWsAdapter {
  public create(port: number, options?: any) {}
  public bindMessageHandlers(client: any, handlers) {}
}

describe('SocketServerProvider', () => {
  let instance: SocketServerProvider;
  let socketsContainer: SocketsContainer, mockContainer: sinon.SinonMock;

  beforeEach(() => {
    socketsContainer = new SocketsContainer();
    mockContainer = sinon.mock(socketsContainer);
    instance = new SocketServerProvider(
      socketsContainer,
      new ApplicationConfig(new NoopAdapter()),
    );
  });
  describe('scanForSocketServer', () => {
    let createSocketServerSpy: sinon.SinonSpy;
    const path = 'localhost:3030';
    const port = 30;

    beforeEach(() => {
      createSocketServerSpy = sinon.spy(instance, 'createSocketServer' as any);
    });

    afterEach(() => {
      mockContainer.restore();
    });
    it(`should return stored server`, () => {
      const server = { test: 'test' };
      mockContainer.expects('getOneByConfig').returns(server);

      const result = instance.scanForSocketServer({ namespace: null! }, port);

      expect(createSocketServerSpy.called).to.be.false;
      expect(result).to.eq(server);
    });

    it(`should call "createSocketServer" when server is not stored already`, () => {
      mockContainer.expects('getOneByConfig').returns(null);

      instance.scanForSocketServer({ path }, port);
      expect(createSocketServerSpy.called).to.be.true;
    });

    it(`should call "decorateWithNamespace" when namespace is specified`, () => {
      const decorateWithNamespaceSpy = sinon.spy(
        instance,
        'decorateWithNamespace' as any,
      );

      instance.scanForSocketServer({ path, namespace: 'random' }, port);
      expect(decorateWithNamespaceSpy.called).to.be.true;
    });

    describe('when namespace is specified and server does exist already', () => {
      it(`should call "decorateWithNamespace" and not call "createSocketServer"`, () => {
        const server = { test: 'test' };
        mockContainer.expects('getOneByConfig').returns(server);

        const decorateWithNamespaceSpy = sinon.spy(
          instance,
          'decorateWithNamespace' as any,
        );

        instance.scanForSocketServer({ path, namespace: 'random' }, port);
        expect(decorateWithNamespaceSpy.called).to.be.true;
        expect(createSocketServerSpy.called).to.be.false;
      });
    });
  });
});



================================================
FILE: packages/websockets/test/tsconfig.json
================================================
{
  "extends": "../../../tsconfig.spec.json"
}



================================================
FILE: packages/websockets/test/web-sockets-controller.spec.ts
================================================
import { NestContainer } from '@nestjs/core';
import { ApplicationConfig } from '@nestjs/core/application-config';
import { expect } from 'chai';
import { fromEvent, lastValueFrom, Observable, of } from 'rxjs';
import * as sinon from 'sinon';
import { GraphInspector } from '../../core/inspector/graph-inspector';
import { MetadataScanner } from '../../core/metadata-scanner';
import { AbstractWsAdapter } from '../adapters/ws-adapter';
import { PORT_METADATA } from '../constants';
import { WsContextCreator } from '../context/ws-context-creator';
import { WebSocketGateway } from '../decorators/socket-gateway.decorator';
import { InvalidSocketPortException } from '../errors/invalid-socket-port.exception';
import {
  GatewayMetadataExplorer,
  MessageMappingProperties,
} from '../gateway-metadata-explorer';
import { SocketServerProvider } from '../socket-server-provider';
import { WebSocketsController } from '../web-sockets-controller';

class NoopAdapter extends AbstractWsAdapter {
  public create(port: number, options?: any) {}
  public bindMessageHandlers(
    client: any,
    handlers,
    transform: (data: any) => Observable<any>,
  ) {
    handlers.forEach(({ message, callback }) => {
      const source$ = fromEvent(client, message);
      source$.subscribe(data => null);
    });
  }
}

describe('WebSocketsController', () => {
  let instance: WebSocketsController;
  let untypedInstance: any;
  let provider: SocketServerProvider,
    graphInspector: GraphInspector,
    config: ApplicationConfig,
    mockProvider: sinon.SinonMock;

  const messageHandlerCallback = () => Promise.resolve();
  const port = 90,
    namespace = '/';
  @WebSocketGateway(port, { namespace })
  class Test {}

  beforeEach(() => {
    config = new ApplicationConfig(new NoopAdapter());
    provider = new SocketServerProvider(null!, config);
    graphInspector = new GraphInspector(new NestContainer());
    mockProvider = sinon.mock(provider);

    const contextCreator = sinon.createStubInstance(WsContextCreator);
    contextCreator.create.returns(messageHandlerCallback);
    instance = new WebSocketsController(
      provider,
      config,
      contextCreator as any,
      graphInspector,
    );
    untypedInstance = instance as any;
  });
  describe('connectGatewayToServer', () => {
    let subscribeToServerEvents: sinon.SinonSpy;

    @WebSocketGateway('test' as any)
    class InvalidGateway {}

    @WebSocketGateway()
    class DefaultGateway {}

    beforeEach(() => {
      subscribeToServerEvents = sinon.spy();
      untypedInstance.subscribeToServerEvents = subscribeToServerEvents;
    });
    it('should throw "InvalidSocketPortException" when port is not a number', () => {
      Reflect.defineMetadata(PORT_METADATA, 'test', InvalidGateway);
      expect(() =>
        instance.connectGatewayToServer(
          new InvalidGateway(),
          InvalidGateway,
          'moduleKey',
          'instanceWrapperId',
        ),
      ).throws(InvalidSocketPortException);
    });
    it('should call "subscribeToServerEvents" with default values when metadata is empty', () => {
      const gateway = new DefaultGateway();
      instance.connectGatewayToServer(
        gateway,
        DefaultGateway,
        'moduleKey',
        'instanceWrapperId',
      );
      expect(subscribeToServerEvents.calledWith(gateway, {}, 0, 'moduleKey')).to
        .be.true;
    });
    it('should call "subscribeToServerEvents" when metadata is valid', () => {
      const gateway = new Test();
      instance.connectGatewayToServer(
        gateway,
        Test,
        'moduleKey',
        'instanceWrapperId',
      );
      expect(
        subscribeToServerEvents.calledWith(
          gateway,
          { namespace },
          port,
          'moduleKey',
        ),
      ).to.be.true;
    });
  });
  describe('subscribeToServerEvents', () => {
    let explorer: GatewayMetadataExplorer,
      mockExplorer: sinon.SinonMock,
      gateway,
      handlers,
      server,
      assignServerToProperties: sinon.SinonSpy,
      subscribeEvents: sinon.SinonSpy;
    const handlerCallback = () => {};

    beforeEach(() => {
      gateway = new Test();
      explorer = new GatewayMetadataExplorer(new MetadataScanner());
      mockExplorer = sinon.mock(explorer);
      untypedInstance.metadataExplorer = explorer;

      handlers = [
        {
          message: 'message',
          methodName: 'methodName',
          callback: handlerCallback,
        },
      ];
      server = { server: 'test' };

      mockExplorer.expects('explore').returns(handlers);
      mockProvider.expects('scanForSocketServer').returns(server);

      assignServerToProperties = sinon.spy();
      subscribeEvents = sinon.spy();
      instance['assignServerToProperties'] = assignServerToProperties;
      instance['subscribeEvents'] = subscribeEvents;
    });
    it('should call "assignServerToProperties" with expected arguments', () => {
      instance.subscribeToServerEvents(
        gateway,
        { namespace },
        port,
        'moduleKey',
        'instanceWrapperId',
      );
      expect(assignServerToProperties.calledWith(gateway, server.server)).to.be
        .true;
    });
    it('should call "subscribeEvents" with expected arguments', () => {
      instance.subscribeToServerEvents(
        gateway,
        { namespace },
        port,
        'moduleKey',
        'instanceWrapperId',
      );
      expect(subscribeEvents.firstCall.args[0]).to.be.equal(gateway);
      expect(subscribeEvents.firstCall.args[2]).to.be.equal(server);
      expect(subscribeEvents.firstCall.args[1]).to.be.eql([
        {
          message: 'message',
          methodName: 'methodName',
          callback: messageHandlerCallback,
        },
      ]);
    });
  });
  describe('inspectEntrypointDefinitions', () => {
    it('should inspect & insert corresponding entrypoint definitions', () => {
      class GatewayHostCls {}

      const port = 80;
      const instanceWrapperId = '1234';
      const messageHandlers: MessageMappingProperties[] = [
        {
          methodName: 'findOne',
          message: 'find',
          callback: null!,
        },
        {
          methodName: 'create',
          message: 'insert',
          callback: null!,
        },
      ];
      const insertEntrypointDefinitionSpy = sinon.spy(
        graphInspector,
        'insertEntrypointDefinition',
      );
      instance.inspectEntrypointDefinitions(
        new GatewayHostCls(),
        port,
        messageHandlers,
        instanceWrapperId,
      );

      expect(insertEntrypointDefinitionSpy.calledTwice).to.be.true;
      expect(
        insertEntrypointDefinitionSpy.calledWith({
          type: 'websocket',
          methodName: messageHandlers[0].methodName,
          className: GatewayHostCls.name,
          classNodeId: instanceWrapperId,
          metadata: {
            port,
            key: messageHandlers[0].message,
            message: messageHandlers[0].message,
          } as any,
        }),
      ).to.be.true;
      expect(
        insertEntrypointDefinitionSpy.calledWith({
          type: 'websocket',
          methodName: messageHandlers[1].methodName,
          className: GatewayHostCls.name,
          classNodeId: instanceWrapperId,
          metadata: {
            port,
            key: messageHandlers[1].message,
            message: messageHandlers[1].message,
          } as any,
        }),
      ).to.be.true;
    });
  });
  describe('subscribeEvents', () => {
    const gateway = new Test();

    let handlers: any;
    let server: any,
      subscribeConnectionEvent: sinon.SinonSpy,
      subscribeDisconnectEvent: sinon.SinonSpy,
      nextSpy: sinon.SinonSpy,
      onSpy: sinon.SinonSpy,
      subscribeInitEvent: sinon.SinonSpy,
      getConnectionHandler: sinon.SinonSpy;

    beforeEach(() => {
      nextSpy = sinon.spy();
      onSpy = sinon.spy();
      subscribeInitEvent = sinon.spy();
      getConnectionHandler = sinon.spy();
      subscribeConnectionEvent = sinon.spy();
      subscribeDisconnectEvent = sinon.spy();

      handlers = ['test'];
      server = {
        server: {
          on: onSpy,
        },
        init: {
          next: nextSpy,
        },
        disconnect: {},
        connection: {},
      };
      untypedInstance.subscribeInitEvent = subscribeInitEvent;
      untypedInstance.getConnectionHandler = getConnectionHandler;
      untypedInstance.subscribeConnectionEvent = subscribeConnectionEvent;
      untypedInstance.subscribeDisconnectEvent = subscribeDisconnectEvent;
    });

    it('should call "subscribeConnectionEvent" with expected arguments', () => {
      instance.subscribeEvents(gateway, handlers, server);
      expect(subscribeConnectionEvent.calledWith(gateway, server.connection)).to
        .be.true;
    });
    it('should call "subscribeDisconnectEvent" with expected arguments', () => {
      instance.subscribeEvents(gateway, handlers, server);
      expect(subscribeDisconnectEvent.calledWith(gateway, server.disconnect)).to
        .be.true;
    });
    it('should call "subscribeInitEvent" with expected arguments', () => {
      instance.subscribeEvents(gateway, handlers, server);
      expect(subscribeInitEvent.calledWith(gateway, server.init)).to.be.true;
    });
    it('should bind connection handler to server', () => {
      instance.subscribeEvents(gateway, handlers, server);
      expect(onSpy.calledWith('connection', getConnectionHandler())).to.be.true;
    });
    it('should call "getConnectionHandler" with expected arguments', () => {
      instance.subscribeEvents(gateway, handlers, server);
      expect(
        getConnectionHandler.calledWith(
          instance,
          gateway,
          handlers,
          server.disconnect,
          server.connection,
        ),
      ).to.be.true;
    });
  });
  describe('getConnectionHandler', () => {
    const gateway = new Test();

    let handlers, fn;
    let connection,
      client,
      nextSpy: sinon.SinonSpy,
      onSpy: sinon.SinonSpy,
      subscribeMessages: sinon.SinonSpy,
      subscribeDisconnectEvent: sinon.SinonSpy,
      subscribeConnectionEvent: sinon.SinonSpy;

    beforeEach(() => {
      nextSpy = sinon.spy();
      onSpy = sinon.spy();
      subscribeMessages = sinon.spy();
      subscribeDisconnectEvent = sinon.spy();
      subscribeConnectionEvent = sinon.spy();

      handlers = ['test'];
      connection = {
        next: nextSpy,
      };
      client = {
        on: onSpy,
      };
      untypedInstance.subscribeDisconnectEvent = subscribeDisconnectEvent;
      untypedInstance.subscribeConnectionEvent = subscribeConnectionEvent;
      untypedInstance.subscribeMessages = subscribeMessages;

      fn = instance.getConnectionHandler(
        instance,
        gateway,
        handlers,
        null!,
        connection,
      );
      fn(client);
    });

    it('should return function', () => {
      expect(
        instance.getConnectionHandler(null!, null!, null!, null!, null!),
      ).to.be.a('function');
    });
    it('should call "next" method of connection object with expected argument', () => {
      expect(nextSpy.calledWith([client])).to.be.true;
    });
    it('should call "subscribeMessages" with expected arguments', () => {
      expect(subscribeMessages.calledWith(handlers, client, gateway)).to.be
        .true;
    });
    it('should call "on" method of client object with expected arguments', () => {
      expect(onSpy.called).to.be.true;
    });
  });
  describe('subscribeInitEvent', () => {
    const gateway = new Test();
    let event: any, subscribe: sinon.SinonSpy;

    beforeEach(() => {
      subscribe = sinon.spy();
      event = { subscribe, pipe: sinon.stub().returnsThis() };
    });
    it('should not call subscribe method when "afterInit" method not exists', () => {
      instance.subscribeInitEvent(gateway, event);
      expect(subscribe.called).to.be.false;
    });
    it('should call subscribe method of event object with expected arguments when "afterInit" exists', () => {
      (gateway as any).afterInit = () => {};
      instance.subscribeInitEvent(gateway, event);
      expect(subscribe.called).to.be.true;
    });
  });
  describe('subscribeConnectionEvent', () => {
    const gateway = new Test();
    let event, subscribe: sinon.SinonSpy;

    beforeEach(() => {
      subscribe = sinon.spy();
      event = { subscribe, pipe: sinon.stub().returnsThis() };
    });
    it('should not call subscribe method when "handleConnection" method not exists', () => {
      instance.subscribeConnectionEvent(gateway, event);
      expect(subscribe.called).to.be.false;
    });
    it('should call subscribe method of event object with expected arguments when "handleConnection" exists', () => {
      (gateway as any).handleConnection = () => {};
      instance.subscribeConnectionEvent(gateway, event);
      expect(subscribe.called).to.be.true;
    });
  });
  describe('subscribeDisconnectEvent', () => {
    const gateway = new Test();
    let event, subscribe: sinon.SinonSpy;

    beforeEach(() => {
      subscribe = sinon.spy();
      event = { subscribe, pipe: sinon.stub().returnsThis() };
    });
    it('should not call subscribe method when "handleDisconnect" method not exists', () => {
      instance.subscribeDisconnectEvent(gateway, event);
      expect(subscribe.called).to.be.false;
    });
    it('should call subscribe method of event object with expected arguments when "handleDisconnect" exists', () => {
      (gateway as any).handleDisconnect = () => {};
      instance.subscribeDisconnectEvent(gateway, event);
      expect(subscribe.called).to.be.true;
    });
  });
  describe('subscribeMessages', () => {
    const gateway = new Test();

    let client, handlers, onSpy: sinon.SinonSpy;

    beforeEach(() => {
      onSpy = sinon.spy();
      client = { on: onSpy, off: onSpy };

      handlers = [
        { message: 'test', callback: { bind: () => 'testCallback' } },
        { message: 'test2', callback: { bind: () => 'testCallback2' } },
      ];
    });
    it('should bind each handler to client', () => {
      instance.subscribeMessages(handlers, client, gateway);
      expect(onSpy.calledTwice).to.be.true;
    });
  });
  describe('pickResult', () => {
    describe('when deferredResult contains value which', () => {
      describe('is a Promise', () => {
        it('should return Promise<Observable>', async () => {
          const value = 100;
          expect(
            await lastValueFrom(
              await instance.pickResult(
                Promise.resolve(Promise.resolve(value)),
              ),
            ),
          ).to.be.eq(value);
        });
      });

      describe('is an Observable', () => {
        it('should return Promise<Observable>', async () => {
          const value = 100;
          expect(
            await lastValueFrom(
              await instance.pickResult(Promise.resolve(of(value))),
            ),
          ).to.be.eq(value);
        });
      });

      describe('is an object that has the method `subscribe`', () => {
        it('should return Promise<Observable>', async () => {
          const value = { subscribe() {} };
          expect(
            await lastValueFrom(
              await instance.pickResult(Promise.resolve(value)),
            ),
          ).to.equal(value);
        });
      });

      describe('is an ordinary value', () => {
        it('should return Promise<Observable>', async () => {
          const value = 100;
          expect(
            await lastValueFrom(
              await instance.pickResult(Promise.resolve(value)),
            ),
          ).to.be.eq(value);
        });
      });
    });
  });
});



================================================
FILE: packages/websockets/test/context/exception-filters.context.spec.ts
================================================
import { expect } from 'chai';
import * as sinon from 'sinon';
import { Catch } from '../../../common/decorators/core/catch.decorator';
import { UseFilters } from '../../../common/decorators/core/exception-filters.decorator';
import { NestContainer } from '../../../core/injector/container';
import { ExceptionFiltersContext } from '../../context/exception-filters-context';

describe('ExceptionFiltersContext', () => {
  let exceptionFilter: ExceptionFiltersContext;

  class CustomException {}
  @Catch(CustomException)
  class ExceptionFilter {
    public catch(exc, res) {}
  }

  beforeEach(() => {
    exceptionFilter = new ExceptionFiltersContext(new NestContainer() as any);
  });
  describe('create', () => {
    describe('when filters metadata is empty', () => {
      class EmptyMetadata {}
      beforeEach(() => {
        sinon.stub(exceptionFilter, 'createContext').returns([]);
      });
      it('should return plain ExceptionHandler object', () => {
        const filter = exceptionFilter.create(
          new EmptyMetadata(),
          () => ({}) as any,
          '',
        );
        expect((filter as any).filters).to.be.empty;
      });
    });
    describe('when filters metadata is not empty', () => {
      @UseFilters(new ExceptionFilter())
      class WithMetadata {}

      it('should return ExceptionHandler object with exception filters', () => {
        const filter = exceptionFilter.create(
          new WithMetadata(),
          () => ({}) as any,
          '',
        );
        expect((filter as any).filters).to.not.be.empty;
      });
    });
  });
});



================================================
FILE: packages/websockets/test/context/ws-context-creator.spec.ts
================================================
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import { of } from 'rxjs';
import * as sinon from 'sinon';
import { Injectable, UseGuards, UsePipes } from '../../../common';
import { CUSTOM_ROUTE_ARGS_METADATA } from '../../../common/constants';
import { GuardsConsumer } from '../../../core/guards/guards-consumer';
import { GuardsContextCreator } from '../../../core/guards/guards-context-creator';
import { NestContainer } from '../../../core/injector/container';
import { InterceptorsConsumer } from '../../../core/interceptors/interceptors-consumer';
import { InterceptorsContextCreator } from '../../../core/interceptors/interceptors-context-creator';
import { PipesConsumer } from '../../../core/pipes/pipes-consumer';
import { PipesContextCreator } from '../../../core/pipes/pipes-context-creator';
import { ExceptionFiltersContext } from '../../context/exception-filters-context';
import { WsContextCreator } from '../../context/ws-context-creator';
import { WsProxy } from '../../context/ws-proxy';
import { WsParamtype } from '../../enums/ws-paramtype.enum';
import { WsParamsFactory } from '../../factories/ws-params-factory';
import { WsException } from '../../index';

@Injectable()
class TestGuard {
  canActivate: () => true;
}

@Injectable()
class TestPipe {
  transform(val) {
    return val;
  }
}

describe('WsContextCreator', () => {
  let contextCreator: WsContextCreator;
  let wsProxy: WsProxy;
  let exceptionFiltersContext: ExceptionFiltersContext;
  let pipesCreator: PipesContextCreator;
  let pipesConsumer: PipesConsumer;
  let guardsContextCreator: GuardsContextCreator;
  let guardsConsumer: GuardsConsumer;
  let instance: Test;
  let module: string;

  @UseGuards(TestGuard)
  @Injectable()
  class Test {
    @UsePipes(new TestPipe())
    test(client: string, data: number) {
      return of(false);
    }
  }

  beforeEach(() => {
    wsProxy = new WsProxy();
    sinon.stub(wsProxy, 'create').callsFake(a => a);

    exceptionFiltersContext = new ExceptionFiltersContext(
      new NestContainer() as any,
    );
    pipesCreator = new PipesContextCreator(new NestContainer() as any);
    pipesConsumer = new PipesConsumer();
    guardsContextCreator = new GuardsContextCreator(new NestContainer());
    guardsConsumer = new GuardsConsumer();
    contextCreator = new WsContextCreator(
      wsProxy,
      exceptionFiltersContext,
      pipesCreator as any,
      pipesConsumer as any,
      guardsContextCreator as any,
      guardsConsumer as any,
      new InterceptorsContextCreator(new NestContainer()) as any,
      new InterceptorsConsumer() as any,
    );

    instance = new Test();
    module = 'test';
  });
  describe('create', () => {
    it('should create exception handler', () => {
      const handlerCreateSpy = sinon.spy(exceptionFiltersContext, 'create');
      contextCreator.create(instance, instance.test, module, 'create');
      expect(
        handlerCreateSpy.calledWith(instance, instance.test as any, module),
      ).to.be.true;
    });
    it('should create pipes context', () => {
      const pipesCreateSpy = sinon.spy(pipesCreator, 'create');
      contextCreator.create(instance, instance.test, module, 'create');
      expect(pipesCreateSpy.calledWith(instance, instance.test, module)).to.be
        .true;
    });
    it('should create guards context', () => {
      const guardsCreateSpy = sinon.spy(guardsContextCreator, 'create');
      contextCreator.create(instance, instance.test, module, 'create');
      expect(guardsCreateSpy.calledWith(instance, instance.test, module)).to.be
        .true;
    });
    describe('when proxy called', () => {
      it('should call guards consumer `tryActivate`', async () => {
        const tryActivateSpy = sinon.spy(guardsConsumer, 'tryActivate');
        sinon
          .stub(guardsContextCreator, 'create')
          .callsFake(() => [{ canActivate: () => true }]);
        const proxy = contextCreator.create(
          instance,
          instance.test,
          module,
          'test',
        );
        const data = 'test';
        await proxy(null, data);

        expect(tryActivateSpy.called).to.be.true;
      });
      describe('when can not activate', () => {
        it('should throw forbidden exception', () => {
          sinon
            .stub(guardsConsumer, 'tryActivate')
            .callsFake(async () => false);
          const proxy = contextCreator.create(
            instance,
            instance.test,
            module,
            'test',
          );
          const data = 'test';
          proxy(null, data).catch(err =>
            expect(err).to.be.instanceOf(WsException),
          );
        });
      });
    });
  });

  describe('reflectCallbackParamtypes', () => {
    it('should return paramtypes array', () => {
      const paramtypes = contextCreator.reflectCallbackParamtypes(
        instance,
        instance.test,
      );
      expect(paramtypes).to.be.eql([String, Number]);
    });
  });

  describe('createGuardsFn', () => {
    it('should throw exception when "tryActivate" returns false', () => {
      const guardsFn = contextCreator.createGuardsFn([null], null!, null!)!;
      sinon.stub(guardsConsumer, 'tryActivate').callsFake(async () => false);
      guardsFn([]).catch(err => expect(err).to.not.be.undefined);
    });
  });

  describe('exchangeKeysForValues', () => {
    it('should exchange arguments keys for appropriate values', () => {
      const metadata = {
        [WsParamtype.SOCKET]: { index: 0, data: 'test', pipes: [] },
        [WsParamtype.PAYLOAD]: { index: 2, data: 'test', pipes: [] },
        [`key${CUSTOM_ROUTE_ARGS_METADATA}`]: {
          index: 3,
          data: 'custom',
          pipes: [],
        },
      };
      const keys = Object.keys(metadata);
      const values = contextCreator.exchangeKeysForValues(
        keys,
        metadata,
        '',
        new WsParamsFactory(),
        (args: unknown[]) => new ExecutionContextHost(args),
      );
      const expectedValues = [
        { index: 0, type: WsParamtype.SOCKET, data: 'test' },
        { index: 2, type: WsParamtype.PAYLOAD, data: 'test' },
        { index: 3, type: `key${CUSTOM_ROUTE_ARGS_METADATA}`, data: 'custom' },
      ];
      expect(values[0]).to.deep.include(expectedValues[0]);
      expect(values[1]).to.deep.include(expectedValues[1]);
    });
  });
  describe('getParamValue', () => {
    let consumerApplySpy: sinon.SinonSpy;
    const value = 3,
      metatype = null,
      transforms = [{ transform: sinon.spy() }];

    beforeEach(() => {
      consumerApplySpy = sinon.spy(pipesConsumer, 'apply');
    });
    it('should call "consumer.apply"', async () => {
      await contextCreator.getParamValue(
        value,
        { metatype, type: WsParamtype.PAYLOAD, data: null },
        transforms,
      );
      expect(consumerApplySpy.called).to.be.true;
    });
  });
  describe('createPipesFn', () => {
    describe('when "paramsOptions" is empty', () => {
      it('returns null', async () => {
        const pipesFn = contextCreator.createPipesFn([], []);
        expect(pipesFn).to.be.null;
      });
    });
    describe('when "paramsOptions" is not empty', () => {
      it('returns function', async () => {
        const pipesFn = contextCreator.createPipesFn(
          [],
          [
            {
              index: 1,
              type: 'test',
              data: null!,
              pipes: [],
              extractValue: () => null,
            },
          ],
        )!;
        await pipesFn([]);
        expect(pipesFn).to.be.a('function');
      });
    });
  });
});



================================================
FILE: packages/websockets/test/context/ws-proxy.spec.ts
================================================
import { expect } from 'chai';
import { throwError } from 'rxjs';
import * as sinon from 'sinon';
import { WsProxy } from '../../context/ws-proxy';
import { WsException } from '../../errors/ws-exception';
import { WsExceptionsHandler } from '../../exceptions/ws-exceptions-handler';

describe('WsProxy', () => {
  let routerProxy: WsProxy;
  let handlerMock: sinon.SinonMock;
  let handler: WsExceptionsHandler;

  beforeEach(() => {
    handler = new WsExceptionsHandler();
    handlerMock = sinon.mock(handler);
    routerProxy = new WsProxy();
  });

  describe('create', () => {
    it('should method return thunk', () => {
      const proxy = routerProxy.create(async (client, data) => {}, handler);
      expect(typeof proxy === 'function').to.be.true;
    });

    it('should method encapsulate callback passed as argument', async () => {
      const expectation = handlerMock.expects('handle').once();
      const proxy = routerProxy.create(async (client, data) => {
        throw new WsException('test');
      }, handler);
      await proxy(null, null);
      expectation.verify();
    });

    it('should attach "catchError" operator when observable was returned', async () => {
      const expectation = handlerMock.expects('handle').once();
      const proxy = routerProxy.create(async (client, data) => {
        return throwError(() => new WsException('test'));
      }, handler);
      (await proxy(null, null)).subscribe(null, () => expectation.verify());
    });
  });
});



================================================
FILE: packages/websockets/test/decorators/connected-socket.decorator.spec.ts
================================================
import { expect } from 'chai';
import { PARAM_ARGS_METADATA } from '../../constants';
import { ConnectedSocket } from '../../decorators';
import { WsParamtype } from '../../enums/ws-paramtype.enum';

class ConnectedSocketTest {
  public test(@ConnectedSocket() socket: any) {}
}

describe('@ConnectedSocket', () => {
  it('should enhance class with expected request metadata', () => {
    const argsMetadata = Reflect.getMetadata(
      PARAM_ARGS_METADATA,
      ConnectedSocketTest,
      'test',
    );
    const expectedMetadata = {
      [`${WsParamtype.SOCKET}:0`]: {
        data: undefined,
        index: 0,
        pipes: [],
      },
    };
    expect(argsMetadata).to.be.eql(expectedMetadata);
  });
});



================================================
FILE: packages/websockets/test/decorators/message-body.decorator.spec.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { expect } from 'chai';
import { PARAM_ARGS_METADATA } from '../../constants';
import { MessageBody } from '../../decorators';
import { WsParamtype } from '../../enums/ws-paramtype.enum';

class MessagePayloadTest {
  public test(@MessageBody(ValidationPipe) payload: any) {}
}

describe('@MessagePayload', () => {
  it('should enhance class with expected request metadata', () => {
    const argsMetadata = Reflect.getMetadata(
      PARAM_ARGS_METADATA,
      MessagePayloadTest,
      'test',
    );
    const expectedMetadata = {
      [`${WsParamtype.PAYLOAD}:0`]: {
        data: undefined,
        index: 0,
        pipes: [ValidationPipe],
      },
    };
    expect(argsMetadata).to.be.eql(expectedMetadata);
  });
});



================================================
FILE: packages/websockets/test/exceptions/ws-exception.spec.ts
================================================
import { expect } from 'chai';
import { WsException } from '../../errors/ws-exception';

describe('WsException', () => {
  describe('when string passed', () => {
    const error = 'test';
    const instance = new WsException(error);

    it('should return error message as string', () => {
      expect(instance.getError()).to.be.eql(error);
    });
    it('should set the message property', () => {
      expect(instance.message).to.be.eql(error);
    });
  });

  describe('when object passed', () => {
    describe('and message property is undefined', () => {
      const error = { test: true };
      const instance = new WsException(error);

      it('should return error as object', () => {
        expect(instance.getError()).to.be.eql(error);
      });
      it('should fallback error message to class name', () => {
        expect(instance.message).to.be.eql('Ws Exception');
      });
    });
    describe('and message property is not undefined', () => {
      const error = { message: 'test', test: true };
      const instance = new WsException(error);

      it('should return error as object', () => {
        expect(instance.getError()).to.be.eql(error);
      });
      it('should return error message as the extracted "message" string', () => {
        expect(instance.message).to.be.eql(error.message);
      });
    });
  });
});



================================================
FILE: packages/websockets/test/exceptions/ws-exceptions-handler.spec.ts
================================================
import { ExecutionContextHost } from '@nestjs/core/helpers/execution-context-host';
import { expect } from 'chai';
import * as sinon from 'sinon';
import { WsException } from '../../errors/ws-exception';
import { WsExceptionsHandler } from '../../exceptions/ws-exceptions-handler';

describe('WsExceptionsHandler', () => {
  let handler: WsExceptionsHandler;
  let emitStub: sinon.SinonStub;
  let client: {
    emit: sinon.SinonStub;
  };
  let pattern: string;
  let data: unknown;
  let executionContextHost: ExecutionContextHost;

  beforeEach(() => {
    handler = new WsExceptionsHandler();
    emitStub = sinon.stub();
    client = {
      emit: emitStub,
    };
    pattern = 'test';
    data = { foo: 'bar' };
    executionContextHost = new ExecutionContextHost([client, data, pattern]);

    client.emit.returns(client);
  });

  describe('handle', () => {
    describe('when "includeCause" is set to true (default)', () => {
      it('should method emit expected status code message when exception is unknown', () => {
        handler.handle(new Error(), executionContextHost);
        expect(
          emitStub.calledWith('exception', {
            status: 'error',
            message: 'Internal server error',
            cause: {
              pattern,
              data,
            },
          }),
        ).to.be.true;
      });
      describe('when exception is instance of WsException', () => {
        it('should method emit expected status and json object', () => {
          const message = {
            custom: 'Unauthorized',
          };
          handler.handle(new WsException(message), executionContextHost);
          expect(emitStub.calledWith('exception', message)).to.be.true;
        });
        it('should method emit expected status and transform message to json', () => {
          const message = 'Unauthorized';

          handler.handle(new WsException(message), executionContextHost);
          console.log(emitStub.getCall(0).args);
          expect(
            emitStub.calledWith('exception', {
              message,
              status: 'error',
              cause: {
                pattern,
                data,
              },
            }),
          ).to.be.true;
        });
      });
    });

    describe('when "includeCause" is set to false', () => {
      beforeEach(() => {
        handler = new WsExceptionsHandler({ includeCause: false });
      });

      it('should method emit expected status code message when exception is unknown', () => {
        handler.handle(
          new Error(),
          new ExecutionContextHost([client, pattern, data]),
        );
        expect(
          emitStub.calledWith('exception', {
            status: 'error',
            message: 'Internal server error',
          }),
        ).to.be.true;
      });
      describe('when exception is instance of WsException', () => {
        it('should method emit expected status and json object', () => {
          const message = {
            custom: 'Unauthorized',
          };
          handler.handle(new WsException(message), executionContextHost);
          expect(emitStub.calledWith('exception', message)).to.be.true;
        });
        it('should method emit expected status and transform message to json', () => {
          const message = 'Unauthorized';

          handler.handle(new WsException(message), executionContextHost);
          expect(emitStub.calledWith('exception', { message, status: 'error' }))
            .to.be.true;
        });
      });
    });

    describe('when "invokeCustomFilters" returns true', () => {
      beforeEach(() => {
        sinon.stub(handler, 'invokeCustomFilters').returns(true);
      });
      it('should not call `emit`', () => {
        handler.handle(new WsException(''), executionContextHost);
        expect(emitStub.notCalled).to.be.true;
      });
    });
  });
  describe('setCustomFilters', () => {
    const filters = ['test', 'test2'];
    it('should set custom filters', () => {
      handler.setCustomFilters(filters as any);
      expect((handler as any).filters).to.be.eql(filters);
    });
    it('should throw exception when passed argument is not an array', () => {
      expect(() => handler.setCustomFilters(null!)).to.throw();
    });
  });
  describe('invokeCustomFilters', () => {
    describe('when filters array is empty', () => {
      it('should return false', () => {
        expect(handler.invokeCustomFilters(null, null!)).to.be.false;
      });
    });
    describe('when filters array is not empty', () => {
      let filters: any[], funcSpy: sinon.SinonSpy;
      class TestException {}

      beforeEach(() => {
        funcSpy = sinon.spy();
      });
      describe('when filter exists in filters array', () => {
        beforeEach(() => {
          filters = [{ exceptionMetatypes: [TestException], func: funcSpy }];
          (handler as any).filters = filters;
        });
        it('should call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.false;
        });
        it('should call funcSpy with exception and response passed as an arguments', () => {
          const exception = new TestException();
          const res = { foo: 'bar' };

          handler.invokeCustomFilters(exception, res as any);
          expect(funcSpy.calledWith(exception, res)).to.be.true;
        });
        it('should return true', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .true;
        });
      });
      describe('when filter does not exists in filters array', () => {
        it('should not call funcSpy', () => {
          handler.invokeCustomFilters(new TestException(), null!);
          expect(funcSpy.notCalled).to.be.true;
        });
        it('should return false', () => {
          expect(handler.invokeCustomFilters(new TestException(), null!)).to.be
            .false;
        });
      });
    });
  });
});



================================================
FILE: packages/websockets/test/factories/server-and-event-streams-factory.spec.ts
================================================
import { expect } from 'chai';
import { ReplaySubject, Subject } from 'rxjs';
import { ServerAndEventStreamsFactory } from '../../factories/server-and-event-streams-factory';

describe('ServerAndEventStreamsFactory', () => {
  describe('create', () => {
    it(`should return expected observable socket object`, () => {
      const server = { test: 'test' };
      const result = ServerAndEventStreamsFactory.create(server);

      expect(result).to.have.keys('init', 'connection', 'disconnect', 'server');
      expect(result.init instanceof ReplaySubject).to.be.true;
      expect(result.connection instanceof Subject).to.be.true;
      expect(result.disconnect instanceof Subject).to.be.true;
      expect(result.server).to.be.eql(server);
    });
  });
});



================================================
FILE: packages/websockets/test/factories/ws-params-factory.spec.ts
================================================
import { expect } from 'chai';
import { WsParamtype } from '../../enums/ws-paramtype.enum';
import { WsParamsFactory } from '../../factories/ws-params-factory';

describe('WsParamsFactory', () => {
  let factory: WsParamsFactory;
  beforeEach(() => {
    factory = new WsParamsFactory();
  });
  describe('exchangeKeyForValue', () => {
    const client = {};
    const data = { data: true };

    describe('when key is', () => {
      const args = [client, data];
      describe(`WsParamtype.PAYLOAD`, () => {
        it('should return a message payload object', () => {
          expect(
            factory.exchangeKeyForValue(WsParamtype.PAYLOAD, null!, args),
          ).to.be.eql(data);
        });
        it('should return a message payload object with parameter extraction', () => {
          expect(
            factory.exchangeKeyForValue(WsParamtype.PAYLOAD, 'data', args),
          ).to.be.eql(data.data);
        });
      });
      describe(`WsParamtype.SOCKET`, () => {
        it('should return a connected socket object', () => {
          expect(
            factory.exchangeKeyForValue(WsParamtype.SOCKET, null!, args),
          ).to.be.eql(client);
        });
      });
    });
    describe('when key is not available', () => {
      it('should return null', () => {
        expect(factory.exchangeKeyForValue(-1, null!, [])).to.be.eql(null);
      });
    });
    describe('when args are not available', () => {
      it('should return null', () => {
        expect(factory.exchangeKeyForValue(null!, null!, null!)).to.be.eql(
          null,
        );
      });
    });
  });
});



================================================
FILE: packages/websockets/test/utils/compare-element.util.spec.ts
================================================
import { expect } from 'chai';
import { compareElementAt } from '../../utils/compare-element.util';

describe('compareElementAt', () => {
  it('should compare elements at the specific position in arrays', () => {
    expect(compareElementAt([0, 1, 0], [2, 1, 7], 1)).to.be.true;
    expect(compareElementAt([0, 1, 0], [2, 0, 7], 1)).to.be.false;
  });
});



================================================
FILE: packages/websockets/test/utils/gateway-server.decorator.spec.ts
================================================
import { expect } from 'chai';
import { WebSocketServer } from '../../decorators/gateway-server.decorator';
import { GATEWAY_SERVER_METADATA } from '../../constants';

describe('@WebSocketServer', () => {
  class TestGateway {
    @WebSocketServer() static server;
  }

  it('should decorate server property with expected metadata', () => {
    const isServer = Reflect.getOwnMetadata(
      GATEWAY_SERVER_METADATA,
      TestGateway,
      'server',
    );
    expect(isServer).to.be.eql(true);
  });
  it('should set property value to null by default', () => {
    expect(TestGateway.server).to.be.eql(null);
  });
});



================================================
FILE: packages/websockets/test/utils/socket-gateway.decorator.spec.ts
================================================
import { expect } from 'chai';
import { GATEWAY_METADATA, GATEWAY_OPTIONS } from '../../constants';
import { WebSocketGateway } from '../../decorators/socket-gateway.decorator';

describe('@WebSocketGateway', () => {
  @WebSocketGateway(80, { namespace: '/' })
  class TestGateway {}

  it('should decorate transport with expected metadata', () => {
    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway);
    const port = Reflect.getMetadata('port', TestGateway);
    const { namespace } = Reflect.getMetadata(GATEWAY_OPTIONS, TestGateway);

    expect(isGateway).to.be.eql(true);
    expect(port).to.be.eql(80);
    expect(namespace).to.be.eql('/');
  });

  @WebSocketGateway()
  class TestGateway2 {}

  it('should decorate transport with port: 0', () => {
    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway2);
    const port = Reflect.getMetadata('port', TestGateway2);

    expect(isGateway).to.be.eql(true);
    expect(port).to.be.eql(0);
  });

  @WebSocketGateway({ namespace: '/' })
  class TestGateway3 {}

  it('should decorate transport with expected options', () => {
    const isGateway = Reflect.getMetadata(GATEWAY_METADATA, TestGateway3);
    const port = Reflect.getMetadata('port', TestGateway3);
    const { namespace } = Reflect.getMetadata(GATEWAY_OPTIONS, TestGateway3);

    expect(isGateway).to.be.eql(true);
    expect(port).to.be.eql(0);
    expect(namespace).to.be.eql('/');
  });
});



================================================
FILE: packages/websockets/test/utils/subscribe-message.decorator.spec.ts
================================================
import { expect } from 'chai';
import { MESSAGE_MAPPING_METADATA } from '../../constants';
import { SubscribeMessage } from '../../decorators/subscribe-message.decorator';

describe('@SubscribeMessage', () => {
  class TestGateway {
    @SubscribeMessage('filter')
    static fn() {}
  }

  it('should decorate transport with expected metadata', () => {
    const isMessageMapping = Reflect.getMetadata(
      MESSAGE_MAPPING_METADATA,
      TestGateway.fn,
    );
    const message = Reflect.getMetadata('message', TestGateway.fn);

    expect(isMessageMapping).to.be.true;
    expect(message).to.be.eql('filter');
  });
});



================================================
FILE: packages/websockets/utils/compare-element.util.ts
================================================
export function compareElementAt(
  prev: unknown[],
  curr: unknown[],
  index: number,
) {
  return prev && curr && prev[index] === curr[index];
}



================================================
FILE: packages/websockets/utils/index.ts
================================================
export * from './param.utils';



================================================
FILE: packages/websockets/utils/param.utils.ts
================================================
import { PipeTransform, Type } from '@nestjs/common';
import { assignMetadata } from '@nestjs/common/decorators/http/route-params.decorator';
import { isNil, isString } from '@nestjs/common/utils/shared.utils';
import 'reflect-metadata';
import { PARAM_ARGS_METADATA } from '../constants';
import { WsParamtype } from '../enums/ws-paramtype.enum';

export function createWsParamDecorator(
  paramtype: WsParamtype,
): (...pipes: (Type<PipeTransform> | PipeTransform)[]) => ParameterDecorator {
  return (...pipes: (Type<PipeTransform> | PipeTransform)[]) =>
    (target, key, index) => {
      const args =
        Reflect.getMetadata(PARAM_ARGS_METADATA, target.constructor, key!) ||
        {};
      Reflect.defineMetadata(
        PARAM_ARGS_METADATA,
        assignMetadata(args, paramtype, index, undefined, ...pipes),
        target.constructor,
        key!,
      );
    };
}

export const createPipesWsParamDecorator =
  (paramtype: WsParamtype) =>
  (
    data?: any,
    ...pipes: (Type<PipeTransform> | PipeTransform)[]
  ): ParameterDecorator =>
  (target, key, index) => {
    const args =
      Reflect.getMetadata(PARAM_ARGS_METADATA, target.constructor, key!) || {};
    const hasParamData = isNil(data) || isString(data);
    const paramData = hasParamData ? data : undefined;
    const paramPipes = hasParamData ? pipes : [data, ...pipes];

    Reflect.defineMetadata(
      PARAM_ARGS_METADATA,
      assignMetadata(args, paramtype, index, paramData!, ...paramPipes),
      target.constructor,
      key!,
    );
  };



================================================
FILE: sample/01-cats-app/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/01-cats-app/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/01-cats-app/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./e2e/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/01-cats-app/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/01-cats-app/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/01-cats-app/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/01-cats-app/e2e/jest-e2e.json
================================================
{
    "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/e2e/.*\\.(e2e-test|e2e-spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/01-cats-app/e2e/cats/cats.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { CatsModule } from '../../src/cats/cats.module';
import { CatsService } from '../../src/cats/cats.service';
import { CoreModule } from '../../src/core/core.module';

describe('Cats', () => {
  const catsService = { findAll: () => ['test'] };

  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [CatsModule, CoreModule],
    })
      .overrideProvider(CatsService)
      .useValue(catsService)
      .compile();

    app = moduleRef.createNestApplication();
    await app.init();
  });

  it(`/GET cats`, () => {
    return request(app.getHttpServer()).get('/cats').expect(200).expect({
      data: catsService.findAll(),
    });
  });

  afterAll(async () => {
    await app.close();
  });
});



================================================
FILE: sample/01-cats-app/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';
import { CoreModule } from './core/core.module';

@Module({
  imports: [CoreModule, CatsModule],
})
export class AppModule {}



================================================
FILE: sample/01-cats-app/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/01-cats-app/src/cats/cats.controller.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

describe('CatsController', () => {
  let catsController: CatsController;
  let catsService: CatsService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      controllers: [CatsController],
      providers: [CatsService],
    }).compile();

    catsService = moduleRef.get<CatsService>(CatsService);
    catsController = moduleRef.get<CatsController>(CatsController);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const cats: Cat[] = [
        {
          age: 2,
          breed: 'Bombay',
          name: 'Pixel',
        },
      ];
      // @ts-ignore
      catsService.cats = cats;

      expect(await catsController.findAll()).toBe(cats);
    });
  });

  describe('create', () => {
    it('should add a new cat', async () => {
      const cat: Cat = {
        age: 2,
        breed: 'Bombay',
        name: 'Pixel',
      };
      const expectedCatArray = [cat];

      // @ts-ignore
      expect(catsService.cats).toStrictEqual([]);

      await catsController.create(cat);

      // @ts-ignore
      expect(catsService.cats).toStrictEqual(expectedCatArray);
    });
  });
});



================================================
FILE: sample/01-cats-app/src/cats/cats.controller.ts
================================================
import { Body, Controller, Get, Param, Post, UseGuards } from '@nestjs/common';
import { Roles } from '../common/decorators/roles.decorator';
import { RolesGuard } from '../common/guards/roles.guard';
import { ParseIntPipe } from '../common/pipes/parse-int.pipe';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@UseGuards(RolesGuard)
@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  @Roles(['admin'])
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }

  @Get(':id')
  findOne(
    @Param('id', new ParseIntPipe())
    id: number,
  ) {
    // Retrieve a Cat instance by ID
    console.log(id);
  }
}



================================================
FILE: sample/01-cats-app/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: sample/01-cats-app/src/cats/cats.service.spec.ts
================================================
import { Test } from '@nestjs/testing';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

describe('CatsService', () => {
  let catsService: CatsService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [CatsService],
    }).compile();

    catsService = moduleRef.get<CatsService>(CatsService);
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const result = [
        {
          name: 'Frajola',
          age: 2,
          breed: 'Stray',
        },
      ];
      //@ts-ignore
      catsService.cats = result;

      await expect(catsService.findAll()).resolves.toBe(result);
    });
  });

  describe('create', () => {
    it('should add a new cat', async () => {
      const cat: Cat = {
        name: 'Frajola',
        age: 2,
        breed: 'Stray',
      };
      const expectedCatArray = [cat];
      //@ts-ignore
      expect(catsService.cats).toStrictEqual([]);

      catsService.create(cat);
      //@ts-ignore
      expect(catsService.cats).toStrictEqual(expectedCatArray);
    });
  });
});



================================================
FILE: sample/01-cats-app/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Promise<Cat[]> {
    return Promise.resolve(this.cats);
  }
}



================================================
FILE: sample/01-cats-app/src/cats/dto/create-cat.dto.ts
================================================
import { IsInt, IsString } from 'class-validator';

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}



================================================
FILE: sample/01-cats-app/src/cats/interfaces/cat.interface.ts
================================================
export interface Cat {
  name: string;
  age: number;
  breed: string;
}



================================================
FILE: sample/01-cats-app/src/common/decorators/roles.decorator.ts
================================================
import { Reflector } from '@nestjs/core';

export const Roles = Reflector.createDecorator<string[]>();



================================================
FILE: sample/01-cats-app/src/common/filters/http-exception.filter.ts
================================================
import {
  ArgumentsHost,
  Catch,
  ExceptionFilter,
  HttpException,
} from '@nestjs/common';

@Catch(HttpException)
export class HttpExceptionFilter implements ExceptionFilter<HttpException> {
  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse();
    const request = ctx.getRequest();
    const statusCode = exception.getStatus();

    response.status(statusCode).json({
      statusCode,
      timestamp: new Date().toISOString(),
      path: request.url,
    });
  }
}



================================================
FILE: sample/01-cats-app/src/common/guards/roles.guard.ts
================================================
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Roles } from '../decorators/roles.decorator';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get(Roles, context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const hasRole = () =>
      user.roles.some(role => !!roles.find(item => item === role));

    return user && user.roles && hasRole();
  }
}



================================================
FILE: sample/01-cats-app/src/common/interceptors/exception.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  HttpException,
  HttpStatus,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ErrorsInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(
        catchError(err =>
          throwError(
            () => new HttpException('New message', HttpStatus.BAD_GATEWAY),
          ),
        ),
      );
  }
}



================================================
FILE: sample/01-cats-app/src/common/interceptors/timeout.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { timeout } from 'rxjs/operators';

@Injectable()
export class TimeoutInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(timeout(5000));
  }
}



================================================
FILE: sample/01-cats-app/src/common/middleware/logger.middleware.ts
================================================
import { Injectable, NestMiddleware } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: any, res: any, next: () => void) {
    console.log(`Request...`);
    next();
  }
}



================================================
FILE: sample/01-cats-app/src/common/pipes/parse-int.pipe.ts
================================================
import {
  BadRequestException,
  PipeTransform,
  Injectable,
  ArgumentMetadata,
} from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string> {
  async transform(value: string, metadata: ArgumentMetadata) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}



================================================
FILE: sample/01-cats-app/src/common/pipes/validation.pipe.ts
================================================
import {
  ArgumentMetadata,
  BadRequestException,
  Injectable,
  PipeTransform,
  Type,
} from '@nestjs/common';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, metadata: ArgumentMetadata) {
    const { metatype } = metadata;
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToInstance(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype: Type<any>): boolean {
    const types = [String, Boolean, Number, Array, Object];
    return !types.find(type => metatype === type);
  }
}



================================================
FILE: sample/01-cats-app/src/core/core.module.ts
================================================
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { TransformInterceptor } from './interceptors/transform.interceptor';

@Module({
  providers: [
    { provide: APP_INTERCEPTOR, useClass: TransformInterceptor },
    { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor },
  ],
})
export class CoreModule {}



================================================
FILE: sample/01-cats-app/src/core/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
  }
}



================================================
FILE: sample/01-cats-app/src/core/interceptors/transform.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler<T>,
  ): Observable<Response<T>> {
    return next.handle().pipe(map(data => ({ data })));
  }
}



================================================
FILE: sample/02-gateways/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/02-gateways/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/02-gateways/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./e2e/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/platform-socket.io": "11.0.13",
    "@nestjs/websockets": "11.0.13",
    "@socket.io/redis-adapter": "8.3.0",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "socket.io": "4.8.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "@types/ws": "8.5.13",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "redis": "4.7.0",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/02-gateways/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/02-gateways/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/02-gateways/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/02-gateways/client/index.html
================================================
<html>
  <head>
    <script src="https://cdn.socket.io/4.3.2/socket.io.min.js" integrity="sha384-KAZ4DtjNhLChOB/hxXuKqhMLYvx3b5MlT55xPEiNmREKRzeEm+RVPlTnAn0ajQNs" crossorigin="anonymous"></script>
    <script>
      const socket = io('http://localhost:3000');
      socket.on('connect', function() {
        console.log('Connected');

        socket.emit('events', { test: 'test' });
        socket.emit('identity', 0, response =>
          console.log('Identity:', response),
        );
      });
      socket.on('events', function(data) {
        console.log('event', data);
      });
      socket.on('exception', function(data) {
        console.log('event', data);
      });
      socket.on('disconnect', function() {
        console.log('Disconnected');
      });
    </script>
  </head>

  <body></body>
</html>



================================================
FILE: sample/02-gateways/e2e/jest-e2e.json
================================================
{
    "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/e2e/.*\\.(e2e-test|e2e-spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/02-gateways/e2e/events-gateway/gateway.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AppModule } from '../../src/app.module';
import { io, Socket } from 'socket.io-client';

describe('EventsGateway', () => {
  let app: INestApplication;
  let socket: Socket;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleRef.createNestApplication();
    await app.listen(3000);
  });

  beforeEach(done => {
    socket = io('http://localhost:3000');
    socket.on('connect', () => {
      done();
    });
  });

  describe('findAll', () => {
    it('should receive 3 numbers', done => {
      let eventCount = 1;
      socket.emit('events', { test: 'test' });
      socket.on('events', data => {
        expect(data).toBe(eventCount);
        if (++eventCount > 3) {
          done();
        }
      });
    });
  });

  describe('identity', () => {
    it('should return the same number has what was sent', done => {
      socket.emit('identity', 0, response => {
        expect(response).toBe(0);
        done();
      });
    });
  });

  afterEach(() => {
    socket.disconnect();
  });

  afterAll(async () => {
    await app.close();
  });
});



================================================
FILE: sample/02-gateways/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventsModule } from './events/events.module';

@Module({
  imports: [EventsModule],
})
export class AppModule {}



================================================
FILE: sample/02-gateways/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  // Uncomment these lines to use the Redis adapter:
  // const redisIoAdapter = new RedisIoAdapter(app);
  // await redisIoAdapter.connectToRedis();
  // app.useWebSocketAdapter(redisIoAdapter);

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/02-gateways/src/adapters/redis-io.adapter.ts
================================================
import { IoAdapter } from '@nestjs/platform-socket.io';
import { ServerOptions } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { createClient } from 'redis';

export class RedisIoAdapter extends IoAdapter {
  private adapterConstructor: ReturnType<typeof createAdapter>;

  async connectToRedis(): Promise<void> {
    const pubClient = createClient({ url: `redis://localhost:6379` });
    const subClient = pubClient.duplicate();

    await Promise.all([pubClient.connect(), subClient.connect()]);

    this.adapterConstructor = createAdapter(pubClient, subClient);
  }

  createIOServer(port: number, options?: ServerOptions): any {
    const server = super.createIOServer(port, options);
    server.adapter(this.adapterConstructor);
    return server;
  }
}



================================================
FILE: sample/02-gateways/src/events/events.gateway.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { reduce } from 'rxjs/operators';
import { EventsGateway } from './events.gateway';

describe('EventsGateway', () => {
  let gateway: EventsGateway;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [EventsGateway],
    }).compile();

    gateway = module.get<EventsGateway>(EventsGateway);
  });

  it('should be defined', () => {
    expect(gateway).toBeDefined();
  });

  describe('findAll', () => {
    it('should return 3 numbers', done => {
      gateway
        .findAll({})
        .pipe(reduce((acc, item) => [...acc, item], []))
        .subscribe(results => {
          expect(results.length).toBe(3);
          results.forEach((result, index) =>
            expect(result.data).toBe(index + 1),
          );
          done();
        });
    });
  });

  describe('identity', () => {
    it('should return the same number has what was sent', async () => {
      await expect(gateway.identity(1)).resolves.toBe(1);
    });
  });
});



================================================
FILE: sample/02-gateways/src/events/events.gateway.ts
================================================
import {
  MessageBody,
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
  WsResponse,
} from '@nestjs/websockets';
import { from, Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Server } from 'socket.io';

@WebSocketGateway({
  cors: {
    origin: '*',
  },
})
export class EventsGateway {
  @WebSocketServer()
  server: Server;

  @SubscribeMessage('events')
  findAll(@MessageBody() data: any): Observable<WsResponse<number>> {
    return from([1, 2, 3]).pipe(map(item => ({ event: 'events', data: item })));
  }

  @SubscribeMessage('identity')
  async identity(@MessageBody() data: number): Promise<number> {
    return data;
  }
}



================================================
FILE: sample/02-gateways/src/events/events.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventsGateway } from './events.gateway';

@Module({
  providers: [EventsGateway],
})
export class EventsModule {}



================================================
FILE: sample/03-microservices/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/03-microservices/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/microservices": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/amqplib": "0.10.7",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/03-microservices/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/03-microservices/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/03-microservices/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/03-microservices/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { MathModule } from './math/math.module';

@Module({
  imports: [MathModule],
})
export class AppModule {}



================================================
FILE: sample/03-microservices/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions, Transport } from '@nestjs/microservices';
import { AppModule } from './app.module';

async function bootstrap() {
  /**
   * This example contains a hybrid application (HTTP + TCP)
   * You can switch to a microservice with NestFactory.createMicroservice() as follows:
   *
   * const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
   *  transport: Transport.TCP,
   *  options: { retryAttempts: 5, retryDelay: 3000 },
   * });
   * await app.listen();
   *
   */
  const app = await NestFactory.create(AppModule);
  app.connectMicroservice<MicroserviceOptions>({
    transport: Transport.TCP,
    options: { retryAttempts: 5, retryDelay: 3000 },
  });

  await app.startAllMicroservices();
  await app.listen(3001);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/03-microservices/src/common/filters/rpc-exception.filter.ts
================================================
import { Catch, RpcExceptionFilter } from '@nestjs/common';
import { RpcException } from '@nestjs/microservices';
import { Observable, throwError } from 'rxjs';

@Catch(RpcException)
export class ExceptionFilter implements RpcExceptionFilter {
  catch(exception: RpcException): Observable<any> {
    return throwError(() => exception.getError());
  }
}



================================================
FILE: sample/03-microservices/src/common/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
  }
}



================================================
FILE: sample/03-microservices/src/common/strategies/nats.strategy.ts
================================================
import { ServerNats } from '@nestjs/microservices';

export interface NatsSubscriber {
  key: string;
  value: {
    pattern: string;
    queue: string;
  };
}

export class NatsStrategy extends ServerNats {
  bindEvents(client: any) {
    const patterns = [...this.messageHandlers.keys()];
    const handlers = patterns.map(item => ({
      key: item,
      value: JSON.parse(item),
    })) as NatsSubscriber[];

    handlers.forEach(({ key, value }) =>
      client.subscribe(
        value.pattern,
        { queue: value.queue },
        this.getMessageHandler(key).bind(this),
      ),
    );
  }
}



================================================
FILE: sample/03-microservices/src/math/math.constants.ts
================================================
export const MATH_SERVICE = 'MATH_SERVICE';



================================================
FILE: sample/03-microservices/src/math/math.controller.ts
================================================
import { Controller, Get, Inject } from '@nestjs/common';
import { ClientProxy, MessagePattern } from '@nestjs/microservices';
import { Observable } from 'rxjs';
import { MATH_SERVICE } from './math.constants';

@Controller()
export class MathController {
  constructor(@Inject(MATH_SERVICE) private readonly client: ClientProxy) {}

  @Get()
  execute(): Observable<number> {
    const pattern = { cmd: 'sum' };
    const data = [1, 2, 3, 4, 5];
    return this.client.send<number>(pattern, data);
  }

  @MessagePattern({ cmd: 'sum' })
  sum(data: number[]): number {
    return (data || []).reduce((a, b) => a + b);
  }
}



================================================
FILE: sample/03-microservices/src/math/math.module.ts
================================================
import { Module } from '@nestjs/common';
import { ClientsModule, Transport } from '@nestjs/microservices';
import { MATH_SERVICE } from './math.constants';
import { MathController } from './math.controller';

@Module({
  imports: [
    ClientsModule.register([{ name: MATH_SERVICE, transport: Transport.TCP }]),
  ],
  controllers: [MathController],
})
export class MathModule {}



================================================
FILE: sample/04-grpc/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/04-grpc/nest-cli.json
================================================
{
  "compilerOptions": {
    "assets": ["**/*.proto"]
  }
}



================================================
FILE: sample/04-grpc/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@grpc/grpc-js": "1.13.2",
    "@grpc/reflection": "1.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/microservices": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/04-grpc/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/04-grpc/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/04-grpc/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/04-grpc/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { HeroModule } from './hero/hero.module';

@Module({
  imports: [HeroModule],
})
export class AppModule {}



================================================
FILE: sample/04-grpc/src/grpc-client.options.ts
================================================
import { ReflectionService } from '@grpc/reflection';
import { GrpcOptions, Transport } from '@nestjs/microservices';
import { join } from 'path';

export const grpcClientOptions: GrpcOptions = {
  transport: Transport.GRPC,
  options: {
    package: 'hero', // ['hero', 'hero2']
    protoPath: join(__dirname, './hero/hero.proto'), // ['./hero/hero.proto', './hero/hero2.proto']
    onLoadPackageDefinition: (pkg, server) => {
      new ReflectionService(pkg).addToServer(server);
    },
  },
};



================================================
FILE: sample/04-grpc/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { MicroserviceOptions } from '@nestjs/microservices';
import { AppModule } from './app.module';
import { grpcClientOptions } from './grpc-client.options';

async function bootstrap() {
  /**
   * This example contains a hybrid application (HTTP + gRPC)
   * You can switch to a microservice with NestFactory.createMicroservice() as follows:
   *
   * const app = await NestFactory.createMicroservice<MicroserviceOptions>(AppModule, {
   *  transport: Transport.GRPC,
   *  options: {
   *    package: 'hero',
   *    protoPath: join(__dirname, './hero/hero.proto'),
   *  }
   * });
   * await app.listen();
   *
   */
  const app = await NestFactory.create(AppModule);
  app.connectMicroservice<MicroserviceOptions>(grpcClientOptions);

  await app.startAllMicroservices();
  await app.listen(3001);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/04-grpc/src/hero/hero.controller.ts
================================================
import { Controller, Get, Inject, OnModuleInit, Param } from '@nestjs/common';
import {
  ClientGrpc,
  GrpcMethod,
  GrpcStreamMethod,
} from '@nestjs/microservices';
import { Observable, ReplaySubject, Subject } from 'rxjs';
import { toArray } from 'rxjs/operators';
import { HeroById } from './interfaces/hero-by-id.interface';
import { Hero } from './interfaces/hero.interface';

interface HeroesService {
  findOne(data: HeroById): Observable<Hero>;
  findMany(upstream: Observable<HeroById>): Observable<Hero>;
}

@Controller('hero')
export class HeroController implements OnModuleInit {
  private readonly items: Hero[] = [
    { id: 1, name: 'John' },
    { id: 2, name: 'Doe' },
  ];
  private heroesService: HeroesService;

  constructor(@Inject('HERO_PACKAGE') private readonly client: ClientGrpc) {}

  onModuleInit() {
    this.heroesService = this.client.getService<HeroesService>('HeroesService');
  }

  @Get()
  getMany(): Observable<Hero[]> {
    const ids$ = new ReplaySubject<HeroById>();
    ids$.next({ id: 1 });
    ids$.next({ id: 2 });
    ids$.complete();

    const stream = this.heroesService.findMany(ids$.asObservable());
    return stream.pipe(toArray());
  }

  @Get(':id')
  getById(@Param('id') id: string): Observable<Hero> {
    return this.heroesService.findOne({ id: +id });
  }

  @GrpcMethod('HeroesService')
  findOne(data: HeroById): Hero {
    return this.items.find(({ id }) => id === data.id);
  }

  @GrpcStreamMethod('HeroesService')
  findMany(data$: Observable<HeroById>): Observable<Hero> {
    const hero$ = new Subject<Hero>();

    const onNext = (heroById: HeroById) => {
      const item = this.items.find(({ id }) => id === heroById.id);
      hero$.next(item);
    };
    const onComplete = () => hero$.complete();
    data$.subscribe({
      next: onNext,
      complete: onComplete,
    });

    return hero$.asObservable();
  }
}



================================================
FILE: sample/04-grpc/src/hero/hero.module.ts
================================================
import { Module } from '@nestjs/common';
import { ClientsModule } from '@nestjs/microservices';
import { grpcClientOptions } from '../grpc-client.options';
import { HeroController } from './hero.controller';

@Module({
  imports: [
    ClientsModule.register([
      {
        name: 'HERO_PACKAGE',
        ...grpcClientOptions,
      },
    ]),
  ],
  controllers: [HeroController],
})
export class HeroModule {}



================================================
FILE: sample/04-grpc/src/hero/hero.proto
================================================
syntax = "proto3";

package hero;

service HeroesService {
  rpc FindOne (HeroById) returns (Hero);
  rpc FindMany (stream HeroById) returns (stream Hero);
}

message HeroById {
  int32 id = 1;
}

message Hero {
  int32 id = 1;
  string name = 2;
}



================================================
FILE: sample/04-grpc/src/hero/interfaces/hero-by-id.interface.ts
================================================
export interface HeroById {
  id: number;
}



================================================
FILE: sample/04-grpc/src/hero/interfaces/hero.interface.ts
================================================
export interface Hero {
  id: number;
  name: string;
}



================================================
FILE: sample/05-sql-typeorm/README.md
================================================
### SQL TypeORM sample

### Installation


`npm install`

### Running

This example requires docker or a local MySQL installation.  If using a local MySQL database, see `app.module.ts` for credentials, and make sure there are matching credentials in the database and the source code.

#### Docker

There is a `docker-compose.yml` file for starting Docker.

`docker-compose up`

After running the sample, you can stop the Docker container with

`docker-compose down`

### Run the sample

Then, run Nest as usual:

`npm run start`




================================================
FILE: sample/05-sql-typeorm/docker-compose.yml
================================================
version: "3"

services:
  mysql:
    image: mysql:9
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
    ports:
      - "3306:3306"
  db-test:
    image: mysql:9
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
    ports:
      - "3307:3306"


================================================
FILE: sample/05-sql-typeorm/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/05-sql-typeorm/jest.json
================================================
{
    "moduleFileExtensions": [
          "ts",
          "tsx",
          "js",
          "json"
      ],
      "transform": {
          "^.+\\.tsx?$": "babel-jest"
      },
      "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
      "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
      "coverageReporters": ["json", "lcov"]
  }


================================================
FILE: sample/05-sql-typeorm/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/typeorm": "11.0.0",
    "mysql2": "3.14.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "typeorm": "0.3.22"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/05-sql-typeorm/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/05-sql-typeorm/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*", "test/**/*"],
}



================================================
FILE: sample/05-sql-typeorm/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/05-sql-typeorm/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { UsersModule } from './users/users.module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mysql',
      host: '127.0.0.1',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      autoLoadEntities: true,
      synchronize: true,
    }),
    UsersModule,
  ],
})
export class AppModule {}



================================================
FILE: sample/05-sql-typeorm/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/05-sql-typeorm/src/users/user.entity.ts
================================================
import { Column, Entity, PrimaryGeneratedColumn } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  firstName: string;

  @Column()
  lastName: string;

  @Column({ default: true })
  isActive: boolean;
}



================================================
FILE: sample/05-sql-typeorm/src/users/users.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { CreateUserDto } from './dto/create-user.dto';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

const createUserDto: CreateUserDto = {
  firstName: 'firstName #1',
  lastName: 'lastName #1',
};

describe('UsersController', () => {
  let usersController: UsersController;
  let usersService: UsersService;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [
        UsersService,
        {
          provide: UsersService,
          useValue: {
            create: jest
              .fn()
              .mockImplementation((user: CreateUserDto) =>
                Promise.resolve({ id: '1', ...user }),
              ),
            findAll: jest.fn().mockResolvedValue([
              {
                firstName: 'firstName #1',
                lastName: 'lastName #1',
              },
              {
                firstName: 'firstName #2',
                lastName: 'lastName #2',
              },
            ]),
            findOne: jest.fn().mockImplementation((id: string) =>
              Promise.resolve({
                firstName: 'firstName #1',
                lastName: 'lastName #1',
                id,
              }),
            ),
            remove: jest.fn(),
          },
        },
      ],
    }).compile();

    usersController = app.get<UsersController>(UsersController);
    usersService = app.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(usersController).toBeDefined();
  });

  describe('create()', () => {
    it('should create a user', () => {
      usersController.create(createUserDto);
      expect(usersController.create(createUserDto)).resolves.toEqual({
        id: '1',
        ...createUserDto,
      });
      expect(usersService.create).toHaveBeenCalledWith(createUserDto);
    });
  });

  describe('findAll()', () => {
    it('should find all users ', () => {
      usersController.findAll();
      expect(usersService.findAll).toHaveBeenCalled();
    });
  });

  describe('findOne()', () => {
    it('should find a user', () => {
      expect(usersController.findOne(1)).resolves.toEqual({
        firstName: 'firstName #1',
        lastName: 'lastName #1',
        id: 1,
      });
      expect(usersService.findOne).toHaveBeenCalled();
    });
  });

  describe('remove()', () => {
    it('should remove the user', () => {
      usersController.remove('2');
      expect(usersService.remove).toHaveBeenCalled();
    });
  });
});



================================================
FILE: sample/05-sql-typeorm/src/users/users.controller.ts
================================================
import {
  Body,
  Controller,
  Delete,
  Get,
  Param,
  Post,
  ParseIntPipe,
} from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { User } from './user.entity';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto): Promise<User> {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll(): Promise<User[]> {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id', ParseIntPipe) id: number): Promise<User> {
    return this.usersService.findOne(id);
  }

  @Delete(':id')
  remove(@Param('id') id: string): Promise<void> {
    return this.usersService.remove(id);
  }
}



================================================
FILE: sample/05-sql-typeorm/src/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './user.entity';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}



================================================
FILE: sample/05-sql-typeorm/src/users/users.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { User } from './user.entity';
import { UsersService } from './users.service';
import { Repository } from 'typeorm';

const userArray = [
  {
    firstName: 'firstName #1',
    lastName: 'lastName #1',
  },
  {
    firstName: 'firstName #2',
    lastName: 'lastName #2',
  },
];

const oneUser = {
  firstName: 'firstName #1',
  lastName: 'lastName #1',
};

describe('UserService', () => {
  let service: UsersService;
  let repository: Repository<User>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: getRepositoryToken(User),
          useValue: {
            find: jest.fn().mockResolvedValue(userArray),
            findOneBy: jest.fn().mockResolvedValue(oneUser),
            save: jest.fn().mockResolvedValue(oneUser),
            remove: jest.fn(),
            delete: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
    repository = module.get<Repository<User>>(getRepositoryToken(User));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create()', () => {
    it('should successfully insert a user', () => {
      const oneUser = {
        firstName: 'firstName #1',
        lastName: 'lastName #1',
      };

      expect(
        service.create({
          firstName: 'firstName #1',
          lastName: 'lastName #1',
        }),
      ).resolves.toEqual(oneUser);
    });
  });

  describe('findAll()', () => {
    it('should return an array of users', async () => {
      const users = await service.findAll();
      expect(users).toEqual(userArray);
    });
  });

  describe('findOne()', () => {
    it('should get a single user', () => {
      const repoSpy = jest.spyOn(repository, 'findOneBy');
      expect(service.findOne(1)).resolves.toEqual(oneUser);
      expect(repoSpy).toBeCalledWith({ id: 1 });
    });
  });

  describe('remove()', () => {
    it('should call remove with the passed value', async () => {
      const removeSpy = jest.spyOn(repository, 'delete');
      const retVal = await service.remove('2');
      expect(removeSpy).toBeCalledWith('2');
      expect(retVal).toBeUndefined();
    });
  });
});



================================================
FILE: sample/05-sql-typeorm/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CreateUserDto } from './dto/create-user.dto';
import { User } from './user.entity';

@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
  ) {}

  create(createUserDto: CreateUserDto): Promise<User> {
    const user = new User();
    user.firstName = createUserDto.firstName;
    user.lastName = createUserDto.lastName;

    return this.usersRepository.save(user);
  }

  async findAll(): Promise<User[]> {
    return this.usersRepository.find();
  }

  findOne(id: number): Promise<User> {
    return this.usersRepository.findOneBy({ id: id });
  }

  async remove(id: string): Promise<void> {
    await this.usersRepository.delete(id);
  }
}



================================================
FILE: sample/05-sql-typeorm/src/users/dto/create-user.dto.ts
================================================
export class CreateUserDto {
  firstName: string;
  lastName: string;
}



================================================
FILE: sample/05-sql-typeorm/test/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}



================================================
FILE: sample/05-sql-typeorm/test/users/users.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import { TypeOrmModule } from '@nestjs/typeorm';
import * as request from 'supertest';
import { CreateUserDto } from '../../src/users/dto/create-user.dto';
import { UsersModule } from '../../src/users/users.module';

describe('Users - /users (e2e)', () => {
  const users = {
    id: 1,
    firstName: 'FirstName #1',
    lastName: 'LastName #1',
    isActive: true,
  };

  let app: INestApplication;

  beforeAll(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [
        TypeOrmModule.forRoot({
          type: 'mysql',
          host: '127.0.0.1',
          port: 3307,
          username: 'root',
          password: 'root',
          database: 'test',
          autoLoadEntities: true,
          synchronize: true,
        }),
        UsersModule,
      ],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('Create [POST /users]', () => {
    return request(app.getHttpServer())
      .post('/users')
      .send(users as CreateUserDto)
      .expect(201)
      .then(({ body }) => {
        expect(body).toEqual(users);
      });
  });

  it('Get all users [GET /users]', () => {
    return request(app.getHttpServer())
      .get('/users')
      .expect(200)
      .then(({ body }) => {
        expect(body).toBeDefined();
      });
  });

  it('Get one user [GET /users/:id]', () => {
    return request(app.getHttpServer())
      .get('/users/2')
      .expect(200)
      .then(({ body }) => {
        expect(body).toBeDefined();
      });
  });

  it('Delete one user [DELETE /users/:id]', () => {
    return request(app.getHttpServer()).delete('/users/1').expect(200);
  });

  afterAll(async () => {
    await app.close();
  });
});



================================================
FILE: sample/06-mongoose/README.md
================================================
### Mongoose sample

### Installation


`npm install`

### Running

This example requires docker or a local mongodb installation.  If using a local mongodb, see `app.module.ts` for connection options, and make sure there are matching options for the mongodb installation and the source code.

#### Docker

There is a `docker-compose.yml` file for starting Docker.

`docker-compose up`

After running the sample, you can stop the Docker container with

`docker-compose down`

### Run the sample

Then, run Nest as usual:

`npm run start`




================================================
FILE: sample/06-mongoose/docker-compose.yml
================================================
version: "3"

services:
  mongodb:
    image: mongo:latest
    environment:
      - MONGODB_DATABASE="test"
    ports:
      - 27017:27017


================================================
FILE: sample/06-mongoose/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/06-mongoose/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/mongoose": "11.0.3",
    "@nestjs/platform-express": "11.0.13",
    "mongoose": "8.13.2",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/06-mongoose/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/06-mongoose/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/06-mongoose/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/06-mongoose/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [
    MongooseModule.forRoot('mongodb://localhost:27017/test'),
    CatsModule,
  ],
})
export class AppModule {}



================================================
FILE: sample/06-mongoose/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/06-mongoose/src/cats/cats.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Types } from 'mongoose';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';

const catsServiceMock = {
  create: jest.fn(),
  findAll: jest.fn(),
  findOne: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};

describe('CatsController', () => {
  let controller: CatsController;
  let service: jest.Mocked<CatsService>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CatsController],
      providers: [
        {
          provide: CatsService,
          useValue: catsServiceMock,
        },
      ],
    }).compile();

    controller = module.get(CatsController);
    service = module.get(CatsService);
  });

  describe('create', () => {
    it('should create a new cat', async () => {
      const mockedCat = {
        _id: new Types.ObjectId(),
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      service.create.mockResolvedValueOnce(mockedCat);

      const createCatDto: CreateCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      const result = await controller.create(createCatDto);

      expect(result).toEqual(mockedCat);
      expect(service.create).toHaveBeenCalledWith(createCatDto);
    });
  });

  describe('findAll', () => {
    it('should return an array of cats', async () => {
      const mockedCats = [
        {
          _id: new Types.ObjectId(),
          name: 'Cat #1',
          breed: 'Bread #1',
          age: 4,
        },
        {
          _id: new Types.ObjectId(),
          name: 'Cat #2',
          breed: 'Breed #2',
          age: 3,
        },
        {
          _id: new Types.ObjectId(),
          name: 'Cat #3',
          breed: 'Breed #3',
          age: 2,
        },
      ];
      service.findAll.mockResolvedValueOnce(mockedCats);

      const result = await controller.findAll();

      expect(result).toEqual(mockedCats);
      expect(service.findAll).toHaveBeenCalled();
    });
  });

  describe('findOne', () => {
    it('should return a single cat', async () => {
      const mockedCat = {
        _id: new Types.ObjectId(),
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      service.findOne.mockResolvedValueOnce(mockedCat);

      const id = new Types.ObjectId().toString();
      const result = await controller.findOne(id);

      expect(result).toEqual(mockedCat);
      expect(service.findOne).toHaveBeenCalledWith(id);
    });
  });

  describe('update', () => {
    it('should update a single cat', async () => {
      const mockedCat = {
        _id: new Types.ObjectId(),
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      service.update.mockResolvedValueOnce(mockedCat);

      const id = new Types.ObjectId().toString();
      const updateCatDto: CreateCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      const result = await controller.update(id, updateCatDto);

      expect(result).toEqual(mockedCat);
      expect(service.update).toHaveBeenCalledWith(id, updateCatDto);
    });
  });

  describe('delete', () => {
    it('should delete a single cat', async () => {
      const mockedCat = {
        _id: new Types.ObjectId(),
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      service.delete.mockResolvedValueOnce(mockedCat);

      const id = new Types.ObjectId().toString();
      const result = await controller.delete(id);

      expect(result).toEqual(mockedCat);
      expect(service.delete).toHaveBeenCalledWith(id);
    });
  });
});



================================================
FILE: sample/06-mongoose/src/cats/cats.controller.ts
================================================
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { UpdateCatDto } from './dto/update-cat.dto';
import { Cat } from './schemas/cat.schema';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    return this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string): Promise<Cat> {
    return this.catsService.findOne(id);
  }

  @Post(':id')
  async update(@Param('id') id: string, @Body() updateCatDto: UpdateCatDto) {
    return this.catsService.update(id, updateCatDto);
  }

  @Delete(':id')
  async delete(@Param('id') id: string) {
    return this.catsService.delete(id);
  }
}



================================================
FILE: sample/06-mongoose/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { Cat, CatSchema } from './schemas/cat.schema';

@Module({
  imports: [MongooseModule.forFeature([{ name: Cat.name, schema: CatSchema }])],
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: sample/06-mongoose/src/cats/cats.service.spec.ts
================================================
import { getModelToken } from '@nestjs/mongoose';
import { Test, TestingModule } from '@nestjs/testing';
import { Model, Types } from 'mongoose';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './schemas/cat.schema';

const catModelMock = {
  create: jest.fn(),
  find: jest.fn(),
  findOne: jest.fn(),
  findByIdAndUpdate: jest.fn(),
  findByIdAndDelete: jest.fn(),
};

describe('CatsService', () => {
  let service: CatsService;
  let model: jest.Mocked<Model<Cat>>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CatsService,
        {
          provide: getModelToken('Cat'),
          useValue: catModelMock,
        },
      ],
    }).compile();

    service = module.get(CatsService);
    model = module.get(getModelToken('Cat'));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create', () => {
    it('should insert a new cat', async () => {
      const mockedCat: CreateCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      model.create.mockResolvedValueOnce(mockedCat as any);

      const createCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      const result = await service.create(createCatDto);

      expect(result).toEqual(mockedCat);
      expect(model.create).toHaveBeenCalledWith(createCatDto);
    });
  });

  describe('findAll', () => {
    it('should return all cats', async () => {
      const mockedCats = [
        {
          name: 'Cat #1',
          breed: 'Breed #1',
          age: 4,
        },
        {
          name: 'Cat #2',
          breed: 'Breed #2',
          age: 2,
        },
      ];
      model.find.mockReturnValueOnce({
        exec: jest.fn().mockResolvedValueOnce(mockedCats),
      } as any);

      const result = await service.findAll();

      expect(result).toEqual(mockedCats);
      expect(model.find).toHaveBeenCalled();
    });
  });

  describe('findOne', () => {
    it('should return one cat', async () => {
      const mockedCat = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      model.findOne.mockReturnValueOnce({
        exec: jest.fn().mockResolvedValueOnce(mockedCat),
      } as any);

      const id = new Types.ObjectId().toString();
      const result = await service.findOne(id);

      expect(result).toEqual(mockedCat);
      expect(model.findOne).toHaveBeenCalledWith({ _id: id });
    });
  });

  describe('update', () => {
    it('should update a cat', async () => {
      const mockedCat = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      model.findByIdAndUpdate.mockReturnValueOnce({
        exec: jest.fn().mockResolvedValueOnce(mockedCat),
      } as any);

      const id = new Types.ObjectId().toString();
      const updateCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      const result = await service.update(id, updateCatDto);

      expect(result).toEqual(mockedCat);
      expect(model.findByIdAndUpdate).toHaveBeenCalledWith(
        { _id: id },
        updateCatDto,
        { new: true },
      );
    });
  });

  describe('delete', () => {
    it('should delete a cat', async () => {
      const mockedCat = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };
      model.findByIdAndDelete.mockReturnValueOnce({
        exec: jest.fn().mockResolvedValueOnce(mockedCat),
      } as any);

      const id = new Types.ObjectId().toString();
      const result = await service.delete(id);

      expect(result).toEqual(mockedCat);
      expect(model.findByIdAndDelete).toHaveBeenCalledWith({ _id: id });
    });
  });
});



================================================
FILE: sample/06-mongoose/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { CreateCatDto } from './dto/create-cat.dto';
import { UpdateCatDto } from './dto/update-cat.dto';
import { Cat } from './schemas/cat.schema';

@Injectable()
export class CatsService {
  constructor(@InjectModel(Cat.name) private readonly catModel: Model<Cat>) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const createdCat = await this.catModel.create(createCatDto);
    return createdCat;
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }

  async findOne(id: string): Promise<Cat> {
    return this.catModel.findOne({ _id: id }).exec();
  }

  async update(id: string, updateCatDto: UpdateCatDto): Promise<Cat> {
    return this.catModel
      .findByIdAndUpdate({ _id: id }, updateCatDto, { new: true })
      .exec();
  }

  async delete(id: string): Promise<Cat> {
    const deletedCat = await this.catModel
      .findByIdAndDelete({ _id: id })
      .exec();
    return deletedCat;
  }
}



================================================
FILE: sample/06-mongoose/src/cats/dto/create-cat.dto.ts
================================================
export class CreateCatDto {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: sample/06-mongoose/src/cats/dto/update-cat.dto.ts
================================================
export class UpdateCatDto {
  readonly name?: string;
  readonly age?: number;
  readonly breed?: string;
}



================================================
FILE: sample/06-mongoose/src/cats/schemas/cat.schema.ts
================================================
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { HydratedDocument } from 'mongoose';

export type CatDocument = HydratedDocument<Cat>;

@Schema()
export class Cat {
  @Prop()
  name: string;

  @Prop()
  age: number;

  @Prop()
  breed: string;
}

export const CatSchema = SchemaFactory.createForClass(Cat);



================================================
FILE: sample/07-sequelize/README.md
================================================
### Sequelize sample

### Installation

`npm install`

### Running

This example requires docker or a local MySQL installation.  If using a local MySQL database, see `app.module.ts` for credentials, and make sure there are matching credentials in the database and the source code.

#### Docker

There is a `docker-compose.yml` file for starting Docker.

`docker-compose up`

After running the sample, you can stop the Docker container with

`docker-compose down`

### Run the sample

Then, run Nest as usual:

`npm run start`




================================================
FILE: sample/07-sequelize/docker-compose.yml
================================================
version: "3"

services:
  mysql:
    image: mysql:9
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: test
    ports:
      - "3306:3306"



================================================
FILE: sample/07-sequelize/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn'
    },
  },
);


================================================
FILE: sample/07-sequelize/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/sequelize": "11.0.0",
    "mysql2": "3.14.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "sequelize": "6.37.7",
    "sequelize-typescript": "2.1.6",
    "typescript": "5.7.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/07-sequelize/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/07-sequelize/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/07-sequelize/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/07-sequelize/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { UsersModule } from './users/users.module';

@Module({
  imports: [
    SequelizeModule.forRoot({
      dialect: 'mysql',
      host: '127.0.0.1',
      port: 3306,
      username: 'root',
      password: 'root',
      database: 'test',
      autoLoadModels: true,
      synchronize: true,
    }),
    UsersModule,
  ],
})
export class AppModule {}



================================================
FILE: sample/07-sequelize/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/07-sequelize/src/users/users.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { CreateUserDto } from './dto/create-user.dto';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

const createUserDto: CreateUserDto = {
  firstName: 'firstName #1',
  lastName: 'lastName #1',
};

describe('UsersController', () => {
  let usersController: UsersController;
  let usersService: UsersService;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [UsersController],
      providers: [
        {
          provide: UsersService,
          useValue: {
            create: jest
              .fn()
              .mockImplementation((user: CreateUserDto) =>
                Promise.resolve({ id: '1', ...user }),
              ),
            findAll: jest.fn().mockResolvedValue([
              {
                firstName: 'firstName #1',
                lastName: 'lastName #1',
              },
              {
                firstName: 'firstName #2',
                lastName: 'lastName #2',
              },
            ]),
            findOne: jest.fn().mockImplementation((id: string) =>
              Promise.resolve({
                firstName: 'firstName #1',
                lastName: 'lastName #1',
                id,
              }),
            ),
            remove: jest.fn(),
          },
        },
      ],
    }).compile();

    usersController = app.get<UsersController>(UsersController);
    usersService = app.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(usersController).toBeDefined();
  });

  describe('create()', () => {
    it('should create a user', () => {
      expect(usersController.create(createUserDto)).resolves.toEqual({
        id: '1',
        ...createUserDto,
      });
      expect(usersService.create).toHaveBeenCalled();
      expect(usersService.create).toHaveBeenCalledWith(createUserDto);
    });
  });

  describe('findAll()', () => {
    it('should find all users ', () => {
      usersController.findAll();
      expect(usersService.findAll).toHaveBeenCalled();
    });
  });

  describe('findOne()', () => {
    it('should find a user', () => {
      usersController.findOne('1');
      expect(usersService.findOne).toHaveBeenCalled();
      expect(usersController.findOne('1')).resolves.toEqual({
        firstName: 'firstName #1',
        lastName: 'lastName #1',
        id: '1',
      });
    });
  });

  describe('remove()', () => {
    it('should remove the user', () => {
      usersController.remove('2');
      expect(usersService.remove).toHaveBeenCalled();
    });
  });
});



================================================
FILE: sample/07-sequelize/src/users/users.controller.ts
================================================
import { Body, Controller, Delete, Get, Param, Post } from '@nestjs/common';
import { CreateUserDto } from './dto/create-user.dto';
import { User } from './models/user.model';
import { UsersService } from './users.service';

@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  create(@Body() createUserDto: CreateUserDto): Promise<User> {
    return this.usersService.create(createUserDto);
  }

  @Get()
  findAll(): Promise<User[]> {
    return this.usersService.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string): Promise<User> {
    return this.usersService.findOne(id);
  }

  @Delete(':id')
  remove(@Param('id') id: string): Promise<void> {
    return this.usersService.remove(id);
  }
}



================================================
FILE: sample/07-sequelize/src/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { SequelizeModule } from '@nestjs/sequelize';
import { User } from './models/user.model';
import { UsersController } from './users.controller';
import { UsersService } from './users.service';

@Module({
  imports: [SequelizeModule.forFeature([User])],
  providers: [UsersService],
  controllers: [UsersController],
})
export class UsersModule {}



================================================
FILE: sample/07-sequelize/src/users/users.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { User } from './models/user.model';
import { UsersService } from './users.service';
import { getModelToken } from '@nestjs/sequelize';

const usersArray = [
  {
    firstName: 'firstName #1',
    lastName: 'lastName #1',
  },
  {
    firstName: 'firstName #2',
    lastName: 'lastName #2',
  },
];

const oneUser = {
  firstName: 'firstName #1',
  lastName: 'lastName #1',
};

describe('UserService', () => {
  let service: UsersService;
  let model: typeof User;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: getModelToken(User),
          useValue: {
            findAll: jest.fn(() => usersArray),
            findOne: jest.fn(),
            create: jest.fn(() => oneUser),
            remove: jest.fn(),
            destroy: jest.fn(() => oneUser),
          },
        },
      ],
    }).compile();

    service = module.get<UsersService>(UsersService);
    model = module.get<typeof User>(getModelToken(User));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('create()', () => {
    it('should successfully insert a user', () => {
      const oneUser = {
        firstName: 'firstName #1',
        lastName: 'lastName #1',
      };
      expect(
        service.create({
          firstName: 'firstName #1',
          lastName: 'lastName #1',
        }),
      ).toEqual(oneUser);
    });
  });

  describe('findAll()', () => {
    it('should return an array of users', async () => {
      const users = await service.findAll();
      expect(users).toEqual(usersArray);
    });
  });

  describe('findOne()', () => {
    it('should get a single user', () => {
      const findSpy = jest.spyOn(model, 'findOne');
      expect(service.findOne('1'));
      expect(findSpy).toBeCalledWith({ where: { id: '1' } });
    });
  });

  describe('remove()', () => {
    it('should remove a user', async () => {
      const findSpy = jest.spyOn(model, 'findOne').mockReturnValue({
        destroy: jest.fn(),
      } as any);
      const retVal = await service.remove('2');
      expect(findSpy).toBeCalledWith({ where: { id: '2' } });
      expect(retVal).toBeUndefined();
    });
  });
});



================================================
FILE: sample/07-sequelize/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/sequelize';
import { CreateUserDto } from './dto/create-user.dto';
import { User } from './models/user.model';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User)
    private readonly userModel: typeof User,
  ) {}

  create(createUserDto: CreateUserDto): Promise<User> {
    return this.userModel.create({
      firstName: createUserDto.firstName,
      lastName: createUserDto.lastName,
    });
  }

  async findAll(): Promise<User[]> {
    return this.userModel.findAll();
  }

  findOne(id: string): Promise<User> {
    return this.userModel.findOne({
      where: {
        id,
      },
    });
  }

  async remove(id: string): Promise<void> {
    const user = await this.findOne(id);
    await user.destroy();
  }
}



================================================
FILE: sample/07-sequelize/src/users/dto/create-user.dto.ts
================================================
export class CreateUserDto {
  firstName: string;
  lastName: string;
}



================================================
FILE: sample/07-sequelize/src/users/models/user.model.ts
================================================
import { Column, Model, Table } from 'sequelize-typescript';

@Table
export class User extends Model {
  @Column
  firstName: string;

  @Column
  lastName: string;

  @Column({ defaultValue: true })
  isActive: boolean;
}



================================================
FILE: sample/08-webpack/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/08-webpack/nest-cli.json
================================================
{
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
FILE: sample/08-webpack/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "build": "tsc -p tsconfig.build.json",
    "build:dev": "nest build --watch --webpack --webpackPath webpack-hmr.config.js",
    "start": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "echo 'No tests implemented yet.'",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2",
    "typescript": "5.7.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@types/node": "22.14.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "start-server-webpack-plugin": "2.2.5",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "webpack": "5.98.0",
    "webpack-cli": "6.0.1",
    "webpack-node-externals": "3.0.0",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/08-webpack/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/08-webpack/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/08-webpack/webpack-hmr.config.js
================================================
const nodeExternals = require('webpack-node-externals');

module.exports = function(options, webpack) {
  return {
    ...options,
    entry: ['webpack/hot/poll?100', options.entry],
    externals: [
      nodeExternals({
        allowlist: ['webpack/hot/poll?100'],
      }),
    ],
    plugins: [
      ...options.plugins,
      new webpack.WatchIgnorePlugin({
        paths: [/\.js$/, /\.d\.ts$/],
      }),
      new webpack.HotModuleReplacementPlugin(),
    ],
  };
};



================================================
FILE: sample/08-webpack/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/08-webpack/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



================================================
FILE: sample/08-webpack/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: sample/08-webpack/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello() {
    return 'Hello world!';
  }
}



================================================
FILE: sample/08-webpack/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

declare const module: any;

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);

  if (module.hot) {
    module.hot.accept();
    module.hot.dispose(() => app.close());
  }
}
bootstrap();



================================================
FILE: sample/09-babel-example/index.js
================================================
require('@babel/register');
require('./src/main');



================================================
FILE: sample/09-babel-example/jsconfig.json
================================================
{
  "compilerOptions": {
      "target": "ES6",
      "experimentalDecorators": true
  },
  "exclude": [
      "node_modules"
  ]
}


================================================
FILE: sample/09-babel-example/nodemon.json
================================================
{
  "watch": ["src"],
  "ext": "js",
  "ignore": ["src/**/*.spec.js"],
  "exec": "node index --exec babel-node"
}



================================================
FILE: sample/09-babel-example/package.json
================================================
{
  "name": "nest-babel-starter",
  "version": "1.0.0",
  "description": "Nest Babel starter repository",
  "license": "MIT",
  "scripts": {
    "format": "prettier --write \"**/*.js\"",
    "build": "babel src -d dist",
    "start": "babel-node index.js",
    "start:dev": "nodemon",
    "test": "jest",
    "test:cov": "jest --coverage",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/microservices": "11.0.13",
    "@nestjs/websockets": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@babel/cli": "7.27.0",
    "@babel/core": "7.26.10",
    "@babel/node": "7.26.0",
    "@babel/plugin-proposal-decorators": "7.25.9",
    "@babel/plugin-transform-runtime": "7.26.10",
    "@babel/preset-env": "7.26.9",
    "@babel/register": "7.25.9",
    "@babel/runtime": "7.27.0",
    "@nestjs/testing": "11.0.13",
    "jest": "29.7.0",
    "nodemon": "3.1.9",
    "prettier": "3.5.3",
    "supertest": "7.1.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.js$",
    "coverageDirectory": "../coverage"
  }
}



================================================
FILE: sample/09-babel-example/.babelrc
================================================
{
  "presets": ["@babel/preset-env"],
  "plugins": [
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    [
      "@babel/plugin-transform-runtime",
      {
        "regenerator": true
      }
    ]
  ]
}



================================================
FILE: sample/09-babel-example/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/09-babel-example/src/app.module.js
================================================
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {}



================================================
FILE: sample/09-babel-example/src/main.js
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/09-babel-example/src/cats/cats.controller.js
================================================
import {
  Controller,
  Get,
  Post,
  Body,
  Bind,
  Dependencies,
  Param,
} from '@nestjs/common';
import { CatsService } from './cats.service';

@Controller('cats')
@Dependencies(CatsService)
export class CatsController {
  constructor(catsService) {
    this.catsService = catsService;
  }

  @Post()
  @Bind(Body())
  async create(createCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll() {
    return this.catsService.findAll();
  }

  @Get(':id')
  @Bind(Param('id'))
  findOne(id) {
    // logic
  }
}



================================================
FILE: sample/09-babel-example/src/cats/cats.module.js
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: sample/09-babel-example/src/cats/cats.service.js
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class CatsService {
  constructor() {
    this.cats = [];
  }

  create(cat) {
    this.cats.push(cat);
  }

  findAll() {
    return this.cats;
  }
}


================================================
FILE: sample/10-fastify/README.md
================================================
### Fastify sample

Note that if you are running the Nest app on a remote machine, you may need to change the listen address, as per [these instructions](https://docs.nestjs.com/techniques/performance#adapter):

`await app.listen(3000, '0.0.0.0')`


================================================
FILE: sample/10-fastify/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/10-fastify/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-fastify": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/10-fastify/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/10-fastify/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/10-fastify/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/10-fastify/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';
import { CoreModule } from './core/core.module';

@Module({
  imports: [CatsModule, CoreModule],
})
export class AppModule {}



================================================
FILE: sample/10-fastify/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter(),
  );
  app.useGlobalPipes(new ValidationPipe());
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/10-fastify/src/cats/cats.controller.ts
================================================
import { Body, Controller, Get, Param, Post, UseGuards } from '@nestjs/common';
import { Roles } from '../common/decorators/roles.decorator';
import { RolesGuard } from '../common/guards/roles.guard';
import { ParseIntPipe } from '../common/pipes/parse-int.pipe';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@UseGuards(RolesGuard)
@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  @Roles('admin')
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }

  @Get(':id')
  findOne(
    @Param('id', new ParseIntPipe())
    id: number,
  ) {
    // get by ID logic
  }
}



================================================
FILE: sample/10-fastify/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: sample/10-fastify/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: Cat) {
    this.cats.push(cat);
  }

  findAll(): Cat[] {
    return this.cats;
  }
}



================================================
FILE: sample/10-fastify/src/cats/dto/create-cat.dto.ts
================================================
import { IsInt, IsString } from 'class-validator';

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}



================================================
FILE: sample/10-fastify/src/cats/interfaces/cat.interface.ts
================================================
export interface Cat {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: sample/10-fastify/src/common/decorators/roles.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';

export const Roles = (...roles: string[]) => SetMetadata('roles', roles);



================================================
FILE: sample/10-fastify/src/common/guards/roles.guard.ts
================================================
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}

  canActivate(context: ExecutionContext): boolean {
    const roles = this.reflector.get<string[]>('roles', context.getHandler());
    if (!roles) {
      return true;
    }
    const request = context.switchToHttp().getRequest();
    const user = request.user;
    const hasRole = () =>
      !!user.roles.find(role => !!roles.find(item => item === role));

    return user && user.roles && hasRole();
  }
}



================================================
FILE: sample/10-fastify/src/common/interceptors/exception.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  HttpException,
  HttpStatus,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';

@Injectable()
export class ExceptionInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next
      .handle()
      .pipe(
        catchError(err =>
          throwError(
            () =>
              new HttpException(
                'Exception interceptor message',
                HttpStatus.BAD_GATEWAY,
              ),
          ),
        ),
      );
  }
}



================================================
FILE: sample/10-fastify/src/common/middleware/logger.middleware.ts
================================================
import { Injectable, NestMiddleware } from '@nestjs/common';

@Injectable()
export class LoggerMiddleware implements NestMiddleware {
  use(req: any, res: any, next: () => void) {
    console.log(`Request...`);
    next();
  }
}



================================================
FILE: sample/10-fastify/src/common/pipes/parse-int.pipe.ts
================================================
import { BadRequestException } from '@nestjs/common';
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ParseIntPipe implements PipeTransform<string> {
  async transform(value: string, metadata: ArgumentMetadata) {
    const val = parseInt(value, 10);
    if (isNaN(val)) {
      throw new BadRequestException('Validation failed');
    }
    return val;
  }
}



================================================
FILE: sample/10-fastify/src/common/pipes/validation.pipe.ts
================================================
import {
  ArgumentMetadata,
  BadRequestException,
  Injectable,
  PipeTransform,
  Type,
} from '@nestjs/common';
import { plainToInstance } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, metadata: ArgumentMetadata) {
    const { metatype } = metadata;
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }
    const object = plainToInstance(metatype, value);
    const errors = await validate(object);
    if (errors.length > 0) {
      throw new BadRequestException('Validation failed');
    }
    return value;
  }

  private toValidate(metatype: Type<any>): boolean {
    const types = [String, Boolean, Number, Array, Object];
    return !types.find(type => metatype === type);
  }
}



================================================
FILE: sample/10-fastify/src/core/core.module.ts
================================================
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR } from '@nestjs/core';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { TransformInterceptor } from './interceptors/transform.interceptor';

@Module({
  providers: [
    { provide: APP_INTERCEPTOR, useClass: TransformInterceptor },
    { provide: APP_INTERCEPTOR, useClass: LoggingInterceptor },
  ],
})
export class CoreModule {}



================================================
FILE: sample/10-fastify/src/core/interceptors/logging.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    console.log('Before...');

    const now = Date.now();
    return next
      .handle()
      .pipe(tap(() => console.log(`After... ${Date.now() - now}ms`)));
  }
}



================================================
FILE: sample/10-fastify/src/core/interceptors/transform.interceptor.ts
================================================
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

export interface Response<T> {
  data: T;
}

@Injectable()
export class TransformInterceptor<T>
  implements NestInterceptor<T, Response<T>>
{
  intercept(
    context: ExecutionContext,
    next: CallHandler<T>,
  ): Observable<Response<T>> {
    return next.handle().pipe(map(data => ({ data })));
  }
}



================================================
FILE: sample/11-swagger/README.md
================================================
### Swagger sample

### Installation

`npm install`

### Running

Once the application is running you can visit [http://localhost:3000/api](http://localhost:3000/api) to see the Swagger interface.

See [here](https://docs.nestjs.com/recipes/swagger#bootstrap) for more information.


================================================
FILE: sample/11-swagger/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/11-swagger/nest-cli.json
================================================
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "@nestjs/swagger",
        "options": {
          "introspectComments": true
        }
      }
    ]
  }
}



================================================
FILE: sample/11-swagger/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/swagger": "11.1.1",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/11-swagger/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/11-swagger/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/11-swagger/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/11-swagger/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {}



================================================
FILE: sample/11-swagger/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);

  const options = new DocumentBuilder()
    .setTitle('Cats example')
    .setDescription('The cats API description')
    .setVersion('1.0')
    .addTag('cats')
    .addBearerAuth()
    .build();
  const document = SwaggerModule.createDocument(app, options);
  SwaggerModule.setup('api', app, document);

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/11-swagger/src/cats/cats.controller.ts
================================================
import { Body, Controller, Get, Param, Post } from '@nestjs/common';
import {
  ApiBearerAuth,
  ApiOperation,
  ApiResponse,
  ApiTags,
} from '@nestjs/swagger';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './entities/cat.entity';

@ApiBearerAuth()
@ApiTags('cats')
@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  @ApiOperation({ summary: 'Create cat' })
  @ApiResponse({ status: 403, description: 'Forbidden.' })
  async create(@Body() createCatDto: CreateCatDto): Promise<Cat> {
    return this.catsService.create(createCatDto);
  }

  @Get(':id')
  @ApiResponse({
    status: 200,
    description: 'The found record',
    type: Cat,
  })
  findOne(@Param('id') id: string): Cat {
    return this.catsService.findOne(+id);
  }
}



================================================
FILE: sample/11-swagger/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';

@Module({
  controllers: [CatsController],
  providers: [CatsService],
})
export class CatsModule {}



================================================
FILE: sample/11-swagger/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './entities/cat.entity';

@Injectable()
export class CatsService {
  private readonly cats: Cat[] = [];

  create(cat: CreateCatDto): Cat {
    this.cats.push(cat);
    return cat;
  }

  findOne(id: number): Cat {
    return this.cats[id];
  }
}



================================================
FILE: sample/11-swagger/src/cats/dto/create-cat.dto.ts
================================================
import { IsInt, IsString } from 'class-validator';

export class CreateCatDto {
  @IsString()
  readonly name: string;

  @IsInt()
  readonly age: number;

  @IsString()
  readonly breed: string;
}



================================================
FILE: sample/11-swagger/src/cats/entities/cat.entity.ts
================================================
import { ApiProperty } from '@nestjs/swagger';

export class Cat {
  /**
   * The name of the Cat
   * @example Kitty
   */
  name: string;

  @ApiProperty({ example: 1, description: 'The age of the Cat' })
  age: number;

  @ApiProperty({
    example: 'Maine Coon',
    description: 'The breed of the Cat',
  })
  breed: string;
}



================================================
FILE: sample/12-graphql-schema-first/README.md
================================================
### Graphql Apollo sample

### Installation

`npm install`

### Graphql Playground

When the application is running, you can go to [http://localhost:3000/graphql](http://localhost:3000/graphql) to access the GraphQL Playground.  See [here](https://docs.nestjs.com/graphql/quick-start#playground) for more.


================================================
FILE: sample/12-graphql-schema-first/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/12-graphql-schema-first/generate-typings.ts
================================================
import { GraphQLDefinitionsFactory } from '@nestjs/graphql';
import { join } from 'path';

const definitionsFactory = new GraphQLDefinitionsFactory();
definitionsFactory.generate({
  typePaths: ['./src/**/*.graphql'],
  path: join(process.cwd(), 'src/graphql.schema.ts'),
  outputAs: 'class',
});



================================================
FILE: sample/12-graphql-schema-first/nest-cli.json
================================================
{
  "compilerOptions": {
    "assets": ["**/*.graphql"]
  }
}



================================================
FILE: sample/12-graphql-schema-first/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./e2e/jest-e2e.json"
  },
  "dependencies": {
    "@apollo/server": "4.11.3",
    "@graphql-tools/utils": "10.8.6",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "graphql": "16.10.0",
    "graphql-subscriptions": "3.0.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-morph": "25.0.1",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s",
      "!main.(t|j)s",
      "!**/*.module.(t|j)s",
      "!**/*.dto.(t|j)s",
      "!**/*.entity.(t|j)s",
      "!**/*.guard.(t|j)s",
      "!**/*.response.(t|j)s",
      "!**/*.strategy.(t|j)s",
      "!**/*.args.(t|j)s",
      "!**/*.types.(t|j)s",
      "!**/*.directive.(t|j)s",
      "!**/*.plugin.(t|j)s",
      "!**/*.scalar.(t|j)s",
      "!**/*.schema.(t|j)s",
      "!**/node_modules/**"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/12-graphql-schema-first/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/12-graphql-schema-first/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/12-graphql-schema-first/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/12-graphql-schema-first/e2e/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["ts", "tsx", "js", "json"],
  "transform": {
    "^.+\\.tsx?$": "ts-jest"
  },
  "testRegex": "/e2e/.*\\.(e2e-test|e2e-spec).(ts|tsx|js)$",
  "collectCoverageFrom": [
    "src/**/*.{js,jsx,tsx,ts}",
    "!**/node_modules/**",
    "!**/vendor/**"
  ],
  "coverageReporters": ["json", "lcov"]
}



================================================
FILE: sample/12-graphql-schema-first/e2e/cats/cats.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test, TestingModule } from '@nestjs/testing';
import * as request from 'supertest';

import { Cat } from '../../src/graphql.schema';
import { AppModule } from '../../src/app.module';

describe('Cats Resolver (e2e)', () => {
  let app: INestApplication;
  let cat: Cat;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  afterEach(async () => {
    await app.close();
  });

  it('should create a new cat', async () => {
    const query = `
      mutation {
        createCat(createCatInput: { name: "Cat", age: 5 }) {
          id
          name
          age
        }
      }
    `;

    return request(app.getHttpServer())
      .post('/graphql')
      .send({ query })
      .expect(200)
      .expect(response => {
        cat = response.body.data.createCat;
        expect(cat.name).toEqual('Cat');
        expect(cat.age).toEqual(5);
      });
  });

  it('should get all cats', async () => {
    const query = `
      query {
        cats {
          id
          name
          age
        }
      }
    `;

    return request(app.getHttpServer())
      .post('/graphql')
      .send({ query })
      .expect(200)
      .expect(response => {
        const cats = response.body.data.cats;
        expect(cats[0].name).toEqual('Cat');
      });
  });
});



================================================
FILE: sample/12-graphql-schema-first/src/app.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { CatsModule } from './cats/cats.module';
import { upperDirectiveTransformer } from './common/directives/upper-case.directive';

@Module({
  imports: [
    CatsModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),
      installSubscriptionHandlers: true,
    }),
  ],
})
export class AppModule {}



================================================
FILE: sample/12-graphql-schema-first/src/graphql.schema.ts
================================================
/*
 * -------------------------------------------------------
 * THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
 * -------------------------------------------------------
 */

/* tslint:disable */

export class CreateCatInput {
  name?: Nullable<string>;
  age?: Nullable<number>;
}

export abstract class IQuery {
  abstract cats():
    | Nullable<Nullable<Cat>[]>
    | Promise<Nullable<Nullable<Cat>[]>>;

  abstract cat(id: string): Nullable<Cat> | Promise<Nullable<Cat>>;
}

export abstract class IMutation {
  abstract createCat(
    createCatInput?: Nullable<CreateCatInput>,
  ): Nullable<Cat> | Promise<Nullable<Cat>>;
}

export abstract class ISubscription {
  abstract catCreated(): Nullable<Cat> | Promise<Nullable<Cat>>;
}

export class Owner {
  id: number;
  name: string;
  age?: Nullable<number>;
  cats?: Nullable<Cat[]>;
}

export class Cat {
  id?: Nullable<number>;
  name?: Nullable<string>;
  age?: Nullable<number>;
  owner?: Nullable<Owner>;
}

type Nullable<T> = T | null;



================================================
FILE: sample/12-graphql-schema-first/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/12-graphql-schema-first/src/cats/cat-owner.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Cat, Owner } from '../graphql.schema';
import { OwnersService } from '../owners/owners.service';
import { CatOwnerResolver } from './cat-owner.resolver';

describe('CatOwnerResolver', () => {
  let resolver: CatOwnerResolver;
  let ownersService: OwnersService;

  beforeEach(async () => {
    const moduleRef: TestingModule = await Test.createTestingModule({
      providers: [
        CatOwnerResolver,
        {
          provide: OwnersService,
          useValue: {
            findOneById: jest.fn(),
          },
        },
      ],
    }).compile();

    resolver = moduleRef.get(CatOwnerResolver);
    ownersService = moduleRef.get(OwnersService);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should resolve the owner for a cat', async () => {
    const cat: Cat & { ownerId: number } = { id: 1, ownerId: 101 };
    const owner: Owner = { id: 101, name: 'Kambale' };

    jest.spyOn(ownersService, 'findOneById').mockImplementation(() => owner);

    const resolvedOwner = await resolver.owner(cat);

    expect(ownersService.findOneById).toHaveBeenCalledWith(cat.ownerId);
    expect(resolvedOwner).toEqual(owner);
  });
});



================================================
FILE: sample/12-graphql-schema-first/src/cats/cat-owner.resolver.ts
================================================
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { Cat, Owner } from '../graphql.schema';
import { OwnersService } from '../owners/owners.service';

@Resolver('Cat')
export class CatOwnerResolver {
  constructor(private readonly ownersService: OwnersService) {}

  @ResolveField()
  async owner(@Parent() cat: Cat & { ownerId: number }): Promise<Owner> {
    return this.ownersService.findOneById(cat.ownerId);
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.graphql
================================================
type Query {
  cats: [Cat]
  cat(id: ID!): Cat
}

type Mutation {
  createCat(createCatInput: CreateCatInput): Cat
}

type Subscription {
  catCreated: Cat
}

type Owner {
  id: Int!
  name: String!
  age: Int
  cats: [Cat!]
}

type Cat {
  id: Int
  name: String
  age: Int
  owner: Owner
}
"""
Test comment
"""
input CreateCatInput {
  name: String
  age: Int
}



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.guard.ts
================================================
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { GqlExecutionContext } from '@nestjs/graphql';

@Injectable()
export class CatsGuard implements CanActivate {
  canActivate(context: ExecutionContext): boolean {
    const ctx = GqlExecutionContext.create(context);
    return true;
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { OwnersModule } from '../owners/owners.module';
import { CatOwnerResolver } from './cat-owner.resolver';
import { CatsResolver } from './cats.resolver';
import { CatsService } from './cats.service';

@Module({
  imports: [OwnersModule],
  providers: [CatsService, CatsResolver, CatOwnerResolver],
})
export class CatsModule {}



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';

import { Cat } from '../graphql.schema';
import { CatsResolver } from './cats.resolver';
import { CatsService } from './cats.service';

import { MINIMUM_AGE, MINIMUM_AGE_ERROR } from './dto/create-cat.dto';

describe('CatsResolver', () => {
  let resolver: CatsResolver;
  const cat: Cat = { name: 'Cat', age: 5 };

  beforeEach(async () => {
    const moduleRef: TestingModule = await Test.createTestingModule({
      providers: [
        CatsResolver,
        {
          provide: CatsService,
          useValue: {
            create: jest
              .fn()
              .mockImplementation((cat: Cat) => ({ id: 1, ...cat })),
            findAll: jest.fn().mockReturnValue([cat]),
            findOneById: jest
              .fn()
              .mockImplementation((id: number) => ({ ...cat, id })),
          },
        },
      ],
    }).compile();

    resolver = moduleRef.get<CatsResolver>(CatsResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should create a new cat', async () => {
    const newCat = await resolver.create({ name: cat.name, age: cat.age });
    expect(newCat.name).toEqual(cat.name);
    expect(newCat).toEqual({ id: 1, ...cat });
  });

  it(`should fail to save if the age is under ${MINIMUM_AGE}`, async () => {
    try {
      await resolver.create({ name: cat.name, age: 0 });
    } catch (error) {
      expect(error.message).toBe(MINIMUM_AGE_ERROR);
    }
  });

  it('should return all cats', async () => {
    const cats = await resolver.getCats();
    expect(cats.length).toEqual(1);
    expect(cats[0].name).toEqual(cat.name);
  });

  it('should return a cat by id', async () => {
    const cat = await resolver.findOneById(1);
    expect(cat).toEqual({ ...cat, id: 1 });
  });
});



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.resolver.ts
================================================
import { ParseIntPipe, UseGuards } from '@nestjs/common';
import { Args, Mutation, Query, Resolver, Subscription } from '@nestjs/graphql';
import { PubSub } from 'graphql-subscriptions';
import { Cat } from '../graphql.schema';
import { CatsGuard } from './cats.guard';
import { CatsService } from './cats.service';
import { CreateCatDto } from './dto/create-cat.dto';

const pubSub = new PubSub();

@Resolver('Cat')
export class CatsResolver {
  constructor(private readonly catsService: CatsService) {}

  @Query('cats')
  @UseGuards(CatsGuard)
  async getCats() {
    return this.catsService.findAll();
  }

  @Query('cat')
  async findOneById(
    @Args('id', ParseIntPipe)
    id: number,
  ): Promise<Cat> {
    return this.catsService.findOneById(id);
  }

  @Mutation('createCat')
  async create(@Args('createCatInput') args: CreateCatDto): Promise<Cat> {
    const createdCat = this.catsService.create(args);
    pubSub.publish('catCreated', { catCreated: createdCat });
    return createdCat;
  }

  @Subscription('catCreated')
  catCreated() {
    return pubSub.asyncIterableIterator('catCreated');
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { CatsService } from './cats.service';
import { Cat } from 'src/graphql.schema';

describe('CatsService', () => {
  let service: CatsService;
  const cat: Cat = { name: 'Cat', age: 5 };

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CatsService],
    }).compile();

    service = module.get<CatsService>(CatsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should create a new cat', () => {
    const newCat = service.create(cat);
    expect(newCat.name).toEqual(cat.name);
    expect(newCat).toEqual({ id: 1, ...cat });
  });

  it('should return all cats', () => {
    const cats = service.findAll();
    expect(cats.length).toEqual(1);
    expect(cats[0].name).toEqual(cat.name);
  });

  it('should return a cat by id', () => {
    const cat = service.findOneById(1);
    expect(cat).toEqual({ ...cat, id: 1 });
  });

  it('should return undefined if cat not found', () => {
    const cat = service.findOneById(2);
    expect(cat).toBeUndefined();
  });
});



================================================
FILE: sample/12-graphql-schema-first/src/cats/cats.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Cat } from '../graphql.schema';

@Injectable()
export class CatsService {
  private readonly cats: Array<Cat & { ownerId?: number }> = [
    { id: 1, name: 'Cat', age: 5, ownerId: 1 },
  ];

  create(cat: Cat): Cat {
    cat.id = this.cats.length + 1;
    this.cats.push(cat);
    return cat;
  }

  findAll(): Cat[] {
    return this.cats;
  }

  findOneById(id: number): Cat {
    return this.cats.find(cat => cat.id === id);
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/cats/dto/create-cat.dto.ts
================================================
import { Min } from 'class-validator';
import { CreateCatInput } from '../../graphql.schema';

export const MINIMUM_AGE = 1;
export const MINIMUM_AGE_ERROR = `Age must be greater than ${MINIMUM_AGE}`;

export class CreateCatDto extends CreateCatInput {
  @Min(MINIMUM_AGE, { message: MINIMUM_AGE_ERROR })
  age: number;
}



================================================
FILE: sample/12-graphql-schema-first/src/common/directives/upper-case.directive.ts
================================================
import { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';
import { defaultFieldResolver, GraphQLSchema } from 'graphql';

export function upperDirectiveTransformer(
  schema: GraphQLSchema,
  directiveName: string,
) {
  return mapSchema(schema, {
    [MapperKind.OBJECT_FIELD]: fieldConfig => {
      const upperDirective = getDirective(
        schema,
        fieldConfig,
        directiveName,
      )?.[0];

      if (upperDirective) {
        const { resolve = defaultFieldResolver } = fieldConfig;

        // Replace the original resolver with a function that *first* calls
        // the original resolver, then converts its result to upper case
        fieldConfig.resolve = async function (source, args, context, info) {
          const result = await resolve(source, args, context, info);
          if (typeof result === 'string') {
            return result.toUpperCase();
          }
          return result;
        };
        return fieldConfig;
      }
    },
  });
}



================================================
FILE: sample/12-graphql-schema-first/src/common/plugins/logging.plugin.ts
================================================
import { ApolloServerPlugin, GraphQLRequestListener } from '@apollo/server';
import { Plugin } from '@nestjs/apollo';

@Plugin()
export class LoggingPlugin implements ApolloServerPlugin {
  async requestDidStart(): Promise<GraphQLRequestListener<any>> {
    console.log('Request started');
    return {
      async willSendResponse() {
        console.log('Will send response');
      },
    };
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/common/scalars/date.scalar.ts
================================================
import { CustomScalar, Scalar } from '@nestjs/graphql';
import { Kind } from 'graphql';

@Scalar('Date')
export class DateScalar implements CustomScalar<number, Date> {
  description = 'Date custom scalar type';

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: any): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}



================================================
FILE: sample/12-graphql-schema-first/src/owners/owners.module.ts
================================================
import { Module } from '@nestjs/common';
import { OwnersService } from './owners.service';

@Module({
  providers: [OwnersService],
  exports: [OwnersService],
})
export class OwnersModule {}



================================================
FILE: sample/12-graphql-schema-first/src/owners/owners.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Owner } from '../graphql.schema';
import { OwnersService } from './owners.service';

describe('OwnersService', () => {
  let service: OwnersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [OwnersService],
    }).compile();

    service = module.get<OwnersService>(OwnersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('findOneById', () => {
    it('should return an owner if exists', () => {
      const ownerId = 1;
      const expectedOwner: Owner = { id: 1, name: 'Jon', age: 5 };

      const result = service.findOneById(ownerId);

      expect(result).toEqual(expectedOwner);
    });

    it('should return undefined if owner does not exist', () => {
      const ownerId = 9999;

      const result = service.findOneById(ownerId);

      expect(result).toBeUndefined();
    });
  });
});



================================================
FILE: sample/12-graphql-schema-first/src/owners/owners.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Owner } from '../graphql.schema';

@Injectable()
export class OwnersService {
  private readonly owners: Owner[] = [{ id: 1, name: 'Jon', age: 5 }];

  findOneById(id: number): Owner {
    return this.owners.find(owner => owner.id === id);
  }
}



================================================
FILE: sample/13-mongo-typeorm/README.md
================================================
### Mongo TypeORM sample

### Installation

`npm install`

### Running

This example requires docker or a local mongodb installation.  If using a local mongodb, see `app.module.ts` for connection options, and make sure there are matching options for the mongodb installation and the source code.

#### Docker

There is a `docker-compose.yml` file for starting Docker.

`docker-compose up`

After running the sample, you can stop the Docker container with

`docker-compose down`

### Run the sample

Then, run Nest as usual:

`npm run start`



================================================
FILE: sample/13-mongo-typeorm/docker-compose.yml
================================================
version: "3"

services:
  mongodb:
    image: mongo:8.0
    environment:
      - MONGODB_DATABASE="test"
    ports:
      - 27017:27017


================================================
FILE: sample/13-mongo-typeorm/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
    },
  },
);


================================================
FILE: sample/13-mongo-typeorm/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/typeorm": "11.0.0",
    "mongodb": "6.15.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "typeorm": "0.3.22"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/13-mongo-typeorm/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/13-mongo-typeorm/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/13-mongo-typeorm/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/13-mongo-typeorm/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Photo } from './photo/photo.entity';
import { PhotoModule } from './photo/photo.module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'mongodb',
      host: 'localhost',
      database: 'test',
      entities: [Photo],
      synchronize: true,
    }),
    PhotoModule,
  ],
})
export class AppModule {}



================================================
FILE: sample/13-mongo-typeorm/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { PhotoController } from './photo.controller';
import { PhotoService } from './photo.service';

describe('Photo Controller', () => {
  let controller: PhotoController;
  let service: PhotoService;
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PhotoController],
      providers: [
        {
          provide: PhotoService,
          useValue: {
            findAll: jest.fn().mockResolvedValue([
              {
                name: 'Photo #1',
                description: 'Description #1',
                filename: 'Filename #1',
                isPublish: true,
              },
              {
                name: 'Photo #2',
                description: 'Description #2',
                filename: 'Filename #2',
                isPublish: true,
              },
              {
                name: 'Photo #3',
                description: 'Description #3',
                filename: 'Filename #3',
                isPublish: false,
              },
            ]),
          },
        },
      ],
    }).compile();

    controller = module.get<PhotoController>(PhotoController);
    service = module.get<PhotoService>(PhotoService);
  });

  describe('findAll()', () => {
    it('should return an array of photos', () => {
      expect(controller.findAll()).resolves.toEqual([
        {
          name: 'Photo #1',
          description: 'Description #1',
          filename: 'Filename #1',
          isPublish: true,
        },
        {
          name: 'Photo #2',
          description: 'Description #2',
          filename: 'Filename #2',
          isPublish: true,
        },
        {
          name: 'Photo #3',
          description: 'Description #3',
          filename: 'Filename #3',
          isPublish: false,
        },
      ]);
    });
  });
});



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { PhotoService } from './photo.service';
import { Photo } from './photo.entity';

@Controller('photo')
export class PhotoController {
  constructor(private readonly photoService: PhotoService) {}

  @Get()
  findAll(): Promise<Photo[]> {
    return this.photoService.findAll();
  }
}



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.entity.ts
================================================
import { Column, Entity, ObjectId, ObjectIdColumn } from 'typeorm';

@Entity()
export class Photo {
  @ObjectIdColumn()
  id: ObjectId;

  @Column()
  name: string;

  @Column()
  description: string;

  @Column()
  filename: string;

  @Column()
  isPublished: boolean;
}



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.module.ts
================================================
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { PhotoService } from './photo.service';
import { PhotoController } from './photo.controller';
import { Photo } from './photo.entity';

@Module({
  imports: [TypeOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Photo } from './photo.entity';
import { PhotoService } from './photo.service';

describe('CatService', () => {
  let service: PhotoService;
  let repository: Repository<Photo>;

  const photosArray = [
    {
      name: 'Photo #1',
      description: 'Description #1',
      filename: 'Filename #1',
      isPublish: true,
    },
    {
      name: 'Photo #2',
      description: 'Description #2',
      filename: 'Filename #2',
      isPublish: true,
    },
  ];

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PhotoService,
        {
          provide: getRepositoryToken(Photo),
          useValue: {
            find: jest.fn().mockResolvedValue(photosArray),
          },
        },
      ],
    }).compile();

    service = module.get<PhotoService>(PhotoService);
    repository = module.get<Repository<Photo>>(getRepositoryToken(Photo));
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should return an array of photos', async () => {
    const photos = await service.findAll();
    expect(photos).toEqual(photosArray);
  });
});



================================================
FILE: sample/13-mongo-typeorm/src/photo/photo.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { MongoRepository } from 'typeorm';
import { Photo } from './photo.entity';

@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: MongoRepository<Photo>,
  ) {}

  async findAll(): Promise<Photo[]> {
    return this.photoRepository.find();
  }
}



================================================
FILE: sample/14-mongoose-base/README.md
================================================
## Mongoose base sample

### Installation


`npm install`

### Running

This example requires docker or a local mongodb installation.  If using a local mongodb, see `app.module.ts` for connection options, and make sure there are matching options for the mongodb installation and the source code.

#### Docker

There is a `docker-compose.yml` file for starting Docker.

`docker-compose up`

After running the sample, you can stop the Docker container with

`docker-compose down`

### Run the sample

Then, run Nest as usual:

`npm run start`


================================================
FILE: sample/14-mongoose-base/docker-compose.yml
================================================
version: "3"

services:
  mongodb:
    image: mongo:latest
    environment:
      - MONGODB_DATABASE="test"
    ports:
      - 27017:27017


================================================
FILE: sample/14-mongoose-base/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
    },
  },
);


================================================
FILE: sample/14-mongoose-base/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "mongoose": "8.13.2",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/14-mongoose-base/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/14-mongoose-base/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/14-mongoose-base/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/14-mongoose-base/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsModule } from './cats/cats.module';

@Module({
  imports: [CatsModule],
})
export class AppModule {}



================================================
FILE: sample/14-mongoose-base/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/14-mongoose-base/src/cats/cats.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { CatsController } from './cats.controller';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';

describe('CatsController', () => {
  let controller: CatsController;
  let service: CatsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CatsController],
      providers: [
        {
          provide: CatsService,
          useValue: {
            findAll: jest.fn().mockResolvedValue([
              {
                name: 'Cat #1',
                breed: 'Bread #1',
                age: 4,
              },
              {
                name: 'Cat #2',
                breed: 'Breed #2',
                age: 3,
              },
              {
                name: 'Cat #3',
                breed: 'Breed #3',
                age: 2,
              },
            ]),
            create: jest
              .fn()
              .mockImplementation((createCatDto: CreateCatDto) =>
                Promise.resolve({ _id: '1', ...createCatDto }),
              ),
          },
        },
      ],
    }).compile();

    controller = module.get(CatsController);
    service = module.get(CatsService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('create()', () => {
    it('should create a new cat', async () => {
      const createCatDto: CreateCatDto = {
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      };

      expect(controller.create(createCatDto)).resolves.toEqual({
        _id: '1',
        ...createCatDto,
      });
    });
  });

  describe('findAll()', () => {
    it('should get an array of cats', () => {
      expect(controller.findAll()).resolves.toEqual([
        {
          name: 'Cat #1',
          breed: 'Bread #1',
          age: 4,
        },
        {
          name: 'Cat #2',
          breed: 'Breed #2',
          age: 3,
        },
        {
          name: 'Cat #3',
          breed: 'Breed #3',
          age: 2,
        },
      ]);
    });
  });
});



================================================
FILE: sample/14-mongoose-base/src/cats/cats.controller.ts
================================================
import { Controller, Get, Post, Body } from '@nestjs/common';
import { CreateCatDto } from './dto/create-cat.dto';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {}

  @Post()
  async create(@Body() createCatDto: CreateCatDto) {
    return this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }
}



================================================
FILE: sample/14-mongoose-base/src/cats/cats.module.ts
================================================
import { Module } from '@nestjs/common';
import { CatsController } from './cats.controller';
import { CatsService } from './cats.service';
import { catsProviders } from './cats.providers';
import { DatabaseModule } from '../database/database.module';

@Module({
  imports: [DatabaseModule],
  controllers: [CatsController],
  providers: [CatsService, ...catsProviders],
})
export class CatsModule {}



================================================
FILE: sample/14-mongoose-base/src/cats/cats.providers.ts
================================================
import { Mongoose } from 'mongoose';
import { CatSchema } from './schemas/cat.schema';

export const catsProviders = [
  {
    provide: 'CAT_MODEL',
    useFactory: (mongoose: Mongoose) => mongoose.model('Cat', CatSchema),
    inject: ['DATABASE_CONNECTION'],
  },
];



================================================
FILE: sample/14-mongoose-base/src/cats/cats.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Model } from 'mongoose';
import { CatsService } from './cats.service';
import { Cat } from './interfaces/cat.interface';

const mockCat = {
  name: 'Cat #1',
  breed: 'Breed #1',
  age: 4,
};

const catsArray = [
  {
    name: 'Cat #1',
    breed: 'Breed #1',
    age: 4,
  },
  {
    name: 'Cat #2',
    breed: 'Breed #2',
    age: 2,
  },
];

describe('CatService', () => {
  let service: CatsService;
  let model: Model<Cat>;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        CatsService,
        {
          provide: 'CAT_MODEL',
          useValue: {
            new: jest.fn().mockResolvedValue(mockCat),
            constructor: jest.fn().mockResolvedValue(mockCat),
            find: jest.fn(),
            create: jest.fn(),
            save: jest.fn(),
            exec: jest.fn(),
          },
        },
      ],
    }).compile();

    service = module.get(CatsService);
    model = module.get<Model<Cat>>('CAT_MODEL');
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should return all cats', async () => {
    jest.spyOn(model, 'find').mockReturnValue({
      exec: jest.fn().mockResolvedValueOnce(catsArray),
    } as any);
    const cats = await service.findAll();
    expect(cats).toEqual(catsArray);
  });

  it('should insert a new cat', async () => {
    jest.spyOn(model, 'create').mockImplementationOnce(() =>
      Promise.resolve({
        name: 'Cat #1',
        breed: 'Breed #1',
        age: 4,
      } as any),
    );
    const newCat = await service.create({
      name: 'Cat #1',
      breed: 'Breed #1',
      age: 4,
    });
    expect(newCat).toEqual(mockCat);
  });
});



================================================
FILE: sample/14-mongoose-base/src/cats/cats.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { CreateCatDto } from './dto/create-cat.dto';
import { Cat } from './interfaces/cat.interface';

@Injectable()
export class CatsService {
  constructor(@Inject('CAT_MODEL') private readonly catModel: Model<Cat>) {}

  async create(createCatDto: CreateCatDto): Promise<Cat> {
    const createdCat = this.catModel.create(createCatDto);
    return createdCat;
  }

  async findAll(): Promise<Cat[]> {
    return this.catModel.find().exec();
  }
}



================================================
FILE: sample/14-mongoose-base/src/cats/dto/create-cat.dto.ts
================================================
export class CreateCatDto {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: sample/14-mongoose-base/src/cats/interfaces/cat.interface.ts
================================================
import { Document } from 'mongoose';

export interface Cat extends Document {
  readonly name: string;
  readonly age: number;
  readonly breed: string;
}



================================================
FILE: sample/14-mongoose-base/src/cats/schemas/cat.schema.ts
================================================
import * as mongoose from 'mongoose';

export const CatSchema = new mongoose.Schema({
  name: String,
  age: Number,
  breed: String,
});



================================================
FILE: sample/14-mongoose-base/src/database/database.module.ts
================================================
import { Module } from '@nestjs/common';
import { databaseProviders } from './database.providers';

@Module({
  providers: [...databaseProviders],
  exports: [...databaseProviders],
})
export class DatabaseModule {}



================================================
FILE: sample/14-mongoose-base/src/database/database.providers.ts
================================================
import * as mongoose from 'mongoose';

export const databaseProviders = [
  {
    provide: 'DATABASE_CONNECTION',
    useFactory: async (): Promise<typeof mongoose> =>
      await mongoose.connect('mongodb://localhost/test'),
  },
];



================================================
FILE: sample/15-mvc/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
    },
  },
);


================================================
FILE: sample/15-mvc/nodemon.json
================================================
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.spec.ts"],
  "exec": "ts-node ./src/main"
}



================================================
FILE: sample/15-mvc/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "hbs": "4.2.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/15-mvc/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/15-mvc/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/15-mvc/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/15-mvc/public/.gitkeep
================================================



================================================
FILE: sample/15-mvc/src/app.controller.ts
================================================
import { Controller, Get, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index')
  root() {
    return { message: 'Hello world!' };
  }
}



================================================
FILE: sample/15-mvc/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/15-mvc/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import { join } from 'path';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  app.useStaticAssets(join(__dirname, '..', 'public'));
  app.setBaseViewsDir(join(__dirname, '..', 'views'));
  app.setViewEngine('hbs');

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/15-mvc/views/index.hbs
================================================
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>App</title>
</head>

<body>
  {{ message }}
</body>

</html>


================================================
FILE: sample/16-gateways-ws/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
    },
  },
);


================================================
FILE: sample/16-gateways-ws/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/platform-ws": "11.0.13",
    "@nestjs/websockets": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "rimraf": "6.0.1",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2",
    "ws": "8.18.0"
  },
  "devDependencies": {
    "@types/ws": "8.5.13",
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/16-gateways-ws/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/16-gateways-ws/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/16-gateways-ws/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/16-gateways-ws/client/index.html
================================================
<html>
  <head>
    <script>
      const socket = new WebSocket('ws://localhost:8080');
      socket.onopen = function() {
        console.log('Connected');
        socket.send(
          JSON.stringify({
            event: 'events',
            data: 'test',
          }),
        );
        socket.onmessage = function(data) {
          console.log(data);
        };
      };
    </script>
  </head>

  <body></body>
</html>



================================================
FILE: sample/16-gateways-ws/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventsModule } from './events/events.module';

@Module({
  imports: [EventsModule],
})
export class AppModule {}



================================================
FILE: sample/16-gateways-ws/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { WsAdapter } from '@nestjs/platform-ws';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useWebSocketAdapter(new WsAdapter(app));

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/16-gateways-ws/src/events/events.gateway.ts
================================================
import {
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
  WsResponse,
} from '@nestjs/websockets';
import { from, Observable } from 'rxjs';
import { map } from 'rxjs/operators';
import { Server } from 'ws';

@WebSocketGateway(8080)
export class EventsGateway {
  @WebSocketServer()
  server: Server;

  @SubscribeMessage('events')
  onEvent(client: any, data: any): Observable<WsResponse<number>> {
    return from([1, 2, 3]).pipe(map(item => ({ event: 'events', data: item })));
  }
}



================================================
FILE: sample/16-gateways-ws/src/events/events.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventsGateway } from './events.gateway';

@Module({
  providers: [EventsGateway],
})
export class EventsModule {}



================================================
FILE: sample/17-mvc-fastify/README.md
================================================
### Fastify MVC sample

Note that if you are running the Nest app on a remote machine, you may need to change the listen address, as per [these instructions](https://docs.nestjs.com/techniques/performance#adapter):

`await app.listen(3000, '0.0.0.0')`


================================================
FILE: sample/17-mvc-fastify/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-require-imports': 'off'
    },
  },
);


================================================
FILE: sample/17-mvc-fastify/nodemon.json
================================================
{
  "watch": ["src"],
  "ext": "ts",
  "ignore": ["src/**/*.spec.ts"],
  "exec": "ts-node ./src/main"
}



================================================
FILE: sample/17-mvc-fastify/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-fastify": "11.0.13",
    "@fastify/static": "8.1.1",
    "handlebars": "4.7.8",
    "@fastify/view": "11.0.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/17-mvc-fastify/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/17-mvc-fastify/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/17-mvc-fastify/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/17-mvc-fastify/public/.gitkeep
================================================



================================================
FILE: sample/17-mvc-fastify/src/app.controller.ts
================================================
import { Get, Controller, Render } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  @Render('index.hbs')
  root() {
    return { message: 'Hello world!' };
  }
}



================================================
FILE: sample/17-mvc-fastify/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/17-mvc-fastify/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import {
  FastifyAdapter,
  NestFastifyApplication,
} from '@nestjs/platform-fastify';
import { join } from 'path';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create<NestFastifyApplication>(
    AppModule,
    new FastifyAdapter(),
  );
  app.useStaticAssets({
    root: join(__dirname, '..', 'public'),
    prefix: '/public/',
  });
  app.setViewEngine({
    engine: {
      handlebars: require('handlebars'),
    },
    templates: join(__dirname, '..', 'views'),
  });

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/17-mvc-fastify/views/index.hbs
================================================
<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>App</title>
</head>

<body>
  {{ message }}
</body>

</html>


================================================
FILE: sample/18-context/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-require-imports': 'off'
    },
  },
);


================================================
FILE: sample/18-context/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/18-context/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/18-context/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/18-context/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/18-context/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppService } from './app.service';
import { MyDynamicModule } from './my-dynamic.module';

export const dynamicModule = MyDynamicModule.register('foobar');

@Module({
  imports: [dynamicModule],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: sample/18-context/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello(): string {
    return 'Hello world!';
  }
}



================================================
FILE: sample/18-context/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule, dynamicModule } from './app.module';
import { AppService } from './app.service';

async function bootstrap() {
  const app = await NestFactory.createApplicationContext(AppModule);

  const appService = app.get(AppService);
  console.log('AppService#getHello:', appService.getHello());

  // Note that below we can't use `app.select(MyDynamicModule)` otherwise we would get an error as the static version of `MyDynamicModule` was not imported anywhere
  const myDynamicProviderValue = app
    .select(dynamicModule)
    .get('MyDynamicProvider');
  console.log('MyDynamicProvider:', myDynamicProviderValue);

  return app.close();
}
bootstrap();



================================================
FILE: sample/18-context/src/my-dynamic.module.ts
================================================
import { Module, DynamicModule } from '@nestjs/common';

@Module({})
export class MyDynamicModule {
  static register(dyanmicProviderValue: any): DynamicModule {
    return {
      module: MyDynamicModule,
      providers: [
        {
          provide: 'MyDynamicProvider',
          useValue: dyanmicProviderValue,
        },
      ],
      exports: ['MyDynamicProvider'],
    };
  }
}



================================================
FILE: sample/19-auth-jwt/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-require-imports': 'off',
      '@typescript-eslint/no-redundant-type-constituents': 'warn',
    },
  },
);


================================================
FILE: sample/19-auth-jwt/nest-cli.json
================================================
{
  "language": "ts",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/19-auth-jwt/package.json
================================================
{
  "name": "auth-sample",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./e2e/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/jwt": "11.0.0",
    "@nestjs/passport": "11.0.5",
    "@nestjs/platform-express": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/19-auth-jwt/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/19-auth-jwt/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/19-auth-jwt/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/19-auth-jwt/e2e/jest-e2e.json
================================================
{
    "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/e2e/.*\\.(e2e-test|e2e-spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}



================================================
FILE: sample/19-auth-jwt/e2e/app/app.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';

describe('E2E JWT Sample', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const modRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = modRef.createNestApplication();
    await app.init();
  });

  it('should get a JWT then successfully make a call', async () => {
    const loginReq = await request(app.getHttpServer())
      .post('/auth/login')
      .send({ username: 'john', password: 'changeme' })
      .expect(200);

    const token = loginReq.body.access_token;
    return request(app.getHttpServer())
      .get('/auth/profile')
      .set('Authorization', 'Bearer ' + token)
      .expect(200)
      .expect(({ body }) => {
        expect(body.sub).toEqual(1);
        expect(body.username).toEqual('john');
      });
  });

  afterAll(async () => {
    await app.close();
  });
});



================================================
FILE: sample/19-auth-jwt/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AuthModule } from './auth/auth.module';
import { UsersModule } from './users/users.module';

@Module({
  imports: [AuthModule, UsersModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/19-auth-jwt/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/19-auth-jwt/src/auth/auth.controller.ts
================================================
import {
  Body,
  Controller,
  Get,
  HttpCode,
  HttpStatus,
  Post,
  Request,
} from '@nestjs/common';
import { AuthService } from './auth.service';
import { Public } from './decorators/public.decorator';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Public()
  @HttpCode(HttpStatus.OK)
  @Post('login')
  signIn(@Body() signInDto: Record<string, any>) {
    return this.authService.signIn(signInDto.username, signInDto.password);
  }

  @Get('profile')
  getProfile(@Request() req) {
    return req.user;
  }
}



================================================
FILE: sample/19-auth-jwt/src/auth/auth.guard.ts
================================================
import {
  CanActivate,
  ExecutionContext,
  Injectable,
  UnauthorizedException,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { JwtService } from '@nestjs/jwt';
import { Request } from 'express';
import { jwtConstants } from './constants';
import { IS_PUBLIC_KEY } from './decorators/public.decorator';

@Injectable()
export class AuthGuard implements CanActivate {
  constructor(
    private jwtService: JwtService,
    private reflector: Reflector,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [
      context.getHandler(),
      context.getClass(),
    ]);
    if (isPublic) {
      // 💡 See this condition
      return true;
    }

    const request = context.switchToHttp().getRequest();
    const token = this.extractTokenFromHeader(request);
    if (!token) {
      throw new UnauthorizedException();
    }
    try {
      const payload = await this.jwtService.verifyAsync(token, {
        secret: jwtConstants.secret,
      });
      // 💡 We're assigning the payload to the request object here
      // so that we can access it in our route handlers
      request['user'] = payload;
    } catch {
      throw new UnauthorizedException();
    }
    return true;
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers.authorization?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}



================================================
FILE: sample/19-auth-jwt/src/auth/auth.module.ts
================================================
import { Module } from '@nestjs/common';
import { APP_GUARD } from '@nestjs/core';
import { JwtModule } from '@nestjs/jwt';
import { UsersModule } from '../users/users.module';
import { AuthController } from './auth.controller';
import { AuthGuard } from './auth.guard';
import { AuthService } from './auth.service';
import { jwtConstants } from './constants';

@Module({
  imports: [
    UsersModule,
    JwtModule.register({
      global: true,
      secret: jwtConstants.secret,
      signOptions: { expiresIn: '60s' },
    }),
  ],
  providers: [
    AuthService,
    {
      provide: APP_GUARD,
      useClass: AuthGuard,
    },
  ],
  controllers: [AuthController],
  exports: [AuthService],
})
export class AuthModule {}



================================================
FILE: sample/19-auth-jwt/src/auth/auth.service.ts
================================================
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { UsersService } from '../users/users.service';

@Injectable()
export class AuthService {
  constructor(
    private usersService: UsersService,
    private jwtService: JwtService,
  ) {}

  async signIn(username: string, pass: string) {
    const user = await this.usersService.findOne(username);
    if (user?.password !== pass) {
      throw new UnauthorizedException();
    }
    const payload = { username: user.username, sub: user.userId };
    return {
      access_token: await this.jwtService.signAsync(payload),
    };
  }
}



================================================
FILE: sample/19-auth-jwt/src/auth/constants.ts
================================================
export const jwtConstants = {
  secret:
    'DO NOT USE THIS VALUE. INSTEAD, CREATE A COMPLEX SECRET AND KEEP IT SAFE OUTSIDE OF THE SOURCE CODE.',
};



================================================
FILE: sample/19-auth-jwt/src/auth/decorators/public.decorator.ts
================================================
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);



================================================
FILE: sample/19-auth-jwt/src/users/users.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersService } from './users.service';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}



================================================
FILE: sample/19-auth-jwt/src/users/users.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});



================================================
FILE: sample/19-auth-jwt/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';

// This should be a real class/interface representing a user entity
export type User = any;

@Injectable()
export class UsersService {
  private readonly users = [
    {
      userId: 1,
      username: 'john',
      password: 'changeme',
    },
    {
      userId: 2,
      username: 'maria',
      password: 'guess',
    },
  ];

  async findOne(username: string): Promise<User | undefined> {
    return this.users.find(user => user.username === username);
  }
}



================================================
FILE: sample/20-cache/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/20-cache/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "<rootDir>/node_modules/ts-jest/preprocessor.js"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/20-cache/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/cache-manager": "3.0.1",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "cache-manager": "6.4.1",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/20-cache/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/20-cache/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/20-cache/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/20-cache/src/app.controller.ts
================================================
import { CacheInterceptor } from '@nestjs/cache-manager';
import { Controller, Get, UseInterceptors } from '@nestjs/common';

@Controller()
@UseInterceptors(CacheInterceptor)
export class AppController {
  @Get()
  async findAll() {
    // For demonstration purposes, we will simulate a delay
    // to show that the cache is working as expected.
    await new Promise(resolve => setTimeout(resolve, 3000));
    return [{ id: 1, name: 'Nest' }];
  }
}



================================================
FILE: sample/20-cache/src/app.module.ts
================================================
import { CacheModule } from '@nestjs/cache-manager';
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  imports: [CacheModule.register()],
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: sample/20-cache/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/20-cache/src/common/http-cache.interceptor.ts
================================================
import { CacheInterceptor } from '@nestjs/cache-manager';
import { ExecutionContext, Injectable } from '@nestjs/common';

@Injectable()
export class HttpCacheInterceptor extends CacheInterceptor {
  trackBy(context: ExecutionContext): string | undefined {
    const request = context.switchToHttp().getRequest();
    const { httpAdapter } = this.httpAdapterHost;

    const isGetRequest = httpAdapter.getRequestMethod(request) === 'GET';
    const excludePaths = [
      // Routes to be excluded
    ];
    if (
      !isGetRequest ||
      (isGetRequest &&
        excludePaths.includes(httpAdapter.getRequestUrl(request)))
    ) {
      return undefined;
    }
    return httpAdapter.getRequestUrl(request);
  }
}



================================================
FILE: sample/21-serializer/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/21-serializer/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "<rootDir>/node_modules/ts-jest/preprocessor.js"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/21-serializer/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/21-serializer/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/21-serializer/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/21-serializer/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/21-serializer/src/app.controller.ts
================================================
import {
  ClassSerializerInterceptor,
  Controller,
  Get,
  UseInterceptors,
} from '@nestjs/common';
import { RoleEntity } from './entities/role.entity';
import { UserEntity } from './entities/user.entity';

@Controller()
@UseInterceptors(ClassSerializerInterceptor)
export class AppController {
  @Get()
  findOne(): UserEntity {
    return new UserEntity({
      id: 1,
      firstName: 'Kamil',
      lastName: 'Mysliwiec',
      password: 'password',
      role: new RoleEntity({ id: 1, name: 'admin' }),
    });
  }
}



================================================
FILE: sample/21-serializer/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: sample/21-serializer/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/21-serializer/src/entities/role.entity.ts
================================================
export class RoleEntity {
  id: number;
  name: string;

  constructor(partial: Partial<RoleEntity>) {
    Object.assign(this, partial);
  }
}



================================================
FILE: sample/21-serializer/src/entities/user.entity.ts
================================================
import { Exclude, Expose, Transform } from 'class-transformer';
import { RoleEntity } from './role.entity';

export class UserEntity {
  id: number;
  firstName: string;
  lastName: string;

  @Exclude()
  password: string;

  @Expose()
  get fullName(): string {
    return `${this.firstName} ${this.lastName}`;
  }

  @Transform(({ value }) => value.name)
  role: RoleEntity;

  constructor(partial: Partial<UserEntity>) {
    Object.assign(this, partial);
  }
}



================================================
FILE: sample/22-graphql-prisma/README.md
================================================
### Prisma GraphQL schema first sample

This sample project uses sqlite as the relational database. To use a different database, check the [Prisma docs](https://www.prisma.io/docs/getting-started).

### Installation

1. Install dependencies: `npm install`
2. Generate TypeScript type definitions for the GraphQL schema: `npm run generate:typings`
3. Create sqlite database and create tables: `npx prisma db push`
4. Start server: `npm run start:dev`

### Graphql Playground

When the application is running, you can go to [http://localhost:3000/graphql](http://localhost:3000/graphql) to access the GraphQL Playground.  See [here](https://docs.nestjs.com/graphql/quick-start#playground) for more.


================================================
FILE: sample/22-graphql-prisma/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/22-graphql-prisma/generate-typings.ts
================================================
import { GraphQLDefinitionsFactory } from '@nestjs/graphql';
import { join } from 'path';

const definitionsFactory = new GraphQLDefinitionsFactory();
definitionsFactory.generate({
  typePaths: ['./src/**/*.graphql'],
  path: join(process.cwd(), 'src/graphql.schema.ts'),
  outputAs: 'class',
});



================================================
FILE: sample/22-graphql-prisma/nest-cli.json
================================================
{
  "compilerOptions": {
    "assets": ["**/*.graphql"]
  }
}



================================================
FILE: sample/22-graphql-prisma/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "generate:typings": "ts-node generate-typings.ts",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/server": "4.11.3",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "@prisma/client": "6.5.0",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "graphql": "16.10.0",
    "graphql-subscriptions": "3.0.0",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "@typescript-eslint/eslint-plugin": "8.29.0",
    "@typescript-eslint/parser": "8.29.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "prisma": "^6.2.1",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-morph": "25.0.1",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/22-graphql-prisma/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/22-graphql-prisma/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/22-graphql-prisma/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist

# database
prisma/dev.db

# secrets
.env


================================================
FILE: sample/22-graphql-prisma/prisma/schema.prisma
================================================
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id          String  @id @default(uuid())
  title       String
  text        String
  isPublished Boolean @default(false)
}



================================================
FILE: sample/22-graphql-prisma/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { PostsModule } from './posts/posts.module';
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';

@Module({
  imports: [
    PostsModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      typePaths: ['./**/*.graphql'],
      installSubscriptionHandlers: true,
    }),
  ],
})
export class AppModule {}



================================================
FILE: sample/22-graphql-prisma/src/graphql.schema.ts
================================================
/*
 * -------------------------------------------------------
 * THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
 * -------------------------------------------------------
 */

/* tslint:disable */

export class NewPost {
  title: string;
  text: string;
}

export class UpdatePost {
  id: string;
  title?: Nullable<string>;
  text?: Nullable<string>;
  isPublished?: Nullable<boolean>;
}

export class Post {
  id: string;
  title: string;
  text: string;
  isPublished: boolean;
}

export abstract class IQuery {
  abstract posts(): Post[] | Promise<Post[]>;

  abstract post(id: string): Nullable<Post> | Promise<Nullable<Post>>;
}

export abstract class IMutation {
  abstract createPost(input: NewPost): Post | Promise<Post>;

  abstract updatePost(
    input: UpdatePost,
  ): Nullable<Post> | Promise<Nullable<Post>>;

  abstract deletePost(id: string): Nullable<Post> | Promise<Nullable<Post>>;
}

export abstract class ISubscription {
  abstract postCreated(): Nullable<Post> | Promise<Nullable<Post>>;
}

type Nullable<T> = T | null;



================================================
FILE: sample/22-graphql-prisma/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
  console.log(`GraphQL Playground: ${await app.getUrl()}/graphql`);
}
bootstrap();



================================================
FILE: sample/22-graphql-prisma/src/posts/posts.module.ts
================================================
import { Module } from '@nestjs/common';
import { PostsResolvers } from './posts.resolvers';
import { PostsService } from './posts.service';
import { PrismaModule } from '../prisma/prisma.module';

@Module({
  providers: [PostsResolvers, PostsService],
  imports: [PrismaModule],
})
export class PostsModule {}



================================================
FILE: sample/22-graphql-prisma/src/posts/posts.resolvers.ts
================================================
import { Args, Mutation, Query, Resolver, Subscription } from '@nestjs/graphql';
import { PubSub } from 'graphql-subscriptions';
import { NewPost, Post, UpdatePost } from 'src/graphql.schema';
import { PostsService } from './posts.service';

const pubSub = new PubSub();

@Resolver('Post')
export class PostsResolvers {
  constructor(private readonly postService: PostsService) {}

  @Query('posts')
  async posts(): Promise<Post[]> {
    return this.postService.findAll();
  }

  @Query('post')
  async post(@Args('id') args: string): Promise<Post> {
    return this.postService.findOne(args);
  }

  @Mutation('createPost')
  async create(@Args('input') args: NewPost): Promise<Post> {
    const createdPost = await this.postService.create(args);
    pubSub.publish('postCreated', { postCreated: createdPost });
    return createdPost;
  }

  @Mutation('updatePost')
  async update(@Args('input') args: UpdatePost): Promise<Post> {
    return this.postService.update(args);
  }

  @Mutation('deletePost')
  async delete(@Args('id') args: string): Promise<Post> {
    return this.postService.delete(args);
  }

  @Subscription('postCreated')
  postCreated() {
    return pubSub.asyncIterableIterator('postCreated');
  }
}



================================================
FILE: sample/22-graphql-prisma/src/posts/posts.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Post } from '@prisma/client';
import { NewPost, UpdatePost } from 'src/graphql.schema';
import { PrismaService } from '../prisma/prisma.service';

@Injectable()
export class PostsService {
  constructor(private prisma: PrismaService) {}

  async findOne(id: string): Promise<Post | null> {
    return this.prisma.post.findUnique({
      where: {
        id,
      },
    });
  }

  async findAll(): Promise<Post[]> {
    return this.prisma.post.findMany({});
  }

  async create(input: NewPost): Promise<Post> {
    return this.prisma.post.create({
      data: input,
    });
  }

  async update(params: UpdatePost): Promise<Post> {
    const { id, ...params_without_id } = params;

    return this.prisma.post.update({
      where: {
        id,
      },
      data: {
        ...params_without_id,
      },
    });
  }

  async delete(id: string): Promise<Post> {
    return this.prisma.post.delete({
      where: {
        id,
      },
    });
  }
}



================================================
FILE: sample/22-graphql-prisma/src/posts/schema.graphql
================================================
type Post {
  id: ID!
  title: String!
  text: String!
  isPublished: Boolean!
}

input NewPost {
  title: String!
  text: String!
}

input UpdatePost {
  id: ID!
  title: String
  text: String
  isPublished: Boolean
}

type Query {
  posts: [Post!]!
  post(id: ID!): Post
}

type Mutation {
  createPost(input: NewPost!): Post!
  updatePost(input: UpdatePost!): Post
  deletePost(id: ID!): Post
}

type Subscription {
  postCreated: Post
}



================================================
FILE: sample/22-graphql-prisma/src/prisma/prisma.module.ts
================================================
import { Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}



================================================
FILE: sample/22-graphql-prisma/src/prisma/prisma.service.ts
================================================
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}



================================================
FILE: sample/23-graphql-code-first/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/23-graphql-code-first/nest-cli.json
================================================
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "@nestjs/graphql",
        "options": {
          "introspectComments": true
        }
      }
    ]
  }
}



================================================
FILE: sample/23-graphql-code-first/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/server": "4.11.3",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "graphql": "16.10.0",
    "graphql-query-complexity": "1.0.0",
    "graphql-subscriptions": "3.0.0",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "eslint-plugin-import": "2.31.0",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/23-graphql-code-first/schema.gql
================================================
# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

directive @upper on FIELD_DEFINITION

"""recipe"""
type Recipe {
  id: ID!
  description: String
  creationDate: Date!
  ingredients: [String!]!
  title: String!
}

"""Date custom scalar type"""
scalar Date

type Query {
  recipe(id: String!): Recipe!
  recipes(skip: Int! = 0, take: Int! = 25): [Recipe!]!
}

type Mutation {
  addRecipe(newRecipeData: NewRecipeInput!): Recipe!
  removeRecipe(id: String!): Boolean!
}

input NewRecipeInput {
  title: String!
  description: String
  ingredients: [String!]!
}

type Subscription {
  recipeAdded: Recipe!
}


================================================
FILE: sample/23-graphql-code-first/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/23-graphql-code-first/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/23-graphql-code-first/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/23-graphql-code-first/src/app.module.ts
================================================
import { ApolloDriver, ApolloDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { DirectiveLocation, GraphQLDirective } from 'graphql';
import { upperDirectiveTransformer } from './common/directives/upper-case.directive';
import { RecipesModule } from './recipes/recipes.module';

@Module({
  imports: [
    RecipesModule,
    GraphQLModule.forRoot<ApolloDriverConfig>({
      driver: ApolloDriver,
      autoSchemaFile: 'schema.gql',
      transformSchema: schema => upperDirectiveTransformer(schema, 'upper'),
      installSubscriptionHandlers: true,
      buildSchemaOptions: {
        directives: [
          new GraphQLDirective({
            name: 'upper',
            locations: [DirectiveLocation.FIELD_DEFINITION],
          }),
        ],
      },
    }),
  ],
})
export class AppModule {}



================================================
FILE: sample/23-graphql-code-first/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/23-graphql-code-first/src/common/directives/upper-case.directive.ts
================================================
import { getDirective, MapperKind, mapSchema } from '@graphql-tools/utils';
import { defaultFieldResolver, GraphQLSchema } from 'graphql';

export function upperDirectiveTransformer(
  schema: GraphQLSchema,
  directiveName: string,
) {
  return mapSchema(schema, {
    [MapperKind.OBJECT_FIELD]: fieldConfig => {
      const upperDirective = getDirective(
        schema,
        fieldConfig,
        directiveName,
      )?.[0];

      if (upperDirective) {
        const { resolve = defaultFieldResolver } = fieldConfig;

        // Replace the original resolver with a function that *first* calls
        // the original resolver, then converts its result to upper case
        fieldConfig.resolve = async function (source, args, context, info) {
          const result = await resolve(source, args, context, info);
          if (typeof result === 'string') {
            return result.toUpperCase();
          }
          return result;
        };
        return fieldConfig;
      }
    },
  });
}



================================================
FILE: sample/23-graphql-code-first/src/common/plugins/complexity.plugin.ts
================================================
import { ApolloServerPlugin, GraphQLRequestListener } from '@apollo/server';
import { Plugin } from '@nestjs/apollo';
import { GraphQLSchemaHost } from '@nestjs/graphql';
import { GraphQLError } from 'graphql';
import {
  fieldExtensionsEstimator,
  getComplexity,
  simpleEstimator,
} from 'graphql-query-complexity';

@Plugin()
export class ComplexityPlugin implements ApolloServerPlugin {
  constructor(private gqlSchemaHost: GraphQLSchemaHost) {}

  async requestDidStart(): Promise<GraphQLRequestListener<any>> {
    const { schema } = this.gqlSchemaHost;

    return {
      async didResolveOperation({ request, document }) {
        const complexity = getComplexity({
          schema,
          operationName: request.operationName,
          query: document,
          variables: request.variables,
          estimators: [
            fieldExtensionsEstimator(),
            simpleEstimator({ defaultComplexity: 1 }),
          ],
        });
        if (complexity >= 20) {
          throw new GraphQLError(
            `Query is too complex: ${complexity}. Maximum allowed complexity: 20`,
          );
        }
        console.log('Query Complexity:', complexity);
      },
    };
  }
}



================================================
FILE: sample/23-graphql-code-first/src/common/plugins/logging.plugin.ts
================================================
import { ApolloServerPlugin, GraphQLRequestListener } from '@apollo/server';
import { Plugin } from '@nestjs/apollo';

@Plugin()
export class LoggingPlugin implements ApolloServerPlugin {
  async requestDidStart(): Promise<GraphQLRequestListener<any>> {
    console.log('Request started');
    return {
      async willSendResponse() {
        console.log('Will send response');
      },
    };
  }
}



================================================
FILE: sample/23-graphql-code-first/src/common/scalars/date.scalar.ts
================================================
import { CustomScalar, Scalar } from '@nestjs/graphql';
import { Kind, ValueNode } from 'graphql';

@Scalar('Date', type => Date)
export class DateScalar implements CustomScalar<number, Date> {
  description = 'Date custom scalar type';

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}



================================================
FILE: sample/23-graphql-code-first/src/recipes/recipes.module.ts
================================================
import { Module } from '@nestjs/common';
import { DateScalar } from '../common/scalars/date.scalar';
import { RecipesResolver } from './recipes.resolver';
import { RecipesService } from './recipes.service';

@Module({
  providers: [RecipesResolver, RecipesService, DateScalar],
})
export class RecipesModule {}



================================================
FILE: sample/23-graphql-code-first/src/recipes/recipes.resolver.ts
================================================
import { NotFoundException } from '@nestjs/common';
import { Args, Mutation, Query, Resolver, Subscription } from '@nestjs/graphql';
import { PubSub } from 'graphql-subscriptions';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe.model';
import { RecipesService } from './recipes.service';

const pubSub = new PubSub();

@Resolver(of => Recipe)
export class RecipesResolver {
  constructor(private readonly recipesService: RecipesService) {}

  @Query(returns => Recipe)
  async recipe(@Args('id') id: string): Promise<Recipe> {
    const recipe = await this.recipesService.findOneById(id);
    if (!recipe) {
      throw new NotFoundException(id);
    }
    return recipe;
  }

  @Query(returns => [Recipe])
  recipes(@Args() recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return this.recipesService.findAll(recipesArgs);
  }

  @Mutation(returns => Recipe)
  async addRecipe(
    @Args('newRecipeData') newRecipeData: NewRecipeInput,
  ): Promise<Recipe> {
    const recipe = await this.recipesService.create(newRecipeData);
    pubSub.publish('recipeAdded', { recipeAdded: recipe });
    return recipe;
  }

  @Mutation(returns => Boolean)
  async removeRecipe(@Args('id') id: string) {
    return this.recipesService.remove(id);
  }

  @Subscription(returns => Recipe)
  recipeAdded() {
    return pubSub.asyncIterableIterator('recipeAdded');
  }
}



================================================
FILE: sample/23-graphql-code-first/src/recipes/recipes.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe.model';

@Injectable()
export class RecipesService {
  /**
   * MOCK
   * Put some real business logic here
   * Left for demonstration purposes
   */

  async create(data: NewRecipeInput): Promise<Recipe> {
    return {} as any;
  }

  async findOneById(id: string): Promise<Recipe> {
    return {} as any;
  }

  async findAll(recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return [] as Recipe[];
  }

  async remove(id: string): Promise<boolean> {
    return true;
  }
}



================================================
FILE: sample/23-graphql-code-first/src/recipes/dto/new-recipe.input.ts
================================================
import { Field, InputType } from '@nestjs/graphql';
import { IsOptional, Length, MaxLength } from 'class-validator';

@InputType()
export class NewRecipeInput {
  @Field()
  @MaxLength(30)
  title: string;

  @Field({ nullable: true })
  @IsOptional()
  @Length(30, 255)
  description?: string;

  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: sample/23-graphql-code-first/src/recipes/dto/recipes.args.ts
================================================
import { ArgsType, Field, Int } from '@nestjs/graphql';
import { Max, Min } from 'class-validator';

@ArgsType()
export class RecipesArgs {
  @Field(type => Int)
  @Min(0)
  skip = 0;

  @Field(type => Int)
  @Min(1)
  @Max(50)
  take = 25;
}



================================================
FILE: sample/23-graphql-code-first/src/recipes/models/recipe.model.ts
================================================
import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType({ description: 'recipe' })
export class Recipe {
  @Field(type => ID)
  id: string;

  @Directive('@upper')
  title: string;

  @Field({ nullable: true })
  description?: string;

  @Field()
  creationDate: Date;

  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: sample/24-serve-static/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/24-serve-static/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/serve-static": "5.0.3",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/24-serve-static/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/24-serve-static/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/24-serve-static/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/24-serve-static/client/index.html
================================================
<img src="/logo.svg" width="100" />
<h1>Static website</h1>
<ul>
  <li><a href="/link-1">Link 1</a></li>
  <li><a href="/link-2">Link 2</a></li>
  <li><a href="/link-3">Link 3</a></li>
</ul>



================================================
FILE: sample/24-serve-static/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';

@Controller()
export class AppController {
  @Get()
  getHello() {
    return 'Hello, world!';
  }
}



================================================
FILE: sample/24-serve-static/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { ServeStaticModule } from '@nestjs/serve-static';
import { join } from 'path';
import { AppController } from './app.controller';

@Module({
  imports: [
    ServeStaticModule.forRoot({
      rootPath: join(__dirname, '..', 'client'),
      exclude: ['/api/{*test}'],
      serveStaticOptions: {
        fallthrough: false,
      },
    }),
  ],
  controllers: [AppController],
})
export class AppModule {}



================================================
FILE: sample/24-serve-static/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.setGlobalPrefix('api');

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/25-dynamic-modules/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[travis-image]: https://api.travis-ci.org/nestjs/nest.svg?branch=master
[travis-url]: https://travis-ci.org/nestjs/nest
[linux-image]: https://img.shields.io/travis/nestjs/nest/master.svg?label=linux
[linux-url]: https://travis-ci.org/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="blank">Node.js</a> framework for building efficient and scalable server-side applications, heavily inspired by <a href="https://angular.io" target="blank">Angular</a>.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/dm/@nestjs/core.svg" alt="NPM Downloads" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://api.travis-ci.org/nestjs/nest.svg?branch=master" alt="Travis" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://img.shields.io/travis/nestjs/nest/master.svg?label=linux" alt="Linux" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#5" alt="Coverage" /></a>
<a href="https://gitter.im/nestjs/nestjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=body_badge"><img src="https://badges.gitter.im/nestjs/nestjs.svg" alt="Gitter" /></a>
<a href="https://opencollective.com/nest#backer"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec"><img src="https://img.shields.io/badge/Donate-PayPal-dc3d53.svg"/></a>
  <a href="https://twitter.com/nestframework"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

  Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/25-dynamic-modules/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/25-dynamic-modules/nest-cli.json
================================================
{
  "language": "ts",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/25-dynamic-modules/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "dotenv": "16.4.7",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/25-dynamic-modules/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/25-dynamic-modules/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/25-dynamic-modules/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/25-dynamic-modules/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/25-dynamic-modules/config/development.env
================================================
HELLO_MESSAGE = 'Hello there, world!'


================================================
FILE: sample/25-dynamic-modules/src/app.controller.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';

const appServiceMock = {
  getHello: jest.fn().mockImplementation(() => 'Hello World!'),
};

describe('AppController', () => {
  let appController: AppController;
  let appService: AppService;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [
        {
          provide: AppService,
          useValue: appServiceMock,
        },
      ],
    }).compile();

    appService = app.get<AppService>(AppService);
    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return "Hello World!"', () => {
      expect(appController.getHello()).toBe('Hello World!');
      expect(appService.getHello).toHaveBeenCalled();
    });
  });
});



================================================
FILE: sample/25-dynamic-modules/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello(): string {
    return this.appService.getHello();
  }
}



================================================
FILE: sample/25-dynamic-modules/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { ConfigModule } from './config/config.module';

@Module({
  imports: [ConfigModule.register({ folder: './config' })],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: sample/25-dynamic-modules/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { ConfigService } from './config/config.service';

@Injectable()
export class AppService {
  private helloMessage: string;

  constructor(configService: ConfigService) {
    this.helloMessage = configService.get('HELLO_MESSAGE');
  }

  getHello(): string {
    return this.helloMessage;
  }
}



================================================
FILE: sample/25-dynamic-modules/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/25-dynamic-modules/src/config/config.module.ts
================================================
import { DynamicModule, Module } from '@nestjs/common';
import { ConfigService } from './config.service';
import { CONFIG_OPTIONS } from './constants';

export interface ConfigModuleOptions {
  folder: string;
}

@Module({})
export class ConfigModule {
  static register(options: ConfigModuleOptions): DynamicModule {
    return {
      module: ConfigModule,
      providers: [
        {
          provide: CONFIG_OPTIONS,
          useValue: options,
        },
        ConfigService,
      ],
      exports: [ConfigService],
    };
  }
}



================================================
FILE: sample/25-dynamic-modules/src/config/config.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from './config.service';
import { CONFIG_OPTIONS } from './constants';

jest.mock('dotenv');
jest.mock('fs');

describe('ConfigService', () => {
  let service: ConfigService;

  beforeEach(async () => {
    const moduleRef: TestingModule = await Test.createTestingModule({
      providers: [
        ConfigService,
        {
          provide: CONFIG_OPTIONS,
          useValue: {
            folder: 'config',
          },
        },
      ],
    }).compile();

    service = moduleRef.get<ConfigService>(ConfigService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});



================================================
FILE: sample/25-dynamic-modules/src/config/config.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import * as dotenv from 'dotenv';
import * as fs from 'fs';
import * as path from 'path';
import { CONFIG_OPTIONS } from './constants';
import { ConfigOptions, EnvConfig } from './interfaces';

@Injectable()
export class ConfigService {
  private readonly envConfig: EnvConfig;

  constructor(@Inject(CONFIG_OPTIONS) options: ConfigOptions) {
    const filePath = `${process.env.NODE_ENV || 'development'}.env`;
    const envFile = path.resolve(__dirname, '../../', options.folder, filePath);
    this.envConfig = dotenv.parse(fs.readFileSync(envFile));
  }

  get(key: string): string {
    return this.envConfig[key];
  }
}



================================================
FILE: sample/25-dynamic-modules/src/config/constants.ts
================================================
export const CONFIG_OPTIONS = 'CONFIG_OPTIONS';



================================================
FILE: sample/25-dynamic-modules/src/config/interfaces/config-options.interface.ts
================================================
export interface ConfigOptions {
  folder: string;
}



================================================
FILE: sample/25-dynamic-modules/src/config/interfaces/envconfig.interface.ts
================================================
export interface EnvConfig {
  [key: string]: string;
}



================================================
FILE: sample/25-dynamic-modules/src/config/interfaces/index.ts
================================================
export * from './envconfig.interface';
export * from './config-options.interface';



================================================
FILE: sample/26-queues/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[travis-image]: https://api.travis-ci.org/nestjs/nest.svg?branch=master
[travis-url]: https://travis-ci.org/nestjs/nest
[linux-image]: https://img.shields.io/travis/nestjs/nest/master.svg?label=linux
[linux-url]: https://travis-ci.org/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="blank">Node.js</a> framework for building efficient and scalable server-side applications, heavily inspired by <a href="https://angular.io" target="blank">Angular</a>.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/dm/@nestjs/core.svg" alt="NPM Downloads" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://api.travis-ci.org/nestjs/nest.svg?branch=master" alt="Travis" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://img.shields.io/travis/nestjs/nest/master.svg?label=linux" alt="Linux" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#5" alt="Coverage" /></a>
<a href="https://gitter.im/nestjs/nestjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=body_badge"><img src="https://badges.gitter.im/nestjs/nestjs.svg" alt="Gitter" /></a>
<a href="https://opencollective.com/nest#backer"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec"><img src="https://img.shields.io/badge/Donate-PayPal-dc3d53.svg"/></a>
  <a href="https://twitter.com/nestframework"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

  Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/26-queues/docker-compose.yml
================================================
version: "3"
services:
  redis:
    image: redis:alpine
    ports:
      - 6379:6379



================================================
FILE: sample/26-queues/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/26-queues/nest-cli.json
================================================
{
  "language": "ts",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/26-queues/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/bull": "11.0.2",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "bull": "4.16.5",
    "dotenv": "16.4.7",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/bull": "4.10.4",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/26-queues/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/26-queues/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/26-queues/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/26-queues/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/26-queues/src/app.module.ts
================================================
import { BullModule } from '@nestjs/bull';
import { Module } from '@nestjs/common';
import { AudioModule } from './audio/audio.module';

@Module({
  imports: [
    BullModule.forRoot({
      redis: {
        host: 'localhost',
        port: 6379,
      },
    }),
    AudioModule,
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/26-queues/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/26-queues/src/audio/audio.controller.ts
================================================
import { InjectQueue } from '@nestjs/bull';
import { Controller, Post } from '@nestjs/common';
import { Queue } from 'bull';

@Controller('audio')
export class AudioController {
  constructor(@InjectQueue('audio') private readonly audioQueue: Queue) {}

  @Post('transcode')
  async transcode() {
    await this.audioQueue.add('transcode', {
      file: 'audio.mp3',
    });
  }
}



================================================
FILE: sample/26-queues/src/audio/audio.module.ts
================================================
import { BullModule } from '@nestjs/bull';
import { Module } from '@nestjs/common';
import { AudioController } from './audio.controller';
import { AudioProcessor } from './audio.processor';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'audio',
    }),
  ],
  controllers: [AudioController],
  providers: [AudioProcessor],
})
export class AudioModule {}



================================================
FILE: sample/26-queues/src/audio/audio.processor.ts
================================================
import { Process, Processor } from '@nestjs/bull';
import { Logger } from '@nestjs/common';
import { Job } from 'bull';

@Processor('audio')
export class AudioProcessor {
  private readonly logger = new Logger(AudioProcessor.name);

  @Process('transcode')
  handleTranscode(job: Job) {
    this.logger.debug('Start transcoding...');
    this.logger.debug(job.data);
    this.logger.debug('Transcoding completed');
  }
}



================================================
FILE: sample/27-scheduling/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[travis-image]: https://api.travis-ci.org/nestjs/nest.svg?branch=master
[travis-url]: https://travis-ci.org/nestjs/nest
[linux-image]: https://img.shields.io/travis/nestjs/nest/master.svg?label=linux
[linux-url]: https://travis-ci.org/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="blank">Node.js</a> framework for building efficient and scalable server-side applications, heavily inspired by <a href="https://angular.io" target="blank">Angular</a>.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/dm/@nestjs/core.svg" alt="NPM Downloads" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://api.travis-ci.org/nestjs/nest.svg?branch=master" alt="Travis" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://img.shields.io/travis/nestjs/nest/master.svg?label=linux" alt="Linux" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#5" alt="Coverage" /></a>
<a href="https://gitter.im/nestjs/nestjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=body_badge"><img src="https://badges.gitter.im/nestjs/nestjs.svg" alt="Gitter" /></a>
<a href="https://opencollective.com/nest#backer"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec"><img src="https://img.shields.io/badge/Donate-PayPal-dc3d53.svg"/></a>
  <a href="https://twitter.com/nestframework"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

  Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/27-scheduling/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/27-scheduling/nest-cli.json
================================================
{
  "language": "ts",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/27-scheduling/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "@nestjs/schedule": "5.0.1",
    "dotenv": "16.4.7",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/bull": "4.10.4",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/27-scheduling/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/27-scheduling/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/27-scheduling/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/27-scheduling/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/27-scheduling/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { ScheduleModule } from '@nestjs/schedule';
import { TasksModule } from './tasks/tasks.module';

@Module({
  imports: [ScheduleModule.forRoot(), TasksModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/27-scheduling/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/27-scheduling/src/tasks/tasks.module.ts
================================================
import { Module } from '@nestjs/common';
import { TasksService } from './tasks.service';

@Module({
  providers: [TasksService],
})
export class TasksModule {}



================================================
FILE: sample/27-scheduling/src/tasks/tasks.service.ts
================================================
import { Injectable, Logger } from '@nestjs/common';
import { Cron, Interval, Timeout } from '@nestjs/schedule';

@Injectable()
export class TasksService {
  private readonly logger = new Logger(TasksService.name);

  @Cron('45 * * * * *')
  handleCron() {
    this.logger.debug('Called when the second is 45');
  }

  @Interval(10000)
  handleInterval() {
    this.logger.debug('Called every 10 seconds');
  }

  @Timeout(5000)
  handleTimeout() {
    this.logger.debug('Called once after 5 seconds');
  }
}



================================================
FILE: sample/28-sse/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[travis-image]: https://api.travis-ci.org/nestjs/nest.svg?branch=master
[travis-url]: https://travis-ci.org/nestjs/nest
[linux-image]: https://img.shields.io/travis/nestjs/nest/master.svg?label=linux
[linux-url]: https://travis-ci.org/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="blank">Node.js</a> framework for building efficient and scalable server-side applications, heavily inspired by <a href="https://angular.io" target="blank">Angular</a>.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore"><img src="https://img.shields.io/npm/dm/@nestjs/core.svg" alt="NPM Downloads" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://api.travis-ci.org/nestjs/nest.svg?branch=master" alt="Travis" /></a>
<a href="https://travis-ci.org/nestjs/nest"><img src="https://img.shields.io/travis/nestjs/nest/master.svg?label=linux" alt="Linux" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#5" alt="Coverage" /></a>
<a href="https://gitter.im/nestjs/nestjs?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=body_badge"><img src="https://badges.gitter.im/nestjs/nestjs.svg" alt="Gitter" /></a>
<a href="https://opencollective.com/nest#backer"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec"><img src="https://img.shields.io/badge/Donate-PayPal-dc3d53.svg"/></a>
  <a href="https://twitter.com/nestframework"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

  Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/28-sse/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/28-sse/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/28-sse/nest-cli.json
================================================
{
  "compilerOptions": {
    "assets": ["**/*.html"]
  }
}



================================================
FILE: sample/28-sse/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/28-sse/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/28-sse/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}



================================================
FILE: sample/28-sse/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/28-sse/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/28-sse/src/app.controller.ts
================================================
import { Controller, Get, MessageEvent, Res, Sse } from '@nestjs/common';
import { Response } from 'express';
import { readFileSync } from 'fs';
import { join } from 'path';
import { interval, Observable } from 'rxjs';
import { map } from 'rxjs/operators';

@Controller()
export class AppController {
  @Get()
  index(@Res() response: Response) {
    response
      .type('text/html')
      .send(readFileSync(join(__dirname, 'index.html')).toString());
  }

  @Sse('sse')
  sse(): Observable<MessageEvent> {
    return interval(1000).pipe(
      map((_) => ({ data: { hello: 'world' } }) as MessageEvent),
    );
  }
}



================================================
FILE: sample/28-sse/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/28-sse/src/index.html
================================================
<script type="text/javascript">
  const eventSource = new EventSource('/sse');
  eventSource.onmessage = ({ data }) => {
    const message = document.createElement('li');
    message.innerText = 'New message: ' + data;
    document.body.appendChild(message);
  }
</script>


================================================
FILE: sample/28-sse/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, {
    forceCloseConnections: true,
  });
  app.enableShutdownHooks();
  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/29-file-upload/README.md
================================================
# File Upload

A simple example of file upload

## Execution

```sh
npm run start # OR npm run start:dev
# in another terminal
curl http://localhost:3000/file -F 'file=@./package.json' -F 'name=test'
```


================================================
FILE: sample/29-file-upload/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/29-file-upload/jest.json
================================================
{
  "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/src/.*\\.(test|spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/29-file-upload/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./e2e/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/platform-express": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/multer": "1.4.12",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-import": "2.31.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/29-file-upload/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/29-file-upload/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/29-file-upload/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/29-file-upload/e2e/jest-e2e.json
================================================
{
    "moduleFileExtensions": [
        "ts",
        "tsx",
        "js",
        "json"
    ],
    "transform": {
        "^.+\\.tsx?$": "ts-jest"
    },
    "testRegex": "/e2e/.*\\.(e2e-test|e2e-spec).(ts|tsx|js)$",
    "collectCoverageFrom" : ["src/**/*.{js,jsx,tsx,ts}", "!**/node_modules/**", "!**/vendor/**"],
    "coverageReporters": ["json", "lcov"]
}


================================================
FILE: sample/29-file-upload/e2e/app/app.e2e-spec.ts
================================================
import { INestApplication } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { readFileSync } from 'fs';
import * as request from 'supertest';
import { AppModule } from '../../src/app.module';

describe('E2E FileTest', () => {
  let app: INestApplication;

  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = moduleRef.createNestApplication();
    await app.init();
  });

  it('should allow for file uploads', async () => {
    return request(app.getHttpServer())
      .post('/file')
      .attach('file', './package.json')
      .field('name', 'test')
      .expect(201)
      .expect({
        body: {
          name: 'test',
        },
        file: readFileSync('./package.json').toString(),
      });
  });

  it('should allow for file uploads that pass validation', async () => {
    return request(app.getHttpServer())
      .post('/file/pass-validation')
      .attach('file', './package.json')
      .field('name', 'test')
      .expect(201)
      .expect({
        body: {
          name: 'test',
        },
        file: readFileSync('./package.json').toString(),
      });
  });

  it('should throw for file uploads that do not pass validation', async () => {
    return request(app.getHttpServer())
      .post('/file/fail-validation')
      .attach('file', './package.json')
      .field('name', 'test')
      .expect(400);
  });

  it('should throw when file is required but no file is uploaded', async () => {
    return request(app.getHttpServer())
      .post('/file/fail-validation')
      .expect(400);
  });

  it('should allow for optional file uploads with validation enabled (fixes #10017)', () => {
    return request(app.getHttpServer())
      .post('/file/pass-validation')
      .expect(201);
  });

  afterAll(async () => {
    await app.close();
  });
});



================================================
FILE: sample/29-file-upload/src/app.controller.ts
================================================
import {
  Body,
  Controller,
  Get,
  ParseFilePipeBuilder,
  Post,
  UploadedFile,
  UseInterceptors,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { Express } from 'express';
import { AppService } from './app.service';
import { SampleDto } from './sample.dto';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  sayHello() {
    return this.appService.getHello();
  }

  @UseInterceptors(FileInterceptor('file'))
  @Post('file')
  uploadFile(
    @Body() body: SampleDto,
    @UploadedFile() file: Express.Multer.File,
  ) {
    return {
      body,
      file: file.buffer.toString(),
    };
  }

  @UseInterceptors(FileInterceptor('file'))
  @Post('file/pass-validation')
  uploadFileAndPassValidation(
    @Body() body: SampleDto,
    @UploadedFile(
      new ParseFilePipeBuilder()
        .addFileTypeValidator({
          fileType: 'json',
        })
        .build({
          fileIsRequired: false,
        }),
    )
    file?: Express.Multer.File,
  ) {
    return {
      body,
      file: file?.buffer.toString(),
    };
  }

  @UseInterceptors(FileInterceptor('file'))
  @Post('file/fail-validation')
  uploadFileAndFailValidation(
    @Body() body: SampleDto,
    @UploadedFile(
      new ParseFilePipeBuilder()
        .addFileTypeValidator({
          fileType: 'jpg',
        })
        .build(),
    )
    file: Express.Multer.File,
  ) {
    return {
      body,
      file: file.buffer.toString(),
    };
  }
}



================================================
FILE: sample/29-file-upload/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: sample/29-file-upload/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class AppService {
  getHello() {
    return { hello: 'world' };
  }
}



================================================
FILE: sample/29-file-upload/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/29-file-upload/src/sample.dto.ts
================================================
export class SampleDto {
  name: string;
}



================================================
FILE: sample/30-event-emitter/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/30-event-emitter/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/30-event-emitter/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/event-emitter": "3.0.1",
    "@nestjs/platform-express": "11.0.13",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".spec.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/30-event-emitter/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/30-event-emitter/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*", "test/**/*"],
}



================================================
FILE: sample/30-event-emitter/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/30-event-emitter/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/30-event-emitter/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { OrdersModule } from './orders/orders.module';

@Module({
  imports: [EventEmitterModule.forRoot(), OrdersModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/30-event-emitter/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();



================================================
FILE: sample/30-event-emitter/src/orders/orders.controller.ts
================================================
import { Body, Controller, Post } from '@nestjs/common';
import { CreateOrderDto } from './dto/create-order.dto';
import { OrdersService } from './orders.service';

@Controller('orders')
export class OrdersController {
  constructor(private ordersService: OrdersService) {}

  @Post()
  create(@Body() createOrderDto: CreateOrderDto) {
    return this.ordersService.create(createOrderDto);
  }
}



================================================
FILE: sample/30-event-emitter/src/orders/orders.module.ts
================================================
import { Module } from '@nestjs/common';
import { OrderCreatedListener } from './listeners/order-created.listener';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';

@Module({
  controllers: [OrdersController],
  providers: [OrdersService, OrderCreatedListener],
})
export class OrdersModule {}



================================================
FILE: sample/30-event-emitter/src/orders/orders.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { Order } from '../orders/entities/order.entity';
import { CreateOrderDto } from './dto/create-order.dto';
import { OrderCreatedEvent } from './events/order-created.event';

@Injectable()
export class OrdersService {
  public orders: Order[] = [
    {
      id: 1,
      name: 'Order #1',
      description: 'Description order #1',
    },
    {
      id: 2,
      name: 'Order #2',
      description: 'Description order #2',
    },
  ];

  constructor(private eventEmitter: EventEmitter2) {}

  create(createOrderDto: CreateOrderDto) {
    const order = {
      id: this.orders.length + 1,
      ...createOrderDto,
    };
    this.orders.push(order);

    const orderCreatedEvent = new OrderCreatedEvent();
    orderCreatedEvent.name = order.name;
    orderCreatedEvent.description = order.description;
    this.eventEmitter.emit('order.created', orderCreatedEvent);

    return order;
  }
}



================================================
FILE: sample/30-event-emitter/src/orders/dto/create-order.dto.ts
================================================
export class CreateOrderDto {
  name: string;
  description: string;
}



================================================
FILE: sample/30-event-emitter/src/orders/entities/order.entity.ts
================================================
export class Order {
  id: number;
  name: string;
  description: string;
}



================================================
FILE: sample/30-event-emitter/src/orders/events/order-created.event.ts
================================================
export class OrderCreatedEvent {
  name: string;
  description: string;
}



================================================
FILE: sample/30-event-emitter/src/orders/listeners/order-created.listener.ts
================================================
import { Injectable } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { OrderCreatedEvent } from '../events/order-created.event';

@Injectable()
export class OrderCreatedListener {
  @OnEvent('order.created')
  handleOrderCreatedEvent(event: OrderCreatedEvent) {
    // handle and process "OrderCreatedEvent" event
    console.log(event);
  }
}



================================================
FILE: sample/30-event-emitter/test/app.e2e-spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect('Hello World!');
  });

  afterEach(() => app.close());
});



================================================
FILE: sample/30-event-emitter/test/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/README.md
================================================
# GraphQL Federation - Code First

A simple example of GraphQL Federation using Code First approach.

## Execution

Make sure to start the two sub-graph applications first, then the gateway. Otherwise the gateway won't be able to fetch schemas from the sub-graphs.

```sh
cd users-application && npm run start
```

```sh
cd posts-application && npm run start
```

```sh
cd gateway && npm run start
```

## Access the graph

You can reach the gateway under `http://localhost:3001/graphql`

## Query a combined graph

```gql
query getUserWithPosts($userId: ID!) {
  getUser(id: $userId) {
    id
    name
    posts {
      authorId
      id
      title
    }
  }
}
```



================================================
FILE: sample/31-graphql-federation-code-first/gateway/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/31-graphql-federation-code-first/gateway/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/31-graphql-federation-code-first/gateway/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/31-graphql-federation-code-first/gateway/package.json
================================================
{
  "name": "gateway",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "4.11.3",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0",
    "webpack": "5.98.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/gateway/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/31-graphql-federation-code-first/gateway/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/31-graphql-federation-code-first/gateway/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/31-graphql-federation-code-first/gateway/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/31-graphql-federation-code-first/gateway/src/app.module.ts
================================================
import { IntrospectAndCompose } from '@apollo/gateway';
import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloGatewayDriverConfig>({
      driver: ApolloGatewayDriver,
      gateway: {
        supergraphSdl: new IntrospectAndCompose({
          subgraphs: [
            { name: 'users', url: 'http://localhost:3002/graphql' },
            { name: 'posts', url: 'http://localhost:3003/graphql' },
          ],
        }),
      },
    }),
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/31-graphql-federation-code-first/gateway/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3001);
}
bootstrap();



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/31-graphql-federation-code-first/posts-application/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/package.json
================================================
{
  "name": "posts-application",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/federation": "0.38.1",
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "4.11.3",
    "@apollo/subgraph": "2.10.0",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-prettier": "5.2.6",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/31-graphql-federation-code-first/posts-application/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { PostsModule } from './posts/posts.module';

@Module({
  imports: [PostsModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3003);
}
bootstrap();



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/posts.module.ts
================================================
import { ApolloServerPluginInlineTrace } from '@apollo/server/plugin/inlineTrace';
import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { User } from './models/user.model';
import { PostsResolver } from './posts.resolver';
import { PostsService } from './posts.service';
import { UsersResolver } from './users.resolver';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      autoSchemaFile: {
        federation: 2,
      },
      plugins: [ApolloServerPluginInlineTrace()],
      buildSchemaOptions: {
        orphanedTypes: [User],
      },
    }),
  ],
  providers: [PostsService, PostsResolver, UsersResolver],
})
export class PostsModule {}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/posts.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Post } from './models/post.model';
import { PostsResolver } from './posts.resolver';
import { PostsService } from './posts.service';

const mockPost: Post = {
  authorId: 1,
  id: 1,
  title: 'Mock Post',
};

const postsServiceMock = {
  findOne: jest.fn((id: number): Post => mockPost),
  findAll: jest.fn((): Post[] => [mockPost]),
};

describe('PostsResolver', () => {
  let resolver: PostsResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PostsResolver,
        { provide: PostsService, useValue: postsServiceMock },
      ],
    }).compile();

    resolver = module.get<PostsResolver>(PostsResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should query for a single post', () => {
    const result = resolver.post(1);
    expect(result.id).toEqual(1);
  });

  it('should query all posts', () => {
    const result = resolver.posts();
    expect(Array.isArray(result)).toEqual(true);
  });

  it('should resolve the user of a post', () => {
    const result = resolver.user(mockPost);
    expect(result).toEqual(
      expect.objectContaining({
        __typename: 'User',
        id: mockPost.authorId,
      }),
    );
  });
});



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/posts.resolver.ts
================================================
import {
  Args,
  ID,
  Parent,
  Query,
  ResolveField,
  Resolver,
} from '@nestjs/graphql';
import { Post } from './models/post.model';
import { User } from './models/user.model';
import { PostsService } from './posts.service';
import { ParseIntPipe } from '@nestjs/common';

@Resolver((of) => Post)
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {}

  @Query((returns) => Post)
  post(@Args({ name: 'id', type: () => ID }, ParseIntPipe) id: number): Post {
    return this.postsService.findOne(id);
  }

  @Query((returns) => [Post])
  posts(): Post[] {
    return this.postsService.findAll();
  }

  @ResolveField((of) => User)
  user(@Parent() post: Post): any {
    return { __typename: 'User', id: post.authorId };
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/posts.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { PostsService } from './posts.service';

describe('PostsService', () => {
  let service: PostsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PostsService],
    }).compile();

    service = module.get<PostsService>(PostsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should get all posts for an author', () => {
    const result = service.findAllByAuthorId(1);
    expect(result).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          authorId: 1,
        }),
      ]),
    );
  });

  it('should get a single post using the id', () => {
    const result = service.findOne(1);
    expect(result.id).toEqual(1);
  });

  it('should get all posts', () => {
    const result = service.findAll();
    expect(result.length).toEqual(service['posts'].length);
  });
});



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/posts.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Post } from './models/post.model';

@Injectable()
export class PostsService {
  private posts: Post[] = [
    { authorId: 1, id: 1, title: 'Lorem Ipsum' },
    { authorId: 1, id: 2, title: 'Foo' },
    { authorId: 2, id: 3, title: 'Bar' },
    { authorId: 2, id: 4, title: 'Hello World' },
  ];

  findAllByAuthorId(authorId: number): Post[] {
    return this.posts.filter((post) => post.authorId === Number(authorId));
  }

  findOne(postId: number): Post {
    return this.posts.find((post) => post.id === postId);
  }

  findAll(): Post[] {
    return this.posts;
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/users.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Post } from './models/post.model';
import { PostsService } from './posts.service';
import { UsersResolver } from './users.resolver';

const postsServiceMock = {
  findAllByAuthorId: jest.fn((authorId: number): Post[] => {
    return [{ authorId, id: 1, title: 'Post Mock' }];
  }),
};

describe('UsersResolver', () => {
  let resolver: UsersResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersResolver,
        { provide: PostsService, useValue: postsServiceMock },
      ],
    }).compile();

    resolver = module.get<UsersResolver>(UsersResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should resolve posts of a user', () => {
    const result = resolver.posts({ id: 1 });
    expect(result).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          authorId: 1,
        }),
      ]),
    );
  });
});



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/users.resolver.ts
================================================
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { Post } from './models/post.model';
import { User } from './models/user.model';
import { PostsService } from './posts.service';

@Resolver((of) => User)
export class UsersResolver {
  constructor(private readonly postsService: PostsService) {}

  @ResolveField((of) => [Post])
  public posts(@Parent() user: User): Post[] {
    return this.postsService.findAllByAuthorId(user.id);
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/models/post.model.ts
================================================
import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';
import { User } from './user.model';

@ObjectType()
@Directive('@key(fields: "id")')
export class Post {
  @Field((type) => ID)
  id: number;

  @Field()
  title: string;

  @Field((type) => Int)
  authorId: number;

  @Field((type) => User)
  user?: User;
}



================================================
FILE: sample/31-graphql-federation-code-first/posts-application/src/posts/models/user.model.ts
================================================
import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';
import { Post } from './post.model';

@ObjectType()
@Directive('@extends')
@Directive('@key(fields: "id")')
export class User {
  @Field((type) => ID)
  @Directive('@external')
  id: number;

  @Field((type) => [Post])
  posts?: Post[];
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/31-graphql-federation-code-first/users-application/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/31-graphql-federation-code-first/users-application/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/package.json
================================================
{
  "name": "users-application",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "4.11.3",
    "@apollo/subgraph": "2.10.0",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "webpack": "5.98.0",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/31-graphql-federation-code-first/users-application/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3002);
}
bootstrap();



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/users.module.ts
================================================
import { ApolloServerPluginInlineTrace } from '@apollo/server/plugin/inlineTrace';
import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service';

@Module({
  providers: [UsersResolver, UsersService],
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      autoSchemaFile: {
        federation: 2,
      },
      plugins: [ApolloServerPluginInlineTrace()],
    }),
  ],
})
export class UsersModule {}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/users.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { User } from './models/user.model';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service';

const usersServiceMock = {
  findById: jest.fn((id: number): User => {
    return { id, name: 'Mocked User' };
  }),
};

describe('UsersResolver', () => {
  let resolver: UsersResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersResolver,
        { provide: UsersService, useValue: usersServiceMock },
      ],
    }).compile();

    resolver = module.get<UsersResolver>(UsersResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should query a user by its id', () => {
    const result = resolver.getUser(1);
    expect(result.id).toEqual(1);
  });

  it('should resolve a reference', () => {
    const result = resolver.resolveReference({ __typename: 'User', id: 1 });
    expect(result.id).toEqual(1);
  });
});



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/users.resolver.ts
================================================
import { Args, ID, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { User } from './models/user.model';
import { UsersService } from './users.service';

@Resolver((of) => User)
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query((returns) => User)
  getUser(@Args({ name: 'id', type: () => ID }) id: number): User {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: number }): User {
    return this.usersService.findById(reference.id);
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/users.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should fetch a user by its id', () => {
    const user = service.findById(1);
    expect(user.id).toEqual(1);
  });
});



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { User } from './models/user.model';

@Injectable()
export class UsersService {
  private users: User[] = [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Richard Roe' },
  ];

  findById(id: number): User {
    return this.users.find((user) => user.id === Number(id));
  }
}



================================================
FILE: sample/31-graphql-federation-code-first/users-application/src/users/models/user.model.ts
================================================
import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType()
@Directive('@key(fields: "id")')
export class User {
  @Field((type) => ID)
  id: number;

  @Field()
  name: string;
}



================================================
FILE: sample/32-graphql-federation-schema-first/README.md
================================================
# GraphQL Federation - Schema First

A simple example of GraphQL Federation using Schema First approach.

## Execution

Make sure to start the two sub-graph applications first, then the gateway. Otherwise the gateway won't be able to fetch schemas from the sub-graphs.

```sh
cd users-application && npm run start
```

```sh
cd posts-application && npm run start
```

```sh
cd gateway && npm run start
```

## Access the graph

You can reach the gateway under `http://localhost:3002/graphql`

## Query a combined graph

```gql
query getUserWithPosts($userId: ID!) {
  getUser(id: $userId) {
    id
    name
    posts {
      authorId
      id
      title
    }
  }
}
```



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/32-graphql-federation-schema-first/gateway/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/package.json
================================================
{
  "name": "gateway",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "^4.11.3",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/32-graphql-federation-schema-first/gateway/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/32-graphql-federation-schema-first/gateway/src/app.module.ts
================================================
import { IntrospectAndCompose } from '@apollo/gateway';
import { ApolloGatewayDriver, ApolloGatewayDriverConfig } from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloGatewayDriverConfig>({
      driver: ApolloGatewayDriver,
      gateway: {
        supergraphSdl: new IntrospectAndCompose({
          subgraphs: [
            { name: 'users', url: 'http://localhost:3000/graphql' },
            { name: 'posts', url: 'http://localhost:3001/graphql' },
          ],
        }),
      },
    }),
  ],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/32-graphql-federation-schema-first/gateway/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3002);
}
bootstrap();



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/package.json
================================================
{
  "name": "posts-application",
  "version": "1.0.0",
  "description": "",
  "author": "Flusinerd",
  "private": true,
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "^4.11.3",
    "@apollo/subgraph": "2.10.0",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { PostsModule } from './posts/posts.module';

@Module({
  imports: [PostsModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3001);
}
bootstrap();



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.graphql
================================================
type Post @key(fields: "id") {
  id: ID!
  title: String!
  body: String!
  authorId: Int!
  user: User
}

extend type User @key(fields: "id") {
  id: ID! @external
  posts: [Post]
}

extend type Query {
  getPosts: [Post]
  findPost(id: ID!): Post
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.interfaces.ts
================================================
import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';

export interface Post {
  id: number;
  title: string;
  authorId: number;
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.module.ts
================================================
import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { PostsResolver } from './posts.resolver';
import { PostsService } from './posts.service';
import { UsersResolver } from './users.resolver';

@Module({
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      typePaths: ['**/*.graphql'],
    }),
  ],
  providers: [PostsService, PostsResolver, UsersResolver],
})
export class PostsModule {}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Post } from './models/post.model';
import { PostsResolver } from './posts.resolver';
import { PostsService } from './posts.service';

const mockPost: Post = {
  authorId: 1,
  id: 1,
  title: 'Mock Post',
};

const postsServiceMock = {
  findOne: jest.fn((id: number): Post => mockPost),
  findAll: jest.fn((): Post[] => [mockPost]),
};

describe('PostsResolver', () => {
  let resolver: PostsResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        PostsResolver,
        { provide: PostsService, useValue: postsServiceMock },
      ],
    }).compile();

    resolver = module.get<PostsResolver>(PostsResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should query for a single post', () => {
    const result = resolver.findPost(1);
    expect(result.id).toEqual(1);
  });

  it('should query all posts', () => {
    const result = resolver.getPosts();
    expect(Array.isArray(result)).toEqual(true);
  });

  it('should resolve the user of a post', () => {
    const result = resolver.user(mockPost);
    expect(result).toEqual(
      expect.objectContaining({
        __typename: 'User',
        id: mockPost.authorId,
      }),
    );
  });
});



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.resolver.ts
================================================
import {
  Args,
  ID,
  Parent,
  Query,
  ResolveField,
  Resolver,
} from '@nestjs/graphql';
import { Post } from './posts.interfaces';
import { PostsService } from './posts.service';

@Resolver('Post')
export class PostsResolver {
  constructor(private readonly postsService: PostsService) {}

  @Query('findPost')
  findPost(@Args({ name: 'id', type: () => ID }) id: number) {
    return this.postsService.findOne(id);
  }

  @Query('getPosts')
  getPosts() {
    return this.postsService.findAll();
  }

  @ResolveField('user')
  user(@Parent() post: Post): any {
    return { __typename: 'User', id: post.authorId };
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { PostsService } from './posts.service';

describe('PostsService', () => {
  let service: PostsService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PostsService],
    }).compile();

    service = module.get<PostsService>(PostsService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should get all posts for an author', () => {
    const result = service.findOneByAuthorId(1);
    expect(result).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          authorId: 1,
        }),
      ]),
    );
  });

  it('should get a single post using the id', () => {
    const result = service.findOne(1);
    expect(result.id).toEqual(1);
  });

  it('should get all posts', () => {
    const result = service.findAll();
    expect(result.length).toEqual(service['posts'].length);
  });
});



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/posts.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { Post } from './posts.interfaces';

@Injectable()
export class PostsService {
  private posts: Post[] = [
    { authorId: 1, id: 1, title: 'Lorem Ipsum' },
    { authorId: 1, id: 2, title: 'Foo' },
    { authorId: 2, id: 3, title: 'Bar' },
    { authorId: 2, id: 4, title: 'Hello World' },
  ];

  findOneByAuthorId(authorId: number) {
    return this.posts.filter((post) => post.authorId === Number(authorId));
  }

  findOne(postId: number) {
    return this.posts.find((post) => post.id === postId);
  }

  findAll() {
    return this.posts;
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/users.interfaces.ts
================================================
import { Post } from './posts.interfaces';

export interface User {
  id: number;
  posts?: Post[];
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/users.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { Post } from './models/post.model';
import { PostsService } from './posts.service';
import { UsersResolver } from './users.resolver';

const postsServiceMock = {
  findOneByAuthorId: jest.fn((authorId: number): Post[] => {
    return [{ authorId, id: 1, title: 'Post Mock' }];
  }),
};

describe('UsersResolver', () => {
  let resolver: UsersResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersResolver,
        { provide: PostsService, useValue: postsServiceMock },
      ],
    }).compile();

    resolver = module.get<UsersResolver>(UsersResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should resolve posts of a user', () => {
    const result = resolver.posts({ id: 1 });
    expect(result).toEqual(
      expect.arrayContaining([
        expect.objectContaining({
          authorId: 1,
        }),
      ]),
    );
  });
});



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/users.resolver.ts
================================================
import { Parent, ResolveField, Resolver } from '@nestjs/graphql';
import { PostsService } from './posts.service';
import { User } from './users.interfaces';

@Resolver('User')
export class UsersResolver {
  constructor(private readonly postsService: PostsService) {}

  @ResolveField('posts')
  public posts(@Parent() user: User) {
    return this.postsService.findOneByAuthorId(user.id);
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/models/post.model.ts
================================================
import { Directive, Field, ID, Int, ObjectType } from '@nestjs/graphql';
import { User } from './user.model';

@ObjectType()
@Directive('@key(fields: "id")')
export class Post {
  @Field((type) => ID)
  id: number;

  @Field()
  title: string;

  @Field((type) => Int)
  authorId: number;

  @Field((type) => User)
  user?: User;
}



================================================
FILE: sample/32-graphql-federation-schema-first/posts-application/src/posts/models/user.model.ts
================================================
import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';
import { Post } from './post.model';

@ObjectType()
@Directive('@extends')
@Directive('@key(fields: "id")')
export class User {
  @Field((type) => ID)
  @Directive('@external')
  id: number;

  @Field((type) => [Post])
  posts?: Post[];
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/README.md
================================================
<p align="center">
  <a href="https://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="https://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Installation

```bash
$ npm install
```

## Running the app

```bash
# development
$ npm run start

# watch mode
$ npm run start:dev

# production mode
$ npm run start:prod
```

## Test

```bash
# unit tests
$ npm run test

# e2e tests
$ npm run test:e2e

# test coverage
$ npm run test:cov
```

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://kamilmysliwiec.com)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](LICENSE).



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/32-graphql-federation-schema-first/users-application/nest-cli.json
================================================
{
  "collection": "@nestjs/schematics",
  "sourceRoot": "src"
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/package.json
================================================
{
  "name": "users-application",
  "version": "1.0.0",
  "description": "",
  "author": "Flusinerd",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@apollo/gateway": "2.10.0",
    "@apollo/server": "^4.11.3",
    "@apollo/subgraph": "2.10.0",
    "@nestjs/apollo": "13.0.4",
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/platform-express": "11.0.13",
    "graphql": "16.10.0",
    "graphql-tools": "9.0.18",
    "reflect-metadata": "0.2.2",
    "rimraf": "6.0.1",
    "rxjs": "7.8.2",
    "ts-morph": "25.0.1"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/jest": "29.5.14",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "eslint": "9.23.0",
    "eslint-config-prettier": "10.1.1",
    "eslint-plugin-prettier": "5.2.6",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/.gitignore
================================================
# compiled output
/dist
/node_modules

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json


================================================
FILE: sample/32-graphql-federation-schema-first/users-application/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
  controllers: [],
  providers: [],
})
export class AppModule {}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.graphql
================================================
type User @key(fields: "id") {
  id: ID!
  name: String!
}

extend type Query {
  getUser(id: ID!): User
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.module.ts
================================================
import {
  ApolloFederationDriver,
  ApolloFederationDriverConfig,
} from '@nestjs/apollo';
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service';

@Module({
  providers: [UsersResolver, UsersService],
  imports: [
    GraphQLModule.forRoot<ApolloFederationDriverConfig>({
      driver: ApolloFederationDriver,
      typePaths: ['**/*.graphql'],
    }),
  ],
})
export class UsersModule {}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.resolver.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { User } from './models/user.model';
import { UsersResolver } from './users.resolver';
import { UsersService } from './users.service';

const usersServiceMock = {
  findById: jest.fn((id: number): User => {
    return { id, name: 'Mocked User' };
  }),
};

describe('UsersResolver', () => {
  let resolver: UsersResolver;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersResolver,
        { provide: UsersService, useValue: usersServiceMock },
      ],
    }).compile();

    resolver = module.get<UsersResolver>(UsersResolver);
  });

  it('should be defined', () => {
    expect(resolver).toBeDefined();
  });

  it('should query a user by its id', () => {
    const result = resolver.getUser(1);
    expect(result.id).toEqual(1);
  });

  it('should resolve a reference', () => {
    const result = resolver.resolveReference({ __typename: 'User', id: 1 });
    expect(result.id).toEqual(1);
  });
});



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.resolver.ts
================================================
import { Args, ID, Query, Resolver, ResolveReference } from '@nestjs/graphql';
import { UsersService } from './users.service';

@Resolver('User')
export class UsersResolver {
  constructor(private usersService: UsersService) {}

  @Query()
  getUser(@Args({ name: 'id', type: () => ID }) id: number) {
    return this.usersService.findById(id);
  }

  @ResolveReference()
  resolveReference(reference: { __typename: string; id: number }) {
    return this.usersService.findById(reference.id);
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.service.spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { UsersService } from './users.service';

describe('UsersService', () => {
  let service: UsersService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [UsersService],
    }).compile();

    service = module.get<UsersService>(UsersService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  it('should fetch a user by its id', () => {
    const user = service.findById(1);
    expect(user.id).toEqual(1);
  });
});



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/users.service.ts
================================================
import { Injectable } from '@nestjs/common';

@Injectable()
export class UsersService {
  private users = [
    { id: 1, name: 'John Doe' },
    { id: 2, name: 'Richard Roe' },
  ];

  findById(id: number) {
    return this.users.find((user) => user.id === Number(id));
  }
}



================================================
FILE: sample/32-graphql-federation-schema-first/users-application/src/users/models/user.model.ts
================================================
import { Directive, Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType()
@Directive('@key(fields: "id")')
export class User {
  @Field((type) => ID)
  id: number;

  @Field()
  name: string;
}



================================================
FILE: sample/33-graphql-mercurius/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/33-graphql-mercurius/nest-cli.json
================================================
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "@nestjs/graphql",
        "options": {
          "introspectComments": true
        }
      }
    ]
  }
}



================================================
FILE: sample/33-graphql-mercurius/package.json
================================================
{
  "name": "nest-typescript-starter",
  "version": "1.0.0",
  "description": "Nest TypeScript starter repository",
  "license": "MIT",
  "scripts": {
    "prebuild": "rimraf dist",
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint '{src,apps,libs,test}/**/*.ts' --fix",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "echo 'No e2e tests implemented yet.'"
  },
  "dependencies": {
    "@nestjs/common": "11.0.13",
    "@nestjs/core": "11.0.13",
    "@nestjs/graphql": "13.0.4",
    "@nestjs/mercurius": "13.0.4",
    "@nestjs/platform-fastify": "11.0.13",
    "class-transformer": "0.5.1",
    "class-validator": "0.14.1",
    "graphql": "16.10.0",
    "mercurius": "16.1.0",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.8.2"
  },
  "devDependencies": {
    "@eslint/eslintrc": "3.3.1",
    "@eslint/js": "9.23.0",
    "@nestjs/cli": "11.0.6",
    "@nestjs/schematics": "11.0.3",
    "@nestjs/testing": "11.0.13",
    "@types/express": "5.0.1",
    "@types/node": "22.14.0",
    "@types/supertest": "6.0.3",
    "jest": "29.7.0",
    "prettier": "3.5.3",
    "supertest": "7.1.0",
    "ts-jest": "29.3.1",
    "ts-loader": "9.5.2",
    "ts-node": "10.9.2",
    "tsconfig-paths": "4.2.0",
    "eslint": "9.23.0",
    "eslint-plugin-prettier": "5.2.6",
    "globals": "16.0.0",
    "typescript": "5.7.3",
    "typescript-eslint": "8.29.0"
  }
}



================================================
FILE: sample/33-graphql-mercurius/schema.gql
================================================
# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

"""recipe """
type Recipe {
  id: ID!
  title: String!
  description: String
  creationDate: Date!
  ingredients: [String!]!
}

"""Date custom scalar type"""
scalar Date

type Query {
  recipe(id: String!): Recipe!
  recipes(skip: Int! = 0, take: Int! = 25): [Recipe!]!
}

type Mutation {
  addRecipe(newRecipeData: NewRecipeInput!): Recipe!
  removeRecipe(id: String!): Boolean!
}

input NewRecipeInput {
  title: String!
  description: String
  ingredients: [String!]!
}

type Subscription {
  recipeAdded: Recipe!
}


================================================
FILE: sample/33-graphql-mercurius/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "dist", "test", "**/*spec.ts"]
}



================================================
FILE: sample/33-graphql-mercurius/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"]
}



================================================
FILE: sample/33-graphql-mercurius/.gitignore
================================================
# dependencies
/node_modules

# IDE
/.idea
/.awcache
/.vscode

# misc
npm-debug.log

# example
/quick-start

# tests
/test
/coverage
/.nyc_output

# dist
/dist


================================================
FILE: sample/33-graphql-mercurius/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { GraphQLModule } from '@nestjs/graphql';
import { MercuriusDriver, MercuriusDriverConfig } from '@nestjs/mercurius';
import { RecipesModule } from './recipes/recipes.module';

@Module({
  imports: [
    RecipesModule,
    GraphQLModule.forRoot<MercuriusDriverConfig>({
      driver: MercuriusDriver,
      autoSchemaFile: 'schema.gql',
      subscription: true,
      graphiql: true,
    }),
  ],
})
export class AppModule {}



================================================
FILE: sample/33-graphql-mercurius/src/main.ts
================================================
import { ValidationPipe } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { FastifyAdapter } from '@nestjs/platform-fastify';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule, new FastifyAdapter());
  app.useGlobalPipes(new ValidationPipe());

  await app.listen(3000);
  console.log(`Application is running on: ${await app.getUrl()}`);
}
bootstrap();



================================================
FILE: sample/33-graphql-mercurius/src/common/scalars/date.scalar.ts
================================================
import { CustomScalar, Scalar } from '@nestjs/graphql';
import { Kind, ValueNode } from 'graphql';

@Scalar('Date', type => Date)
export class DateScalar implements CustomScalar<number, Date> {
  description = 'Date custom scalar type';

  parseValue(value: number): Date {
    return new Date(value); // value from the client
  }

  serialize(value: Date): number {
    return value.getTime(); // value sent to the client
  }

  parseLiteral(ast: ValueNode): Date {
    if (ast.kind === Kind.INT) {
      return new Date(ast.value);
    }
    return null;
  }
}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/recipes.module.ts
================================================
import { Module } from '@nestjs/common';
import { DateScalar } from '../common/scalars/date.scalar';
import { RecipesResolver } from './recipes.resolver';
import { RecipesService } from './recipes.service';

@Module({
  providers: [RecipesResolver, RecipesService, DateScalar],
})
export class RecipesModule {}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/recipes.resolver.ts
================================================
import { NotFoundException } from '@nestjs/common';
import {
  Args,
  Context,
  Mutation,
  Query,
  Resolver,
  Subscription,
} from '@nestjs/graphql';
import { PubSub } from 'mercurius';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe.model';
import { RecipesService } from './recipes.service';

@Resolver(of => Recipe)
export class RecipesResolver {
  constructor(private readonly recipesService: RecipesService) {}

  @Query(returns => Recipe)
  async recipe(@Args('id') id: string): Promise<Recipe> {
    const recipe = await this.recipesService.findOneById(id);
    if (!recipe) {
      throw new NotFoundException(id);
    }
    return recipe;
  }

  @Query(returns => [Recipe])
  recipes(@Args() recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return this.recipesService.findAll(recipesArgs);
  }

  @Mutation(returns => Recipe)
  async addRecipe(
    @Args('newRecipeData') newRecipeData: NewRecipeInput,
    @Context('pubsub') pubSub: PubSub,
  ): Promise<Recipe> {
    const recipe = await this.recipesService.create(newRecipeData);
    pubSub.publish({ topic: 'recipeAdded', payload: { recipeAdded: recipe } });
    return recipe;
  }

  @Mutation(returns => Boolean)
  async removeRecipe(@Args('id') id: string) {
    return this.recipesService.remove(id);
  }

  @Subscription(returns => Recipe)
  recipeAdded(@Context('pubsub') pubSub: PubSub) {
    return pubSub.subscribe('recipeAdded');
  }
}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/recipes.service.ts
================================================
import { Injectable } from '@nestjs/common';
import { NewRecipeInput } from './dto/new-recipe.input';
import { RecipesArgs } from './dto/recipes.args';
import { Recipe } from './models/recipe.model';

@Injectable()
export class RecipesService {
  /**
   * MOCK
   * Put some real business logic here
   * Left for demonstration purposes
   */

  async create(data: NewRecipeInput): Promise<Recipe> {
    return {} as any;
  }

  async findOneById(id: string): Promise<Recipe> {
    return {} as any;
  }

  async findAll(recipesArgs: RecipesArgs): Promise<Recipe[]> {
    return [] as Recipe[];
  }

  async remove(id: string): Promise<boolean> {
    return true;
  }
}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/dto/new-recipe.input.ts
================================================
import { Field, InputType } from '@nestjs/graphql';
import { IsOptional, Length, MaxLength } from 'class-validator';

@InputType()
export class NewRecipeInput {
  @Field()
  @MaxLength(30)
  title: string;

  @Field({ nullable: true })
  @IsOptional()
  @Length(30, 255)
  description?: string;

  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/dto/recipes.args.ts
================================================
import { ArgsType, Field, Int } from '@nestjs/graphql';
import { Max, Min } from 'class-validator';

@ArgsType()
export class RecipesArgs {
  @Field(type => Int)
  @Min(0)
  skip = 0;

  @Field(type => Int)
  @Min(1)
  @Max(50)
  take = 25;
}



================================================
FILE: sample/33-graphql-mercurius/src/recipes/models/recipe.model.ts
================================================
import { Field, ID, ObjectType } from '@nestjs/graphql';

@ObjectType({ description: 'recipe ' })
export class Recipe {
  @Field(type => ID)
  id: string;

  @Field()
  title: string;

  @Field({ nullable: true })
  description?: string;

  @Field()
  creationDate: Date;

  @Field(type => [String])
  ingredients: string[];
}



================================================
FILE: sample/34-using-esm-packages/README.md
================================================
## About using ESM with Jest

We are using the `--experimental-vm-modules` NodeJS v18 flag as explained at https://jestjs.io/docs/ecmascript-modules

You can see how to mock an ESM package at [`app.controller.spec.ts`](./src/app.controller.spec.ts)  
You can see how that the real import of an ESM package is working at [`app.e2e-spec.ts`](./test/app.e2e-spec.ts)


================================================
FILE: sample/34-using-esm-packages/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
      '@typescript-eslint/no-implied-eval': 'warn'
    },
  },
);


================================================
FILE: sample/34-using-esm-packages/nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
FILE: sample/34-using-esm-packages/package.json
================================================
{
  "name": "34-using-esm-packages",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "type": "commonjs",
  "engines": {
    "node": ">=18.8"
  },
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "test": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" jest",
    "test:watch": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" jest --watch",
    "test:cov": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" jest --coverage",
    "test:debug": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "NODE_OPTIONS=\"$NODE_OPTIONS --experimental-vm-modules\" jest --config ./test/jest-e2e.json"
  },
  "dependencies": {
    "@nestjs/common": "11.x",
    "@nestjs/core": "11.x",
    "@nestjs/platform-express": "11.x",
    "delay": "6.x",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.x",
    "superjson": "2.x"
  },
  "devDependencies": {
    "@nestjs/cli": "11.x",
    "@nestjs/schematics": "11.x",
    "@nestjs/testing": "11.x",
    "@types/express": "5.x",
    "@types/jest": "29.x",
    "@types/node": "22.x",
    "@types/supertest": "6.x",
    "@typescript-eslint/eslint-plugin": "8.x",
    "@typescript-eslint/parser": "8.x",
    "eslint": "9.x",
    "eslint-config-prettier": "10.x",
    "eslint-plugin-prettier": "5.x",
    "jest": "29.7.0",
    "prettier": "3.x",
    "source-map-support": "0.5.21",
    "supertest": "7.x",
    "ts-jest": "29.x",
    "ts-loader": "9.x",
    "ts-node": "10.x",
    "tsconfig-paths": "4.x",
    "typescript": "5.7.x"
  },
  "jest": {
    "moduleFileExtensions": [
      "js",
      "json",
      "ts"
    ],
    "rootDir": "src",
    "testRegex": ".*\\.spec\\.ts$",
    "transform": {
      "^.+\\.(t|j)s$": "ts-jest"
    },
    "collectCoverageFrom": [
      "**/*.(t|j)s"
    ],
    "coverageDirectory": "../coverage",
    "testEnvironment": "node"
  }
}



================================================
FILE: sample/34-using-esm-packages/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/34-using-esm-packages/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================
FILE: sample/34-using-esm-packages/.gitignore
================================================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json



================================================
FILE: sample/34-using-esm-packages/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/34-using-esm-packages/src/app.controller.spec.ts
================================================
// NOTE: This tests nothing, it's just to show how to mock an ESM package
import { jest } from '@jest/globals';

// We will test the mocking feature from Jest to mock the `superjson` package for testing purposes
// We must call this before loading the module!
jest.unstable_mockModule('superjson', () => ({
  stringify: () => 'noop',
}));

import { Test, TestingModule } from '@nestjs/testing';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { superJSONProvider } from './superjson.provider';

describe('AppController', () => {
  let appController: AppController;

  beforeEach(async () => {
    const app: TestingModule = await Test.createTestingModule({
      controllers: [AppController],
      providers: [superJSONProvider, AppService],
    }).compile();

    appController = app.get<AppController>(AppController);
  });

  describe('root', () => {
    it('should return the stub object', () => {
      expect(appController.getHello()).toEqual({
        jsonString: 'noop',
      });
    });
  });
});



================================================
FILE: sample/34-using-esm-packages/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello() {
    return this.appService.getHello();
  }
}



================================================
FILE: sample/34-using-esm-packages/src/app.module.ts
================================================
import { Module, OnModuleInit } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { superJSONProvider } from './superjson.provider';
import { importEsmPackage } from './import-esm-package';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [
    superJSONProvider, // One way to load the ESM package is turning it into a custom provider

    AppService,
  ],
})
export class AppModule implements OnModuleInit {
  // This is just to test the 'delay' ESM-only package
  async onModuleInit() {
    // Another way to load the ESM package is using our 'import' function directly when we need to use it
    const delay =
      await importEsmPackage<typeof import('delay').default>('delay');

    console.time('delay');
    await delay(1_000);
    console.timeEnd('delay');
  }
}



================================================
FILE: sample/34-using-esm-packages/src/app.service.ts
================================================
import { Inject, Injectable } from '@nestjs/common';
import { superJSONProvider, SuperJSON } from './superjson.provider';

@Injectable()
export class AppService {
  constructor(
    @Inject(superJSONProvider.provide)
    private readonly superjson: SuperJSON,
  ) {}

  getHello() {
    const jsonString = this.superjson.stringify({ big: 10n });

    return {
      jsonString,
    };
  }
}



================================================
FILE: sample/34-using-esm-packages/src/import-esm-package.ts
================================================
/**
 * This is the same as `import()` expression that is supposed to load ESM packages while
 * preventing TypeScript from transpiling the import statement into `require()`.
 */
export const importEsmPackage = async <ReturnType>(
  packageName: string,
): Promise<ReturnType> =>
  new Function(`return import('${packageName}')`)().then(
    (loadedModule: unknown) => loadedModule['default'] ?? loadedModule,
  );



================================================
FILE: sample/34-using-esm-packages/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();



================================================
FILE: sample/34-using-esm-packages/src/superjson.provider.ts
================================================
import { FactoryProvider } from '@nestjs/common';
import { importEsmPackage } from './import-esm-package';

// We must expose only the type definition!
export type { SuperJSON } from 'superjson';

export const superJSONProvider: FactoryProvider = {
  provide: 'SuperJSON',
  useFactory: () => importEsmPackage('superjson'),
};



================================================
FILE: sample/34-using-esm-packages/test/app.e2e-spec.ts
================================================
import { Test, TestingModule } from '@nestjs/testing';
import { INestApplication } from '@nestjs/common';
import * as request from 'supertest';
import { AppModule } from './../src/app.module';

describe('AppController (e2e)', () => {
  let app: INestApplication;

  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();

    app = moduleFixture.createNestApplication();
    await app.init();
  });

  it('/ (GET)', () => {
    return request(app.getHttpServer())
      .get('/')
      .expect(200)
      .expect(
        JSON.stringify({
          jsonString:
            '{"json":{"big":"10"},"meta":{"values":{"big":["bigint"]}}}',
        }),
      );
  });
});



================================================
FILE: sample/34-using-esm-packages/test/jest-e2e.json
================================================
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/README.md
================================================
## How this works

We are relying on the [`--experimental-require-module`](https://nodejs.org/api/modules.html#loading-ecmascript-modules-using-require) NodeJS v22 flag so that we can load ESM packages using `require()`

Check out the `package.json` file.

## About automated tests with Jest

While Jest [does not supports](https://github.com/jestjs/jest/issues/15275) the `--experimental-require-module` flag, we cannot use Jest in this project!


================================================
FILE: sample/35-use-esm-package-after-node22/eslint.config.mjs
================================================
// @ts-check
import eslint from '@eslint/js';
import eslintPluginPrettierRecommended from 'eslint-plugin-prettier/recommended';
import globals from 'globals';
import tseslint from 'typescript-eslint';

export default tseslint.config(
  {
    ignores: ['eslint.config.mjs'],
  },
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  eslintPluginPrettierRecommended,
  {
    languageOptions: {
      globals: {
        ...globals.node,
        ...globals.jest,
      },
      ecmaVersion: 5,
      sourceType: 'module',
      parserOptions: {
        projectService: true,
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
  {
    rules: {
      '@typescript-eslint/no-explicit-any': 'off',
      '@typescript-eslint/no-floating-promises': 'off',
      '@typescript-eslint/no-unsafe-argument': 'warn',
      '@typescript-eslint/ban-ts-comment': 'off',
      '@typescript-eslint/no-unsafe-return': 'off',
      '@typescript-eslint/no-unsafe-assignment': 'warn',
      '@typescript-eslint/no-unsafe-call': 'warn',
      '@typescript-eslint/no-unsafe-member-access': 'warn',
      '@typescript-eslint/require-await': 'warn',
      '@typescript-eslint/no-unused-vars': 'warn',
      '@typescript-eslint/unbound-method': 'warn',
    },
  },
);


================================================
FILE: sample/35-use-esm-package-after-node22/nest-cli.json
================================================
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/package.json
================================================
{
  "name": "35-using-esm-package-after-node22",
  "version": "0.0.1",
  "description": "",
  "author": "",
  "private": true,
  "license": "UNLICENSED",
  "type": "commonjs",
  "engines": {
    "node": ">=22"
  },
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start --exec \"node --experimental-require-module\"",
    "start:dev": "nest start --exec \"node --experimental-require-module\" --watch",
    "start:debug": "nest start --exec \"node --experimental-require-module\" --debug --watch",
    "start:prod": "node --experimental-require-module dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix"
  },
  "dependencies": {
    "@nestjs/common": "11.x",
    "@nestjs/core": "11.x",
    "@nestjs/platform-express": "11.x",
    "reflect-metadata": "0.2.2",
    "rxjs": "7.x",
    "superjson": "2.x"
  },
  "devDependencies": {
    "@nestjs/cli": "11.x",
    "@nestjs/schematics": "11.x",
    "@nestjs/testing": "11.x",
    "@types/express": "5.x",
    "@types/node": "22.x",
    "@types/supertest": "6.x",
    "@typescript-eslint/eslint-plugin": "8.x",
    "@typescript-eslint/parser": "8.x",
    "eslint": "9.x",
    "eslint-config-prettier": "10.x",
    "eslint-plugin-prettier": "5.x",
    "prettier": "3.x",
    "source-map-support": "0.5.21",
    "supertest": "7.x",
    "ts-loader": "9.x",
    "ts-node": "10.x",
    "tsconfig-paths": "4.x",
    "typescript": "5.7.x"
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/tsconfig.build.json
================================================
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}



================================================
FILE: sample/35-use-esm-package-after-node22/tsconfig.json
================================================
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/.gitignore
================================================
# compiled output
/dist
/node_modules
/build

# Logs
logs
*.log
npm-debug.log*
pnpm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*

# OS
.DS_Store

# Tests
/coverage
/.nyc_output

# IDEs and editors
/.idea
.project
.classpath
.c9/
*.launch
.settings/
*.sublime-workspace

# IDE - VSCode
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# temp directory
.temp
.tmp

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json



================================================
FILE: sample/35-use-esm-package-after-node22/.prettierrc
================================================
{
  "singleQuote": true,
  "trailingComma": "all"
}


================================================
FILE: sample/35-use-esm-package-after-node22/src/app.controller.ts
================================================
import { Controller, Get } from '@nestjs/common';
import { AppService } from './app.service';

@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}

  @Get()
  getHello() {
    return this.appService.getJsonStringExample();
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/src/app.module.ts
================================================
import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}



================================================
FILE: sample/35-use-esm-package-after-node22/src/app.service.ts
================================================
import { Injectable } from '@nestjs/common';
import superjson from 'superjson';

@Injectable()
export class AppService {
  getJsonStringExample() {
    const jsonString = superjson.stringify({ big: 10n });

    return {
      jsonString,
    };
  }
}



================================================
FILE: sample/35-use-esm-package-after-node22/src/main.ts
================================================
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  await app.listen(3000);
}
bootstrap();



================================================
FILE: scripts/prepare.sh
================================================
# 1. Build fresh packages and move them to sample and integration directories
npm run build &>/dev/null

# 2. Start docker containers to perform integration tests
npm run test:docker:up


================================================
FILE: scripts/run-integration.sh
================================================
# 1. Build fresh packages and move them integration dit
npm run build &>/dev/null

# 2. Start docker containers to perform integration tests
npm run test:docker:up

# 3. Run integration tests
npm run test:integration


================================================
FILE: scripts/test.sh
================================================
# Run both unit and integration tests
npm run test
npm run test:integration


================================================
FILE: scripts/update-samples.sh
================================================
for d in ./sample/*/ ; do (cd "$d" && printf $d\\n && ncu -u && npm i --package-lock-only); done


================================================
FILE: tools/benchmarks/check-benchmarks.ts
================================================
import { codechecks, CodeChecksReport } from '@codechecks/client';
import * as bytes from 'bytes';
import { Benchmarks, getBenchmarks, LIBS } from './get-benchmarks';

const markdownTable = require('markdown-table');
const benchmarksKey = 'nest/performance-benchmark';

export default async function checkBenchmarks() {
  const currentBenchmarks = await getBenchmarks();
  await codechecks.saveValue(benchmarksKey, currentBenchmarks);

  if (!codechecks.isPr()) {
    return;
  }
  const baselineBenchmarks =
    await codechecks.getValue<Benchmarks>(benchmarksKey);
  const report = getCodechecksReport(currentBenchmarks, baselineBenchmarks);
  await codechecks.report(report);
}

function getCodechecksReport(
  current: Benchmarks,
  baseline: Benchmarks | undefined,
): CodeChecksReport {
  const diff = getDiff(current, baseline);

  const shortDescription = getShortDescription(baseline, diff);
  const longDescription = getLongDescription(current, baseline, diff);

  return {
    name: 'Benchmarks',
    status: 'success',
    shortDescription,
    longDescription,
  };
}

function getShortDescription(
  baseline: Benchmarks | undefined,
  diff: BenchmarksDiff,
): string {
  if (!baseline) {
    return 'New benchmarks generated';
  }

  const avgDiff = getAverageDiff(diff);
  if (avgDiff > 0) {
    return `Performance improved by ${avgDiff.toFixed(
      2,
    )}% on average, good job!`;
  }
  if (avgDiff === 0) {
    return `No changes in performance detected`;
  }
  if (avgDiff < 0) {
    return `Performance decreased by ${avgDiff.toFixed(
      2,
    )}% on average, be careful!`;
  }
}

function getLongDescription(
  current: Benchmarks,
  baseline: Benchmarks | undefined,
  diff: BenchmarksDiff,
): string {
  function printTableRow(id: string, label: string): string[] {
    return [
      label,
      current[id].requestsPerSec.toFixed(0),
      current[id].transferPerSec,
      baseline ? formatPerc(diff[id].requestsPerSecDiff) : '-',
      baseline ? formatPerc(diff[id].transferPerSecDiff) : '-',
    ];
  }

  const table = [
    ['', 'Req/sec', 'Trans/sec', 'Req/sec DIFF', 'Trans/sec DIFF'],
    printTableRow('nest', 'Nest-Express'),
    printTableRow('nest-fastify', 'Nest-Fastify'),
    printTableRow('express', 'Express'),
    printTableRow('fastify', 'Fastify'),
  ];

  return markdownTable(table);
}

function getDiff(
  current: Benchmarks,
  baseline: Benchmarks | undefined,
): BenchmarksDiff {
  const diff: BenchmarksDiff = {};
  for (const l of LIBS) {
    if (!baseline) {
      diff[l] = undefined;
      continue;
    }

    const currentValue = current[l];
    const baselineValue = baseline[l];

    diff[l] = {
      requestsPerSecDiff: getRequestDiff(
        currentValue.requestsPerSec,
        baselineValue.requestsPerSec,
      ),
      transferPerSecDiff: getTransferDiff(
        currentValue.transferPerSec,
        baselineValue.transferPerSec,
      ),
    };
  }
  return diff;
}

function getTransferDiff(
  currentTransfer: string,
  baselineTransfer: string,
): number {
  return 1 - bytes.parse(currentTransfer) / bytes.parse(baselineTransfer);
}

function getAverageDiff(diff: BenchmarksDiff) {
  return (
    (diff['nest'].transferPerSecDiff +
      diff['nest'].requestsPerSecDiff +
      diff['nest-fastify'].transferPerSecDiff +
      diff['nest-fastify'].requestsPerSecDiff) /
    4
  );
}

function getRequestDiff(currentRequest: number, baselineRequest: number) {
  return 1 - currentRequest / baselineRequest;
}

interface BenchmarkDiff {
  transferPerSecDiff: number | undefined;
  requestsPerSecDiff: number | undefined;
}

interface BenchmarksDiff {
  [lib: string]: BenchmarkDiff;
}

function formatPerc(n: number) {
  return (n > 0 ? '+' : '') + (n * 100).toFixed(2) + '%';
}



================================================
FILE: tools/benchmarks/get-benchmarks.ts
================================================
import wrkPkg = require('wrk');
import { spawn } from 'child_process';
import { join } from 'path';

export interface Benchmarks {
  [lib: string]: WrkResults;
}

const wrk = (options: any) =>
  new Promise<WrkResults>((resolve, reject) =>
    wrkPkg(options, (err: any, result: any) =>
      err ? reject(err) : resolve(result),
    ),
  );

const sleep = (time: number) =>
  new Promise(resolve => setTimeout(resolve, time));

const BENCHMARK_PATH = join(__dirname, '../../benchmarks');
export const LIBS = ['express', 'fastify', 'nest', 'nest-fastify'];

async function runBenchmarkOfLib(lib: string): Promise<WrkResults> {
  const libPath = join(BENCHMARK_PATH, `${lib}.js`);
  const process = spawn('node', [libPath], {
    detached: true,
  });

  process.stdout!.on('data', data => {
    console.log(`stdout: ${data}`);
  });
  process.stderr!.on('data', data => {
    console.log(`stderr: ${data}`);
  });

  process.unref();

  await sleep(2000);

  const result = await wrk({
    threads: 8,
    duration: '10s',
    connections: 1024,
    url: 'http://localhost:3000',
  });

  process.kill();
  return result;
}

export async function getBenchmarks() {
  const results: Benchmarks = {};
  for await (const lib of LIBS) {
    const result = await runBenchmarkOfLib(lib);
    results[lib] = result;
  }
  return results;
}

interface WrkResults {
  transferPerSec: string;
  requestsPerSec: number;
  connectErrors: string;
  readErrors: string;
  writeErrors: string;
  timeoutErrors: string;
  requestsTotal: number;
  durationActual: string;
  transferTotal: string;
  latencyAvg: string;
  latencyStdev: string;
  latencyMax: string;
  latencyStdevPerc: number;
  rpsAvg: string;
  rpsStdev: string;
  rpsMax: string;
  rpsStdevPerc: number;
}



================================================
FILE: tools/benchmarks/report-contents.md
================================================
Short description (shown on main PR screen): Performance improved 0.13% on average.

Long description (after clicking details):

|                | Req/sec | Trans/sec | Req/sec DIFF | Trans/sec DIFF | Req vs Express | Trans vs Fastify |
| -------------- | ------- | --------- | ------------ | -------------- | -------------- | ---------------- |
| NestJS-Express | 3.37MB  | 16375.58  | +0.15%       | +0.14%         | 80.62%         | 80.37%           |
| NestJS-Fastify | 4.78MB  | 32728.51  | +0.12%       | +0.12          | 64.76%         | 64.25%           |
| Express        | 4.18MB  | 20374.59  | 0%           | 0%             | -              | -                |
| Fastify        | 7.38MB  | 50938     | 0%           | 0%             | -              | -                |

## Explanations:

Short description: average of all diffs for NestJS-\* so: `(0.15 + 0.14 + 0.12 + 0.12) / 4`

Long description:

`req/sec DIFF` and `Trans/sec DIFF` is in comparison to the baseline on target branch (master).

Req vs express is calculated as perf compared to NOT using nestjs so: 80.62% = (3.37/4.18) \* 100%



================================================
FILE: tools/gulp/config.ts
================================================
import { getDirs } from './util/task-helpers';

// All paths are related to the base dir
export const source = 'packages';
export const samplePath = 'sample';

export const packagePaths = getDirs(source);



================================================
FILE: tools/gulp/gulpfile.ts
================================================
import './tasks/clean';
import './tasks/copy-misc';
import './tasks/move';
import './tasks/samples';



================================================
FILE: tools/gulp/tsconfig.json
================================================
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "noUnusedParameters": false,
    "noUnusedLocals": false,
    "module": "commonjs",
    "moduleResolution": "node",
    "outDir": "../../dist/tools/gulp",
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "noImplicitThis": true,
    "noEmitOnError": true,
    "noImplicitAny": false,
    "target": "ES2021",
    "types": [
      "node"
    ],
    "typeRoots": ["./typings", "../../node_modules/@types/"],
    "baseUrl": ".",
  },
  "files": [
    "gulpfile.ts"
  ]
}



================================================
FILE: tools/gulp/tasks/clean.ts
================================================
import { task, src, series } from 'gulp';
import { source } from '../config';
import * as clean from 'gulp-clean';
import * as deleteEmpty from 'delete-empty';

/**
 * Cleans the build output assets from the packages folders
 */
function cleanOutput() {
  return src(
    [
      `${source}/**/*.js`,
      `${source}/**/*.d.ts`,
      `${source}/**/*.js.map`,
      `${source}/**/*.d.ts.map`,
    ],
    {
      read: false,
    },
  ).pipe(clean());
}

/**
 * Cleans empty dirs
 */
function cleanDirs(done: () => void) {
  deleteEmpty.sync(`${source}/`);
  done();
}

task('clean:output', cleanOutput);
task('clean:dirs', cleanDirs);
task('clean:bundle', series('clean:output', 'clean:dirs'));



================================================
FILE: tools/gulp/tasks/copy-misc.ts
================================================
import { task, src, dest } from 'gulp';
import { packagePaths } from '../config';

/**
 * Copies assets like Readme.md or LICENSE from the project base path
 * to all the packages.
 */
function copyMisc(): NodeJS.ReadWriteStream {
  const miscFiles = src(['Readme.md', 'LICENSE', '.npmignore']);
  // Since `dest()` does not take a string-array, we have to append it
  // ourselves
  return packagePaths.reduce(
    (stream, packagePath) => stream.pipe(dest(packagePath)),
    miscFiles,
  );
}

task('copy-misc', copyMisc);



================================================
FILE: tools/gulp/tasks/move.ts
================================================
import { dest, src, task } from 'gulp';
import { join } from 'path';
import { samplePath } from '../config';
import { containsPackageJson, getDirs } from '../util/task-helpers';

const distFiles = src([
  'packages/**/*',
  '!packages/**/*.ts',
  'packages/**/*.d.ts',
]);

/**
 * Moves the compiled nest files into "node_module" folder.
 */
function moveToNodeModules() {
  return distFiles.pipe(dest('node_modules/@nestjs'));
}

/**
 * Moves the compiled nest files into the `samples/*` dirs.
 */
function moveToSamples() {
  const samplesDirs = getDirs(samplePath);

  /**
   * Flatten the sampleDirs
   * If a sample dir contains does not contain a package.json
   * Push the subDirs into the destinations instead
   */
  const flattenedSampleDirs: string[] = [];

  for (const sampleDir of samplesDirs) {
    if (containsPackageJson(sampleDir)) {
      flattenedSampleDirs.push(sampleDir);
    } else {
      flattenedSampleDirs.push(...getDirs(sampleDir));
    }
  }

  return flattenedSampleDirs.reduce(
    (distFile, dir) => distFile.pipe(dest(join(dir, '/node_modules/@nestjs'))),
    distFiles,
  );
}

task('move:node_modules', moveToNodeModules);
task('move:samples', moveToSamples);



================================================
FILE: tools/gulp/tasks/samples.ts
================================================
import { blue, magenta } from 'ansis';
import * as childProcess from 'child_process';
import * as log from 'fancy-log';
import { task } from 'gulp';
import { resolve } from 'path';
import { promisify } from 'util';
import { samplePath } from '../config';
import { containsPackageJson, getDirs } from '../util/task-helpers';

const exec = promisify(childProcess.exec);

async function executeNpmScriptInSamples(
  script: string,
  appendScript?: string,
) {
  const nodejsVersionMajorSlice = Number.parseInt(process.versions.node);

  const directories = getDirs(samplePath);

  // TODO: temporarily ignore Prisma sample as require('.')
  // leads to Module '"@prisma/client"' has no exported member 'Post' error
  const prismaSampleIndex = directories.indexOf(
    `${samplePath}/22-graphql-prisma`,
  );
  if (prismaSampleIndex !== -1) {
    directories.splice(prismaSampleIndex, 1);
  }

  // A dictionary that maps the sample number to the minimum Node.js version
  // required to execute any scripts.
  const minNodejsVersionBySampleNumber = {
    '34': 18, // we could use `engines.node` from package.json instead of hardcoding
    '35': 22,
  };

  for await (const dir of directories) {
    const sampleIdentifier = dir.match(/\d+/)?.[0];
    const minNodejsVersionForDir =
      sampleIdentifier && sampleIdentifier in minNodejsVersionBySampleNumber
        ? minNodejsVersionBySampleNumber[sampleIdentifier]
        : undefined;
    const isOnDesiredMinNodejsVersion = minNodejsVersionForDir
      ? nodejsVersionMajorSlice >= minNodejsVersionForDir
      : true;
    if (!isOnDesiredMinNodejsVersion) {
      console.info(
        `Skipping sample ${sampleIdentifier} because it requires Node.js version v${minNodejsVersionForDir}`,
      );
      continue;
    }

    // Check if the sample is a multi-application sample
    const isSingleApplicationSample = containsPackageJson(dir);
    if (!isSingleApplicationSample) {
      // Application is a multi-application sample
      // Go down into the sub-directories
      const subDirs = getDirs(dir);
      for (const subDir of subDirs) {
        await executeNPMScriptInDirectory(subDir, script, appendScript);
      }
    } else {
      await executeNPMScriptInDirectory(dir, script, appendScript);
    }
  }
}

/**
 * Executes the provided NPM script in the specified directory
 * @param dir directory of the application
 * @param script script to execute
 * @param appendScript additional params appended to the script
 */
async function executeNPMScriptInDirectory(
  dir: string,
  script: string,
  appendScript?: string,
) {
  const dirName = dir.replace(resolve(__dirname, '../../../'), '');
  log.info(`Running ${blue(script)} in ${magenta(dirName)}`);
  try {
    const result = await exec(
      `${script} --prefix ${dir} ${appendScript ? '-- ' + appendScript : ''}`,
    );
    // const result = await exec(`npx npm-check-updates -u`, {
    //   cwd: join(process.cwd(), dir),
    // });

    log.info(`Finished running ${blue(script)} in ${magenta(dirName)}`);
    if (result.stderr) {
      log.error(result.stderr);
    }
    if (result.stdout) {
      log.error(result.stdout);
    }
  } catch (err) {
    log.error(`Failed running ${blue(script)} in ${magenta(dirName)}`);
    if (err.stderr) {
      log.error(err.stderr);
    }
    if (err.stdout) {
      log.error(err.stdout);
    }
    process.exit(1);
  }
}

task('install:samples', async () =>
  executeNpmScriptInSamples(
    // 'npm ci --no-audit --no-shrinkwrap --no-optional',
    'npm install --legacy-peer-deps',
  ),
);
task('build:samples', async () => executeNpmScriptInSamples('npm run build'));
task('test:samples', async () =>
  executeNpmScriptInSamples('npm run test', '--passWithNoTests'),
);
task('test:e2e:samples', async () =>
  executeNpmScriptInSamples('npm run test:e2e', '--passWithNoTests'),
);



================================================
FILE: tools/gulp/util/task-helpers.ts
================================================
import { readdirSync, statSync } from 'fs';
import { join } from 'path';

function isDirectory(path: string) {
  return statSync(path).isDirectory();
}

export function getFolders(dir: string) {
  return readdirSync(dir).filter(file => isDirectory(join(dir, file)));
}

export function getDirs(base: string) {
  return getFolders(base).map(path => `${base}/${path}`);
}

/**
 * Checks if the directory contains a package.json file
 * @param dir Path to the directory
 * @returns True if the directory contains a package.json
 */
export function containsPackageJson(dir: string) {
  return readdirSync(dir).some(file => file === 'package.json');
}



================================================
FILE: .circleci/config.yml
================================================
version: 2.1

parameters:
  check-legacy-node-version:
    type: boolean
    default: false
  legacy-node-version:
    type: string
    default: '18.20'
  maintenance-node-version:
    type: string
    default: '20.18'
  active-node-version:
    type: string
    default: '22.11'
  current-node-version:
    type: string
    default: '23.3'

aliases:
  - &restore-cache
    restore_cache:
      key: dependency-cache-{{ checksum "package.json" }}
  - &save-cache
    save_cache:
      key: dependency-cache-{{ checksum "package.json" }}
      paths:
        - ./node_modules
  - &install-deps
    run:
      name: Install dependencies
      command: npm install --legacy-peer-deps
  - &build-packages
    run:
      name: Build
      command: npm run build
  - &run-unit-tests
    run:
      name: Test
      command: npm run test

jobs:
  build:
    working_directory: ~/nest
    docker:
      - image: cimg/node:<< pipeline.parameters.maintenance-node-version >>
    steps:
      - checkout
      - run:
          name: Update NPM version
          command: 'sudo npm install -g npm@^9'
      - *restore-cache
      - *install-deps
      - *save-cache
      - *build-packages

  test:
    parameters:
      node-version:
        type: string
    working_directory: ~/nest
    docker:
      - image: cimg/node:<< parameters.node-version >>
    steps:
      - when:
          condition:
            and:
              - equal:
                  [
                    '<< parameters.node-version >>',
                    '<< pipeline.parameters.legacy-node-version >>',
                  ]
              - not: << pipeline.parameters.check-legacy-node-version >>
          steps:
            - run:
                name: Skip
                command: |
                  echo Skipping
      - when:
          condition:
            or:
              - not:
                  equal:
                    [
                      '<< parameters.node-version >>',
                      '<< pipeline.parameters.legacy-node-version >>',
                    ]
              - << pipeline.parameters.check-legacy-node-version >>
          steps:
            - checkout
            - *restore-cache
            - *install-deps
            - *build-packages
            - when:
                condition:
                  equal:
                    [
                      '<< parameters.node-version >>',
                      '<< pipeline.parameters.maintenance-node-version >>',
                    ]
                steps:
                  - run:
                      name: Test (coverage)
                      command: npm run test:cov
                  - run:
                      name: Collect coverage
                      command: npm run coverage
                  - store_artifacts:
                      path: coverage
            - when:
                condition:
                  not:
                    equal:
                      [
                        '<< parameters.node-version >>',
                        '<< pipeline.parameters.maintenance-node-version >>',
                      ]
                steps:
                  - *run-unit-tests

  lint:
    working_directory: ~/nest
    docker:
      - image: cimg/node:<< pipeline.parameters.active-node-version >>
    steps:
      - checkout
      - *restore-cache
      - *install-deps
      - run:
          name: Lint
          command: npm run lint:ci

  integration_tests:
    working_directory: ~/nest
    machine: true
    steps:
      - checkout
      - run:
          name: Prepare nvm
          command: |
            echo 'export NVM_DIR="/opt/circleci/.nvm"' >> $BASH_ENV
            echo ' [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"' >> $BASH_ENV
      - run:
          name: Upgrade Node.js
          command: |
            nvm install << pipeline.parameters.maintenance-node-version >>
            node -v
            nvm alias default << pipeline.parameters.maintenance-node-version >>
      - run:
          name: Install Docker Compose
          command: |
            curl -L https://github.com/docker/compose/releases/download/1.19.0/docker-compose-`uname -s`-`uname -m` > ~/docker-compose
            chmod +x ~/docker-compose
            sudo mv ~/docker-compose /usr/local/bin/docker-compose
      - *install-deps
      - run:
          name: Prepare tests
          command: |
            bash ./scripts/prepare.sh
            sleep 10
      - run:
          name: List containers
          command: docker ps
      - run:
          name: Integration tests
          command: npm run test:integration

  codechecks_benchmarks:
    working_directory: ~/nest
    docker:
      - image: cimg/node:<< pipeline.parameters.maintenance-node-version >>
    steps:
      - checkout
      - *restore-cache
      - *install-deps
      - *build-packages
      - run:
          name: Install native wrk
          command: .circleci/install-wrk.sh
      - run:
          name: Run codechecks with benchmarks
          command: yarn codechecks:benchmarks

  samples:
    working_directory: ~/nest
    docker:
      - image: cimg/node:<< pipeline.parameters.maintenance-node-version >>
    environment:
      DISABLE_OPENCOLLECTIVE: 'true'
    steps:
      - checkout
      - *restore-cache
      - *install-deps
      - run:
          name: Build all samples
          command: npm run build:samples

workflows:
  build-and-test:
    jobs:
      - build
      - test:
          requires:
            - build
          matrix:
            parameters:
              node-version:
                [
                  '<< pipeline.parameters.legacy-node-version >>',
                  '<< pipeline.parameters.maintenance-node-version >>',
                  '<< pipeline.parameters.active-node-version >>',
                  '<< pipeline.parameters.current-node-version >>',
                ]
      - lint:
          requires:
            - build
      - integration_tests:
          requires:
            - build
      - samples:
          requires:
            - build
      - codechecks_benchmarks:
          requires:
            - build



================================================
FILE: .circleci/install-wrk.sh
================================================
#!/usr/bin/env bash
set -e
cd "$(dirname "$0")"

# based on https://medium.com/@felipedutratine/intelligent-benchmark-with-wrk-163986c1587f

cd /tmp/
sudo apt-get install build-essential libssl-dev git -y
git clone --depth=1 https://github.com/wg/wrk.git wrk
cd wrk
sudo make
# move the executable to somewhere in your PATH, ex:
sudo cp wrk /usr/local/bin



================================================
FILE: .github/dependabot.yml
================================================
version: 2
updates:
- package-ecosystem: npm
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10
- package-ecosystem: "github-actions"
  directory: "/"
  schedule:
    interval: daily
  open-pull-requests-limit: 10



================================================
FILE: .github/FUNDING.yml
================================================
# These are supported funding model platforms

github: [kamilmysliwiec]
open_collective: nest



================================================
FILE: .github/lock.yml
================================================
# Number of days of inactivity before a closed issue or pull request is locked
daysUntilLock: 90

# Skip issues and pull requests created before a given timestamp. Timestamp must
# follow ISO 8601 (`YYYY-MM-DD`). Set to `false` to disable
skipCreatedBefore: false

# Issues and pull requests with these labels will be ignored. Set to `[]` to disable
exemptLabels: []

# Label to add before locking, such as `outdated`. Set to `false` to disable
lockLabel: false

# Comment to post before locking. Set to `false` to disable
lockComment: >
  This thread has been automatically locked since there has not been
  any recent activity after it was closed. Please open a new issue for
  related bugs.

# Assign `resolved` as the reason for locking. Set to `false` to disable
setLockReason: true

# Limit to only `issues` or `pulls`
# only: issues

# Optionally, specify configuration settings just for `issues` or `pulls`
# issues:
#   exemptLabels:
#     - help-wanted
#   lockLabel: outdated

# pulls:
#   daysUntilLock: 30

# Repository to extend settings from
# _extends: repo


================================================
FILE: .github/PULL_REQUEST_TEMPLATE.md
================================================
## PR Checklist
Please check if your PR fulfills the following requirements:

- [ ] The commit message follows our guidelines: https://github.com/nestjs/nest/blob/master/CONTRIBUTING.md
- [ ] Tests for the changes have been added (for bug fixes / features)
- [ ] Docs have been added / updated (for bug fixes / features)


## PR Type
What kind of change does this PR introduce?

<!-- Please check the one that applies to this PR using "x". -->
- [ ] Bugfix
- [ ] Feature
- [ ] Code style update (formatting, local variables)
- [ ] Refactoring (no functional changes, no api changes)
- [ ] Build related changes
- [ ] CI related changes
- [ ] Other... Please describe:

## What is the current behavior?
<!-- Please describe the current behavior that you are modifying, or link to a relevant issue. -->

Issue Number: N/A


## What is the new behavior?


## Does this PR introduce a breaking change?
- [ ] Yes
- [ ] No

<!-- If this PR contains a breaking change, please describe the impact and migration path for existing applications below. -->


## Other information


================================================
FILE: .github/ISSUE_TEMPLATE/Bug_report.yml
================================================
name: "\U0001F41B Bug Report"
description: "If something isn't working as expected \U0001F914"
labels: ["needs triage"]
type: bug
body:
  - type: markdown
    attributes:
      value: |
        ## :warning: We use GitHub Issues to track bug reports, feature requests and regressions

        If you are not sure that your issue is a bug, you could:

        - read the [FAQ's common errors](https://docs.nestjs.com/faq/common-errors) page
        - use our [Discord community](https://discord.gg/NestJS)
        - use [StackOverflow using the tag `nestjs`](https://stackoverflow.com/questions/tagged/nestjs)
        - If it's just a quick question you can ping [our Twitter](https://twitter.com/nestframework)

        **NOTE:** You don't need to answer questions that you know that aren't relevant.

        ---

  - type: checkboxes
    attributes:
      label: "Is there an existing issue for this?"
      description: "Please search [here](../issues?q=is%3Aissue) to see if an issue already exists for the bug you encountered"
      options:
      - label: "I have searched the existing issues"
        required: true

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Current behavior"
      description: "How the issue manifests?"

  - type: input
    validations:
      required: true
    attributes:
      label: "Minimum reproduction code"
      placeholder: "https://github.com/..."
      description: |
        An URL to some Git repository/[StackBlitz](https://stackblitz.com/fork/github/nestjs/typescript-starter)/[CodeSandbox](https://codesandbox.io/s/github/nestjs/typescript-starter/tree/master) project that reproduces your issue. [What is a minimum reproduction?](https://jmcdo29.github.io/wtf-is-a-minimum-reproduction)

        > [!WARNING]
        > We may close this Issue if we don't manage to reproduce the potential bug. [Read this](https://antfu.me/posts/why-reproductions-are-required) to understand why.

  - type: textarea
    attributes:
      label: "Steps to reproduce"
      description: |
        How the issue manifests?
        You could leave this blank if you already write this in your reproduction code
      placeholder: |
        1. `npm ci`
        2. `npm start:dev`
        3. See error...

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Expected behavior"
      description: "A clear and concise description of what you expected to happened (or code)"

  - type: markdown
    attributes:
      value: |
        ---

  - type: checkboxes
    validations:
      required: true
    attributes:
      label: "Package"
      description: |
        Which package (or packages) do you think your issue is related to?
        **Tip**: The first line of the stack trace can help you to figure out this

        The package isn't listed below? Try to find its repository [here](https://github.com/orgs/nestjs/repositories) and open the issue there instead
      options:
        - label: "I don't know. Or some 3rd-party package"
        - label: "<code>@nestjs/common</code>"
        - label: "<code>@nestjs/core</code>"
        - label: "<code>@nestjs/microservices</code>"
        - label: "<code>@nestjs/platform-express</code>"
        - label: "<code>@nestjs/platform-fastify</code>"
        - label: "<code>@nestjs/platform-socket.io</code>"
        - label: "<code>@nestjs/platform-ws</code>"
        - label: "<code>@nestjs/testing</code>"
        - label: "<code>@nestjs/websockets</code>"
        - label: "Other (see below)"

  - type: input
    attributes:
      label: "Other package"
      description: "If your issue is related to some package that is not listed above nor under @nestjs org, write its name here"

  - type: input
    attributes:
      label: "NestJS version"
      description: |
        Which version of `@nestjs/core` are you using?
        **Tip**: Make sure that all of yours `@nestjs/*` dependencies are in sync!
      placeholder: "8.1.3"

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Packages versions"
      description: |
        You could leave your whole `package.json` dependencies list here, or just indicate which version of `@nestjs/*` you are using
        **Tip**: run _npx nest info_
      value: |
        ```json

        ```

  - type: input
    attributes:
      label: "Node.js version"
      description: "Which version of Node.js are you using?"
      placeholder: "14.17.6"

  - type: checkboxes
    validations:
      required: true
    attributes:
      label: "In which operating systems have you tested?"
      options:
        - label: macOS
        - label: Windows
        - label: Linux

  - type: markdown
    attributes:
      value: |
        ---

  - type: textarea
    attributes:
      label: "Other"
      description: |
        Anything else relevant? eg: Logs, OS version, IDE, package manager, etc.
        **Tip:** You can attach images, recordings or log files by clicking this area to highlight it and then dragging files in



================================================
FILE: .github/ISSUE_TEMPLATE/config.yml
================================================
## To encourage contributors to use issue templates, we don't allow blank issues
blank_issues_enabled: false

contact_links:
  - name: "\u2049 FAQ"
    url: "https://docs.nestjs.com/faq"
    about: "Make sure you have read the Frequently Asked Questions page."
  - name: "\u2753 Discord Community of NestJS"
    url: "https://discord.gg/NestJS"
    about: "Please ask support questions or discuss suggestions/enhancements here."



================================================
FILE: .github/ISSUE_TEMPLATE/Feature_request.yml
================================================
name: "\U0001F680 Feature Request"
description: "I have a suggestion \U0001F63B!"
labels: ["type: enhancement :wolf:", "needs triage"]
type: feature
body:
  - type: markdown
    attributes:
      value: |
        ## :warning: We use GitHub Issues to track bug reports, feature requests and regressions

        If you are not sure that your issue is a bug, you could:

        - read the [FAQ's common errors](https://docs.nestjs.com/faq/common-errors) page
        - use our [Discord community](https://discord.gg/NestJS)
        - use [StackOverflow using the tag `nestjs`](https://stackoverflow.com/questions/tagged/nestjs)
        - If it's just a quick question you can ping [our Twitter](https://twitter.com/nestframework)

        ---

  - type: checkboxes
    attributes:
      label: "Is there an existing issue that is already proposing this?"
      description: "Please search [here](../issues?q=is%3Aissue) to see if an issue already exists for the feature you are requesting"
      options:
      - label: "I have searched the existing issues"
        required: true

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Is your feature request related to a problem? Please describe it"
      description: "A clear and concise description of what the problem is"
      placeholder: |
        I have an issue when ...

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Describe the solution you'd like"
      description: "A clear and concise description of what you want to happen. Add any considered drawbacks"

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Teachability, documentation, adoption, migration strategy"
      description: "If you can, explain how users will be able to use this and possibly write out a version the docs. Maybe a screenshot or design?"

  - type: textarea
    validations:
      required: true
    attributes:
      label: "What is the motivation / use case for changing the behavior?"
      description: "Describe the motivation or the concrete use case"



================================================
FILE: .github/ISSUE_TEMPLATE/Regression.yml
================================================
name: "\U0001F4A5 Regression"
description: "Report an unexpected while upgrading your Nest application!"
labels: ["type: bug :sob:", "needs triage"]
type: bug
body:
  - type: markdown
    attributes:
      value: |
        ## :warning: We use GitHub Issues to track bug reports, feature requests and regressions

        If you are not sure that your issue is a bug, you could:

        - read the [FAQ's common errors](https://docs.nestjs.com/faq/common-errors) page
        - use our [Discord community](https://discord.gg/NestJS)
        - use [StackOverflow using the tag `nestjs`](https://stackoverflow.com/questions/tagged/nestjs)
        - If it's just a quick question you can ping [our Twitter](https://twitter.com/nestframework)

        **NOTE:** You don't need to answer questions that you know that aren't relevant.

        ---

  - type: checkboxes
    attributes:
      label: "Did you read the migration guide?"
      description: "Check out the [migration guide here](https://docs.nestjs.com/migration-guide)!"
      options:
      - label: "I have read the whole migration guide"
        required: false

  - type: checkboxes
    attributes:
      label: "Is there an existing issue that is already proposing this?"
      description: "Please search [here](../issues?q=is%3Aissue) to see if an issue already exists for the feature you are requesting"
      options:
      - label: "I have searched the existing issues"
        required: true

  - type: input
    attributes:
      label: "Potential Commit/PR that introduced the regression"
      description: "If you have time to investigate, what PR/date/version introduced this issue"
      placeholder: "PR #123 or commit 5b3c4a4"

  - type: input
    validations:
      required: true
    attributes:
      label: "NestJS version"
      placeholder: "8.1.0 -> 8.1.3"

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Describe the regression"
      description: "A clear and concise description of what the regression is"

  - type: input
    attributes:
      label: "Minimum reproduction code"
      description: "An URL to some git repository that reproduces this issue. [Wtf is a minimum reproduction?](https://jmcdo29.github.io/wtf-is-a-minimum-reproduction)"
      placeholder: "https://github.com/..."

  - type: textarea
    attributes:
      label: "Input code"
      description: "Write some code snippets if you think it is worth it"
      value: |
        ```ts

        ```

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Expected behavior"
      description: "A clear and concise description of what you expected to happened (or code)"

  - type: textarea
    attributes:
      label: "Other"
      description: |
        Anything else relevant? eg: Logs, OS version, IDE, package manager, etc.
        **Tip:** You can attach images, recordings or log files by clicking this area to highlight it and then dragging files in



================================================
FILE: .github/ISSUE_TEMPLATE/Suggestion_improve_performance.yml
================================================
title: "perf: "
name: "\U0001F525 Suggestion for Improving Performance"
description: "I have a suggestion that might improve the performance of Nest \U00002728"
labels: ["type: enhancement :wolf:", "needs triage"]
type: task
body:
  - type: checkboxes
    attributes:
      label: "Is there an existing issue that is already proposing this?"
      description: "Please search [here](../issues?q=is%3Aissue) to see if an issue already exists for this"
      options:
      - label: "I have searched the existing issues"
        required: true

  - type: input
    validations:
      required: true
    attributes:
      label: "NestJS version"
      description: "Which version do you intend to improve?"
      placeholder: "8.1.3"

  - type: textarea
    attributes:
      label: "Is your performance suggestion related to a problem? Please describe it"
      description: "A clear and concise description of what the problem is"

  - type: textarea
    validations:
      required: true
    attributes:
      label: "Describe the performance enhancement you are proposing and how we can try it out"
      placeholder: |
        Cache `array.length` on the following lines ...

  - type: textarea
    validations:
     required: true
    attributes:
      label: "Benchmarks result or another proof (eg: POC)"
      description: |
        If you've already prototyped a solution, share your results here
        If not, what makes you believe there will be a performance improvement?
      placeholder: |
        ```
        ```

        MacBook Pro Mid 2014, 2.5 GHz Quad-Core Intel Core i7, 16 GB 1600 MHz DDR3, SSD




================================================
FILE: .github/workflows/codeql-analysis.yml
================================================
name: "CodeQL"

on:
  push:
    branches: [master, ]
  pull_request:
    # The branches below must be a subset of the branches above
    branches: [master]
  schedule:
    - cron: '0 17 * * 4'

permissions:
  contents: read

jobs:
  analyse:
    permissions:
      security-events: write
    name: Analyse
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        # We must fetch at least the immediate parents so that if this is
        # a pull request then we can checkout the head.
        fetch-depth: 2

    # If this run was triggered by a pull request event, then checkout
    # the head of the pull request instead of the merge commit.
    - run: git checkout HEAD^2
      if: ${{ github.event_name == 'pull_request' }}

    # Initializes the CodeQL tools for scanning.
    - name: Initialize CodeQL
      uses: github/codeql-action/init@v3
      with:
        queries: +security-extended
      # Override language selection by uncommenting this and choosing your languages
      # with:
      #   languages: go, javascript, csharp, python, cpp, java

    # Autobuild attempts to build any compiled languages  (C/C++, C#, or Java).
    # If this step fails, then you should remove it and run the build manually (see below)
    - name: Autobuild
      uses: github/codeql-action/autobuild@v3

    # ℹ️ Command-line programs to run using the OS shell.
    # 📚 https://git.io/JvXDl

    # ✏️ If the Autobuild fails above, remove it and uncomment the following three lines
    #    and modify them (or add more) to build your code if your project
    #    uses a compiled language

    #- run: |
    #   make bootstrap
    #   make release

    - name: Perform CodeQL Analysis
      uses: github/codeql-action/analyze@v3



================================================
FILE: .husky/commit-msg
================================================
npx --no-install commitlint --edit $1



================================================
FILE: .husky/pre-commit
================================================
npx lint-staged


